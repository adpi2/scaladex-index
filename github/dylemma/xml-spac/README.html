<div class="announce instapaper_body md" data-path="readme.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-xml-spac" class="anchor" href="https://github.com/dylemma/xml-spac#xml-spac" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>XML SPaC</h1> 
  <p><a href="https://travis-ci.org/dylemma/xml-spac" target="_blank"><img src="https://camo.githubusercontent.com/069d3c52323173aeb96611d2cc6a8779e7d51a20/68747470733a2f2f7472617669732d63692e6f72672f64796c656d6d612f786d6c2d737061632e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/dylemma/xml-spac.svg?branch=master" style="max-width:100%;"></a></p> 
  <p><strong>XML</strong> <strong>S</strong>treaming <strong>Pa</strong>rser <strong>C</strong>ombinators is a Scala library for creating <a href="https://docs.oracle.com/javase/7/docs/api/javax/xml/stream/package-summary.html" target="_blank">StAX</a> parsers that are:</p> 
  <ul> 
   <li><strong>Declarative</strong> - You write <em>what</em> you want to get, not <em>how</em> to get it.</li> 
   <li><strong>Immutable</strong> - Parsers that you create have no internal state.</li> 
   <li><strong>Composable</strong> - Combine and transform parsers to handle complex data structures. </li> 
   <li><strong>Fast</strong> - With minimal abstraction to get in the way, speed rivals any hand-written handler.</li> 
   <li><strong>Streaming</strong> - Parse huge XML documents without loading it all into memory.</li> 
  </ul> 
  <p>There's a full-fledged example <a href="https://github.com/dylemma/xml-spac#writing-a-parser-by-example" target="_blank">further down</a> in this readme, and the <a href="https://github.com/dylemma/xml-spac/tree/master/examples/src/main/scala/io/dylemma/xml/example" target="_blank">examples project</a> has a collection of annotated examples, but here's a taste of how you'd write a parser for a relatively-complex blog post XML structure:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">PostParser</span> <span class="pl-k">=</span> <span class="pl-en">Parser</span>.combine(
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>).map(commentDateFormat.parseLocalDate),
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>).first[<span class="pl-en">Author</span>],
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>stats<span class="pl-pds">"</span></span>).first[<span class="pl-en">Stats</span>],
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>body<span class="pl-pds">"</span></span>).first.asText,
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>comments<span class="pl-pds">"</span></span> \ <span class="pl-s"><span class="pl-pds">"</span>comment<span class="pl-pds">"</span></span>).asListOf[<span class="pl-en">Comment</span>]
).as(<span class="pl-en">Post</span>)</pre>
  </div> 
  <h1><a id="user-content-get-it" class="anchor" href="https://github.com/dylemma/xml-spac#get-it" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Get it!</h1> 
  <p>Add the following to your <code>build.sbt</code> file:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.dylemma<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>xml-spac<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2<span class="pl-pds">"</span></span></pre>
  </div> 
  <h1><a id="user-content-how-it-works" class="anchor" href="https://github.com/dylemma/xml-spac#how-it-works" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How it Works</h1> 
  <p><strong>XML SPaC</strong> doesn't have any particular representation of a "stream". Instead, it defines the <code>ConsumableLike</code> typeclass:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">ConsumableLike</span>[<span class="pl-k">-</span><span class="pl-en">S</span>, <span class="pl-k">+</span><span class="pl-en">In</span>]{
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">Out</span>](<span class="pl-v">source</span>: <span class="pl-en">S</span>, <span class="pl-v">handler</span>: <span class="pl-en">Handler</span>[<span class="pl-en">In</span>, <span class="pl-en">Out</span>])<span class="pl-k">:</span> <span class="pl-en">Out</span>
}</pre>
  </div> 
  <p>The <code>S</code> type parameter represents the "source" or the "stream".<br> The <code>In</code> type parameter represents the events that the stream generates.<br> The <code>Out</code> type parameter represents the result type of the handler.</p> 
  <p>There are many different <code>ConsumableLike</code> instances already, including generalized ones for <code>Iterable</code> collections and <code>Iterator</code>s, and XML-specific ones for <code>String</code>, <code>File</code>, and <code>InputStream</code>. If you have a more specific "Stream" type, you can <a href="https://github.com/dylemma/xml-spac/blob/master/core/src/main/scala/io/dylemma/spac/ConsumableLike.scala" target="_blank">write your own <code>ConsumableLike[StreamType, EventType]</code></a>.</p> 
  <p>A <code>Handler</code> is a mutable object that can accept inputs until it comes up with some result.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">Handler</span>[<span class="pl-k">-</span><span class="pl-en">In</span>, <span class="pl-k">+</span><span class="pl-en">Out</span>] {
    <span class="pl-k">def</span> <span class="pl-en">isFinished</span><span class="pl-k">:</span> <span class="pl-k">Boolean</span>
    <span class="pl-k">def</span> <span class="pl-en">handleInput</span>(<span class="pl-v">input</span>: <span class="pl-en">In</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Out</span>]
    <span class="pl-k">def</span> <span class="pl-en">handleError</span>(<span class="pl-v">err</span>: <span class="pl-en">Throwable</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Out</span>]
    <span class="pl-k">def</span> <span class="pl-en">handleEnd</span>()<span class="pl-k">:</span> <span class="pl-en">Out</span>
}</pre>
  </div> 
  <p>The main classes in <strong>XML SPaC</strong> revolve around creating different <code>Handler</code>s.</p> 
  <h2><a id="user-content-consumer" class="anchor" href="https://github.com/dylemma/xml-spac#consumer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Consumer</h2> 
  <p>A <code>Consumer[In, Out]</code> can create a <code>Handler[In, Out]</code> on demand. <code>Consumer</code>s have a <code>consume</code> method which will consume a stream by creating a handler and running it until it emits a result.</p> 
  <h2><a id="user-content-parser" class="anchor" href="https://github.com/dylemma/xml-spac#parser" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parser</h2> 
  <p>A <code>Parser[Context, Out]</code> creates a <code>Handler[XMLEvent, Try[Out]</code> when given a <code>Context</code>.<br> <strong>XML SPaC</strong> has many helper methods for creating <code>Parser</code>s.<br> <code>Parser</code>s have a <code>parse</code> method which will consume a stream of <code>XMLEvent</code>s to produce an <code>Try[Out]</code>.</p> 
  <h2><a id="user-content-transformer" class="anchor" href="https://github.com/dylemma/xml-spac#transformer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Transformer</h2> 
  <p>A <code>Transformer[A, B]</code> turns a stream of <code>A</code> into a stream of <code>B</code>.<br> A <code>Transformer[A, B]</code> can attach to a <code>Consumer[B, C]</code> to create a <code>Consumer[A, C]</code>.<br> A <code>Transformer[A, B]</code> can attach to a <code>Transformer[B, C]</code> to create a <code>Transformer[A, C]</code>.</p> 
  <h2><a id="user-content-splitter" class="anchor" href="https://github.com/dylemma/xml-spac#splitter" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Splitter</h2> 
  <p>A <code>Splitter[In, Context]</code> combines with a <code>Parser[Context, Out]</code> to create a <code>Transformer[In, Out]</code>.<br> It divides the incoming stream into "substreams", each of which have some "context" value, then runs the parser on each of the substreams, passing the parser's result downstream.<br> This is how you can write a <code>Parser</code> that only gets events from inside a particular element, like a <code>&lt;comment&gt;</code>.</p> 
  <h1><a id="user-content-writing-a-parser-by-example" class="anchor" href="https://github.com/dylemma/xml-spac#writing-a-parser-by-example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Writing a Parser by Example</h1> 
  <p>Let's write a parser for this pretend blog data file.</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">blog</span>&gt;
  &lt;<span class="pl-ent">post</span> <span class="pl-e">date</span>=<span class="pl-s"><span class="pl-pds">"</span>2015-11-16<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">author</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>dylemma<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>abc123<span class="pl-pds">"</span></span>/&gt;
    &lt;<span class="pl-ent">stats</span> <span class="pl-e">likes</span>=<span class="pl-s"><span class="pl-pds">"</span>123<span class="pl-pds">"</span></span> <span class="pl-e">tweets</span>=<span class="pl-s"><span class="pl-pds">"</span>4<span class="pl-pds">"</span></span>/&gt;
    &lt;<span class="pl-ent">body</span>&gt;Hello world!&lt;/<span class="pl-ent">body</span>&gt;
    &lt;<span class="pl-ent">comments</span>&gt;
      &lt;<span class="pl-ent">comment</span> <span class="pl-e">date</span>=<span class="pl-s"><span class="pl-pds">"</span>2015-11-18<span class="pl-pds">"</span></span>&gt;
        &lt;<span class="pl-ent">author</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>anonymous<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>def456<span class="pl-pds">"</span></span>/&gt;
        &lt;<span class="pl-ent">body</span>&gt;I'm commenting on your fake blog!&lt;/<span class="pl-ent">body</span>&gt;
      &lt;/<span class="pl-ent">comment</span>&gt;
    &lt;/<span class="pl-ent">comments</span>&gt;
  &lt;/<span class="pl-ent">post</span>&gt;
  &lt;<span class="pl-ent">post</span> <span class="pl-e">date</span>=<span class="pl-s"><span class="pl-pds">"</span>2015-11-18<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">author</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>johndoe<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>004200<span class="pl-pds">"</span></span>/&gt;
    &lt;<span class="pl-ent">stats</span> <span class="pl-e">likes</span>=<span class="pl-s"><span class="pl-pds">"</span>7<span class="pl-pds">"</span></span> <span class="pl-e">tweets</span>=<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>/&gt;
    &lt;<span class="pl-ent">body</span>&gt;A second blog post, huzzah!&lt;/<span class="pl-ent">body</span>&gt;
    &lt;<span class="pl-ent">comments</span>&gt;
      &lt;<span class="pl-ent">comment</span> <span class="pl-e">date</span>=<span class="pl-s"><span class="pl-pds">"</span>2015-11-19<span class="pl-pds">"</span></span>&gt;
        &lt;<span class="pl-ent">author</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>anonymous<span class="pl-pds">"</span></span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>def456<span class="pl-pds">"</span></span>/&gt;
        &lt;<span class="pl-ent">body</span>&gt;It's me again&lt;/<span class="pl-ent">body</span>&gt;
      &lt;/<span class="pl-ent">comment</span>&gt;
    &lt;/<span class="pl-ent">comments</span>&gt;
  &lt;/<span class="pl-ent">post</span>&gt;
&lt;/<span class="pl-ent">blog</span>&gt;</pre>
  </div> 
  <p>For this example, we'll use the following classes:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Post</span>(<span class="pl-v">date</span>: <span class="pl-en">LocalDate</span>, <span class="pl-v">author</span>: <span class="pl-en">Author</span>, <span class="pl-v">stats</span>: <span class="pl-en">Stats</span>, <span class="pl-v">body</span>: <span class="pl-k">String</span>, <span class="pl-v">comments</span>: <span class="pl-en">List</span>[<span class="pl-en">Comment</span>])
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Author</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Stats</span>(<span class="pl-v">numLikes</span>: <span class="pl-k">Int</span>, <span class="pl-v">numTweets</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Comment</span>(<span class="pl-v">date</span>: <span class="pl-en">LocalDate</span>, <span class="pl-v">author</span>: <span class="pl-en">Author</span>, <span class="pl-v">body</span>: <span class="pl-k">String</span>)</pre>
  </div> 
  <p>And the following imports:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.dylemma.spac.</span><span class="pl-v">_</span></pre>
  </div> 
  <h3><a id="user-content-parserauthor" class="anchor" href="https://github.com/dylemma/xml-spac#parserauthor" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parser[Author]</h3> 
  <p>We'll start by defining a parser for the <code>Author</code> class:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">AuthorParser</span><span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">Any</span>, <span class="pl-en">Author</span>] <span class="pl-k">=</span> <span class="pl-en">Parser</span>.combine(
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>),
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)
).as(<span class="pl-en">Author</span>)</pre>
  </div> 
  <p>What happened here is that we actually defined two parsers, then joined them together. <code>forMandatoryAttribute("id")</code> is a parser that takes the "id" attribute from the first <code>StartElement</code> event it encounters. Similarly, <code>forMandatoryAttribute("name")</code> is a parser that takes the "name" attribute. In order to combine the "id" and the "name" parsers, we use <code>Parser.combine(...)</code> followed by <code>.as(Author)</code>. This works because <code>Author</code> is a case class, and therefore the <code>Author</code> companion object can be treated as a <code>(String, String) =&gt; Author</code>, which fits the signature of <code>.as</code>. The <code>Any</code> in the type signature is the parser's context type. Some parsers require a context value in order to work. This one doesn't require any particular context type. We mark the <code>AuthorParser</code> as implicit so that it can be used with some of the parser convenience methods later on.</p> 
  <h3><a id="user-content-parserstats" class="anchor" href="https://github.com/dylemma/xml-spac#parserstats" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parser[Stats]</h3> 
  <p>Building on the concepts from the <code>Author</code> parser, we can define the <code>Stats</code> parser.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">StatsParser</span><span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">Any</span>, <span class="pl-en">Stats</span>] <span class="pl-k">=</span> <span class="pl-en">Parser</span>.combine(
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>likes<span class="pl-pds">"</span></span>).map(_.toInt),
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>tweets<span class="pl-pds">"</span></span>).map(_.toInt)
).as(<span class="pl-en">Stats</span>)</pre>
  </div> 
  <p>Note the addition of <code>map(_.toInt)</code>. A parser's <code>map</code> method transforms its result with the given function. Note that if the function throws an exception, that exception will be caught and represented in the parser's result. Also note that the <code>join</code> method is completely typesafe. Without the <code>map</code> calls, <code>as(Stats)</code> would fail since you would be trying to pass Strings into a function that expected Ints.</p> 
  <h3><a id="user-content-parsercomment" class="anchor" href="https://github.com/dylemma/xml-spac#parsercomment" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parser[Comment]</h3> 
  <p>Using some new concepts, we can define the <code>Comment</code> parser.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">commentDateFormat</span> <span class="pl-k">=</span> <span class="pl-en">DateTimeFormat</span>.forPattern(<span class="pl-s"><span class="pl-pds">"</span>yyyy-MM-dd<span class="pl-pds">"</span></span>)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">CommentParser</span><span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">Any</span>, <span class="pl-en">Comment</span>] <span class="pl-k">=</span> <span class="pl-en">Parser</span>.combine(
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>).map(commentDateFormat.parseLocalDate),
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>).first[<span class="pl-en">Author</span>],
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>body<span class="pl-pds">"</span></span>).first.asText
).as(<span class="pl-en">Comment</span>)</pre>
  </div> 
  <p>The <code>Splitter(* \ "author")</code> is a new Splitter that only passes along events coming from the <code>&lt;author&gt;</code> element directly within the top-level element, which in this case could be anything. Then we call <code>first[Author]</code>, which implicitly looks for a <code>Parser[Any, Author]</code> and should find our <code>AuthorParser</code> that we defined earlier. <code>first[T]</code> is actually shorthand for <code>through(parser).parseFirst</code>, meaning that we will run the AuthorParser only on the first <code>&lt;author&gt;</code> substream, returning a single <code>Author</code> instance rather than a list or option.</p> 
  <p>The <code>Splitter(* \ "body" ).first.asText</code> is a parser that collects the text in first <code>&lt;body&gt;</code> element directly within the top-level element. Any <code>Characters</code> events encountered within that substream will be concatenated to generate the result.</p> 
  <h3><a id="user-content-parserpost" class="anchor" href="https://github.com/dylemma/xml-spac#parserpost" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parser[Post]</h3> 
  <p>Combining the parsers and concepts from above, we can define the <code>Post</code> parser.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">PostParser</span><span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">Any</span>, <span class="pl-en">Post</span>] <span class="pl-k">=</span> <span class="pl-en">Parser</span>.combine(
    <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>).map(commentDateFormat.parseLocalDate),
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>).first[<span class="pl-en">Author</span>],
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>stats<span class="pl-pds">"</span></span>).first[<span class="pl-en">Stats</span>],
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>body<span class="pl-pds">"</span></span>).first.asText,
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>comments<span class="pl-pds">"</span></span> \ <span class="pl-s"><span class="pl-pds">"</span>comment<span class="pl-pds">"</span></span>).asListOf[<span class="pl-en">Comment</span>]
).as(<span class="pl-en">Post</span>)</pre>
  </div> 
  <p>Note the use of <code>asListOf</code> instead of <code>first</code> for the comments. Instead of just taking the first <code>&lt;comment&gt;</code>, we gather all of them into a list.</p> 
  <h3><a id="user-content-common-functionality-is-easy-to-share" class="anchor" href="https://github.com/dylemma/xml-spac#common-functionality-is-easy-to-share" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Common Functionality is Easy to Share</h3> 
  <p>Note the common functionality between <code>PostParser</code> and <code>CommentParser</code> for getting the <code>date</code> and <code>author</code>. That functionality can be pulled out to some common location and reused anywhere, e.g.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">dateAttributeParser</span> <span class="pl-k">=</span> <span class="pl-en">Parser</span>.forMandatoryAttribute(<span class="pl-s"><span class="pl-pds">"</span>date<span class="pl-pds">"</span></span>).map(commentDateFormat.parseLocalDate)
<span class="pl-k">val</span> <span class="pl-en">authorElementParser</span> <span class="pl-k">=</span> <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>author<span class="pl-pds">"</span></span>).first[<span class="pl-en">Author</span>]

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">CommentParser</span><span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">Comment</span>] <span class="pl-k">=</span> <span class="pl-en">Parser</span>.combine(
    dateAttributeParser,
    authorElementParser,
    <span class="pl-en">Splitter</span>(<span class="pl-k">*</span> \ <span class="pl-s"><span class="pl-pds">"</span>body<span class="pl-pds">"</span></span>).first.asText
).as(<span class="pl-en">Comment</span>)</pre>
  </div> 
  <h2><a id="user-content-using-the-parser" class="anchor" href="https://github.com/dylemma/xml-spac#using-the-parser" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using the Parser</h2> 
  <p>Remember that the <code>&lt;post&gt;</code> element was inside the top-level <code>&lt;blog&gt;</code> element, so we can't run the <code>PostParser</code> directly on the XML stream. We need to put it in the right context first.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">postTransformer</span><span class="pl-k">:</span> <span class="pl-en">Transformer</span>[<span class="pl-en">XMLEvent</span>, <span class="pl-en">Post</span>] <span class="pl-k">=</span> <span class="pl-en">Splitter</span>(<span class="pl-s"><span class="pl-pds">"</span>blog<span class="pl-pds">"</span></span> \ <span class="pl-s"><span class="pl-pds">"</span>post<span class="pl-pds">"</span></span>) through <span class="pl-en">PostParser</span>
<span class="pl-c">// or</span>
<span class="pl-k">val</span> <span class="pl-en">postTransformerAlt</span><span class="pl-k">:</span> <span class="pl-en">Transformer</span>[<span class="pl-en">XMLEvent</span>, <span class="pl-en">Post</span>] <span class="pl-k">=</span> <span class="pl-en">Splitter</span>(<span class="pl-s"><span class="pl-pds">"</span>blog<span class="pl-pds">"</span></span> \ <span class="pl-s"><span class="pl-pds">"</span>post<span class="pl-pds">"</span></span>).as[<span class="pl-en">Post</span>]</pre>
  </div> 
  <p>The <code>postTransformer</code> is a <code>Transformer[XMLEvent, Post]</code>, meaning that it can be used to transform a stream of XMLEvent to a stream of <code>Post</code> values. Depending on how you want to consume that stream, you might call <code>postTransformer.parseToList</code> or <code>postTransformer.consumeForeach(println)</code>, or one of <code>Transformer</code>'s several other convenience methods. These methods return <code>Parsers</code> or <code>Consumers</code>, both of which can then be used to consume the whole XML stream.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// the raw xml data can be a String, a File, an InputStream,</span>
<span class="pl-c">// or anything belonging to the `ConsumableLike` typeclass.</span>
<span class="pl-k">val</span> <span class="pl-en">xml</span> <span class="pl-k">=</span> ...
postTransformer.consumeForEach(println) consume xml <span class="pl-c">// println each Post as the stream finds it</span>
println(postTransformer.consumeToList consume xml) <span class="pl-c">// collect all of the Posts to a list</span>
println(postTransformer.parseToList parse xml) <span class="pl-c">// collect all of the Posts, but wrap parsing failures as values</span></pre>
  </div> 
  <p>You can use <code>parser.parse(xml)</code> or <code>consumer.consume(xml)</code>. <code>Parser</code> and <code>Consumer</code> are very similar, but the main difference is that the output of a <code>Parser</code> will always be a <code>Try</code>. Exceptions thrown by parsers' inner handlers will be caught and wrapped as <code>Failure</code>s. For example if the <code>StatsParser</code> encountered a <code>"asdf"</code> as the value for the "likes" attribute, the <code>_.toInt</code> would throw an exception, which would be caught, causing the result for that element to be an <code>Failure(NumberFormatException)</code>.</p> 
 </article>
</div>