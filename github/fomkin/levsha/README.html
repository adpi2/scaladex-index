<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-levsha" class="anchor" href="https://github.com/fomkin/levsha#levsha" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Levsha</h1> 
  <p>Levsha is a fast HTML template engine and Scala eDSL. It works without additional memory allocation. Levsha supports changeset inference, which allows to use it as virtual-dom-like middleware.</p> 
  <h2><a id="user-content-static-rendering" class="anchor" href="https://github.com/fomkin/levsha#static-rendering" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Static rendering</h2> 
  <p>You can use Levsha as a static HTML renderer.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> build.sbt</span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.fomkin<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>levsha-core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.6.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> In your code</span>
<span class="pl-k">import</span> <span class="pl-v">levsha.text.symbolDsl.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">levsha.text.</span><span class="pl-v">renderHtml</span>

<span class="pl-k">val</span> <span class="pl-en">features</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>Very fast<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Memory-effective<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">html</span> <span class="pl-k">=</span> renderHtml {
  <span class="pl-en">'body</span>(
    <span class="pl-en">'div</span>(<span class="pl-en">'class</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Hello, I'm Levsha!<span class="pl-pds">"</span></span>),
    <span class="pl-en">'ul</span>(<span class="pl-en">'class</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>list<span class="pl-pds">"</span></span>,
      features map { feature <span class="pl-k">=&gt;</span>
        <span class="pl-en">'li</span>(<span class="pl-en">'class</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>item<span class="pl-pds">"</span></span>, feature)
      }
    )
  )
}

println(html)</pre>
  </div> 
  <div class="highlight highlight-text-html-basic">
   <pre>&lt;<span class="pl-ent">body</span>&gt;
  &lt;<span class="pl-ent">div</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>&gt;Hello, I'm Levsha!&lt;/<span class="pl-ent">div</span>&gt;
  &lt;<span class="pl-ent">ul</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>list<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">li</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>item<span class="pl-pds">"</span></span>&gt;Super-fast&lt;/<span class="pl-ent">li</span>&gt;
    &lt;<span class="pl-ent">li</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>item<span class="pl-pds">"</span></span>&gt;Off-heap&lt;/<span class="pl-ent">li</span>&gt;
  &lt;/<span class="pl-ent">ul</span>&gt;
&lt;/<span class="pl-ent">body</span>&gt;</pre>
  </div> 
  <h4><a id="user-content-benchmarks" class="anchor" href="https://github.com/fomkin/levsha#benchmarks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Benchmarks</h4> 
  <p>Benchmarks show that Levsha is really fast. Unlike Twirl, Levsha's performance does not depend on template complexity.</p> 
  <table> 
   <thead> 
    <tr> 
     <th>Test</th> 
     <th align="left">Engine</th> 
     <th align="right">Ops/s</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>simpleHtml</td> 
     <td align="left">levsha</td> 
     <td align="right">1336693,499</td> 
    </tr> 
    <tr> 
     <td>simpleHtml</td> 
     <td align="left">scalatags</td> 
     <td align="right">533740,566</td> 
    </tr> 
    <tr> 
     <td>simpleHtml</td> 
     <td align="left">twirl</td> 
     <td align="right">5950436,854</td> 
    </tr> 
    <tr> 
     <td>withConditionAndLoop</td> 
     <td align="left">levsha</td> 
     <td align="right">1299646,768</td> 
    </tr> 
    <tr> 
     <td>withConditionAndLoop</td> 
     <td align="left">scalatags</td> 
     <td align="right">531345,430</td> 
    </tr> 
    <tr> 
     <td>withConditionAndLoop</td> 
     <td align="left">twirl</td> 
     <td align="right">239537,158</td> 
    </tr> 
    <tr> 
     <td>withVariables</td> 
     <td align="left">levsha</td> 
     <td align="right">1140298,804</td> 
    </tr> 
    <tr> 
     <td>withVariables</td> 
     <td align="left">scalatags</td> 
     <td align="right">483508,457</td> 
    </tr> 
    <tr> 
     <td>withVariables</td> 
     <td align="left">twirl</td> 
     <td align="right">2146419,329</td> 
    </tr>
   </tbody>
  </table> 
  <p>In your sbt shell.</p> 
  <pre><code>bench/jmh:run .StaticRenderingComparision
</code></pre> 
  <h2><a id="user-content-as-a-virtual-dom" class="anchor" href="https://github.com/fomkin/levsha#as-a-virtual-dom" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>As a virtual DOM</h2> 
  <p>Levsha can be used as virtual-DOM-like middleware. Unlike other popular virtual DOM solutions, Levsha doesn't allocate additional memory for construction of a new virtual DOM copy. Also it does not allocate memory in changes inferring phase. Levsha's memory usage is constant.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> build.sbt</span>
libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.fomkin<span class="pl-pds">"</span></span> <span class="pl-k">%%%</span> <span class="pl-s"><span class="pl-pds">"</span>levsha-dom<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.6.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> In your code</span>
<span class="pl-k">import</span> <span class="pl-v">org.scalajs.dom.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">levsha.dom.symbolDsl.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">levsha.dom.</span><span class="pl-v">render</span>
<span class="pl-k">import</span> <span class="pl-v">levsha.dom.</span><span class="pl-v">event</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Todo</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>, <span class="pl-v">text</span>: <span class="pl-k">String</span>, <span class="pl-v">done</span>: <span class="pl-k">Boolean</span>)

<span class="pl-k">def</span> <span class="pl-en">renderTodos</span>(<span class="pl-v">todos</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Todo</span>])<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> render(document.body) {
  <span class="pl-en">'body</span>(
    <span class="pl-en">'div</span>(<span class="pl-en">'class</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>title<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Todos<span class="pl-pds">"</span></span>),
    <span class="pl-en">'ul</span>(<span class="pl-en">'class</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>list<span class="pl-pds">"</span></span>,
      todos map { todo <span class="pl-k">=&gt;</span>
        <span class="pl-en">'li</span>(
          todo <span class="pl-k">match</span> {
            <span class="pl-k">case</span> <span class="pl-en">Todo</span>(_, text, <span class="pl-c1">true</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">'strike</span>(text)
            <span class="pl-k">case</span> <span class="pl-en">Todo</span>(_, text, <span class="pl-c1">false</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">'span</span>(text)
          },
          event(<span class="pl-en">'click</span>) {
            renderTodos(
              todos.updated(
                todos.indexOf(todo),
                todo.copy(done <span class="pl-k">=</span> <span class="pl-k">!</span>todo.done)
              )
            )
          }
        )
      }
    ),
    <span class="pl-en">'input</span>(<span class="pl-en">'id</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>todo-input<span class="pl-pds">"</span></span>, <span class="pl-en">'placeholder</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>New ToDo<span class="pl-pds">"</span></span>),
    <span class="pl-en">'button</span>(<span class="pl-s"><span class="pl-pds">"</span>Submit<span class="pl-pds">"</span></span>,
      event(<span class="pl-en">'click</span>) {
        <span class="pl-k">val</span> <span class="pl-en">input</span> <span class="pl-k">=</span> document
          .getElementById(<span class="pl-s"><span class="pl-pds">"</span>todo-input<span class="pl-pds">"</span></span>)
          .<span class="pl-c1">asInstanceOf</span>[html.<span class="pl-en">Input</span>]
        <span class="pl-k">val</span> <span class="pl-en">inputText</span> <span class="pl-k">=</span> input.value
        <span class="pl-c"><span class="pl-c">//</span> Reset input</span>
        input.value <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>
        <span class="pl-k">val</span> <span class="pl-en">newTodo</span> <span class="pl-k">=</span> <span class="pl-en">Todo</span>(
          id <span class="pl-k">=</span> <span class="pl-en">Random</span>.alphanumeric.take(<span class="pl-c1">5</span>).mkString,
          text <span class="pl-k">=</span> inputText,
          done <span class="pl-k">=</span> <span class="pl-c1">false</span>
        )
        renderTodos(todos <span class="pl-k">:</span><span class="pl-k">+</span> newTodo)
      }
    )
  )
}

<span class="pl-k">val</span> <span class="pl-en">todos</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(
  <span class="pl-en">Todo</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Start use Levsha<span class="pl-pds">"</span></span>, done <span class="pl-k">=</span> <span class="pl-c1">false</span>),
  <span class="pl-en">Todo</span>(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Lean back and have rest<span class="pl-pds">"</span></span>, done <span class="pl-k">=</span> <span class="pl-c1">false</span>)
)

renderTodos(todos)</pre>
  </div> 
  <h2><a id="user-content-memory-allocation-model-explanation" class="anchor" href="https://github.com/fomkin/levsha#memory-allocation-model-explanation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Memory allocation model explanation</h2> 
  <p>As noted below Levsha does not make <em>additional</em> memory allocations. It is possible because every template, written in Levsha DSL, in compile-time optimizes into calls of <code>RenderContext</code> methods (unlike other template engines which<br> represent their templates as AST on-heap).</p> 
  <p>For example,</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">'div</span>(<span class="pl-en">'class</span> <span class="pl-k">/</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span>, 
  <span class="pl-en">'h1</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello world<span class="pl-pds">"</span></span>),
  <span class="pl-en">'p</span>(<span class="pl-s"><span class="pl-pds">"</span>Lorem ipsum dolor<span class="pl-pds">"</span></span>)
)</pre>
  </div> 
  <p>Will be rewritten to</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Node</span> { renderContext <span class="pl-k">=&gt;</span>
  renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)
  renderContext.setAttr(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>class<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span>)
  renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>h1<span class="pl-pds">"</span></span>)
  renderContext.addTextNode(<span class="pl-s"><span class="pl-pds">"</span>Hello world<span class="pl-pds">"</span></span>)
  renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>h1<span class="pl-pds">"</span></span>)
  renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>)
  renderContext.addTextNode(<span class="pl-s"><span class="pl-pds">"</span>Lorem ipsum dolor<span class="pl-pds">"</span></span>)
  renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>p<span class="pl-pds">"</span></span>)
  renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <p>In turn, <code>RenderContext</code> (namely <code>DiffRenderContext</code> implementation) saves instructions in <code>ByteBuffer</code> to infer changes in the future.</p> 
  <p>Of course, Levsha optimizer does not cover all cases. When optimization can't be performed Levsha just applies current <code>RenderContext</code> to the unoptimized node.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">'ul</span>(
  <span class="pl-en">Seq</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>).collect { 
    <span class="pl-k">case</span> x <span class="pl-k">if</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> <span class="pl-en">'li</span>(x.toString)
  }
)

<span class="pl-c"><span class="pl-c">//</span> ==&gt;</span>

<span class="pl-en">Node</span> { renderContext <span class="pl-k">=&gt;</span>
  renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>ul<span class="pl-pds">"</span></span>)
  <span class="pl-en">Seq</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>)
    .collect {
      <span class="pl-k">case</span> x <span class="pl-k">if</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> 
        <span class="pl-en">Node</span> { renderContext <span class="pl-k">=&gt;</span>
          renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>)
          renderContext.addTextNode(x.toString)
          renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>)
        }
    }
    .foreach { childNode <span class="pl-k">=&gt;</span>
      childNode.apply(renderContext)
    }
  renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>ul<span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <p>When you write your Levsha templates, keep in your mind this list of optimizations:</p> 
  <ol> 
   <li>Nodes and attrs in branches of <code>if</code> expression will be moved to current <code>RenderContext</code></li> 
   <li>Same for cases of pattern matching</li> 
   <li><code>xs.map(x =&gt; 'div(x))</code> will be rewritten into a <code>while</code> loop</li> 
   <li><code>maybeX.map(x =&gt; 'div(x))</code> will be rewritten into an <code>if</code> expression</li> 
   <li><code>void</code> will be removed</li> 
  </ol> 
  <p>The third item of this list shows us how to rewrite previous example so that optimization could be performed.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">'ul</span>(
  <span class="pl-en">Seq</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>)
    .filter(x <span class="pl-k">=&gt;</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>)
    .map { x <span class="pl-k">=&gt;</span> <span class="pl-en">'li</span>(x.toString) }
)

<span class="pl-c"><span class="pl-c">//</span> ==&gt;</span>

<span class="pl-en">Node</span> { renderContext <span class="pl-k">=&gt;</span>
  renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">iterator</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>)
    .filter(x <span class="pl-k">=&gt;</span> x <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>)
    .iterator
  <span class="pl-k">while</span> (iterator.hasNext) {
    <span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> iterator.next()
    renderContext.openNode(<span class="pl-en">XmlNs</span>.html, <span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>)
    renderContext.addTextNode(x.toString)
    renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>)
  }
  renderContext.closeNode(<span class="pl-s"><span class="pl-pds">"</span>div<span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <p>If you are not sure about you code, run compiler with <code>levsha.macros.notOptimizedWarnings=true</code> parameter. For example <code>sbt -Dlevsha.macros.notOptimizedWarnings=true</code></p> 
  <h2><a id="user-content-worthy-to-note" class="anchor" href="https://github.com/fomkin/levsha#worthy-to-note" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Worthy to note</h2> 
  <ol> 
   <li><a href="https://en.wikipedia.org/wiki/The_Tale_of_Cross-eyed_Lefty_from_Tula_and_the_Steel_Flea" target="_blank">The Tale of Cross-eyed Lefty from Tula and the Steel Flea</a></li> 
  </ol> 
 </article>
</div>