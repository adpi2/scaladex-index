<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/mziccard/scala-audio-file#scala-audio-file" aria-hidden="true" class="anchor" id="user-content-scala-audio-file" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>scala-audio-file</h1> 
  <p>Minimal Scala library to process audio files. Only WAVE files are supported now.</p> 
  <h2><a href="https://github.com/mziccard/scala-audio-file#overview" aria-hidden="true" class="anchor" id="user-content-overview" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h2> 
  <p>This library allows to:</p> 
  <ul> 
   <li>Wrap an audio file and extract metadata as well as audio data</li> 
   <li>Compute a normalized waveform</li> 
   <li>Detect audio tempo in beats per minute</li> 
  </ul> 
  <h2><a href="https://github.com/mziccard/scala-audio-file#cloning-the-library" aria-hidden="true" class="anchor" id="user-content-cloning-the-library" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cloning the library</h2> 
  <p>The library uses <a href="https://github.com/cscheiblich/jwave" target="_blank">JWave</a> and adds it as a git submodule in <code>lib/jwave</code>. To have a working copy of the library, after cloning the repository you need to init and update the submodules.</p> 
  <div class="highlight highlight-source-shell">
   <pre>git submodule init
git submodule update</pre>
  </div> 
  <h2><a href="https://github.com/mziccard/scala-audio-file#configuring-sbt" aria-hidden="true" class="anchor" id="user-content-configuring-sbt" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuring sbt</h2> 
  <p>The scala audio library can be included into you sbt project as:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-en">Resolver</span>.bintrayRepo(<span class="pl-s"><span class="pl-pds">"</span>mziccard<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>maven<span class="pl-pds">"</span></span>)
libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>me.mziccard<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scala-audio-file<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>All releases are pushed to the maven repository. Latest release is:</p> 
  <ul> 
   <li>scala-audio-file v0.2 compatible with Scala 2.10 and Scala 2.11</li> 
  </ul> 
  <h2><a href="https://github.com/mziccard/scala-audio-file#library" aria-hidden="true" class="anchor" id="user-content-library" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Library</h2> 
  <p>A WAVE file can be opened via the <code>WavFile</code> class. The class has private constructor and cannot be directly istantiated, use the companion object instead. <code>WavFile</code> provides several functionalites to access audio data and metadata.<br> Audio samples can be read as floating point values in the interval [0,1].</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">audioFile</span> <span class="pl-k">=</span> <span class="pl-en">WavFile</span>(<span class="pl-s"><span class="pl-pds">"</span>filename.wav<span class="pl-pds">"</span></span>);
<span class="pl-k">val</span> <span class="pl-en">readBuffer</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Array</span>[<span class="pl-k">Double</span>](<span class="pl-c1">1024</span><span class="pl-k">*</span>audioFile.numChannels);
<span class="pl-k">val</span> <span class="pl-en">framesRead</span> <span class="pl-k">=</span> audioFile.readNormalizedFrames(readBuffer, <span class="pl-c1">1024</span>);</pre>
  </div> 
  <p>or as integer values.</p> 
  <pre><code>val audioFile = WavFile("filename.wav");
val readBuffer = new Array[Double](1024*audioFile.numChannels);
val framesRead = audioFile.readFrames(readBuffer, 1024);
</code></pre> 
  <h3><a href="https://github.com/mziccard/scala-audio-file#computing-waveform" aria-hidden="true" class="anchor" id="user-content-computing-waveform" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Computing waveform</h3> 
  <p>A waveform can be computed for the audio track by wrapping the file object inside a <code>Waveform</code> object. A waveform is represented as a Scala array of Double values in the interval [0,1]. User can specify the amount of points per minutes the waveform should be made of.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">audioFile</span> <span class="pl-k">=</span> <span class="pl-en">WavFile</span>(<span class="pl-s"><span class="pl-pds">"</span>filename.wav<span class="pl-pds">"</span></span>);
<span class="pl-k">val</span> <span class="pl-en">waveform</span> <span class="pl-k">=</span> <span class="pl-en">Waveform</span>(audioFile);
<span class="pl-k">var</span> <span class="pl-en">waveformJSON</span> <span class="pl-k">=</span> <span class="pl-en">Waveform</span>.formatToJson(waveform.getWaveform(<span class="pl-c1">512</span>), <span class="pl-c1">2</span>);</pre>
  </div> 
  <p><code>Waveform</code> companion object provides a method to export the waveform as a JSON array with a controlled amount of decimal digits.</p> 
  <h3><a href="https://github.com/mziccard/scala-audio-file#computing-beats-per-minute" aria-hidden="true" class="anchor" id="user-content-computing-beats-per-minute" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Computing beats per minute</h3> 
  <p>Three classes are available to compute audio file tempo in bpm. Both classes implement the <code>BPMDetector</code> trait.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">BPMDetector</span> {
  <span class="pl-k">def</span> <span class="pl-en">bpm</span>() <span class="pl-k">:</span> <span class="pl-k">Double</span>;
}</pre>
  </div> 
  <p>The <code>SoundEnergyBPMDetector</code> applies a simple bpm detection algorithm based on identificaiton of energy peaks in the track's audio data. No transform is applied to data, the class implementes the algorithm #3 described <a href="http://goo.gl/AmWo1u" target="_blank">here</a>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">audioFile</span> <span class="pl-k">=</span> <span class="pl-en">WavFile</span>(<span class="pl-s"><span class="pl-pds">"</span>filename.wav<span class="pl-pds">"</span></span>);
<span class="pl-k">val</span> <span class="pl-en">tempo</span> <span class="pl-k">=</span> <span class="pl-en">SoundEnergyBPMDetector</span>(audioFile).bpm;</pre>
  </div> 
  <p>The <code>FilterBPMDetector</code> applies a more complex algorithm based on filters. Data are filtered, for instance low-passed, before detecting peaks. Tempo is computed as the most recurring distance across identified peaks. The <code>BiquadFilter</code> class, implementing a <a href="http://www.musicdsp.org/files/Audio-EQ-Cookbook.txt" target="_blank">biquad filter</a>, can be used in combination with <code>FilterBPMDetector</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">audioFile</span> <span class="pl-k">=</span> <span class="pl-en">WavFile</span>(<span class="pl-s"><span class="pl-pds">"</span>filename.wav<span class="pl-pds">"</span></span>);
<span class="pl-k">val</span> <span class="pl-en">filter</span> <span class="pl-k">=</span> <span class="pl-en">BiquadFilter</span> (
  audioFile.sampleRate,
  audioFile.numChannels,
  <span class="pl-en">FilterType</span>.<span class="pl-en">LowPass</span>)
<span class="pl-k">val</span> <span class="pl-en">detector</span> <span class="pl-k">=</span> <span class="pl-en">FilterBPMDetector</span>(audioFile, filter);
<span class="pl-k">val</span> <span class="pl-en">tempo</span> <span class="pl-k">=</span> detector.bpm</pre>
  </div> 
  <p>More complex factory methods are also available in <code>FilterBPMDetector</code> that allow more fine-grained configuration. For more details on the algorithm implemented by <code>FilterBPMDetector</code> you can have a look at Beatport's <a href="http://tech.beatport.com/2014/web-audio/beat-detection-using-web-audio/" target="_blank">blog</a>.</p> 
  <p>The class <code>WaveletBPMDetector</code> applies a more precise algorithm (described in this <a href="http://soundlab.cs.princeton.edu/publications/2001_amta_aadwt.pdf" target="_blank">paper</a>) based on the Discrete Wavelet Transform (DWT). The algorithm operates on windows of frames so the class can be istantiated by providing an audio file, the size of a window in number of frames and the type of wavelet.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">audioFile</span> <span class="pl-k">=</span> <span class="pl-en">WavFile</span>(<span class="pl-s"><span class="pl-pds">"</span>filename.wav<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">tempo</span> <span class="pl-k">=</span> <span class="pl-en">WaveletBPMDetector</span>(
              audioFile, 
              <span class="pl-c1">131072</span>, 
              <span class="pl-en">WaveletBPMDetector</span>.<span class="pl-en">Daubechies4</span>).bpm</pre>
  </div> 
  <p>So far only Haar and Daubechies4 wavelets are supported. Due to the way DWT is implemented the size of a window must be a power of 2. An additional integer parameter can be given to the factory method providing the maximum number of windows to process. If not specified the entire track is processed.</p> 
 </article>
</div>