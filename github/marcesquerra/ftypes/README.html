<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-what-is-ftypes" class="anchor" href="https://github.com/marcesquerra/ftypes#what-is-ftypes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>What is FTypes?</h1> 
  <p>FTypes:</p> 
  <ul> 
   <li>Right now: <strong>IS EXPERIMENTAL</strong></li> 
   <li>Is a type system (that is: a collection of base types plus means for building complex types out of simpler ones)</li> 
   <li>Is for concurrent programming (async)</li> 
   <li>Solve the same problem than futures do. But without futures (or nearly so)</li> 
   <li>Allows working with asynchronous types as if they were normal synchronous ones</li> 
   <li>These async types have the same interface (methods) than their synchronous counterparts</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">com.bryghts.ftypes.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> async.<span class="pl-k">Int</span>(<span class="pl-en">Future</span>.successful(<span class="pl-c1">3</span>)) <span class="pl-c"><span class="pl-c">//</span> Convert Future into async</span>
<span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> async.<span class="pl-k">Int</span>(<span class="pl-en">Future</span>.successful(<span class="pl-c1">4</span>))

<span class="pl-k">val</span> <span class="pl-en">c</span><span class="pl-k">:</span> async.<span class="pl-k">Int</span> <span class="pl-k">=</span> a <span class="pl-k">+</span> b
</pre>
  </div> 
  <p><br> <br></p> 
  <h1><a id="user-content-getting-started" class="anchor" href="https://github.com/marcesquerra/ftypes#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h1> 
  <p>Include in your SBT file:</p> 
  <div class="highlight highlight-source-scala">
   <pre>addCompilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.scalamacros<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>paradise<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.0<span class="pl-pds">"</span></span> cross <span class="pl-en">CrossVersion</span>.full)

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.bryghts.ftypes<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>ftypes<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.0.3<span class="pl-pds">"</span></span>
</pre>
  </div> 
  <p>Or, if you are using <a href="http://www.scala-js.org/" target="_blank">ScalaJS</a>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>addCompilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.scalamacros<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>paradise<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.0<span class="pl-pds">"</span></span> cross <span class="pl-en">CrossVersion</span>.full)

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.bryghts.ftypes<span class="pl-pds">"</span></span> <span class="pl-k">%%%</span> <span class="pl-s"><span class="pl-pds">"</span>ftypes<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.0.3<span class="pl-pds">"</span></span>
</pre>
  </div> 
  <p>NOTE: The first line is to include the <a href="http://docs.scala-lang.org/overviews/macros/paradise.html" target="_blank">Macro Paradise compiler plugin</a> which powers the <a href="https://github.com/marcesquerra/ftypes#case-classes" target="_blank">@Async</a> macro-annotation <br> <br> <br></p> 
  <h1><a id="user-content-example" class="anchor" href="https://github.com/marcesquerra/ftypes#example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example</h1> 
  <p>Imagine we have coded a function that returns how many healthy and active servers we have, for a particular region. The response of such a method would quite possibly be asynchronous, which, if we want to access the value, usually opens up three possibilities:</p> 
  <ul> 
   <li>Blocking. Currently, in the Scalasphere this is considerd a <strong>Very Bad Idea</strong> (I'm looking on sources to support this point)</li> 
   <li>Callbacks. Nearly as bad a blocking (<a href="http://www.google.com/search?q=callback+hell" target="_blank">Google for "Callback Hell"</a>)</li> 
   <li>Futures (of which FTypes are a variant)</li> 
  </ul> 
  <p>In this example, I'm going to compare standard scala Futures with FTypes.</p> 
  <h2><a id="user-content-with-futures" class="anchor" href="https://github.com/marcesquerra/ftypes#with-futures" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>With Futures</h2> 
  <p>In this case, our method would have a signature more or less like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">_</span>

<span class="pl-k">def</span> <span class="pl-en">getActiveServers</span>(<span class="pl-v">regionId</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
</pre>
  </div> 
  <p>And, if we want to compute how many servers we have if we combine Europe and America:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">europeCount</span><span class="pl-k">:</span>  <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]  <span class="pl-k">=</span> getActiveServers(europeId)
<span class="pl-k">val</span> <span class="pl-en">americaCount</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]  <span class="pl-k">=</span> getActiveServers(americaId)

<span class="pl-k">val</span> <span class="pl-en">totalCount</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span>
    europeCount.flatMap(e <span class="pl-k">=&gt;</span> americaCount.map(a <span class="pl-k">=&gt;</span> e <span class="pl-k">+</span> a))
</pre>
  </div> 
  <p>Or, with for comprehencion, we can make it a bit nicer:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">europeCount</span><span class="pl-k">:</span>  <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]  <span class="pl-k">=</span> getActiveServers(europeId)
<span class="pl-k">val</span> <span class="pl-en">americaCount</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]  <span class="pl-k">=</span> getActiveServers(americaId)

<span class="pl-k">val</span> <span class="pl-en">totalCount</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-k">for</span> {
  e   <span class="pl-k">&lt;</span><span class="pl-k">-</span>   europeCount
  a   <span class="pl-k">&lt;</span><span class="pl-k">-</span>   americaCount
  } <span class="pl-k">yield</span> a <span class="pl-k">+</span> e
</pre>
  </div> 
  <h2><a id="user-content-with-ftypes" class="anchor" href="https://github.com/marcesquerra/ftypes#with-ftypes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>With FTypes</h2> 
  <p>Here, our method would have a really similar signature:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.bryghts.ftypes.</span><span class="pl-v">_</span>

<span class="pl-k">def</span> <span class="pl-en">getActiveServers</span>(<span class="pl-v">regionId</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> async.<span class="pl-k">Int</span> <span class="pl-k">=</span> <span class="pl-k">???</span>
</pre>
  </div> 
  <p>The real difference comes when we use this method to the same computation than before:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">europeCount</span><span class="pl-k">:</span>  async.<span class="pl-k">Int</span> <span class="pl-k">=</span> getActiveServers(europeId)
<span class="pl-k">val</span> <span class="pl-en">americaCount</span><span class="pl-k">:</span> async.<span class="pl-k">Int</span> <span class="pl-k">=</span> getActiveServers(americaId)

<span class="pl-k">val</span> <span class="pl-en">totalCount</span><span class="pl-k">:</span>   async.<span class="pl-k">Int</span> <span class="pl-k">=</span> europeCount <span class="pl-k">+</span> americaCount
</pre>
  </div> 
  <p><strong>async.Int</strong> is just one of the types that FTypes provides out of the box, with, practically, all the same operations (methods) than the standard Int, where, like in the example, the '+' operation returns an async.Int that will hold the value of the sum (whenever the other two numbers are available) <br> <br> <br></p> 
  <h1><a id="user-content-futures-without-future" class="anchor" href="https://github.com/marcesquerra/ftypes#futures-without-future" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Futures without Future</h1> 
  <p>Most Scala devs have to work with <a href="http://docs.scala-lang.org/overviews/core/futures.html" target="_blank">Futures</a> in a daily basis and know the toll they apply in the mental model and the code readability/maintainability. If you don't know what a Future is, you can find an excellent introduction in <a href="http://danielwestheide.com/blog/2013/01/09/the-neophytes-guide-to-scala-part-8-welcome-to-the-future.html" target="_blank">this article</a> by Daniel Westheide.</p> 
  <p>If you know what a future is and how it works, let me present you with a comparison. On one side, we have:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Future</span>[<span class="pl-k">Int</span>]</pre>
  </div> 
  <p>On the other hand, we have:</p> 
  <div class="highlight highlight-source-scala">
   <pre>async.<span class="pl-k">Int</span></pre>
  </div> 
  <p>Both represent exactly the same thing, an Int value that will be available at some, unknown, point in time.</p> 
  <p>Comparing both snippets, you can draw an immediate conclusion. While a Future is a generic type (a Future can hold any type of data), the <code>async.Int</code> is a concrete type that con only hold integers. This means that if you want some sort of asynchronous <code>Boolean</code>, with Futures you have the problem already solved (i.e. <code>Future[Boolean]</code>) while with FTypes you need another specific type (which, by the way, FTypes already provides and is called <code>async.Boolean</code>).</p> 
  <p>The <strong>main difference</strong> comes when you compare the methods provided by <code>Future</code> and <code>async.Int</code>. Future is a generic type and knows nothing about the data is going to end up holding, were async.Int is always going to be used to only hold ints. In fact <code>async.Int</code> has none of the methods provided by the <code>Future</code> class but (nearly) all the methods provided by a regular, synchronous <code>Int</code>.</p> 
  <p>That is: With an <code>async.Int</code> you operate exactly the same as if it was a normal <code>scala.Int</code></p> 
  <p>And this has a nice consequence: Functions that before received regular, synchronous types:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">average</span>(<span class="pl-v">a</span>: <span class="pl-k">Double</span>, <span class="pl-v">b</span>: <span class="pl-k">Double</span>)<span class="pl-k">:</span> <span class="pl-k">Double</span> <span class="pl-k">=</span> (a <span class="pl-k">+</span> b) <span class="pl-k">/</span> <span class="pl-c1">2</span></pre>
  </div> 
  <p>Can now be reimplemented for the asynchronous world like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">average</span>(<span class="pl-v">a</span>: async.<span class="pl-k">Double</span>, <span class="pl-v">b</span>: async.<span class="pl-k">Double</span>)<span class="pl-k">:</span> async.<span class="pl-k">Double</span> <span class="pl-k">=</span> (a <span class="pl-k">+</span> b) <span class="pl-k">/</span> <span class="pl-c1">2</span></pre>
  </div> 
  <p><br> <br> <br></p> 
  <h1><a id="user-content-a-type-system" class="anchor" href="https://github.com/marcesquerra/ftypes#a-type-system" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>A Type System</h1> 
  <p>FTypes is a type system. What I mean with that is that it provides a collection of <a href="https://github.com/marcesquerra/ftypes#base-types" target="_blank">base-types</a> and means for creating complex types out of simpler ones, like <a href="https://github.com/marcesquerra/ftypes#arrays" target="_blank">async arrays</a> or <a href="https://github.com/marcesquerra/ftypes#case-classes" target="_blank">async case classes</a>.</p> 
  <h2><a id="user-content-every-async-has-a-sync" class="anchor" href="https://github.com/marcesquerra/ftypes#every-async-has-a-sync" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Every ASync has a Sync</h2> 
  <p>In the end, the async types provided by FTypes are a very specialised form of Future: something that will hold a value at some point in time, in the future. This something, this result of a computation, is going to be a concrete series of bits in your computer. And this series of bits, to be meaningful, are going to have a concrete, synchronous, old-school type.</p> 
  <p>If, for example, a method returns an <code>async.Int</code>, what we are saying is that this method is returning a ticket, a special ticket that is changeable for the actual value when that value becomes available. But, that value that will become available is going to be an standard Scala <code>Int</code>.</p> 
  <p><strong>The <code>async.Int</code> type is associated with (or represented by) an <code>scala.Int</code></strong></p> 
  <p>And that holds true for every single async type.</p> 
  <h2><a id="user-content-any-async-type" class="anchor" href="https://github.com/marcesquerra/ftypes#any-async-type" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Any async type</h2> 
  <p>All async types extend:</p> 
  <div class="highlight highlight-source-scala">
   <pre>async.<span class="pl-en">Any</span>[<span class="pl-en">T</span>, <span class="pl-en">FT</span>]</pre>
  </div> 
  <p>Where, <code>T</code> is the synchronous type and <code>FT</code> is the type extending <code>async.Any</code>. For example, <code>async.Int</code> declared in a way similar to this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">com.bryghts.ftypes</span>
<span class="pl-k">package</span> <span class="pl-en">async</span>

<span class="pl-k">class</span> <span class="pl-en">Int</span> <span class="pl-k">extends</span> <span class="pl-e">async.Any</span>[scala.<span class="pl-k">Int</span>, async.<span class="pl-k">Int</span>]</pre>
  </div> 
  <h2><a id="user-content-base-types" class="anchor" href="https://github.com/marcesquerra/ftypes#base-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Base types</h2> 
  <p>For now, the following base types are implemented:</p> 
  <ul> 
   <li>async.Byte</li> 
   <li>async.Char</li> 
   <li>async.Short</li> 
   <li>async.Int</li> 
   <li>async.Long</li> 
   <li>async.Float</li> 
   <li>async.Double</li> 
   <li>async.Boolean</li> 
   <li>async.String</li> 
  </ul> 
  <p>Note: The <a href="http://www.scala-lang.org/files/archive/api/current/index.html#scala.runtime.RichInt" target="_blank">RichInt</a> and similar extensions have not been implemented yet.</p> 
  <h2><a id="user-content-arrays" class="anchor" href="https://github.com/marcesquerra/ftypes#arrays" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Arrays</h2> 
  <p>You can create immutable async arrays like with basic arrays:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> async.<span class="pl-en">Array</span>[async.<span class="pl-k">Int</span>](<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
<span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> a(<span class="pl-c1">1</span>)
<span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> l.length  <span class="pl-c"><span class="pl-c">//</span> returns an async.Int</span>
</pre>
  </div> 
  <p>These arrays are immutable because update operations on asynchronous types would break the reason why futures work so well.</p> 
  <p>NOTE: async arrays can only hold async types</p> 
  <h2><a id="user-content-case-classes" class="anchor" href="https://github.com/marcesquerra/ftypes#case-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Case classes</h2> 
  <p>This bit is extremely experimental, because:</p> 
  <ul> 
   <li>It uses macro annotations (which are experimental by themselves)</li> 
   <li>Macros are hard and complex to write, which makes this bit require a lot more testing than it has (for now)</li> 
  </ul> 
  <p>As I've <a href="https://github.com/marcesquerra/ftypes#every-async-has-a-sync" target="_blank">mentioned before</a>, every async type needs a synchronous counterpart. And this starts being a problem when you need to create custom classes.</p> 
  <p>Imagine we need a Person class:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>)
</pre>
  </div> 
  <p>If we want to make "Person" asynchronous, the first idea that comes to mind, is to make the fields asynchronous:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: async.<span class="pl-k">String</span>, <span class="pl-v">age</span>: async.<span class="pl-k">Int</span>)
</pre>
  </div> 
  <p>But this doesn't really solve the problem. If you have a method that returns a Person in an async way you will still need to return a Future[Person], which doesn't solve much. Another option is to create two types and relate them. This is a non-compiling and simplified version on how you would do that with FTypes:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SyncPerson</span>(<span class="pl-v">name</span>: async.<span class="pl-k">String</span>, <span class="pl-v">age</span>: async.<span class="pl-k">Int</span>)

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">future</span>: <span class="pl-en">Future</span>[<span class="pl-en">SyncPerson</span>]) <span class="pl-k">extends</span> <span class="pl-e">async.Any</span>[<span class="pl-en">SyncPerson</span>, <span class="pl-en">Person</span>] {
    <span class="pl-k">def</span> <span class="pl-en">name</span> <span class="pl-k">=</span> future.map(_.name).flatten
    <span class="pl-k">def</span> <span class="pl-en">age</span> <span class="pl-k">=</span> future.map(_.age).flatten
}
</pre>
  </div> 
  <p>As you can see, this approach is bloated, cumbersome and error-prone. And it's just the non-compiling and simplified version!</p> 
  <p>The solution is the <code>@Async</code> macro annotation that FTypes provides. This macro does all that for you in a transparent way:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">@</span><span class="pl-en">Async</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: async.<span class="pl-k">String</span>, <span class="pl-v">age</span>: async.<span class="pl-k">Int</span>)
</pre>
  </div> 
  <p>NOTE: as in the case of Array, async case classes can only hold async fields <br> <br> <br></p> 
  <h1><a id="user-content-interoperativility" class="anchor" href="https://github.com/marcesquerra/ftypes#interoperativility" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Interoperativility</h1> 
  <p>Eventually (probably in the extremes of your code) you will need to operate with a more standard Scala way. FTypes provides an easy way to convert to (and from) Futures (Futures to the underlaying synchronous type):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">fi</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">i</span> <span class="pl-k">=</span> async.<span class="pl-k">Int</span>(fi)


<span class="pl-k">val</span> <span class="pl-en">b</span><span class="pl-k">:</span> async.<span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">fb</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> b.future
</pre>
  </div> 
  <p><br> <br> <br></p> 
  <h1><a id="user-content-compatibility" class="anchor" href="https://github.com/marcesquerra/ftypes#compatibility" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Compatibility</h1> 
  <p>The project is provided for:</p> 
  <ul> 
   <li>JVM</li> 
   <li>ScalaJS</li> 
  </ul> 
  <p>And Scala Versions:</p> 
  <ul> 
   <li>2.10</li> 
   <li>2.11 <br> <br> <br></li> 
  </ul> 
  <h1><a id="user-content-roadmap" class="anchor" href="https://github.com/marcesquerra/ftypes#roadmap" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Roadmap</h1> 
  <ul> 
   <li>Improve this documentation (including the SBT section)</li> 
   <li>Create async versions of StringOps, RichInt, ...</li> 
   <li>Create an async version of the collections library</li> 
   <li>Create the Option and Try monads <br> <br> <br></li> 
  </ul> 
  <h1><a id="user-content-layers" class="anchor" href="https://github.com/marcesquerra/ftypes#layers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Layers</h1> 
  <p>This project don't contain much code by itself. It's instead a composition of the following projects:</p> 
  <ul> 
   <li><a href="https://github.com/marcesquerra/FTypes-Vals" target="_blank">Vals</a> Core system and base types (childs of "AnyVal")</li> 
   <li><a href="https://github.com/marcesquerra/FTypes-Array" target="_blank">Array</a></li> 
   <li><a href="https://github.com/marcesquerra/FTypes-String" target="_blank">String</a></li> 
   <li><a href="https://github.com/marcesquerra/FTypes-CaseClass" target="_blank">CaseClass</a> Provides the "@Async" annotation for case classes. Require Macro Paradise</li> 
  </ul> 
 </article>
</div>