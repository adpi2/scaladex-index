<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/regb/scala-smtlib#scala-smt-lib-" aria-hidden="true" class="anchor" id="user-content-scala-smt-lib-" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scala SMT-LIB <a href="http://laraquad4.epfl.ch:9000/regb/scala-smtlib" target="_blank"><img src="https://camo.githubusercontent.com/17575744a380057b1e568d902a89556991e535ec/687474703a2f2f6c61726171756164342e6570666c2e63683a393030302f726567622f7363616c612d736d746c69622f7374617475732f6d6173746572" alt="Build Status" data-canonical-src="http://laraquad4.epfl.ch:9000/regb/scala-smtlib/status/master" style="max-width:100%;"></a></h1> 
  <p>Scala SMT-LIB is a lightweight, no dependency, abstraction over the <a href="http://www.smtlib.org/" target="_blank">SMT-LIB</a> standard for Satisfiability Modulo Theory (SMT) solvers. It lets you use a type safe Scala API to build SMT-LIB scripts and ship them to any SMT-LIB complient solver over a process interface.</p> 
  <p>Scala SMT-LIB provides the tools for parsing and printing the SMT-LIB syntax. It can help you if you need to communicate with a native SMT solver process via its text interface. You can also write a Scala wrapper around an SMT solver and use it with a friendlier API. You could even get crazier and use a <a href="https://github.com/regb/cafesat" target="_blank">pure Scala SMT solver</a> that happens to implement the SMT-LIB api.</p> 
  <p>The library is still under active development and is evolving along with the needs of the projects using it. Essentially it means the API is going to change quite frequently until we are satisfied with how it feels. However, the code is actually quite robust, and comes with an extensive test suite. You should not fear relying on a current snapshot.</p> 
  <h2><a href="https://github.com/regb/scala-smtlib#applications" aria-hidden="true" class="anchor" id="user-content-applications" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Applications</h2> 
  <p>Scala SMT-LIB deals with the messy details of parsing and writing SMT-LIB. It provides a programmer friendly interface to simplify the development of tools that rely on SMT-LIB.</p> 
  <p>You may want to use Scala SMT-LIB if:</p> 
  <ul> 
   <li>You plan to write a tool that will use SMT-LIB as its input format, but do not wish to spend too much time figuring out the SMT-LIB standard. Then you can plug-in the parser component of Scala SMT-LIB in your tool and only deal with the Scala representation of the few SMT-LIB commands of your interest.</li> 
   <li>You need to output a complex SMT-LIB encoding of some mathematical problems. We got you covered: You can programatically build a set of expressions using the Scala SMT-LIB abstract syntax tree, and use the printer components to get a valid SMT-LIB representation to pass along to another tool.</li> 
   <li>You need to query an external black-box SMT solver, but the task of setting up a proper communication with this strange beast seems a bit too daunting? Scala SMT-LIB offers a module that abstracts SMTLIB-compliant solvers. You can program your tool against this simple high-level API. Scala SMT-LIB provides integration with <a href="https://github.com/Z3Prover/z3" target="_blank">Z3</a> and <a href="http://cvc4.cs.nyu.edu/web/" target="_blank">CVC4</a> out of the box, and you can add support for any other solver by implementing a relatively thin interface.</li> 
  </ul> 
  <h2><a href="https://github.com/regb/scala-smtlib#setup" aria-hidden="true" class="anchor" id="user-content-setup" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Setup</h2> 
  <p>The latest stable release for Scala 2.11 is available on Sonatype, simply add the following to your <code>build.sbt</code>:</p> 
  <pre><code>libraryDependencies += "com.regblanc" %% "scala-smtlib" % "0.2"
</code></pre> 
  <h2><a href="https://github.com/regb/scala-smtlib#getting-started-with-examples" aria-hidden="true" class="anchor" id="user-content-getting-started-with-examples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started with Examples</h2> 
  <p>To construct a parser, you will need a java.io.Reader and a lexer:</p> 
  <pre><code>val is = new java.io.FileReader("INPUT")
val lexer = new smtlib.lexer.Lexer(is)
val parser = new smtlib.parser.Parser(lexer)
</code></pre> 
  <p>The parser then provides a <code>parseCommand</code> functions that will consume the input until the end of command:</p> 
  <pre><code>val script: List[Command] = {
  var cmds = new ListBuffer[Command]
  var cmd = parser.parseCommand
  while(cmd != null)
    cmds.append(cmd)
  cmds.toList
}
</code></pre> 
  <p><code>parseCommand</code> returns <code>null</code> when the end of file is reached.</p> 
  <p>You can decompose a command using pattern matching:</p> 
  <pre><code>import smtlib.parser.Commands._
cmd match {
  case Assert(term) =&gt; ???
  case CheckSat() =&gt; ???
  case Pop(1) =&gt; ???
}
</code></pre> 
  <p>If you want to generate a script to feed to a solver, you can build the AST explicitly, and use the pretty printers:</p> 
  <pre><code>import smtlib.parser.Commands._
import smtlib.parser.theories.Ints._
val x = QualifiedIdentifier(SimpleIdentifier(SSymbol("x")))
val y = QualifiedIdentifier(SimpleIdentifier(SSymbol("y")))
val formula = Assert(LessThan(NumeralLit(0), Plus(x, y)))
smtlib.printer.RecursivePrinter.toString(formula) //(assert (&lt; 0 (+ x y)))
</code></pre> 
  <p>The above is a little bit verbose due to the objective of supporting all of SMT-LIB. We are hoping to provide a nicer API in the future to build SMT-LIB scripts, at least in the common cases, but the AST will probably remain at the core of the library.</p> 
  <h2><a href="https://github.com/regb/scala-smtlib#low-level-api" aria-hidden="true" class="anchor" id="user-content-low-level-api" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Low Level API</h2> 
  <p>This section introduces the low level API of Scala SMT-LIB. In the future, it is expected to be wrapped by a higher-level API to perform most common operations. However, that API is expected to remain relatively stable and at the core of the library, so if that fits your needs you should be able to safely use it. It comes with a relatively extensive test suite to make sure it is working as expected.</p> 
  <h3><a href="https://github.com/regb/scala-smtlib#lexing" aria-hidden="true" class="anchor" id="user-content-lexing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Lexing</h3> 
  <p>The <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/lexer" target="_blank"><code>lexer</code></a> package implements low level parsing of <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/lexer/Tokens.scala" target="_blank"><code>Tokens</code></a>, The <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/lexer/Lexer.scala" target="_blank"><code>Lexer</code></a> lexes the input into tokens. It reads lazily from a <code>java.io.Reader</code>, on invocation of the <code>nextToken</code> method:</p> 
  <pre><code>class Lexer(reader: java.io.Reader) { 
  def nextToken: Token = { ... }
}
</code></pre> 
  <p>One call to <code>nextToken</code> will only consume the input until the end of the current token. It will read one character at a time from the input <code>Reader</code> until it was able to unambiguously identify the end of the token. You can provide a buffered input as a way to improve performance on some use cases.</p> 
  <p><code>nextToken</code> either returns a valid <code>Token</code>, or <code>null</code> if EOF is reached in the input <code>Reader</code>. It will signal errors with exceptions: a value of <code>null</code> is not an error and is expected to be eventually reached (unless the input never ends, such as <code>stdin</code>). The following two exceptions can be thrown by the lexer:</p> 
  <ul> 
   <li><code>UnexpectedCharException</code> signals that an error in the input. It corresponds to a malformed token --- for example, a <code>#ffff</code> (instead of <code>#xffff</code>) would throw the exception on the first <code>f</code>. The exception indicates the position in the input.</li> 
   <li><code>UnexpectedEOFException</code> occurs when the EOF is reached in the middle of an un-completed token. For example, a string literal which is not closed before the EOF.</li> 
  </ul> 
  <h3><a href="https://github.com/regb/scala-smtlib#parsing" aria-hidden="true" class="anchor" id="user-content-parsing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parsing</h3> 
  <p>Usually one does not need to work on a token by token basis, and is only interested in fully formated SMT-LIB expressions. The <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/parser" target="_blank"><code>parser</code></a> provides the extraction of SMT-LIB expressions. The <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/parser/Parser.scala" target="_blank"><code>Parser</code></a> consumes tokens generated by the above lexer:</p> 
  <pre><code>class Parser(lexer: smtlib.lexer.Lexer) { 
  def nextCommand: Command = { ... }
  def nextTerm: Term = { ... }
}
</code></pre> 
  <p>It provides many <code>nextX</code> methods (more than shown above) to parse any expressions defined by the SMT-LIB standard grammar. The more common are the <code>nextCommand</code> and the <code>nextTerm</code> to parse respectively a command and a term-formula expression.</p> 
  <p>A <code>Parser</code> uses exceptions to signal parsing error, they are defined in the <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/parser/Parser.scala" target="_blank"><code>Parser</code> companion object</a>. They provide a bunch of information, including the token on which the parsing failed, the expected tokens, and the position in the input (the position is an attribute of the token and can be accessed through it).</p> 
  <p>A <code>Command</code> is the root of a complex abstract syntax tree (AST) representing the corresponding SMT-LIB command. It is defined <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/parser/Commands.scala" target="_blank">here</a>. A few commands take as parameter a <code>Term</code>, whose AST is defined <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/parser/Terms.scala" target="_blank">here</a>.</p> 
  <h3><a href="https://github.com/regb/scala-smtlib#printing" aria-hidden="true" class="anchor" id="user-content-printing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Printing</h3> 
  <p>The <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/printer" target="_blank"><code>printer</code></a> helps with printing out SMT-LIB complient commands. This means that the output of a printer can be send directly to an SMT solver.</p> 
  <h3><a href="https://github.com/regb/scala-smtlib#standard-theories" aria-hidden="true" class="anchor" id="user-content-standard-theories" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Standard Theories</h3> 
  <p>Finally the <a href="https://github.com/regb/scala-smtlib/blob/master/src/main/scala/smtlib/theories" target="_blank"><code>theories</code></a> module provides tree builders to create theory-specific formulas. Each theory module provides <code>apply</code> and <code>unapply</code> methods on various object to manipulate the <code>Term</code> representing the actual theory expression.</p> 
  <h2><a href="https://github.com/regb/scala-smtlib#development" aria-hidden="true" class="anchor" id="user-content-development" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Development</h2> 
  <p>The library is still under development and the API will likely go through quite a few changes. It was originally part of <a href="https://github.com/regb/scabolic" target="_blank">CafeSat</a> and has been made standalone in order for the <a href="https://github.com/epfl-lara/leon" target="_blank">Leon</a> project to rely on it. Hopefully, it can be useful to other people as well.</p> 
  <h3><a href="https://github.com/regb/scala-smtlib#testing" aria-hidden="true" class="anchor" id="user-content-testing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Testing</h3> 
  <p>In order to attain a decent level of quality, there is a relatively strict policy for testing. Testing is separated in two levels of testing: unit tests and integration tests. Unit test are dependency free and run entirely in memory. While integration tests will rely on things like file system and external solvers. Unit test are very fast and should be easy to run as part of a regular build cycle (you can run them after each compile), while integration tests are a bit slower and are meant to pass on each commit.</p> 
  <p>In SBT, the command <code>sbt test</code> will run the unit test suite, while the command <code>sbt it:test</code> will run the integration test suite. During developement, it should be fine to run in mode <code>~testQuick</code>.</p> 
  <h3><a href="https://github.com/regb/scala-smtlib#building-the-sources" aria-hidden="true" class="anchor" id="user-content-building-the-sources" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Building the Sources</h3> 
  <p>The project is built with <a href="http://www.scala-sbt.org/" target="_blank">sbt</a>. To build the library, just type:</p> 
  <pre><code>sbt package
</code></pre> 
  <p>It will produce a jar that you can add to the classpath of your own project.</p> 
  <p>If you are building your project using sbt, it is possible to setup a reference to this github repository in the build system to automatically get the most recent build. <a href="https://github.com/regb/cafesat/blob/master/build.sbt" target="_blank">Here</a> is an example of how to do it, you can pick any commit. If you are interested in this route, you should check the sbt official documentation.</p> 
  <p>Optionally, you can test Scala SMT-LIB in your environment by running the test suite. The tests are organized in unit and functional tests. Tu run the unit tests (very fast) you can type:</p> 
  <pre><code>sbt test
</code></pre> 
  <p>All tests should pass. Please open an issue if any test is failing. The functional tests are testing end-to-end flows of Scala SMT-LIB. They do take a bit more time and require some setup in your environment. In particular, they will try to use the SMT solvers <code>z3</code> and/or <code>cvc4</code> if they are available in your PATH (the commands tried are exactly <code>z3</code> and <code>cvc4</code>). If present in the PATH, Scala SMT-LIB will test its interpreter module directly against these SMT solvers. You can run those tests with:</p> 
  <pre><code>sbt it:test
</code></pre> 
  <h2><a href="https://github.com/regb/scala-smtlib#changelog" aria-hidden="true" class="anchor" id="user-content-changelog" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changelog</h2> 
  <p>See <a href="https://github.com/regb/scala-smtlib/blob/master/CHANGELOG.md" target="_blank">Changelog</a>.</p> 
 </article>
</div>