<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-checklist" class="anchor" href="https://github.com/davegurnell/checklist#checklist" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Checklist</h1> 
  <p>Library for reading and validating data, with support for hard and soft constraints. Pre-alpha. Not ready for use.</p> 
  <p>Copyright 2016-17 Dave Gurnell. Licensed <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache 2</a>.</p> 
  <p><a href="https://travis-ci.org/davegurnell/checklist" target="_blank"><img src="https://camo.githubusercontent.com/22c624bb8269e0f8ff82875b42cdca3e32c330d1/68747470733a2f2f7472617669732d63692e6f72672f646176656775726e656c6c2f636865636b6c6973742e7376673f6272616e63683d646576656c6f70" alt="Build Status" data-canonical-src="https://travis-ci.org/davegurnell/checklist.svg?branch=develop" style="max-width:100%;"></a> <a href="https://codecov.io/github/davegurnell/checklist" target="_blank"><img src="https://camo.githubusercontent.com/b26ef513f72c6209bac47a1192f08f765ac3cde4/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f646176656775726e656c6c2f636865636b6c6973742f646576656c6f702e737667" alt="Coverage status" data-canonical-src="https://img.shields.io/codecov/c/github/davegurnell/checklist/develop.svg" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/com.davegurnell/checklist_2.11" target="_blank"><img src="https://camo.githubusercontent.com/ac92b7f7d0879c08ce1bacfb5a01c8dacb8ca539/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e646176656775726e656c6c2f636865636b6c6973745f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.davegurnell/checklist_2.11/badge.svg" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-synopsis" class="anchor" href="https://github.com/davegurnell/checklist#synopsis" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Synopsis</h2> 
  <p>Checklist is a library for validating data in applications and inputs to applications. Key features include:</p> 
  <ul> 
   <li>hard and soft validation ("errors" and "warnings");</li> 
   <li>accumulation of errors (as opposed to fail-fast error handling);</li> 
   <li>the ability to transform values when validating them;</li> 
   <li>recording the location of errors within an ADT using "Paths";</li> 
   <li>a convenient shorthand syntax for tip-down validation of existing data.</li> 
  </ul> 
  <p>The main concepts are as follows:</p> 
  <p>The main unit of code is a function-like <code>Rule</code> type. A <code>Rule[A, B]</code> validates a value of type <code>A</code> and returns a value of type <code>B</code>.</p> 
  <p>Because validation can fail, the actual return type is <code>Checked[B]</code>, which is a type alias for <code>Ior[NonEmptyList[Message], B]</code>.</p> 
  <p>A <code>Message</code> is a data structure containing a <code>String</code> and a <code>Path</code> describing the location of the error.</p> 
  <h3><a id="user-content-hard-vs-soft-validation" class="anchor" href="https://github.com/davegurnell/checklist#hard-vs-soft-validation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Hard vs Soft Validation</h3> 
  <p><code>Messages</code> come in two varieties:</p> 
  <ul> 
   <li><code>ErrorMessages</code> represent "fatal" errors (hard validation);</li> 
   <li><code>WarningMessages</code> represent advisory messages (soft validation).</li> 
  </ul> 
  <p>Here's an example of a hard validation rule:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Message.</span><span class="pl-v">errors</span>

<span class="pl-k">val</span> <span class="pl-en">parseInt</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">String</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span>
  <span class="pl-en">Rule</span>.pure { str <span class="pl-k">=&gt;</span>
    <span class="pl-en">Xor</span>.catchNonFatal(str.toInt).fold(
      exn <span class="pl-k">=&gt;</span> <span class="pl-en">Ior</span>.left(errors(<span class="pl-s"><span class="pl-pds">"</span>Must be an integer<span class="pl-pds">"</span></span>))
      num <span class="pl-k">=&gt;</span> <span class="pl-en">Ior</span>.right(num)
    )
  }</pre>
  </div> 
  <p>and a soft rule:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist._, .Message.</span><span class="pl-v">warnings</span>

<span class="pl-k">def</span> <span class="pl-en">tooManyCoffees</span>(<span class="pl-v">recommendedLimit</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span>
  <span class="pl-en">Rule</span>.pure { coffees <span class="pl-k">=&gt;</span>
    <span class="pl-k">if</span>(coffees <span class="pl-k">&gt;</span> recommendedLimit) {
      <span class="pl-en">Ior</span>.both(warnings(<span class="pl-s"><span class="pl-pds">"</span>Hands shaking yet?<span class="pl-pds">"</span></span>), coffees)
    } <span class="pl-k">else</span> {
      <span class="pl-en">Ior</span>.right(coffees)
    }
  }</pre>
  </div> 
  <h3><a id="user-content-built-in-rules" class="anchor" href="https://github.com/davegurnell/checklist#built-in-rules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Built-in Rules</h3> 
  <p>There are a host of built-in rules that do useful things for example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">greaterThanZero</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span>
  gte(<span class="pl-c1">0</span>)

<span class="pl-k">val</span> <span class="pl-en">nonEmptyString</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">String</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span>
  nonEmpty[<span class="pl-k">String</span>]

<span class="pl-k">def</span> <span class="pl-en">nonEmptyList</span>[<span class="pl-en">A</span>]<span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">List</span>[<span class="pl-en">A</span>], <span class="pl-en">List</span>[<span class="pl-en">A</span>]] <span class="pl-k">=</span>
  nonEmpty[<span class="pl-en">List</span>[<span class="pl-en">A</span>]]</pre>
  </div> 
  <p>The built-in rules provide default English error messages that make sense in a suitable context (e.g. below a control on a web form). However, you can specify your own messages for each:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">greaterThanZero</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span>
  gte(<span class="pl-c1">0</span>, <span class="pl-en">Message</span>.errors(<span class="pl-s"><span class="pl-pds">"</span>Pull up!<span class="pl-pds">"</span></span>))

<span class="pl-k">val</span> <span class="pl-en">nonEmptyString</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">String</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span>
  nonEmpty[<span class="pl-k">String</span>](<span class="pl-en">Message</span>.errors(<span class="pl-s"><span class="pl-pds">"</span>Talk to me!<span class="pl-pds">"</span></span>))

<span class="pl-k">def</span> <span class="pl-en">nonEmptyList</span>[<span class="pl-en">A</span>]<span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">List</span>[<span class="pl-en">A</span>], <span class="pl-en">List</span>[<span class="pl-en">A</span>]] <span class="pl-k">=</span>
  nonEmpty[<span class="pl-en">List</span>[<span class="pl-en">A</span>]](<span class="pl-en">Message</span>.errors(<span class="pl-s"><span class="pl-pds">"</span>Not enough data!<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>There are also a handful of useful constructor methods for building your own rules:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">test, </span><span class="pl-v">Message.</span><span class="pl-v">errors</span>

<span class="pl-k">val</span> <span class="pl-en">evenNumber</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span>
  test[<span class="pl-k">Int</span>](errors(<span class="pl-s"><span class="pl-pds">"</span>That's odd...<span class="pl-pds">"</span></span>)) { num <span class="pl-k">=&gt;</span>
    num <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>
  }</pre>
  </div> 
  <h3><a id="user-content-combining-rules" class="anchor" href="https://github.com/davegurnell/checklist#combining-rules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Combining Rules</h3> 
  <p>Checklist is built on top of Cats. <code>Rule</code> has an instance of Cats' <code>Applicative</code> type class, so we can combine them in parallel using Cartesian syntax:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">cats.syntax.cartesian.</span><span class="pl-v">_</span>

<span class="pl-k">type</span> <span class="pl-en">Data</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-k">String</span>]

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Coord</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">Int</span>)

<span class="pl-k">val</span> <span class="pl-en">readCoord</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">Data</span>, <span class="pl-en">Coord</span>] <span class="pl-k">=</span> (
  mapValue(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>).andThen(parseInt).andThen(gte(<span class="pl-c1">0</span>)) <span class="pl-k">|@|</span>
  mapValue(<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>).andThen(parseInt).andThen(gte(<span class="pl-c1">0</span>))
).map(<span class="pl-en">Coord</span>.apply)</pre>
  </div> 
  <p>The error handling semantics are to gather as many errors as possible, and construct a result value if possible. The result is an <code>Ior</code> containing errors and/or the result value as appropriate:</p> 
  <div class="highlight highlight-source-scala">
   <pre>readCoord(<span class="pl-en">Map</span>.empty)
<span class="pl-c"><span class="pl-c">//</span> res0: checklist.Checked[Coord] = Left(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Value not found,Path(x)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Value not found,Path(y))</span>
<span class="pl-c"><span class="pl-c">//</span>   )</span>
<span class="pl-c"><span class="pl-c">//</span> )</span>

readCoord(<span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>-1<span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">//</span> res1: checklist.Checked[Coord] = Both(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 0,Path()),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 0,Path())</span>
<span class="pl-c"><span class="pl-c">//</span>   ),</span>
<span class="pl-c"><span class="pl-c">//</span>   Coord(-1,-1)</span>
<span class="pl-c"><span class="pl-c">//</span> )</span>

readCoord(<span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">//</span> res2: checklist.Checked[Coord] = Right(Coord(0,0))</span></pre>
  </div> 
  <p>Checklist contains built-in functionality for calculating error <code>Paths</code> from a variety of data types, including <code>Strings</code>, <code>Ints</code>, and other <code>Paths</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">cats.instances.list.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> for Traverse[List]</span>

<span class="pl-k">val</span> <span class="pl-en">readNestedLists</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">List</span>[<span class="pl-en">List</span>[<span class="pl-k">Int</span>]], <span class="pl-en">List</span>[<span class="pl-en">List</span>[<span class="pl-k">String</span>]]] <span class="pl-k">=</span>
  gte(<span class="pl-c1">0</span>).map(_ <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>).seq[<span class="pl-en">List</span>].seq[<span class="pl-en">List</span>]

readNestedLists(<span class="pl-en">List</span>(<span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-k">-</span><span class="pl-c1">2</span>, <span class="pl-c1">3</span>), <span class="pl-en">List</span>(<span class="pl-k">-</span><span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-k">-</span><span class="pl-c1">6</span>)))
<span class="pl-c"><span class="pl-c">//</span> res3: checklist.Checked[List[List[String]]] = Both(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 0,Path(0/1)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 0,Path(1/0)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 0,Path(1/2))</span>
<span class="pl-c"><span class="pl-c">//</span>   ),</span>
<span class="pl-c"><span class="pl-c">//</span>   List(List(1!, -2!, 3!), List(-4!, 5!, -6!))</span>
<span class="pl-c"><span class="pl-c">//</span> )</span></pre>
  </div> 
  <h3><a id="user-content-top-down-syntax" class="anchor" href="https://github.com/davegurnell/checklist#top-down-syntax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Top-Down Syntax</h3> 
  <p>Checklist uses macros and Monocle lenses to make it easy to validate and clean existing data. Here's an example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">_</span>

<span class="pl-c"><span class="pl-c">//</span> The `field` macro below makes use of higher kinded types:</span>
<span class="pl-k">import</span> <span class="pl-v">scala.language.</span><span class="pl-v">higherKinds</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Address</span>(<span class="pl-v">house</span>: <span class="pl-k">Int</span>, <span class="pl-v">street</span>: <span class="pl-k">String</span>)

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">checkAddress</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">Address</span>, <span class="pl-en">Address</span>] <span class="pl-k">=</span>
  <span class="pl-en">Rule</span>.pass[<span class="pl-en">Address</span>]
    .field(_.house)(gte(<span class="pl-c1">1</span>))
    .field(_.street)(trimString andThen nonEmpty)</pre>
  </div> 
  <p>This rule picks up errors in input values:</p> 
  <div class="highlight highlight-source-scala">
   <pre>checkAddress(<span class="pl-en">Address</span>(<span class="pl-k">-</span><span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">//</span> res4: checklist.Checked[Address] = Both(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 1,Path(house)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must not be empty,Path(street))</span>
<span class="pl-c"><span class="pl-c">//</span>   ),</span>
<span class="pl-c"><span class="pl-c">//</span>   Address(-1,)</span>
<span class="pl-c"><span class="pl-c">//</span> )</span></pre>
  </div> 
  <p>and cleans data as it goes (note the trimmed street name):</p> 
  <div class="highlight highlight-source-scala">
   <pre>checkAddress(<span class="pl-en">Address</span>(<span class="pl-c1">29</span>, <span class="pl-s"><span class="pl-pds">"</span>   Acacia Road   <span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">//</span> res5: checklist.Checked[Address] = Right(Address(29,Acacia Road))</span></pre>
  </div> 
  <p>It can even pick up street names that are empty after trimming:</p> 
  <div class="highlight highlight-source-scala">
   <pre>checkAddress(<span class="pl-en">Address</span>(<span class="pl-c1">29</span>, <span class="pl-s"><span class="pl-pds">"</span>   <span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">//</span> res6: checklist.Checked[Address] = Both(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must not be empty,Path(street))</span>
<span class="pl-c"><span class="pl-c">//</span>   ),</span>
<span class="pl-c"><span class="pl-c">//</span>   Address(29,)</span>
<span class="pl-c"><span class="pl-c">//</span> )</span></pre>
  </div> 
  <h3><a id="user-content-a-complete-example" class="anchor" href="https://github.com/davegurnell/checklist#a-complete-example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>A Complete Example</h3> 
  <p>Here's a more complete example involving nested case classes. Note that the <code>Rule</code> for <code>Address</code> is picked up implicitly when defining the <code>Rule</code> for <code>Person</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">checklist.</span><span class="pl-v">_, </span><span class="pl-v">Rule.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.language.</span><span class="pl-v">higherKinds</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Address</span>(<span class="pl-v">house</span>: <span class="pl-k">Int</span>, <span class="pl-v">street</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>, <span class="pl-v">address</span>: <span class="pl-en">Address</span>)

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">checkAddress</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">Address</span>, <span class="pl-en">Address</span>] <span class="pl-k">=</span>
  <span class="pl-en">Rule</span>.pass[<span class="pl-en">Address</span>]
    .field(_.house)(gte(<span class="pl-c1">1</span>))
    .field(_.street)(nonEmpty)

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">checkPerson</span><span class="pl-k">:</span> <span class="pl-en">Rule</span>[<span class="pl-en">Person</span>, <span class="pl-en">Person</span>] <span class="pl-k">=</span>
  <span class="pl-en">Rule</span>.pass[<span class="pl-en">Person</span>]
    .field(_.name)(nonEmpty)
    .field(_.age)(gte(<span class="pl-c1">1</span>))
    .field(_.address)</pre>
  </div> 
  <p>Also note that the paths in the error messages take into account their absolute position within the data being validated:</p> 
  <div class="highlight highlight-source-scala">
   <pre>checkAddress(<span class="pl-en">Address</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>))
<span class="pl-c"><span class="pl-c">//</span> res7: checklist.Checked[Address] = Both(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 1,Path(house)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must not be empty,Path(street))</span>
<span class="pl-c"><span class="pl-c">//</span>   ),</span>
<span class="pl-c"><span class="pl-c">//</span>   Address(0,)</span>
<span class="pl-c"><span class="pl-c">//</span> )</span>

checkPerson(<span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, <span class="pl-c1">0</span>, <span class="pl-en">Address</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)))
<span class="pl-c"><span class="pl-c">//</span> res8: checklist.Checked[Person] = Both(</span>
<span class="pl-c"><span class="pl-c">//</span>   NonEmptyList(</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must not be empty,Path(name)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 1,Path(age)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must be greater than or equal to 1,Path(address/house)),</span>
<span class="pl-c"><span class="pl-c">//</span>     ErrorMessage(Must not be empty,Path(address/street))</span>
<span class="pl-c"><span class="pl-c">//</span>   ),</span>
<span class="pl-c"><span class="pl-c">//</span>   Person(,0,Address(0,))</span>
<span class="pl-c"><span class="pl-c">//</span> )</span>

checkPerson(<span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">"</span>Eric Wimp<span class="pl-pds">"</span></span>, <span class="pl-c1">11</span>, <span class="pl-en">Address</span>(<span class="pl-c1">29</span>, <span class="pl-s"><span class="pl-pds">"</span>Acacia Road<span class="pl-pds">"</span></span>)))
<span class="pl-c"><span class="pl-c">//</span> res9: checklist.Checked[Person] = Right(Person(Eric Wimp,11,Address(29,Acacia Road)))</span>
<span class="pl-k">~~~</span></pre>
  </div> 
 </article>
</div>