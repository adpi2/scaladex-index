<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-type-safe-off-heap-memory-for-scala" class="anchor" href="https://github.com/densh/scala-offheap#type-safe-off-heap-memory-for-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type-safe off-heap memory for Scala</h1> 
  <p><a href="https://travis-ci.org/densh/scala-offheap" target="_blank"><img src="https://camo.githubusercontent.com/1481a185c72c22772454b50a53f52633286b0741/68747470733a2f2f7472617669732d63692e6f72672f64656e73682f7363616c612d6f6666686561702e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/densh/scala-offheap.svg" style="max-width:100%;"></a> <a href="https://gitter.im/densh/scala-offheap" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/densh/scala-offheap" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></p> 
  <p>Garbage collection is the standard memory management paradigm on the JVM. In theory, it lets one completely forget about the hurdles of memory management and delegate all of it to the underlying runtime. In practice, GC often leads to scalability issues on large heaps and latency-sensitive workloads.</p> 
  <p>The goal of this project is to expose a completely different memory management paradigm to the developers: explicitly annotated region-based memory. This paradigm gives more control over memory management without the need to micro-manage allocations.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">@</span>data <span class="pl-k">class</span> <span class="pl-en">Dummy</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>) {
  <span class="pl-k">def</span> <span class="pl-en">hello</span><span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> println(s<span class="pl-s"><span class="pl-pds">"</span>Hello, i'm $id<span class="pl-pds">"</span></span>)
}

<span class="pl-en">Region</span> { <span class="pl-k">implicit</span> r <span class="pl-k">=&gt;</span>
  <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">1</span> to <span class="pl-c1">100</span>)
     <span class="pl-en">Dummy</span>(i).hello
}</pre>
  </div> 
  <p>For example the snippet above allocates 100 objects in a memory region. As long as the region is open, objects are retained in memory and available for access. Once it ends, all of them are efficiently deallocated at once.</p> 
  <h2><a id="user-content-features" class="anchor" href="https://github.com/densh/scala-offheap#features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <ul> 
   <li>Efficient scoped region-based memory allocator</li> 
   <li>Optional low-overhead memory sanitizer for debugging and development</li> 
   <li>Offheap classes as a nice typed API for custom data layout</li> 
   <li>Offheap arrays with direct sequential layout in memory</li> 
   <li>Extensibility to accomodate custom memory allocators</li> 
  </ul> 
  <h2><a id="user-content-documentation" class="anchor" href="https://github.com/densh/scala-offheap#documentation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Documentation</h2> 
  <p>Documentation is available in <a href="https://github.com/densh/scala-offheap/blob/master/docs/00_toc.md" target="_blank">docs subfolder</a>.</p> 
  <h2><a id="user-content-how-to-contribute" class="anchor" href="https://github.com/densh/scala-offheap#how-to-contribute" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How to contribute</h2> 
  <ol> 
   <li>Check the list of <a href="https://github.com/densh/scala-offheap/issues" target="_blank">open issues</a> and see if you are interested in fixing any of them. If you have encountered a problem or have a feature suggestion feel free to open a new issue.</li> 
   <li>Fork the <a href="https://github.com/densh/scala-offheap" target="_blank">main repo</a> and start hacking up the fix. If you have problems with getting started, contact <a href="https://github.com/densh" target="_blank">@densh</a> to help you out.</li> 
   <li>Whenever you fix an issue, add a test that shows that it was indeed fixed. If you introduce a new feature, add a new test suite with a bunch of tests that cover common use cases. If you propose a performance enhancement, include before &amp; after results of a corresponding jmh performance benchmark run in the commit message.</li> 
   <li>Fire up a pull request. Don't forget to sign the <a href="http://typesafe.com/contribute/cla/scala" target="_blank">Scala CLA</a>.</li> 
  </ol> 
 </article>
</div>