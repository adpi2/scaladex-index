<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-scala-json-rpc" class="anchor" href="https://github.com/shogowada/scala-json-rpc#scala-json-rpc" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>scala-json-rpc</h1> 
  <p>scala-json-rpc is JSON-RPC 2.0 server and client for Scala JVM/JS. <strong>It has no dependency</strong> and should fit into any of your Scala JVM/JS application.</p> 
  <table>
   <thead> 
    <tr> 
     <th>Component</th> 
     <th>SBT</th> 
     <th>Scala Version</th> 
     <th>Scala JS Version</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>scala-json-rpc</td> 
     <td><code>"io.github.shogowada" %%% "scala-json-rpc" % "0.2.3"</code></td> 
     <td>2.11, 2.12</td> 
     <td>0.6</td> 
    </tr> 
    <tr> 
     <td><a href="https://github.com/shogowada/scala-json-rpc/blob/master/upickle-json-serializer" target="_blank">scala-json-rpc-upickle-json-serializer</a></td> 
     <td><code>"io.github.shogowada" %%% "scala-json-rpc-upickle-json-serializer" % "0.2.3"</code></td> 
     <td>2.11, 2.12</td> 
     <td>0.6</td> 
    </tr> 
   </tbody>
  </table> 
  <p>It supports the following features:</p> 
  <ul> 
   <li>Send/receive JSON-RPC request</li> 
   <li><a href="https://github.com/shogowada/scala-json-rpc/blob/master/examples/notification" target="_blank">Send/receive JSON-RPC notification</a></li> 
   <li><a href="http://www.jsonrpc.org/specification#error_object" target="_blank">Respond pre-defined JSON-RPC error</a></li> 
   <li><a href="https://github.com/shogowada/scala-json-rpc/blob/master/examples/customJsonSerialization" target="_blank">Define custom JSON serialization</a></li> 
   <li><a href="https://github.com/shogowada/scala-json-rpc/blob/master/examples/customMethodName" target="_blank">Define custom JSON-RPC method name</a></li> 
  </ul> 
  <p>We have the following example projects for common use cases:</p> 
  <ul> 
   <li><a href="https://github.com/shogowada/scala-json-rpc/blob/master/examples/e2e" target="_blank">Unidirectional JSON-RPC from Scala JS to Scala JVM over HTTP</a></li> 
   <li>Bidirectional JSON-RPC between Scals JS and Scala JVM over WebSocket (coming soon)</li> 
  </ul> 
  <p>It should already serve you well as a RPC library, but it still does not fully support JSON-RPC spec yet. Here are list of known JSON-RPC features that's not supported yet.</p> 
  <ul> 
   <li>Send/receive named parameter 
    <ul> 
     <li>Define custom parameter name</li> 
    </ul></li> 
   <li>Send/receive custom JSON-RPC error</li> 
   <li>Define custom JSON-RPC request ID</li> 
  </ul> 
  <h1><a id="user-content-quick-look" class="anchor" href="https://github.com/shogowada/scala-json-rpc#quick-look" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick Look</h1> 
  <p>In this example, we will implement calculator on server side and call the calculator methods from client side.</p> 
  <h2><a id="user-content-shared" class="anchor" href="https://github.com/shogowada/scala-json-rpc#shared" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Shared</h2> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Define an API.</span>
<span class="pl-c"><span class="pl-c">//</span> Note that API methods must return either Future or Unit type.</span>
<span class="pl-c"><span class="pl-c">//</span> If the method returns Future, it will be JSON-RPC request method, and client can receive response.</span>
<span class="pl-c"><span class="pl-c">//</span> If the method returns Unit, it will be JSON-RPC notification method, and client does not receive response.</span>
<span class="pl-k">trait</span> <span class="pl-en">CalculatorApi</span> {
  <span class="pl-k">def</span> <span class="pl-en">add</span>(<span class="pl-v">lhs</span>: <span class="pl-k">Int</span>, <span class="pl-v">rhs</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]
  <span class="pl-k">def</span> <span class="pl-en">subtract</span>(<span class="pl-v">lhs</span>: <span class="pl-k">Int</span>, <span class="pl-v">rhs</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]
}

<span class="pl-c"><span class="pl-c">//</span> Define how to serialize/deserialize JSON.</span>
<span class="pl-k">class</span> <span class="pl-en">MyJsonSerializer</span> <span class="pl-k">extends</span> <span class="pl-e">JsonSerializer</span> {
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">serialize</span>[<span class="pl-en">T</span>](<span class="pl-v">value</span>: <span class="pl-en">T</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">//</span> ... Serialize model into JSON.</span>
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">deserialize</span>[<span class="pl-en">T</span>](<span class="pl-v">json</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">//</span> ... Deserialize JSON into model.</span>
}</pre>
  </div> 
  <p>You can also use <a href="https://github.com/shogowada/scala-json-rpc/blob/master/upickle-json-serializer" target="_blank">upickle-json-serializer</a> as your <code>JsonSerializer</code> instead of <a href="https://github.com/shogowada/scala-json-rpc/blob/master/examples/customJsonSerialization" target="_blank">implementing it by yourself</a>.</p> 
  <h2><a id="user-content-server-side" class="anchor" href="https://github.com/shogowada/scala-json-rpc#server-side" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Server side</h2> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Implement the API.</span>
<span class="pl-k">class</span> <span class="pl-en">CalculatorApiImpl</span> <span class="pl-k">extends</span> <span class="pl-e">CalculatorApi</span> {
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">add</span>(<span class="pl-v">lhs</span>: <span class="pl-k">Int</span>, <span class="pl-v">rhs</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span>(lhs <span class="pl-k">+</span> rhs)
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">subtract</span>(<span class="pl-v">lhs</span>: <span class="pl-k">Int</span>, <span class="pl-v">rhs</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span>(lhs <span class="pl-k">-</span> rhs)
}

<span class="pl-c"><span class="pl-c">//</span> Create JSON-RPC server.</span>
<span class="pl-c"><span class="pl-c">//</span> JsonSerializer type parameter is required to support JsonSerializer who's implementation is macro (e.g. upickle).</span>
<span class="pl-c"><span class="pl-c">//</span> You can bind as many APIs as you want.</span>
<span class="pl-k">val</span> <span class="pl-en">serverBuilder</span> <span class="pl-k">=</span> <span class="pl-en">JsonRpcServerBuilder</span>[<span class="pl-en">MyJsonSerializer</span>](<span class="pl-k">new</span> <span class="pl-en">MyJsonSerializer</span>())
serverBuilder.bindApi[<span class="pl-en">CalculatorApi</span>](<span class="pl-k">new</span> <span class="pl-en">CalculatorApiImpl)</span>

<span class="pl-k">val</span> <span class="pl-en">server</span><span class="pl-k">:</span> <span class="pl-en">JsonRpcServer</span>[<span class="pl-en">MyJsonSerializer</span>] <span class="pl-k">=</span> serverBuilder.build

<span class="pl-c"><span class="pl-c">//</span> Feed JSON-RPC request into server and send its response to client.</span>
<span class="pl-c"><span class="pl-c">//</span> Server's receive method returns Future[Option[String]], where the String is JSON-RPC response.</span>
<span class="pl-c"><span class="pl-c">//</span> If the response is present, you are supposed to send it back to client.</span>
<span class="pl-k">val</span> <span class="pl-en">requestJson</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">//</span> ... JSON-RPC request as JSON</span>
<span class="pl-k">val</span> <span class="pl-en">futureMaybeResponse</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> server.receive(requestJson)
futureMaybeResponse.onComplete {
  <span class="pl-k">case</span> <span class="pl-en">Success</span>(<span class="pl-en">Some</span>(responseJson)) <span class="pl-k">=&gt;</span> <span class="pl-c"><span class="pl-c">//</span> Send the response to client.</span>
  <span class="pl-k">case</span> <span class="pl-en">Success</span>(<span class="pl-c1">None</span>) <span class="pl-k">=&gt;</span> <span class="pl-c"><span class="pl-c">//</span> Response is absent if it was JSON-RPC notification.</span>
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span>
}</pre>
  </div> 
  <h2><a id="user-content-client-side" class="anchor" href="https://github.com/shogowada/scala-json-rpc#client-side" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Client side</h2> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Create JSON-RPC client.</span>
<span class="pl-k">val</span> <span class="pl-en">jsonSender</span><span class="pl-k">:</span> (<span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> (requestJson) <span class="pl-k">=&gt;</span> {
  <span class="pl-c"><span class="pl-c">//</span> By returning the future here, it will automatically take care of the responses for you.</span>
  <span class="pl-k">val</span> <span class="pl-en">futureMaybeResponseJson</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> <span class="pl-c"><span class="pl-c">//</span> ... Send the request JSON and receive its response.</span>
  futureMaybeResponseJson
}
<span class="pl-k">val</span> <span class="pl-en">clientBuilder</span> <span class="pl-k">=</span> <span class="pl-en">JsonRpcClientBuilder</span>[<span class="pl-en">MyJsonSerializer</span>](
  <span class="pl-k">new</span> <span class="pl-en">MyJsonSerializer</span>(),
  jsonSender
)
<span class="pl-k">val</span> <span class="pl-en">client</span><span class="pl-k">:</span> <span class="pl-en">JsonRpcClient</span>[<span class="pl-en">MyJsonSerializer</span>] <span class="pl-k">=</span> clientBuilder.build

<span class="pl-c"><span class="pl-c">//</span> Create an API.</span>
<span class="pl-c"><span class="pl-c">//</span> You can create as many APIs as you want.</span>
<span class="pl-k">val</span> <span class="pl-en">calculatorApi</span><span class="pl-k">:</span> <span class="pl-en">CalculatorApi</span> <span class="pl-k">=</span> client.createApi[<span class="pl-en">CalculatorApi</span>]

<span class="pl-c"><span class="pl-c">//</span> Use the API.</span>
<span class="pl-c"><span class="pl-c">//</span> When you invoke an API method, under the hood, it:</span>
<span class="pl-c"><span class="pl-c">//</span> 1. creates a JSON-RPC request with the given parameters.</span>
<span class="pl-c"><span class="pl-c">//</span> 2. serializes the request into JSON using JsonSerializer.</span>
<span class="pl-c"><span class="pl-c">//</span> 3. sends the JSON to server using JsonSender.</span>
<span class="pl-c"><span class="pl-c">//</span> 4. receives the response JSON via Future[Option[String]] returned from the JsonSender.</span>
<span class="pl-c"><span class="pl-c">//</span>     - Or, it receives the response JSON via client.receive(responseJson) method.</span>
<span class="pl-c"><span class="pl-c">//</span> 5. deserializes the response JSON into JSON-RPC response using JsonSerializer.</span>
<span class="pl-c"><span class="pl-c">//</span> 6. completes the Future returned by the API method with result of the JSON-RPC response.</span>
<span class="pl-k">val</span> <span class="pl-en">futureResult</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> calculatorApi.add(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>)
futureResult.onComplete {
  <span class="pl-k">case</span> <span class="pl-en">Success</span>(result) <span class="pl-k">=&gt;</span> <span class="pl-c"><span class="pl-c">//</span> ... Do something with the result.</span>
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span>
}</pre>
  </div> 
  <p>Alternatively, you can feed JSON-RPC responses explicitly like below. You can use whichever flow makes more sense for your application. For example, if you are using web socket to connect client and server, this flow might make more sense than to return <code>Future[Option[String]]</code> from the JSON sender.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">jsonSender</span><span class="pl-k">:</span> (<span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> (requestJson) <span class="pl-k">=&gt;</span> {
  <span class="pl-c"><span class="pl-c">//</span> Send JSON to server without returning its response as future.</span>
  <span class="pl-c"><span class="pl-c">//</span> Because client doesn't have access to the response now, you need to explicitly feed the response like below.</span>
  <span class="pl-c"><span class="pl-c">//</span> ...</span>
}
<span class="pl-c"><span class="pl-c">//</span> ...</span>
client.receive(responseJson) <span class="pl-c"><span class="pl-c">//</span> Explicitly feed JSON-RPC responses.</span></pre>
  </div> 
 </article>
</div>