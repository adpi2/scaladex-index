<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-scala-java8-compat--" class="anchor" href="https://github.com/scala/scala-java8-compat#scala-java8-compat--" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>scala-java8-compat <a href="https://travis-ci.org/scala/scala-java8-compat" target="_blank"><img src="https://camo.githubusercontent.com/257ddb678bae7320fa58a3c26d2b4c7495f89a10/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f7363616c612f7363616c612d6a617661382d636f6d7061742e737667" data-canonical-src="https://img.shields.io/travis/scala/scala-java8-compat.svg" style="max-width:100%;"></a> <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3Aorg.scala-lang.modules%20a%3Ascala-java8-compat_2.11*" target="_blank"><img src="https://camo.githubusercontent.com/9c82b4c1c8c044de629a66e2c1f97c851a0a22ac/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f6f72672e7363616c612d6c616e672e6d6f64756c65732f7363616c612d6a617661382d636f6d7061745f322e31312a2e7376673f6c6162656c3d6c617465737425323072656c65617365253230666f72253230322e3131" data-canonical-src="https://img.shields.io/maven-central/v/org.scala-lang.modules/scala-java8-compat_2.11*.svg?label=latest%20release%20for%202.11" style="max-width:100%;"></a></h2> 
  <p>A Java 8 compatibility kit for Scala.</p> 
  <p>The API is currently still experimental: we do not yet guarantee source or binary compatibility with future releases.</p> 
  <h2><a id="user-content-functional-interfaces-for-scala-functions" class="anchor" href="https://github.com/scala/scala-java8-compat#functional-interfaces-for-scala-functions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Functional Interfaces for Scala functions</h2> 
  <p>A set of <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank">Functional Interfaces</a> for <code>scala.FunctionN</code>. These are designed for convenient construction of Scala functions using Java 8 lambda syntax.</p> 
  <h4><a id="user-content-usage" class="anchor" href="https://github.com/scala/scala-java8-compat#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h4> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">scala.concurrent.*</span>;
<span class="pl-k">import static</span> <span class="pl-smi">scala.compat.java8.JFunction.*</span>;

<span class="pl-k">class</span> <span class="pl-en">Test</span> {
    <span class="pl-k">private</span> <span class="pl-k">static</span> <span class="pl-k">Future&lt;<span class="pl-smi">Integer</span>&gt;</span> <span class="pl-en">futureExample</span>(<span class="pl-k">Future&lt;<span class="pl-smi">String</span>&gt;</span> <span class="pl-v">future</span>, <span class="pl-smi">ExecutionContext</span> <span class="pl-v">ec</span>) {
        <span class="pl-k">return</span> future<span class="pl-k">.</span>map(func(s <span class="pl-k">-</span><span class="pl-k">&gt;</span> s<span class="pl-k">.</span>toUpperCase()), ec)<span class="pl-k">.</span>map(func(s <span class="pl-k">-</span><span class="pl-k">&gt;</span> s<span class="pl-k">.</span>length()), ec);
    }
}</pre>
  </div> 
  <p><a href="https://github.com/scala/scala-java8-compat/blob/master/src/test/java/scala/compat/java8/LambdaTest.java" target="_blank">More Examples / Documentation</a></p> 
  <h2><a id="user-content-converters-between-scalafunctionn-and-javautilfunction" class="anchor" href="https://github.com/scala/scala-java8-compat#converters-between-scalafunctionn-and-javautilfunction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Converters between <code>scala.FunctionN</code> and <code>java.util.function</code></h2> 
  <p>A set of converters that enable interconversion between Java's standard Functional Interfaces defined in <code>java.util.function</code> and Scala's <code>Function0</code>, <code>Function1</code>, and <code>Function2</code> traits. These are intended for use when you already have an instance of a <code>java.util.function</code> and need a Scala function, or have a Scala function and need an instance of a <code>java.util.function</code>.</p> 
  <p>The <code>.asScala</code> extension method will convert a <code>java.util.function</code> to the corresponding Scala function. The <code>.asJava</code> extension method will convert a Scala function to the most specific corresponding Java functional interface. If you wish to obtain a less specific functional interface, there are named methods that start with <code>asJava</code> and continue with the name of the Java functional interface. For instance, the most specific interface corresponding to the Scala function <code>val rev = (s: String) =&gt; s.reverse</code> is <code>UnaryOperator[String]</code>, and that is what <code>rev.asJava</code> will produce. However, <code>asJavaFunction(rev)</code> will return a <code>java.util.function.Function[String, String]</code> instead.</p> 
  <p>The <code>asJava</code> methods can also be called conveniently from Java. There are additional <code>asScalaFrom</code> methods (e.g. <code>asScalaFromUnaryOperator</code>) that will perform the functional-interface-to-Scala-function conversion; this is primarily of use when calling from Java since the <code>.asScala</code> extension method is more convenient in Scala.</p> 
  <h4><a id="user-content-usage-examples" class="anchor" href="https://github.com/scala/scala-java8-compat#usage-examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage examples</h4> 
  <p>In Scala:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">java.util.function.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.compat.java8.FunctionConverters.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">foo</span><span class="pl-k">:</span> <span class="pl-k">Int</span> <span class="pl-k">=&gt;</span> <span class="pl-k">Boolean</span> <span class="pl-k">=</span> i <span class="pl-k">=&gt;</span> i <span class="pl-k">&gt;</span> <span class="pl-c1">7</span>
<span class="pl-k">def</span> <span class="pl-en">testBig</span>(<span class="pl-v">ip</span>: <span class="pl-en">IntPredicate</span>) <span class="pl-k">=</span> ip.test(<span class="pl-c1">9</span>)
println(testBig(foo.asJava))  <span class="pl-c">// Prints true</span>

<span class="pl-k">val</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">UnaryOperator</span>[<span class="pl-k">String</span>]{ <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> s.reverse }
<span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>cod<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>herring<span class="pl-pds">"</span></span>).map(bar.asScala)    <span class="pl-c">// List("doc", "gnirrih")</span>

<span class="pl-k">def</span> <span class="pl-en">testA</span>[<span class="pl-en">A</span>](<span class="pl-v">p</span>: <span class="pl-en">Predicate</span>[<span class="pl-en">A</span>])(<span class="pl-v">a</span>: <span class="pl-en">A</span>) <span class="pl-k">=</span> p.test(a)
println(testA(asJavaPredicate(foo))(<span class="pl-c1">4</span>))  <span class="pl-c">// Prints false</span>

<span class="pl-c">// println(testA(foo.asJava)(4))  &lt;-- doesn't work</span>
<span class="pl-c">//                                    IntPredicate does not extend Predicate!</span></pre>
  </div> 
  <p>In Java:</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">java.util.function.*</span>;
<span class="pl-k">import</span> <span class="pl-smi">scala.compat.java8.FunctionConverters</span>;

<span class="pl-k">class</span> <span class="pl-en">Example</span> {
  <span class="pl-smi">String</span> <span class="pl-en">foo</span>(<span class="pl-k">UnaryOperator&lt;<span class="pl-smi">String</span>&gt;</span> <span class="pl-v">f</span>) {
    <span class="pl-k">return</span> f<span class="pl-k">.</span>apply(<span class="pl-s"><span class="pl-pds">"</span>halibut<span class="pl-pds">"</span></span>);
  }
  <span class="pl-smi">String</span> <span class="pl-en">bar</span>(<span class="pl-k">scala.Function1&lt;<span class="pl-smi">String</span>, <span class="pl-smi">String</span>&gt;</span> <span class="pl-v">f</span>) {
    <span class="pl-k">return</span> foo(functionConverters<span class="pl-k">.</span>asJavaUnaryOperator(f));
  }
  <span class="pl-smi">String</span> <span class="pl-en">baz</span>(<span class="pl-k">Function&lt;<span class="pl-smi">String</span>, <span class="pl-smi">String</span>&gt;</span> <span class="pl-v">f</span>) {
    <span class="pl-k">return</span> bar(functionConverters<span class="pl-k">.</span>asScalaFromFunction(f));
  }
}</pre>
  </div> 
  <h2><a id="user-content-converters-between-scalaconcurrent-and-javautilconcurrent" class="anchor" href="https://github.com/scala/scala-java8-compat#converters-between-scalaconcurrent-and-javautilconcurrent" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Converters between <code>scala.concurrent</code> and <code>java.util.concurrent</code></h2> 
  <ul> 
   <li><a href="https://github.com/scala/scala-java8-compat/blob/master/src/main/scala/scala/compat/java8/FutureConverters.scala" target="_blank">API</a></li> 
   <li><a href="https://github.com/scala/scala-java8-compat/blob/master/src/test/java/scala/compat/java8/FutureConvertersTest.java" target="_blank">Test Cases</a></li> 
  </ul> 
  <h2><a id="user-content-converters-between-scalaoption-and-javautil-classes-optional-optionaldouble-optionalint-and-optionallong" class="anchor" href="https://github.com/scala/scala-java8-compat#converters-between-scalaoption-and-javautil-classes-optional-optionaldouble-optionalint-and-optionallong" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Converters between <code>scala.Option</code> and <code>java.util</code> classes <code>Optional</code>, <code>OptionalDouble</code>, <code>OptionalInt</code>, and <code>OptionalLong</code>.</h2> 
  <p>A set of extension methods to enable explicit conversion between <a href="http://www.scala-lang.org/files/archive/api/2.11.6/#scala.Option" target="_blank">Scala Option</a> and the Java 8 optional types, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank">Optional</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html" target="_blank">OptionalDouble</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html" target="_blank">OptionalInt</a>, and <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html" target="_blank">OptionalLong</a>.</p> 
  <p>Note that the four Java classes have no inheritance relationship despite all encoding optional types.</p> 
  <h4><a id="user-content-usage-example" class="anchor" href="https://github.com/scala/scala-java8-compat#usage-example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage example</h4> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.compat.java8.OptionConverters.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">Test</span> {
  <span class="pl-k">val</span> <span class="pl-en">o</span> <span class="pl-k">=</span> <span class="pl-en">Option</span>(<span class="pl-c1">2.7</span>)
  <span class="pl-k">val</span> <span class="pl-en">oj</span> <span class="pl-k">=</span> o.asJava        <span class="pl-c">// Optional[Double]</span>
  <span class="pl-k">val</span> <span class="pl-en">ojd</span> <span class="pl-k">=</span> o.asPrimitive  <span class="pl-c">// OptionalDouble</span>
  <span class="pl-k">val</span> <span class="pl-en">ojds</span> <span class="pl-k">=</span> ojd.asScala   <span class="pl-c">// Option(2.7) again</span>
}</pre>
  </div> 
  <h2><a id="user-content-converters-from-scala-collections-to-java-8-streams" class="anchor" href="https://github.com/scala/scala-java8-compat#converters-from-scala-collections-to-java-8-streams" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Converters from Scala collections to Java 8 Streams</h2> 
  <p>Scala collections gain <code>seqStream</code> and <code>parStream</code> as extension methods that produce a Java 8 Stream running sequentially or in parallel, respectively. These are automatically specialized to a primitive type if possible, including automatically applied widening conversions. For instance, <code>List(1,2).seqStream</code> produces an <code>IntStream</code>, and so does <code>List(1.toShort, 2.toShort).parStream</code>. Maps additionally have <code>seqKeyStream</code>, <code>seqValueStream</code>, <code>parKeyStream</code>, and <code>parValueStream</code> methods.</p> 
  <p>Scala collections also gain <code>accumulate</code> and <code>stepper</code> methods that produce utility collections that can be useful when working with Java 8 Streams. <code>accumulate</code> produces an <code>Accumulator</code> or its primitive counterpart (<code>DoubleAccumulator</code>, etc.), which is a low-level collection designed for efficient collection and dispatching of results to and from Streams. Unlike most collections, it can contain more than <code>Int.MaxValue</code> elements.</p> 
  <p><code>stepper</code> produces a <code>Stepper</code> which is a fusion of <code>Spliterator</code> and <code>Iterator</code>. <code>Stepper</code>s underlie the Scala collections' instances of Java 8 Streams. Steppers are intended as low-level building blocks for streams. Usually you would not create them directly or call their methods but you can implement them alongside custom collections to get better performance when streaming from these collections.</p> 
  <p>Java 8 Streams gain <code>toScala[Coll]</code> and <code>accumulate</code> methods, to make it easy to produce Scala collections or Accumulators, respectively, from Java 8 Streams. For instance, <code>myStream.to[Vector]</code> will collect the contents of a Stream into a <code>scala.collection.immutable.Vector</code>. Note that standard sequential builders are used for collections, so this is best done to gather the results of an expensive computation.</p> 
  <p>Finally, there is a Java class, <code>ScalaStreamSupport</code>, that has a series of <code>stream</code> methods that can be used to obtain Java 8 Streams from Scala collections from within Java.</p> 
  <h4><a id="user-content-performance-considerations" class="anchor" href="https://github.com/scala/scala-java8-compat#performance-considerations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Performance Considerations</h4> 
  <p>For sequential operations, Scala's <code>iterator</code> almost always equals or exceeds the performance of a Java 8 stream. Thus, one should favor <code>iterator</code> (and its richer set of operations) over <code>seqStream</code> for general use. However, long chains of processing of primitive types can sometimes benefit from the manually specialized methods in <code>DoubleStream</code>, <code>IntStream</code>, and <code>LongStream</code>.</p> 
  <p>Note that although <code>iterator</code> typically has superior performance in a sequential context, the advantage is modest (usually less than 50% higher throughput for <code>iterator</code>).</p> 
  <p>For parallel operations, <code>parStream</code> and even <code>seqStream.parallel</code> meets or exceeds the performance of Scala parallel collections methods (invoked with <code>.par</code>). Especially for small collections, the difference can be substantial. In some cases, when a Scala (parallel) collection is the ultimate result, Scala parallel collections can have an advantage as the collection can (in some cases) be built in parallel.</p> 
  <p>Because the wrappers are invoked based on the static type of the collection, there are also cases where parallelization is inefficient when interfacing with Java 8 Streams (e.g. when a collection is typed as <code>Seq[String]</code> so might have linear access like <code>List</code>, but actually is a <code>WrappedArray[String]</code> that can be efficiently parallelized) but can be efficient with Scala parallel collections. The <code>parStream</code> method is only available when the static type is known to be compatible with rapid parallel operation; <code>seqStream</code> can be parallelized by using <code>.parallel</code>, but may or may not be efficient.</p> 
  <p>If the operations available on Java 8 Streams are sufficient, the collection type is known statically with enough precision to enable parStream, and an <code>Accumulator</code> or non-collection type is an acceptable result, Java 8 Streams will essentially always outperform the Scala parallel collections.</p> 
  <h4><a id="user-content-scala-usage-example" class="anchor" href="https://github.com/scala/scala-java8-compat#scala-usage-example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scala Usage Example</h4> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.compat.java8.StreamConverters.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">Test</span> {
  <span class="pl-k">val</span> <span class="pl-en">m</span> <span class="pl-k">=</span> collection.immutable.<span class="pl-en">HashMap</span>(<span class="pl-s"><span class="pl-pds">"</span>fish<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>bird<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>)
  <span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> m.parValueStream.sum          <span class="pl-c">// 6, potientially computed in parallel</span>
  <span class="pl-k">val</span> <span class="pl-en">t</span> <span class="pl-k">=</span> m.seqKeyStream.toScala[<span class="pl-en">List</span>]  <span class="pl-c">// List("fish", "bird")</span>
  <span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> m.accumulate                  <span class="pl-c">// Accumulator[(String, Int)]</span>

  <span class="pl-k">val</span> <span class="pl-en">n</span> <span class="pl-k">=</span> a.stepper.fold(<span class="pl-c1">0</span>)(_ <span class="pl-k">+</span> _._1.length) <span class="pl-k">+</span>
          a.parStream.count             <span class="pl-c">// 8 + 2 = 10</span>

  <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> java.util.<span class="pl-en">Arrays</span>.stream(<span class="pl-en">Array</span>(<span class="pl-c1">2L</span>, <span class="pl-c1">3L</span>, <span class="pl-c1">4L</span>)).
          accumulate                    <span class="pl-c">// LongAccumulator</span>
    <span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> b.to[<span class="pl-en">List</span>]                    <span class="pl-c">// List(2L, 3L, 4L)</span>
}</pre>
  </div> 
  <h4><a id="user-content-using-java-8-streams-with-scala-function-converters" class="anchor" href="https://github.com/scala/scala-java8-compat#using-java-8-streams-with-scala-function-converters" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using Java 8 Streams with Scala Function Converters</h4> 
  <p>Scala can emit Java SAMs for lambda expressions that are arguments to methods that take a Java SAM rather than a Scala Function. However, it can be convenient to restrict the SAM interface to interactions with Java code (including Java 8 Streams) rather than having it propagate throughout Scala code.</p> 
  <p>Using Java 8 Stream converters together with function converters allows one to accomplish this with only a modest amount of fuss.</p> 
  <p>Example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.compat.java8.FunctionConverters.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.compat.java8.StreamConverters.</span><span class="pl-v">_</span>

<span class="pl-k">def</span> <span class="pl-en">mapToSortedString</span>[<span class="pl-en">A</span>](<span class="pl-v">xs</span>: <span class="pl-en">Vector</span>[<span class="pl-en">A</span>], <span class="pl-v">f</span>: <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-k">String</span>, <span class="pl-v">sep</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span>
  xs.parStream.                     <span class="pl-c">// Creates java.util.stream.Stream[String]</span>
    map[<span class="pl-k">String</span>](f.asJava).sorted.   <span class="pl-c">// Maps A to String and sorts (in parallel)</span>
    toArray.mkString(sep)           <span class="pl-c">// Back to an Array to use Scala's mkString</span></pre>
  </div> 
  <p>Note that explicit creation of a new lambda will tend to lead to improved type inference and at least equal performance:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">mapToSortedString</span>[<span class="pl-en">A</span>](<span class="pl-v">xs</span>: <span class="pl-en">Vector</span>[<span class="pl-en">A</span>], <span class="pl-v">f</span>: <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-k">String</span>, <span class="pl-v">sep</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span>
  xs.parStream.
    map[<span class="pl-k">String</span>](a <span class="pl-k">=&gt;</span> f(a)).sorted.  <span class="pl-c">// Explicit lambda creates a SAM wrapper for f</span>
    toArray.mkString(sep)</pre>
  </div> 
  <h4><a id="user-content-java-usage-example" class="anchor" href="https://github.com/scala/scala-java8-compat#java-usage-example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Java Usage Example</h4> 
  <p>To convert a Scala collection to a Java 8 Stream from within Java, it usually suffices to call <code>ScalaStreamSupport.stream(xs)</code> on your collection <code>xs</code>. If <code>xs</code> is a map, you may wish to get the keys or values alone by using <code>fromKeys</code> or <code>fromValues</code>. If the collection has an underlying representation that is not efficiently parallelized (e.g. <code>scala.collection.immutable.List</code>), then <code>fromAccumulated</code> (and <code>fromAccumulatedKeys</code> and <code>fromAccumulatedValues</code>) will first gather the collection into an <code>Accumulator</code> and then return a stream over that accumulator. If not running in parallel, <code>from</code> is preferable (faster and less memory usage).</p> 
  <p>Note that a Scala <code>Iterator</code> cannot fulfill the contract of a Java 8 Stream (because it cannot support <code>trySplit</code> if it is called). Presently, one must call <code>fromAccumulated</code> on the <code>Iterator</code> to cache it, even if the Stream will be evaluated sequentially, or wrap it as a Java Iterator and use static methods in <code>Spliterator</code> to wrap that as a <code>Spliterator</code> and then a <code>Stream</code>.</p> 
  <p>Here is an example of conversion of a Scala collection within Java 8:</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">scala.collection.mutable.ArrayBuffer</span>;
<span class="pl-k">import</span> <span class="pl-smi">scala.compat.java8.ScalaStreamSupport</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">StreamConvertersExample</span> {
  <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">MakeAndUseArrayBuffer</span>() {
    <span class="pl-k">ArrayBuffer&lt;<span class="pl-smi">String</span>&gt;</span> ab <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">ArrayBuffer&lt;<span class="pl-smi">String</span>&gt;</span>();
    ab<span class="pl-k">.</span>$plus$eq(<span class="pl-s"><span class="pl-pds">"</span>salmon<span class="pl-pds">"</span></span>);
    ab<span class="pl-k">.</span>$plus$eq(<span class="pl-s"><span class="pl-pds">"</span>herring<span class="pl-pds">"</span></span>);
    <span class="pl-k">return</span> <span class="pl-smi">ScalaStreamSupport</span><span class="pl-k">.</span>stream(ab)<span class="pl-k">.</span>mapToInt(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x<span class="pl-k">.</span>length())<span class="pl-k">.</span>sum();  <span class="pl-c">// 6+7 = 13</span>
  }
}</pre>
  </div> 
 </article>
</div>