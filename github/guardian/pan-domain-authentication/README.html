<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p>#&nbsp;Pan Domain Authentication <a href="https://maven-badges.herokuapp.com/maven-central/com.gu/pan-domain-auth-core_2.11" target="_blank"><img src="https://camo.githubusercontent.com/ced0fb0640cd16aacc5184e41329c64c4c27db17/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e67752f70616e2d646f6d61696e2d617574682d636f72655f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.gu/pan-domain-auth-core_2.11/badge.svg" style="max-width:100%;"></a></p> 
  <p>Pan domain authentication provides distributed authentication for multiple webapps running in the same domain. Each application can authenticate users (currently by using Google's oauth mechanism, but other mechanisms could be added in the future) and store the authentication information in a common cookie. Each application can read this cookie and check if the user is allowed in the specific application and allow access accordingly.</p> 
  <p>This means that users are only prompted to provide authentication credentials once across the domain and any inter-app interactions (e.g javascript CORS or jsonp requests) can be easily secured.</p> 
  <h2><a id="user-content-how-it-works" class="anchor" href="https://github.com/guardian/pan-domain-authentication#how-it-works" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How it works</h2> 
  <p>Each application that needs to issue logins is configured with the domain, an application name and an AWS key. The AWS key allows the application to connect to an S3 bucket (<code>pan-domain-auth-settings</code>) and download the settings for that domain (from a <code>&lt;domain&gt;.settings</code> file). The downloaded settings configure the public/private keypair used to sign and verify the login cookie as well as the credentials needed to authenticate with Google.</p> 
  <p>Each authenticated request that an application receives is checked to see if there is a auth cookie.</p> 
  <ul> 
   <li> <p>If the cookie is not present then the user is sent to Google for authentication. Upon returning from Google the use information is checked and if the user is allowed in the app then the shared cookie is set marking the user as valid in the application.</p> </li> 
   <li> <p>If there is a cookie but te cookie does not indicate that the the user is valid in the application then the user is validated for the application. if they are valid then the cookie is updated to indicate this otherwise an error page is displayed.</p> </li> 
   <li> <p>If there is a cookie and it indicates the user is valid in this application then the request is processed as normal.</p> </li> 
   <li> <p>if there is a cookie but it indicated the the authentication is expired then the user is sent off to Google to renew their session. On returning from Google the existing cookie is updated with the new expiry time.</p> </li> 
  </ul> 
  <h2><a id="user-content-whats-provided" class="anchor" href="https://github.com/guardian/pan-domain-authentication#whats-provided" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>What's provided</h2> 
  <p>Pan domain auth is split into 4 modules.</p> 
  <p>The <code>pan-domain-auth-verification</code> library provides the basic functionality for sigining and verifying login cookies. For applications that only need to <em>VERIFY</em> an existing login (rather than issue logins themselves) this is the library to use. In most cases this will be useful for APIs that are unwilling or unable to offer a user-facing OAuth dance to acquire credentials directly, on behalf of the user. Note that this module also includes means for obtaining the public key used to do the verification (more details below).</p> 
  <p>The <code>pan-domain-auth-core</code> library provides the core utilities to load the domain settings, create and validate the cookie and check if the user has mutlifactor auth turned on (see below). Note this does not include the Google oath dance code or cookie setting as these vary based on web framework being used by implementing apps.</p> 
  <p>The <code>pan-domain-auth-play</code> libraries (<code>2-4-0</code> and <code>2-5</code>) provide an implementation for play apps. There is an auth action that can be applied to the endpoints in you appliciation that will do checking and setting of the cookie and will give you the Google authentication mechanism and callback. This is the only framework specific implementation currently (due to play being the framework predominantly used at the guardian), this can be used as reference if you need to implement another framework implementation. This library is for applications that need to be able to issue and verify logins which is likely to include user-facing applications.</p> 
  <p>The <code>pan-domain-auth-example</code> provides an example app with authentication. This is implemented in play and is used for testing. Additionally the nginx directory provides an example of how to set up an nginx configuration to allow you to run multiple authenticated apps locally as if they were all on the same domain (also useful for testing)</p> 
  <p>The <code>pan-domain-auth-verification</code>, <code>pan-domain-auth-core</code> and <code>pan-domain-auth-play</code> libraries are available on maven central cross compiled for scala 2.10.4 and 2.11.1. to include them via sbt:</p> 
  <h3><a id="user-content-to-verify-logins" class="anchor" href="https://github.com/guardian/pan-domain-authentication#to-verify-logins" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>To verify logins</h3> 
  <pre><code>"com.gu" %% "pan-domain-auth-verification" % "0.3.0"
</code></pre> 
  <p>To verify a login, you'll need to read the user's cookie value and verify its integrity. This is done using the <code>authStatus</code> method on the <code>PanDomain</code> object. This method can optionally take a callback function used to validate the authenticated user - by default this enforces two-factor-auth and ensures it is a Guardian user.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.gu.pandomainauth.</span><span class="pl-v">PanDomain</span>

<span class="pl-en">PanDomain</span>.authStatus(cookieValue, publicKey)</pre>
  </div> 
  <p>The way you fetch the cookie value depends on your application but this library includes a way to retrieve the public key for the domain you are using. The recommended way is to use the provided akka agent using an instance of <code>PublicSettings</code>. You can call this instance's <code>start</code> method when your application comes up and it will keep the publicKey value up to date in the background while your application runs.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.gu.pandomainauth.</span><span class="pl-v">PublicSettings</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">dispatch.</span><span class="pl-v">Http</span>

<span class="pl-c"><span class="pl-c">//</span> provide a client to use for fetching the required information</span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">httpClient</span> <span class="pl-k">=</span> <span class="pl-en">Http</span>
<span class="pl-k">val</span> <span class="pl-en">publicSettings</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">PublicSettings</span>(domain)

<span class="pl-c"><span class="pl-c">//</span> call this when your application comes up to kick off the agent (e.g. Global.onStart in Play)</span>
publicSettings.start()

<span class="pl-c"><span class="pl-c">//</span> the public key will be None until a value is successfully obtained</span>
<span class="pl-k">def</span> <span class="pl-en">publicKey</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> publicSettings.publicKey</pre>
  </div> 
  <p>You'll need to the public key for your domain before you can verify the pan-domain-auth cookies. The <code>PublicSettings</code> object contains the cookie name to read from as well as a function that fetches the public key. You should use <code>getPublicKey(domain)</code> to fetch the public key for the domain you are using. This returns a <code>Future</code> containing the value fetched from the settings bucket in S3. You might do this at application start, lazily when the check happens, or in an agent to keep the value up to date.</p> 
  <p>You will likely also want to have some logging in place for the calls to fetch the public settings. This can be achieved by providing a callback to the publicSettings instance.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">publicSettings</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">PublicSettings</span>(domain, {
  <span class="pl-k">case</span> <span class="pl-en">Success</span>(settings) <span class="pl-k">=&gt;</span>
    <span class="pl-en">Logger</span>.info(<span class="pl-s"><span class="pl-pds">"</span>successfully updated pan-domain public settings<span class="pl-pds">"</span></span>)
  <span class="pl-k">case</span> <span class="pl-en">Failure</span>(err) <span class="pl-k">=&gt;</span>
    <span class="pl-en">Logger</span>.warn(<span class="pl-s"><span class="pl-pds">"</span>failed to update pan-domain public settings<span class="pl-pds">"</span></span>, err)
})</pre>
  </div> 
  <p>If you'd rather not use the provided agent you can hook the <code>PublicSettings</code> instance up to your own scheduler by calling its <code>refresh</code> method directly, instead of invoking start. You can also manually fetch the settings using the provided helper <code>PublicSettings.getPublicKey(domain)</code> helper function.</p> 
  <h3><a id="user-content-if-your-application-needs-to-issue-logins" class="anchor" href="https://github.com/guardian/pan-domain-authentication#if-your-application-needs-to-issue-logins" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>If your application needs to issue logins</h3> 
  <pre><code>"com.gu" %% "pan-domain-auth-core" % "0.3.0"
</code></pre> 
  <p>or</p> 
  <pre><code>"com.gu" %% "pan-domain-auth-play_2-5" % "0.3.0"
</code></pre> 
  <p>In both cases you will need to set up a few things, see <code>Requirements</code> below.</p> 
  <h2><a id="user-content-requirements" class="anchor" href="https://github.com/guardian/pan-domain-authentication#requirements" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Requirements</h2> 
  <p>To use pan domain authentication you will need:</p> 
  <ul> 
   <li> <p>At least one webapp running on subdomains of a single domain (eg. app1.example.com and app2.example.com)</p> </li> 
   <li> <p>The apps must be using https - the cookie set by pan domain auth are set to secure and http only</p> </li> 
   <li> <p>An AWS S3 bucket where the configuration for your domain will live</p> 
    <ul> 
     <li>the name is taken from <code>PANDA_BUCKET_NAME</code> environment variable or <code>pan-domain-auth-settings</code> is used by default</li> 
    </ul> </li> 
   <li> <p>The AWS login credentials for a user that can read from the said bucket (it is recommended that this is the only thing that the user is allowed to do in your s3 account)</p> </li> 
   <li> <p>An app set up in Google with access to the Google+ api (this is used for the actual authentication):</p> 
    <ul> 
     <li>get a set of API credentials for your app from the <a href="https://console.developers.google.com" target="_blank">Google Developer Console</a></li> 
     <li>ensure that you have switched on access to the <code>Google+ API</code> for your credentials</li> 
     <li>configure all the oath callbacks used by your apps</li> 
    </ul> </li> 
   <li> <p>A configuartion file in the S3 bucket named <code>&lt;domain&gt;.settings</code></p> </li> 
  </ul> 
  <h2><a id="user-content-setting-up-your-domain-configuration" class="anchor" href="https://github.com/guardian/pan-domain-authentication#setting-up-your-domain-configuration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Setting up your domain configuration</h2> 
  <p>The configuration file is named for the domain and is a simple properties style file. For all apps on the *.example.com domain the file would be called example.com.settings. The contents of the file would look something like this:</p> 
  <div class="highlight highlight-source-ini">
   <pre><span class="pl-k">publicKey</span>=example_key
<span class="pl-k">privateKey</span>=example_key
<span class="pl-k">cookieName</span>=exampleAuth

<span class="pl-k">googleAuthClientId</span>=example_google_client
<span class="pl-k">googleAuthSecret</span>=example_google_secret

<span class="pl-k">googleServiceAccountId</span>=serviceAccount@developer.gserviceaccount.com
<span class="pl-k">googleServiceAccountCert</span>=name_of_cert_in_bucket.p12
<span class="pl-k">google2faUser</span>=an.admin@example.com
<span class="pl-k">multifactorGroupId</span>=group@2fa_admin_user</pre>
  </div> 
  <p>There is a corresponding (publicly available) file called example.com.settings.public. The contents of the file looks like:</p> 
  <div class="highlight highlight-source-ini">
   <pre><span class="pl-k">publicKey</span>=example_key</pre>
  </div> 
  <ul> 
   <li> <p><strong>secret</strong> - this is the shared secret used to sign the cookie</p> </li> 
   <li> <p><strong>cookieName</strong> - this is what the shared cookie is called</p> </li> 
   <li> <p><strong>googleAuthClientId</strong> - this is the client id for the Google app you autheniticate with - this is obtained from the Google <a href="https://console.developers.google.com" target="_blank">Google Developer Console</a></p> </li> 
   <li> <p><strong>googleAuthSecret</strong> - this is the secret for the Google app you autheniticate with - this is obtained from the Google <a href="https://console.developers.google.com" target="_blank">Google Developer Console</a></p> </li> 
   <li> <p><strong>googleServiceAccountId, googleServiceAccountCert, google2faUser and multifactorGroupId</strong> - these are optional parameters for using a group based 2 factor auth verification, see explanation below</p> </li> 
   <li> <p><strong>privateKey</strong> - this is the private key used to sign the asymmetrical cookie</p> </li> 
   <li> <p><strong>publicKey</strong> - this is the public key used to verify the asymmetrical cookie</p> </li> 
  </ul> 
  <h3><a id="user-content-generating-keys" class="anchor" href="https://github.com/guardian/pan-domain-authentication#generating-keys" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Generating Keys</h3> 
  <p>You can generate an rsa key pair as follows:</p> 
  <pre><code>openssl genrsa -out private_key.pem 4096
openssl rsa -pubout -in private_key.pem -out public_key.pem
</code></pre> 
  <p>There is a helper script in the root of this project that uses the commands above and outputs a new keypair in the format used by the panda settings file:</p> 
  <pre><code>./generateKeyPair.sh
</code></pre> 
  <p>Note: you only need to pass the key ie the blob of base64 between the start and end markers in the pem file.</p> 
  <h2><a id="user-content-integrating-with-your-app" class="anchor" href="https://github.com/guardian/pan-domain-authentication#integrating-with-your-app" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Integrating with your app</h2> 
  <h3><a id="user-content-verify-only" class="anchor" href="https://github.com/guardian/pan-domain-authentication#verify-only" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Verify-only</h3> 
  <p>If your service only needs to verify existing pan-domain-auth cookies use the <code>pan-domain-auth-verification</code> library. Inside it is a <code>PanDomain</code> object which contains an <code>authStatus</code> method. You'll just need the pan-domain-auth cookie value and the public key for the domain you are on. Calling that function will return an <code>AuthenticationStatus</code> which can be any of:</p> 
  <ul> 
   <li>Authenticated</li> 
   <li>Expired</li> 
   <li>InvalidCookie</li> 
   <li>NotAuthorized</li> 
  </ul> 
  <p>Note that the <code>authStatus</code> method takes a function you can use to validate the user. Typically this involves checking the domain and ensuring the user has 2-factor-auth enabled on their Google account so the default argument (guardianValidation) does this for you. If this check fails you will recieve a <code>NotAuthorized</code> result.</p> 
  <h3><a id="user-content-using-the-play-implementation" class="anchor" href="https://github.com/guardian/pan-domain-authentication#using-the-play-implementation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using the play implementation</h3> 
  <p>If you are using play then use the play library, this provides the actions that allow you to secure your endpoints.</p> 
  <p>Create a pan domain auth actions trait that extends the <code>AuthActions</code> trait in the the play lib. This trait will provide the config needed to connect to the aws bucket and the domain and app you are using. You will also need to add a method here to ensure that any authenticated user is valid in your specific app (and this could be used to create users in you app's datastore). You should also provide the full url of the endpoint that will handle the oauth callback from Google.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">controllers</span>

<span class="pl-k">import</span> <span class="pl-v">com.gu.pandomainauth.action.</span><span class="pl-v">AuthActions</span>
<span class="pl-k">import</span> <span class="pl-v">com.gu.pandomainauth.model.</span><span class="pl-v">AuthenticatedUser</span>

<span class="pl-k">trait</span> <span class="pl-en">PanDomainAuthActions</span> <span class="pl-k">extends</span> <span class="pl-e">AuthActions</span> {

  <span class="pl-k">import</span> <span class="pl-v">play.api.Play.</span><span class="pl-v">current</span>
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">config</span> <span class="pl-k">=</span> play.api.<span class="pl-en">Play</span>.configuration

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">validateUser</span>(<span class="pl-v">authedUser</span>: <span class="pl-en">AuthenticatedUser</span>)<span class="pl-k">:</span> <span class="pl-k">Boolean</span> <span class="pl-k">=</span> {
    (authedUser.user.email endsWith (<span class="pl-s"><span class="pl-pds">"</span>@guardian.co.uk<span class="pl-pds">"</span></span>)) <span class="pl-k">&amp;&amp;</span> authedUser.multiFactor
  }

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">cacheValidation</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">authCallbackUrl</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> config.getString(<span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>).get <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>/oauthCallback<span class="pl-pds">"</span></span>

  <span class="pl-k">override</span> <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">domain</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> config.getString(<span class="pl-s"><span class="pl-pds">"</span>pandomain.domain<span class="pl-pds">"</span></span>).get

  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">awsSecretAccessKey</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> config.getString(<span class="pl-s"><span class="pl-pds">"</span>pandomain.aws.secret<span class="pl-pds">"</span></span>)
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">awsKeyId</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> config.getString(<span class="pl-s"><span class="pl-pds">"</span>pandomain.aws.keyId<span class="pl-pds">"</span></span>)
  <span class="pl-k">override</span> <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">awscredentials</span> <span class="pl-k">=</span>
    <span class="pl-k">for</span> (key <span class="pl-k">&lt;</span><span class="pl-k">-</span> awsKeyId; secret <span class="pl-k">&lt;</span><span class="pl-k">-</span> awsSecretAccessKey)
    <span class="pl-k">yield</span> <span class="pl-k">new</span> <span class="pl-en">BasicAWSCredentials</span>(key, secret)

  <span class="pl-k">override</span> <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">system</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>workflow<span class="pl-pds">"</span></span>
}</pre>
  </div> 
  <p>By default the user validation method is called every request. If your validation method has side effects or is expensive then you can set <code>cacheValidation</code> to true, this will mean that <code>validateUser</code> is only called once per system per Google auth (i.e validation will only reoccur when the Google session is refreshed)</p> 
  <p>Create a controller that will handle the oauth callback and logout actions, add these actions to the routes file.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">controllers</span>

<span class="pl-k">import</span> <span class="pl-v">play.api.mvc.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>

<span class="pl-k">object</span> <span class="pl-en">Login</span> <span class="pl-k">extends</span> <span class="pl-e">Controller</span> <span class="pl-k">with</span> <span class="pl-e">PanDomainAuthActions</span> {

  <span class="pl-k">def</span> <span class="pl-en">oauthCallback</span> <span class="pl-k">=</span> <span class="pl-en">Action</span>.async { <span class="pl-k">implicit</span> request <span class="pl-k">=&gt;</span>
    processGoogleCallback()
  }

  <span class="pl-k">def</span> <span class="pl-en">logout</span> <span class="pl-k">=</span> <span class="pl-en">Action</span>.async { <span class="pl-k">implicit</span> request <span class="pl-k">=&gt;</span>
    <span class="pl-en">Future</span>(processLogout)
  }
}</pre>
  </div> 
  <p>Add the <code>AuthAction</code> or <code>ApiAuthAction</code> to any endpoints you with to require an authenticated user for.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">controllers</span>

<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">lib.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">play.api.mvc.</span><span class="pl-v">_</span>


<span class="pl-k">object</span> <span class="pl-en">Application</span> <span class="pl-k">extends</span> <span class="pl-e">Controller</span> <span class="pl-k">with</span> <span class="pl-e">PanDomainAuthActions</span> {

  <span class="pl-k">def</span> <span class="pl-en">loginStatus</span> <span class="pl-k">=</span> <span class="pl-en">AuthAction</span> { request <span class="pl-k">=&gt;</span>
    <span class="pl-k">val</span> <span class="pl-en">user</span> <span class="pl-k">=</span> request.user
    <span class="pl-en">Ok</span>(views.html.loginStatus(user.toJson))
  }

  <span class="pl-k">def</span> <span class="pl-en">getItems</span> <span class="pl-k">=</span> <span class="pl-en">APIAuthAction</span> { <span class="pl-k">implicit</span> req <span class="pl-k">=&gt;</span>
    ...
  }

  ...
}</pre>
  </div> 
  <ul> 
   <li> <p><code>AuthAction</code> is used for endpoints that the user requests and will redirect unauthenticated users to Google for authentication. Use this for standard page loads etc.</p> </li> 
   <li> <p><code>ApiAuthAction</code> is used for api ajax / xhr style requests and will not redirect to Google for auth. This action will either process the action or return an error code that can be processed by your client javascript (see section on handling expired logins in a single page webapp).</p> <p>A grace period on expiry can be set by adding a <code>apiGracePeriod</code>. This is useful for when browsers have third party cookies disabled and reauthenticaiton solutions like <a href="https://github.com/guardian/pandular" target="_blank">pandular</a> break due to cookies being blocked on <code>window.open</code> or <code>iframe</code> requests. During this period we are hopeful of the user refreshing or revisiting the application through a standard browser request thus triggering off a reauthentication.</p> <p>The response codes are:</p> 
    <ul> 
     <li> <p><strong>401</strong> - user not authenticated - probably tricky to get this response as presumably the user has already loaded a page that would have logged them in</p> </li> 
     <li> <p><strong>403</strong> - not authorised - occurs then the user is authenticated but not valid in this app, this can happen when making cross app CORS requests</p> </li> 
     <li> <p><strong>419</strong> - authorisation expired - occurs when the authorisation with Google has expired (after 1 hour), you will need to re auth with Google to reestablish the session, this can typically be done transparently on the next page load request.</p> </li> 
    </ul> <p>See also <a href="https://github.com/guardian/pan-domain-authentication/blob/master" target="_blank">Customising error responses for an authenticated API</a>.</p> </li> 
  </ul> 
  <p>Both the actions add the current user to the request, this is available as <code>request.user</code>.</p> 
  <h3><a id="user-content-using-pan-domain-auth-with-another-framework" class="anchor" href="https://github.com/guardian/pan-domain-authentication#using-pan-domain-auth-with-another-framework" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using pan domain auth with another framework</h3> 
  <p>Other scala frameworks exist as well as play. Full framework libraries are not provided for these yet as we predominantly use play at the guardian. To use pan domain auth with another framework you will need to provide an equivalent of the user auth checking in the play actions and provide an implementation of the Google oauth integration. Have a look at how this is done in the play library and provide your own implementation for your framework and http client etc.</p> 
  <p>More examples and framework clients may be added in the future as they become available.</p> 
  <h3><a id="user-content-configuring-access-to-the-s3-bucket" class="anchor" href="https://github.com/guardian/pan-domain-authentication#configuring-access-to-the-s3-bucket" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuring access to the S3 bucket</h3> 
  <p>Access to the s3 bucket is controlled by overriding the <code>awsCredentials</code> and <code>awsRegion</code> options in the <code>PanDomainAuth</code> trait (or the <code>AuthActions</code> sub trait in the play implementation).</p> 
  <ul> 
   <li> <p><strong>awsCredentialsProvider</strong> defaults to DefaultAWSCredentialsProviderChain - this means that the instance profile of your app running in EC2 will be used. You can configure access to the bucket in your cloud formation script. For apps that are not running in EC2 (such as developer environments) you can supply <code>StaticCredentialsProvider(BasicAWSCredentials)</code> with a key and secret for a user that will grant access to the bucket.</p> </li> 
   <li> <p><strong>awsRegion</strong> defaults to eu-west-1 - This is where the guardian runs the majority of it's aws estate so is a useful default for us.</p> </li> 
  </ul> 
  <h3><a id="user-content-the-user-object" class="anchor" href="https://github.com/guardian/pan-domain-authentication#the-user-object" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>The user object</h3> 
  <p>The user object is defined as:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">User</span>(
  <span class="pl-v">firstName</span>: <span class="pl-k">String</span>,
  <span class="pl-v">lastName</span>: <span class="pl-k">String</span>,
  <span class="pl-v">email</span>: <span class="pl-k">String</span>,
  <span class="pl-v">avatarUrl</span>: <span class="pl-en">Option</span>[<span class="pl-k">String</span>]
)</pre>
  </div> 
  <p>Hopefully the fields are clear as to what they are. There is a budget toJson method on it that will give a json string representation of the user which can be consumed by your javascript, this method does no use any json libraries so should work for any framework and library choices you've made in you implementing app.</p> 
  <h3><a id="user-content-validating-the-user" class="anchor" href="https://github.com/guardian/pan-domain-authentication#validating-the-user" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Validating the user</h3> 
  <p>As different apps may have different requirements on user validity each individual app should provide a user validation mechanism. The validation method takes in an <code>AuthenticatedUser</code> object which contains the user object and metadata about the authentication.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">AuthenticatedUser</span>(
  <span class="pl-v">user</span>: <span class="pl-en">User</span>,
  <span class="pl-v">authenticatingSystem</span>: <span class="pl-k">String</span>,
  <span class="pl-v">authenticatedIn</span>: <span class="pl-en">Set</span>[<span class="pl-k">String</span>],
  <span class="pl-v">expires</span>: <span class="pl-k">Long</span>,
  <span class="pl-v">multiFactor</span>: <span class="pl-k">Boolean</span>
)</pre>
  </div> 
  <p>The fields are:</p> 
  <ul> 
   <li><strong>user</strong> - the user object</li> 
   <li><strong>authenticatingSystem</strong> - the app name of the app that authenticated the user</li> 
   <li><strong>authenticatedIn</strong> - the set of app names that this user is known to be valid, this prevents revalidation if cacheValidation is set to true</li> 
   <li><strong>expires</strong> - the authentication session expiry time in milliseconds, after this has passed then the session is invalid and the user will need to be reauthenticated with Google. There is a handy method to check if the authentication is expired <code>def isExpired = expires &lt; new Date().getTime</code></li> 
   <li><strong>multiFactor</strong> - true if the user's authentication used a 2 factor type login. This defaults to false</li> 
  </ul> 
  <p>In many cases you will just want to check that the user is on the right domain and that they have 2-factor-auth enabled on their Google account. A function that enforces this common use-case is provided for convenience, <code>PanDomain.guardianValidation</code>.</p> 
  <h3><a id="user-content-customising-error-responses-for-an-authenticated-api" class="anchor" href="https://github.com/guardian/pan-domain-authentication#customising-error-responses-for-an-authenticated-api" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Customising error responses for an authenticated API</h3> 
  <p>The default <code>ApiAuthAction</code> error responses returns sensible status codes but no body.</p> 
  <p>To customise the responses (code and body) of an authenticated API, you can provide your own implementation of the <code>AbstractApiAuthAction</code> trait that provides the various abstract result properties:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">VerboseAPIAuthAction</span> <span class="pl-k">extends</span> <span class="pl-e">AbstractApiAuthAction</span> {
  <span class="pl-k">val</span> <span class="pl-en">notAuthenticatedResult</span><span class="pl-k">:</span> <span class="pl-en">Result</span> <span class="pl-k">=</span> <span class="pl-en">Unauthorized</span>(errorResponse(<span class="pl-s"><span class="pl-pds">"</span>Not authenticated<span class="pl-pds">"</span></span>))
  <span class="pl-k">val</span> <span class="pl-en">invalidCookieResult</span><span class="pl-k">:</span> <span class="pl-en">Result</span>    <span class="pl-k">=</span> notAuthenticatedResult
  <span class="pl-k">val</span> <span class="pl-en">expiredResult</span><span class="pl-k">:</span> <span class="pl-en">Result</span>          <span class="pl-k">=</span> <span class="pl-en">Forbidden</span>(errorResponse(<span class="pl-s"><span class="pl-pds">"</span>Session expired<span class="pl-pds">"</span></span>))
  <span class="pl-k">val</span> <span class="pl-en">notAuthorizedResult</span><span class="pl-k">:</span> <span class="pl-en">Result</span>    <span class="pl-k">=</span> <span class="pl-en">Forbidden</span>(errorResponse(<span class="pl-s"><span class="pl-pds">"</span>Not authorized<span class="pl-pds">"</span></span>))

  <span class="pl-k">private</span> <span class="pl-k">def</span> <span class="pl-en">errorResponse</span>(<span class="pl-v">msg</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> <span class="pl-en">Json</span>.obj(<span class="pl-s"><span class="pl-pds">"</span>error<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> msg)
}</pre>
  </div> 
  <h2><a id="user-content-using-google-group-based-2-factor-authentication-validation" class="anchor" href="https://github.com/guardian/pan-domain-authentication#using-google-group-based-2-factor-authentication-validation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using Google group based 2-factor authentication validation</h2> 
  <p>Some applications may require that a multifactor authentication is used when authenticating a user. Since it is not possible to tell if this happened from the standard callback this is checked by asserting that the user is in a Google group that enforces 2 factor auth (this was the workaround suggested by Google themselves when we asked about checking 2fa). Since the group is likely set up within an apps for domains setup and not accessible to everyone checking the 2fa group uses different Google credentials from the main auth.</p> 
  <p>To configure multifactor checking you will need to create a service account that can access the Google directory api, see <a href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation" target="_blank">directory API docs</a>. once this is configured fill in all the following properties in the domain's property file and upload the service accounts cert to the s3bucket. If you do not wish to use this feature just omit the properties:</p> 
  <ul> 
   <li><strong>googleServiceAccountId</strong> - the service account email that is set up to allow access to the directory API</li> 
   <li><strong>googleServiceAccountCert</strong> - the name within the bucket of the certificate used to validate the service account</li> 
   <li><strong>google2faUser</strong> - the admin user to connect to the directory api as, this is not the service account user but a user in your org who is authorised to access group information</li> 
   <li><strong>multifactorGroupId</strong> - the name of the group that indicates and enforces that 2fa is turned on</li> 
  </ul> 
  <h2><a id="user-content-dealing-with-auth-expiry-in-a-single-page-webapp" class="anchor" href="https://github.com/guardian/pan-domain-authentication#dealing-with-auth-expiry-in-a-single-page-webapp" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dealing with auth expiry in a single page webapp</h2> 
  <p>In a single page webapp there will typically be an initial page load and then all communication with the server will be initiated by JavaScript. This causes problems when the auth session expires as you can't redirect the request to Google to reauthenticate the request. To work around this all ajax type requests should return 419 responses on auth session expiry and this should be handled by the JavaScript layer.</p> 
  <p>See also the helper <a href="https://github.com/guardian/panda-session" target="_blank">panda-session</a> JavaScript library.</p> 
  <h2><a id="user-content-a-note-for-guardian-developers" class="anchor" href="https://github.com/guardian/pan-domain-authentication#a-note-for-guardian-developers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>A note for guardian developers</h2> 
  <p>At the guardian we are using pan domain auth on our tools domain. To add your tools apps you will need the s3 credentials and the oauth callbacks set up in Google for you app. To get this done come and speak to Swells or the tools team.</p> 
 </article>
</div>