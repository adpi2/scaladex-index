<div class="announce instapaper_body markdown" data-path="README.markdown" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-command-line-arguments" class="anchor" href="https://github.com/deanwampler/command-line-arguments#command-line-arguments" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Command Line Arguments</h2> 
  <p>Dean Wampler, Ph.D. <a href="https://twitter.com/deanwampler" target="_blank">@deanwampler</a></p> 
  <p>This is a <a href="http://scala-lang.org" target="_blank">Scala</a> library for handling command-line arguments. It has few dependencies on other libraries, <a href="https://github.com/sirthias/parboiled/wiki/parboiled-for-Scala" target="_blank">Parboiled</a>, for parsing, and <a href="http://scalatest.org" target="_blank">ScalaTest</a> and <a href="http://scalacheck.org" target="_blank">ScalaCheck</a>, for testing. So its footprint is small.</p> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/deanwampler/command-line-arguments#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>This library is built for Scala 2.10.6, 2.11.7 (the default). Artifacts are published to <a href="https://oss.sonatype.org/index.html#nexus-search;quick%7Eshapeless" target="_blank">Sonatype's OSS service</a>. You'll need the following settings.</p> 
  <pre><code>resolvers ++= Seq(
  Resolver.sonatypeRepo("releases"),
  Resolver.sonatypeRepo("snapshots")
)
...

scalaVersion := "2.11.7"  // or 2.10.6

libraryDependencies ++= Seq(
  "com.concurrentthought.cla" %% "command-line-arguments" % "0.4.0"
)
</code></pre> 
  <h2><a id="user-content-api" class="anchor" href="https://github.com/deanwampler/command-line-arguments#api" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>API</h2> 
  <p>The included <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/CLASampleMain.scala" target="_blank">com.concurrentthought.cla.CLASampleMain</a> shows two different idiomatic ways to set up and use the API.</p> 
  <p>The simplest approach parses a multi-line string to specify the command-line arguments <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Args.scala" target="_blank">com.concurrentthought.cla.Args</a>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.concurrentthought.cla.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">CLASampleMain</span> {

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">argstrings</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">initialArgs</span><span class="pl-k">:</span> <span class="pl-en">Args</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">      |run-main CLASampleMain [options]</span>
<span class="pl-s">      |Demonstrates the CLA API.</span>
<span class="pl-s">      |   -i | --in  | --input      string              Path to input file.</span>
<span class="pl-s">      |  [-o | --out | --output     string=/dev/null]   Path to output file.</span>
<span class="pl-s">      |  [-l | --log | --log-level  int=3]              Log level to use.</span>
<span class="pl-s">      |  [-p | --path               path]               Path elements separated by ':' (*nix) or ';' (Windows).</span>
<span class="pl-s">      |  [--things                  seq([-|])]          String elements separated by '-' or '|'.</span>
<span class="pl-s">      |  [-q | --quiet              flag]               Suppress some verbose output.</span>
<span class="pl-s">      |                             others              Other arguments.</span>
<span class="pl-s">      |Note that --input and "others" are required.</span>
<span class="pl-s">      |<span class="pl-pds">"""</span></span>.stripMargin.toArgs

    <span class="pl-c">// Process the input arguments. If help requested or an error occurs,</span>
    <span class="pl-c">// a message is written to stdout and the program exits with an error code.</span>
    <span class="pl-c">// Default arguments for `process` aren't shown. See also Args#parse() for </span>
    <span class="pl-c">// more flexible handling.</span>
    <span class="pl-k">val</span> <span class="pl-en">finalArgs</span><span class="pl-k">:</span> <span class="pl-en">Args</span> <span class="pl-k">=</span> initialArgs.process(argstrings)

    <span class="pl-c">// If here, successfully parsed the args and none where "--help" or "-h".</span>
    showResults(finalArgs)
  }
  ...</pre>
  </div> 
  <p>The <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/package.scala" target="_blank">Scaladocs comments</a> for the <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/package.scala" target="_blank">cla package</a> explain the format and its limitations, but hopefully most of the format is reasonable intuitive from the example.</p> 
  <p>The first and last lines in the string that <em>don't</em> have leading whitespace are interpreted as lines to show as part of the corresponding help message. It's a good idea to use the first line to show an example of how to invoke the program.</p> 
  <p>Next come the command-line options, one per line. Each must start with whitespace, followed by zero or more flags separated by <code>|</code>. There can be at most one option that has no flags. It is used to provide a help message for how command-line tokens that aren't associated with flags will be interpreted. (Note that the library will still handle these tokens whether or not you specify a line like this.)</p> 
  <p>To indicate that an option can be omitted by the user (i.e., it's truly <em>optional</em>), the flags and name must be wrapped in <code>[...]</code>. Otherwise, the user must specify the option explicitly on the command line. However, if a default value is specified (discussed next), it makes an option <em>optional</em> anyway. The purpose of the optional feature is to indicate to the user which arguments are required and to automatically report missing arguments as errors.</p> 
  <p>In this example, all are optional except for the <code>--input</code> and <code>others</code> arguments.</p> 
  <p>The center "column" specifies the type of the option. All but the <code>flag</code> and <code>~flag</code> types accept an optional default value, which is indicated with an equals <code>=</code> sign. The following "types" are supported:</p> 
  <table>
   <thead> 
    <tr> 
     <th align="right">String</th> 
     <th align="left">Interpretation</th> 
     <th align="left">Corresponding Helper Method</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td align="right"><code>flag</code></td> 
     <td align="left"><code>Boolean</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.flag</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>~flag</code></td> 
     <td align="left"><code>Boolean</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.flag</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>string</code></td> 
     <td align="left"><code>String</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.string</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>byte</code></td> 
     <td align="left"><code>Byte</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.byte</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>char</code></td> 
     <td align="left"><code>Char</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.char</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>int</code></td> 
     <td align="left"><code>Int</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.int</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>long</code></td> 
     <td align="left"><code>Long</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.long</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>float</code></td> 
     <td align="left"><code>Float</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.float</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>double</code></td> 
     <td align="left"><code>Double</code> value</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.double</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>seq</code></td> 
     <td align="left"><code>Seq[String]</code> [1]</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.seqString</a></td> 
    </tr> 
    <tr> 
     <td align="right"><code>path</code></td> 
     <td align="left">"path-like" <code>Seq[String]</code> [1]</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.path</a></td> 
    </tr> 
    <tr> 
     <td align="right"><em>other</em></td> 
     <td align="left">Only allowed for the single, no-flags case</td> 
     <td align="left"><a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Args.scala" target="_blank">Args.remainingOpt</a></td> 
    </tr> 
   </tbody>
  </table> 
  <p>1: Both <code>path</code> and <code>seq</code> split an argument using the delimiter regular expression. For <code>path</code>, this is the platform-specific path separator, given by <code>sys.props.getOrElse("path.separator", ":")</code>. It is designed for class paths, etc. For <code>seq</code>, you must provide the delimiter regular expression using a suffix of the form <code>(delimRE)</code>. In the example above, the regex is <code>[-|]</code> (split on either <code>-</code> or <code>|</code>).</p> 
  <p>Both <code>flag</code> and <code>~flag</code> represent <code>Boolean</code> flags where no default value can be supplied (e.g., <code>--help</code>). The value corresponding to a <code>flag</code> defaults to <code>false</code> if the user doesn't invoke the flag on the command line, <code>~flag</code> ("tilde" or "not" flag) defaults to <code>true</code>.</p> 
  <p>So, when an option expects something other than a <code>String</code>, the token given on the command line (or as a default value) will be parsed into the correct type, with error handling captured in the <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Args.scala" target="_blank">Args.failures</a> field.</p> 
  <p>Finally, the rest of the text on a line is the help message for the option.</p> 
  <p>Before discussing the <code>process</code> method shown, let's see two alternative, programmatic ways to declare <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Args.scala" target="_blank">Args</a> using the API:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  ...
  <span class="pl-k">def</span> <span class="pl-en">main2</span>(<span class="pl-v">argstrings</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">input</span>  <span class="pl-k">=</span> <span class="pl-en">Opt</span>.string(
      name     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>input<span class="pl-pds">"</span></span>,
      flags    <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-i<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--in<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--input<span class="pl-pds">"</span></span>),
      help     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Path to input file.<span class="pl-pds">"</span></span>,
      requiredFlag <span class="pl-k">=</span> <span class="pl-c1">true</span>)
    <span class="pl-k">val</span> <span class="pl-en">output</span> <span class="pl-k">=</span> <span class="pl-en">Opt</span>.string(
      name     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>output<span class="pl-pds">"</span></span>,
      flags    <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-o<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--out<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--output<span class="pl-pds">"</span></span>),
      default  <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>/dev/null<span class="pl-pds">"</span></span>),
      help     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Path to output file.<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">logLevel</span> <span class="pl-k">=</span> <span class="pl-en">Opt</span>.int(
      name     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>log-level<span class="pl-pds">"</span></span>,
      flags    <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-l<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--log<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--log-level<span class="pl-pds">"</span></span>),
      default  <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-c1">3</span>),
      help     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Log level to use.<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">path</span> <span class="pl-k">=</span> <span class="pl-en">Opt</span>.path(
      name     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>path<span class="pl-pds">"</span></span>,
      flags    <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-p<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--path<span class="pl-pds">"</span></span>))
    <span class="pl-k">val</span> <span class="pl-en">things</span> <span class="pl-k">=</span> <span class="pl-en">Opt</span>.seqString(delimsRE <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>[-|]<span class="pl-pds">"</span></span>)(
      name     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>things<span class="pl-pds">"</span></span>,
      flags    <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>--things<span class="pl-pds">"</span></span>),
      help     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>String elements separated by '-' or '|'.<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">others</span> <span class="pl-k">=</span> <span class="pl-en">Args</span>.makeRemainingOpt(
      name     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>others<span class="pl-pds">"</span></span>,
      help     <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Other arguments<span class="pl-pds">"</span></span>,
      requiredFlag <span class="pl-k">=</span> <span class="pl-c1">true</span>)

    <span class="pl-k">val</span> <span class="pl-en">initialArgs</span> <span class="pl-k">=</span> <span class="pl-en">Args</span>(
      <span class="pl-s"><span class="pl-pds">"</span>run-main CLASampleMain [options]<span class="pl-pds">"</span></span>, 
      <span class="pl-s"><span class="pl-pds">"</span>Demonstrates the CLA API.<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"""</span>Note that --input and "others" are required.<span class="pl-pds">"""</span></span>,
      <span class="pl-en">Seq</span>(input, output, logLevel, path, things, <span class="pl-en">Args</span>.quietFlag, others))

    <span class="pl-k">val</span> <span class="pl-en">finalArgs</span><span class="pl-k">:</span> <span class="pl-en">Args</span> <span class="pl-k">=</span> initialArgs.process(argstrings)
    showResults(finalArgs)
  }
  ...
}</pre>
  </div> 
  <p>Each option is defined using a <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">com.concurrentthought.cla.Opt</a> value. In this case, there are helper methods in the <code>Opt</code> companion object for constructing options where the values are strings or numbers. The <code>string</code> and <code>int</code> helpers are used here for <code>String</code> and <code>Int</code> arguments, respectively).</p> 
  <p>The arguments to each of these helpers (and also for <code>Opt[V].apply()</code> that they invoke) is the option name, used to retrieve the value later, a <code>Seq</code> of flags for command line invocation, an optional default value if the command-line argument isn't used (defaults to <code>None</code>), a help string (defaults to ""), and a boolean flag indicating whether or not the "option" is required (defaults to <code>false</code>, which is sort of the opposite behavior of the string DSL discussed previously).</p> 
  <p>There are also two helpers for command-line arguments that are strings that contain sequences of elements. We use one of them here, <code>seqString</code>, for a classpath-style argument, where the elements will be split into a <code>Seq[String]</code>, using <code>:</code> and <code>;</code> as delimiters; the first argument is a regular expression for the delimiter. If you want to support a path-like option, e.g., a <code>CLASSPATH</code>, there is another, even more specific helper, <code>Opt.path</code>, that handles the platform-specific value for the path-element separator.</p> 
  <p>There is also a more general <code>seq[V]</code> helper, where the string is first split, then parsed into <code>V</code> instances. See <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Opt.scala" target="_blank">Opt.seq[V]</a> for more details.</p> 
  <p>The first two arguments to the <code>Args.apply()</code> method provide help strings. The first shows how to run the application, e.g., <code>run-main CLASampleMain</code> as shown, or perhaps <code>java -cp ... foo.bar.Main</code>, etc. The string is arbitrary. The second string is an optional description of the program. Finally, a <code>Seq[Opt[V]]</code> specifies the actual options supported. Note that we didn't define a <code>Flag</code> for quiet, as in the first example, instead we used a built-in flag <code>Args.quietFlag</code>.</p> 
  <p>Here is a slightly more concise way to write the content in <code>main2</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  ...
  <span class="pl-k">def</span> <span class="pl-en">main3</span>(<span class="pl-v">argstrings</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
    <span class="pl-k">import</span> <span class="pl-v">Opt.</span><span class="pl-v">_</span>
    <span class="pl-k">import</span> <span class="pl-v">Args.</span><span class="pl-v">_</span>
    <span class="pl-k">val</span> <span class="pl-en">initialArgs</span> <span class="pl-k">=</span> <span class="pl-en">Args</span>(
      <span class="pl-s"><span class="pl-pds">"</span>run-main CLASampleMain [options]<span class="pl-pds">"</span></span>, 
      <span class="pl-s"><span class="pl-pds">"</span>Demonstrates the CLA API.<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"""</span>Note that --input and "others" are required.<span class="pl-pds">"""</span></span>,
      <span class="pl-en">Seq</span>(
        string(<span class="pl-s"><span class="pl-pds">"</span>input<span class="pl-pds">"</span></span>,     <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-i<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--in<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--input<span class="pl-pds">"</span></span>),      <span class="pl-c1">None</span>,              <span class="pl-s"><span class="pl-pds">"</span>Path to input file.<span class="pl-pds">"</span></span>),
        string(<span class="pl-s"><span class="pl-pds">"</span>output<span class="pl-pds">"</span></span>,    <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-o<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--out<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--output<span class="pl-pds">"</span></span>),    <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>/dev/null<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>Path to output file.<span class="pl-pds">"</span></span>),
        int(   <span class="pl-s"><span class="pl-pds">"</span>log-level<span class="pl-pds">"</span></span>, <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-l<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--log<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--log-level<span class="pl-pds">"</span></span>), <span class="pl-en">Some</span>(<span class="pl-c1">3</span>),           <span class="pl-s"><span class="pl-pds">"</span>Log level to use.<span class="pl-pds">"</span></span>),
        path(  <span class="pl-s"><span class="pl-pds">"</span>path<span class="pl-pds">"</span></span>,      <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-p<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>--path<span class="pl-pds">"</span></span>),               <span class="pl-c1">None</span>),
        seqString(<span class="pl-s"><span class="pl-pds">"</span>[:;]<span class="pl-pds">"</span></span>)(
               <span class="pl-s"><span class="pl-pds">"</span>things<span class="pl-pds">"</span></span>,    <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>--things<span class="pl-pds">"</span></span>),                   <span class="pl-c1">None</span>,              <span class="pl-s"><span class="pl-pds">"</span>String elements separated by '-' or '|'.<span class="pl-pds">"</span></span>),
        <span class="pl-en">Args</span>.quietFlag,
        makeRemainingOpt(
               <span class="pl-s"><span class="pl-pds">"</span>others<span class="pl-pds">"</span></span>,                                                          <span class="pl-s"><span class="pl-pds">"</span>Other arguments<span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>)))

    <span class="pl-k">val</span> <span class="pl-en">finalArgs</span><span class="pl-k">:</span> <span class="pl-en">Args</span> <span class="pl-k">=</span> initialArgs.process(argstrings)
    showResults(finalArgs)
  }
  ...</pre>
  </div> 
  <p>This is more concise, but perhaps harder to follow.</p> 
  <p>The <a href="https://github.com/deanwampler/command-line-arguments/blob/master/src/main/scala/com/concurrentthought/cla/Args.scala" target="_blank">Args#process</a> first calls <code>Args#parse</code> on the user-specified arguments, which returns a new <code>Args</code> instance with updated values for each argument. However, if an error occurs or help is requested, <code>process</code> automatically prints a message and exits. This behavior is configurable by overriding default arguments. See also <code>Args#parse()</code> for more flexible handling.</p> 
  <p>You'll almost always want to include logic like this in your code that uses this library.</p> 
  <p>If <code>--quiet</code> wasn't specified, then you might print information about the argument values. We demonstrate this in the <code>CLASampleMain</code> program. where the <code>showResults</code> method prints all the options and the current values for them, either the defaults or the user-specified values.</p> 
  <pre><code>  protected def showResults(parsedArgs: Args): Unit = {
    if (parsedArgs.getOrElse("quiet", false)) {
      println("(... I'm being very quiet...)")
    } else {
      // Print all the default values or those specified by the user.
      parsedArgs.printValues()

      // Print all the values including repeats.
      parsedArgs.printAllValues()

      // Repeat the "other" arguments (not associated with flags).
      println("\nYou gave the following \"other\" arguments: " +
        parsedArgs.remaining.mkString(", "))
      ...
</code></pre> 
  <p>What's the difference between <code>printValues</code> and <code>printAllValues</code>. They address the case where the user should be able to repeat some options, for example, multiple sources of input, while other examples should only be used once. To simplify handling, the API remembers all occurrences of an option on the command line. The method <code>printAllValues</code> and the corresponding <code>getAll</code> and <code>getAllOrElse</code> methods print or return all occurrences seen, respectively. So, if you want an option to be repeatable, retrieve the results with <code>getAll</code> or <code>getAllOrElse</code>. Otherwise, use <code>get</code> and <code>getOrElse</code>, which return the <em>last</em> occurrence of an option (or the default, if any). This supports the common practice in POSIX systems of allowing subsequent option occurrences to override previous occurrences on a command line.</p> 
  <p>Finally, we extract some other values and "use" them.</p> 
  <pre><code>    ...
      showPathElements(parsedArgs.get[Seq[String]]("path"))
      showLogLevel(parsedArgs.getOrElse("log-level", 0))
      println
    }
  }

  protected def showPathElements(path: Option[Seq[String]]) = path match {
    case None =&gt; println("No path elements to show!")
    case Some(seq) =&gt; println(s"Setting path elements to $seq")
  }

  protected def showLogLevel(level: Int) =
    println(s"New log level: $level")
}
</code></pre> 
  <p>The <code>get[V]</code> method returns values of the expected type. It uses <code>asInstanceOf[]</code> internally, but it should never fail because the parsing process already converted the value to the correct type (and then put it in a <code>Map[String,Any]</code> used by <code>get[V]</code>).</p> 
  <p>Note that an advantage of <code>getOrElse[V]</code> is that its type parameter can be inferred due to the second argument.</p> 
  <p>Try running the following examples within SBT (<code>run</code> and <code>run-main com.concurrentthought.cla.CLASampleMain</code> do the same thing):</p> 
  <pre><code> run-main com.concurrentthought.cla.CLASampleMain -h
 run -h
 run --help
 run -i /in -o /out -l 4 -p a:b --things x-y|z foo bar baz
 run -i /in -o /out -l 4 -p a:b --things x-y|z foo bar baz --quiet
 run --in /in --out=/out -l=4 --path "a:b" --things=x-y|z foo bar baz
</code></pre> 
  <p>The last example mixes <code>argflag value</code> and <code>argflag=value</code> syntax, which of are both supported.</p> 
  <p>Try a few runs with unknown flags and other errors. Note the error handling that's done, such as when you omit a value expected by a flag, or you provide an invalid value, such as <code>--log-level foo</code>.</p> 
 </article>
</div>