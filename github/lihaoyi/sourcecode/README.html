<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-sourcecode--" class="anchor" href="https://github.com/lihaoyi/sourcecode#sourcecode--" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SourceCode <a href="https://travis-ci.org/lihaoyi/sourcecode" target="_blank"><img src="https://camo.githubusercontent.com/530c0f1c251e40335ba60f49bdf757cff2d216ec/68747470733a2f2f7472617669732d63692e6f72672f6c6968616f79692f736f75726365636f64652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/lihaoyi/sourcecode.svg?branch=master" style="max-width:100%;"></a> <a href="https://gitter.im/lihaoyi/sourcecode?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/lihaoyi/Ammonite" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></h1> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-s"><span class="pl-pds">"</span>com.lihaoyi<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.1.3<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> Scala-JVM</span>
<span class="pl-s"><span class="pl-pds">"</span>com.lihaoyi<span class="pl-pds">"</span></span> <span class="pl-k">%%%</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.1.3<span class="pl-pds">"</span></span> <span class="pl-c"><span class="pl-c">//</span> Scala.js</span></pre>
  </div> 
  <p><code>sourcecode</code> is a small Scala library for that provides common "source code" context to your program at runtime, similar to Python's <code>__name__</code>, C++'s <code>__LINE__</code> or Ruby's <code>__FILE__</code>. For example, you can ask for the file-name and line number of the current file, either through the <code>()</code> syntax or via an implicit:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">file</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">File</span>()
assert(file.endsWith(<span class="pl-s"><span class="pl-pds">"</span>/sourcecode/shared/src/test/scala/sourcecode/Tests.scala<span class="pl-pds">"</span></span>))

<span class="pl-k">val</span> <span class="pl-en">line</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Line</span>]
assert(line <span class="pl-k">==</span> <span class="pl-c1">16</span>)</pre>
  </div> 
  <p>This might not be something you want to use for "business logic", but is very helpful for things like <a href="https://github.com/lihaoyi/sourcecode#debug-prints" target="_blank">debugging</a>, <a href="https://github.com/lihaoyi/sourcecode#logging" target="_blank">logging</a> or providing automatic diagnostics for <a href="https://github.com/lihaoyi/sourcecode#embedding-domain-specific-languages" target="_blank">DSLs</a>. This information is also available via an <code>implicit</code>, letting you write functions that automatically pull it in.</p> 
  <p>Using SourceCode on code dealing with lots of anonymous functions or anonymous classes can easily turn what you see in your debug printouts from this:</p> 
  <p><a href="https://github.com/lihaoyi/sourcecode/blob/master/docs/Before.png" target="_blank"><img src="https://github.com/lihaoyi/sourcecode/raw/master/docs/Before.png" alt="Before" style="max-width:100%;"></a></p> 
  <p>To this:</p> 
  <p><a href="https://github.com/lihaoyi/sourcecode/blob/master/docs/After.png" target="_blank"><img src="https://github.com/lihaoyi/sourcecode/raw/master/docs/After.png" alt="After" style="max-width:100%;"></a></p> 
  <p>By capturing source information you can use to give your objects and function meaningful names that tell you where they were defined, automatically without needing you to manually assign a string-ID to every anonymous function or anonymous class you define all over your code bas.</p> 
  <h1><a id="user-content-table-of-contents" class="anchor" href="https://github.com/lihaoyi/sourcecode#table-of-contents" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Table of Contents</h1> 
  <ul> 
   <li><a href="https://github.com/lihaoyi/sourcecode#overview" target="_blank">Overview</a></li> 
   <li><a href="https://github.com/lihaoyi/sourcecode#examples" target="_blank">Examples</a></li> 
   <li><a href="https://github.com/lihaoyi/sourcecode#use-cases" target="_blank">Use Cases</a> 
    <ul> 
     <li><a href="https://github.com/lihaoyi/sourcecode#logging" target="_blank">Logging</a></li> 
     <li><a href="https://github.com/lihaoyi/sourcecode#enums" target="_blank">Enums</a></li> 
     <li><a href="https://github.com/lihaoyi/sourcecode#debug-prints" target="_blank">Debug Prints</a></li> 
     <li><a href="https://github.com/lihaoyi/sourcecode#embedding-domain-specific-languages" target="_blank">Embedding Domain-Specific Languages</a></li> 
    </ul> </li> 
   <li><a href="https://github.com/lihaoyi/sourcecode#version-history" target="_blank">Version History</a></li> 
  </ul> 
  <h1><a id="user-content-overview" class="anchor" href="https://github.com/lihaoyi/sourcecode#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h1> 
  <p>The kinds of compilation-time data that <code>sourcecode</code> provides are:</p> 
  <ul> 
   <li><code>sourcecode.File</code>: full path of the current file where the call occurs</li> 
   <li><code>sourcecode.Line</code>: current line number</li> 
   <li><code>sourcecode.Name</code>: the name of the nearest enclosing definition: <code>val</code>, <code>class</code>, whatever.</li> 
   <li><code>sourcecode.FullName</code>: the name of the nearest enclosing definition: <code>val</code>, <code>class</code>, whatever, prefixed by the names of all enclosing <code>class</code>s, <code>trait</code>s, <code>object</code>s or <code>package</code>s. Note that this does <em>not</em> include other enclosing <code>def</code>s, <code>val</code>s, <code>var</code>s or <code>lazy val</code>s`</li> 
   <li><code>sourcecode.Enclosing</code>: the name of the nearest enclosing definition: <code>val</code>, <code>class</code>, whatever, prefixed by the names of all enclosing <code>class</code>s, <code>trait</code>s, <code>object</code>s or <code>package</code>s, <code>def</code>s, <code>val</code>s, <code>var</code>s or <code>lazy val</code>s`</li> 
   <li><code>sourcecode.Text[T]</code>: when you want to take a value of type <code>T</code>, but also want to get the "source text" of that particular value. Note that if you have multiple statements in a <code>{}</code> block, <code>sourcecode.Text</code> will only capture the source code for the last expression that gets returned. This implicit is slightly experimental; be sure to report any bugs you find!</li> 
   <li><code>sourcecode.Args</code>: the arguments that where provided to the nearest enclosing method</li> 
   <li><code>sourcecode.Name.Machine</code>, <code>sourcecode.FullName.Machine</code> and <code>sourcecode.Enclosing.Machine</code> which are similar to <code>sourcecode.Name</code>, <code>sourcecode.FullName</code> and <code>sourcecode.Enclosing</code> except they do not filter out synthetic method names; e.g. if you want to see the <code>&lt;init&gt;</code> names or <code>&lt;local foo&gt;</code> names as part of the path, use these instead.</li> 
  </ul> 
  <p>All these are available both via <code>()</code> and as implicits, e.g. <code>sourcecode.File</code> can be summoned via <code>sourcecode.File()</code> or <code>implicitly[sourcecode.File].value</code>. This also means you can define functions that pull in this information automatically:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">foo</span>(<span class="pl-v">arg</span>: <span class="pl-k">String</span>)(<span class="pl-k">implicit</span> <span class="pl-v">file</span>: sourcecode.<span class="pl-en">File</span>) <span class="pl-k">=</span> {
  ... <span class="pl-k">do</span> something <span class="pl-k">with</span> <span class="pl-e">arg</span> ...
  ... <span class="pl-k">do</span> something <span class="pl-k">with</span> <span class="pl-e">file.value</span> ...
}

foo(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> the implicit sourcecode.File is filled in automatically</span></pre>
  </div> 
  <p><code>sourcecode</code> does not rely on runtime reflection or stack inspection, and is done at compile-time using macros. This means that it is both orders of magnitude faster than e.g. getting file-name and line-numbers using stack inspection, and also works on Scala.js where reflection and stack inspection can't be used.</p> 
  <h1><a id="user-content-examples" class="anchor" href="https://github.com/lihaoyi/sourcecode#examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples</h1> 
  <p>Here are a few examples of <code>sourcecode</code>'s core functions being used in a variety of contexts. Hopefully they will give you an idea of how the various implicits behave:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">sourcecode</span>

<span class="pl-k">object</span> <span class="pl-en">Implicits</span> {
  <span class="pl-k">def</span> <span class="pl-en">implicitRun</span>() <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Name</span>]
    assert(name.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">fullName</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">FullName</span>]
    assert(fullName.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Implicits.fullName<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">enclosing</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Enclosing</span>]
    assert(enclosing.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Implicits.implicitRun enclosing<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">pkg</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Pkg</span>]
    assert(pkg.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">file</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">File</span>]
    assert(file.value.endsWith(<span class="pl-s"><span class="pl-pds">"</span>/sourcecode/shared/src/test/scala/sourcecode/Implicits.scala<span class="pl-pds">"</span></span>))

    <span class="pl-k">val</span> <span class="pl-en">line</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Line</span>]
    assert(line.value <span class="pl-k">==</span> <span class="pl-c1">20</span>)

    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">myLazy</span> <span class="pl-k">=</span> {
      <span class="pl-k">trait</span> <span class="pl-en">Bar</span>{
        <span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Name</span>]
        assert(name.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)

        <span class="pl-k">val</span> <span class="pl-en">fullName</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">FullName</span>]
        assert(fullName.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Implicits.Bar.fullName<span class="pl-pds">"</span></span>)

        <span class="pl-k">val</span> <span class="pl-en">file</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">File</span>]
        assert(file.value.endsWith(<span class="pl-s"><span class="pl-pds">"</span>/sourcecode/shared/src/test/scala/sourcecode/Implicits.scala<span class="pl-pds">"</span></span>))

        <span class="pl-k">val</span> <span class="pl-en">line</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Line</span>]
        assert(line.value <span class="pl-k">==</span> <span class="pl-c1">34</span>)

        <span class="pl-k">val</span> <span class="pl-en">enclosing</span> <span class="pl-k">=</span> implicitly[sourcecode.<span class="pl-en">Enclosing</span>]
        assert(enclosing.value <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Implicits.implicitRun myLazy$lzy Bar#enclosing<span class="pl-pds">"</span></span>)
      }
      <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>{}
    }
    myLazy
  }
}</pre>
  </div> 
  <p>Note that in "normal" usage you would not directly call <code>implicitly</code> to summon up <code>sourcecode</code> values; rather, you would add implicit parameters of these types to your functions. That would make these values automatically available to your functions without needing to manually keep passing them in. Apart from summoning them via implicits, you can also use the <code>apply</code> method on each type to pull them in using the <code>()</code> syntax:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">sourcecode</span>

<span class="pl-k">object</span> <span class="pl-en">Apply</span> {
  <span class="pl-k">def</span> <span class="pl-en">applyRun</span>() <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Name</span>()
    assert(name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">fullName</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">FullName</span>()
    assert(fullName <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Apply.fullName<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">enclosing</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Enclosing</span>()
    assert(enclosing <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Apply.applyRun enclosing<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">pkg</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Pkg</span>()
    assert(pkg <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode<span class="pl-pds">"</span></span>)

    <span class="pl-k">val</span> <span class="pl-en">file</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">File</span>()
    assert(file.endsWith(<span class="pl-s"><span class="pl-pds">"</span>/sourcecode/shared/src/test/scala/sourcecode/Apply.scala<span class="pl-pds">"</span></span>))

    <span class="pl-k">val</span> <span class="pl-en">line</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Line</span>()
    assert(line <span class="pl-k">==</span> <span class="pl-c1">20</span>)

    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">myLazy</span> <span class="pl-k">=</span> {
      <span class="pl-k">trait</span> <span class="pl-en">Bar</span>{
        <span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Name</span>()
        assert(name <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)

        <span class="pl-k">val</span> <span class="pl-en">fullName</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">FullName</span>()
        assert(fullName <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Apply.Bar.fullName<span class="pl-pds">"</span></span>)

        <span class="pl-k">val</span> <span class="pl-en">file</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">File</span>()
        assert(file.endsWith(<span class="pl-s"><span class="pl-pds">"</span>/sourcecode/shared/src/test/scala/sourcecode/Apply.scala<span class="pl-pds">"</span></span>))

        <span class="pl-k">val</span> <span class="pl-en">line</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Line</span>()
        assert(line <span class="pl-k">==</span> <span class="pl-c1">34</span>)

        <span class="pl-k">val</span> <span class="pl-en">enclosing</span> <span class="pl-k">=</span> sourcecode.<span class="pl-en">Enclosing</span>()
        assert(enclosing <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Apply.applyRun myLazy$lzy Bar#enclosing<span class="pl-pds">"</span></span>)
      }
      <span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Bar</span>{}
    }
    myLazy
  }
}</pre>
  </div> 
  <p>By default, the various implicits all ignore any synthetic <code>&lt;init&gt;</code> or <code>&lt;local Foo&gt;</code> methods that might be present:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">sourcecode</span>

<span class="pl-k">object</span> <span class="pl-en">NoSynthetic</span> {
  <span class="pl-k">def</span> <span class="pl-en">run</span>() <span class="pl-k">=</span> {
    <span class="pl-k">class</span> <span class="pl-en">EnumValue</span>(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>){
      <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span> <span class="pl-k">=</span> name.value
    }
    <span class="pl-k">object</span> <span class="pl-en">Foo</span> <span class="pl-k">extends</span> <span class="pl-e">EnumValue</span>

    assert(<span class="pl-en">Foo</span>.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>)

    <span class="pl-k">object</span> <span class="pl-en">Bar</span>{
      assert(sourcecode.<span class="pl-en">Name</span>() <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Bar<span class="pl-pds">"</span></span>)
      assert(sourcecode.<span class="pl-en">FullName</span>() <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.NoSynthetic.Bar<span class="pl-pds">"</span></span>)
      assert(sourcecode.<span class="pl-en">Enclosing</span>() <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.NoSynthetic.run Bar<span class="pl-pds">"</span></span>)
    }
    <span class="pl-en">Bar</span>
  }
}</pre>
  </div> 
  <p>If you want these synthetic methods to be shown, use the <code>.Machine</code> versions of each of these instead:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">sourcecode</span>

<span class="pl-k">object</span> <span class="pl-en">Synthetic</span> {
  <span class="pl-k">def</span> <span class="pl-en">run</span>() <span class="pl-k">=</span> {
    <span class="pl-k">class</span> <span class="pl-en">EnumValue</span>(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>.<span class="pl-en">Machine</span>){
      <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span> <span class="pl-k">=</span> name.value
    }
    <span class="pl-k">object</span> <span class="pl-en">Foo</span> <span class="pl-k">extends</span> <span class="pl-e">EnumValue</span>

    assert(<span class="pl-en">Foo</span>.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>&lt;init&gt;<span class="pl-pds">"</span></span>)

    <span class="pl-k">object</span> <span class="pl-en">Bar</span>{
      assert(sourcecode.<span class="pl-en">Name</span>.<span class="pl-en">Machine</span>() <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>&lt;local Bar&gt;<span class="pl-pds">"</span></span>, sourcecode.<span class="pl-en">Name</span>())
      assert(sourcecode.<span class="pl-en">FullName</span>.<span class="pl-en">Machine</span>() <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Synthetic.Bar.&lt;local Bar&gt;<span class="pl-pds">"</span></span>)
      assert(sourcecode.<span class="pl-en">Enclosing</span>.<span class="pl-en">Machine</span>() <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.Synthetic.run Bar.&lt;local Bar&gt;<span class="pl-pds">"</span></span>)
    }
    <span class="pl-en">Bar</span>
  }
}</pre>
  </div> 
  <p>Hopefully this has given you a reasonable feel for <em>what</em>* sourcecode does. You may still be wondering <em>why</em> we would want any of this: what could we possibly use these things for? Why would we want to write code that depends on our package paths or variable names? The section below will provide use cases that you will hopefully be able to relate to.</p> 
  <h1><a id="user-content-use-cases" class="anchor" href="https://github.com/lihaoyi/sourcecode#use-cases" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Use Cases</h1> 
  <p>At first it might seem strange to make use of these source-level details in your program: shouldn't a program's meaning not change under re-formatting and re-factoring?</p> 
  <p>It turns out that there are a number of entirely valid use cases for this sort of information that is both extremely handy, and also would not be surprising at all to a developer using your API. Here are a few example use cases:</p> 
  <h2><a id="user-content-logging" class="anchor" href="https://github.com/lihaoyi/sourcecode#logging" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Logging</h2> 
  <p>You can use <code>sourcecode.File</code> and <code>sourcecode.Line</code> to define <code>log</code> functions that automatically capture their line number and file-name</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">log</span>(<span class="pl-v">foo</span>: <span class="pl-k">String</span>)(<span class="pl-k">implicit</span> <span class="pl-v">line</span>: sourcecode.<span class="pl-en">Line</span>, <span class="pl-v">file</span>: sourcecode.<span class="pl-en">File</span>) <span class="pl-k">=</span> {
  println(s<span class="pl-s"><span class="pl-pds">"</span>${file.value}:${line.value} $foo<span class="pl-pds">"</span></span>)
}

log(<span class="pl-s"><span class="pl-pds">"</span>Foooooo<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> sourcecode/shared/src/test/scala/sourcecode/Tests.scala:86 Fooooo</span></pre>
  </div> 
  <p>This can be handy for letting you see where the log lines are coming from, without tediously tagging every log statement with a unique prefix. Furthermore, this happens at compile time, and is thus orders of magnitude faster than getting this information by generating stack traces, and works on Scala.js where stack-inspection does not. Lastly, if you want additional information such as method names, class names, or packages to be provided to your logging function, you can easily do so by asking for the <code>sourcecode.Name</code> or <code>sourcecode.FullName</code> or <code>sourcecode.Pkg</code> implicits.</p> 
  <h2><a id="user-content-enums" class="anchor" href="https://github.com/lihaoyi/sourcecode#enums" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Enums</h2> 
  <p>You can use <code>sourcecode.Name</code> to define an enumeration-value factory function that automatically assigns names to the enum values based on the name of the <code>val</code> that it is assigned to</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">sourcecode</span>

<span class="pl-k">object</span> <span class="pl-en">EnumExample</span> {
  <span class="pl-k">def</span> <span class="pl-en">run</span>() <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">EnumValue</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>){
      <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span> <span class="pl-k">=</span> name
    }
    <span class="pl-k">class</span> <span class="pl-en">Enum</span>{
      <span class="pl-k">def</span> <span class="pl-en">value</span>(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>) <span class="pl-k">=</span> <span class="pl-en">EnumValue</span>(name.value)
    }
    <span class="pl-k">object</span> <span class="pl-en">MyEnum</span> <span class="pl-k">extends</span> <span class="pl-e">Enum</span>{
      <span class="pl-k">val</span> <span class="pl-en">firstItem</span> <span class="pl-k">=</span> value
      <span class="pl-k">val</span> <span class="pl-en">secondItem</span> <span class="pl-k">=</span> value
    }
    assert(<span class="pl-en">MyEnum</span>.firstItem.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>firstItem<span class="pl-pds">"</span></span>)
    assert(<span class="pl-en">MyEnum</span>.secondItem.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>secondItem<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>This is very handy, and this functionality is used in a number of libraries such as <a href="http://lihaoyi.github.io/fastparse/" target="_blank">FastParse</a> and <a href="http://lihaoyi.github.io/scalatags/#CSSStylesheets" target="_blank">Scalatags</a> to provide a boilerplate-free experience while still providing good debuggability and convenience.</p> 
  <p>Sometimes you want to make sure that different enum values in differently named enums (or even an enum of the same name in a different package!) are given unique names. In that case, you can use <code>sourcecode.FullName</code> or <code>sourcecode.Enclosing</code> to capture the full path e.g. <code>"com.mypkg.MyEnum.firstItem"</code> and <code>"com.mypkg.MyEnum.secondItem"</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">sourcecode</span>

<span class="pl-k">object</span> <span class="pl-en">EnumFull</span> {
  <span class="pl-k">def</span> <span class="pl-en">run</span>() <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">EnumValue</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>){
      <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span> <span class="pl-k">=</span> name
    }
    <span class="pl-k">class</span> <span class="pl-en">Enum</span>{
      <span class="pl-k">def</span> <span class="pl-en">value</span>(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">FullName</span>) <span class="pl-k">=</span> <span class="pl-en">EnumValue</span>(name.value)
    }
    <span class="pl-k">object</span> <span class="pl-en">MyEnum</span> <span class="pl-k">extends</span> <span class="pl-e">Enum</span>{
      <span class="pl-k">val</span> <span class="pl-en">firstItem</span> <span class="pl-k">=</span> value
      <span class="pl-k">val</span> <span class="pl-en">secondItem</span> <span class="pl-k">=</span> value
    }
    assert(<span class="pl-en">MyEnum</span>.firstItem.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.EnumFull.MyEnum.firstItem<span class="pl-pds">"</span></span>)
    assert(<span class="pl-en">MyEnum</span>.secondItem.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>sourcecode.EnumFull.MyEnum.secondItem<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>You can also use <code>sourcecode.Name</code> in an constructor, in which case it'll be picked up during inheritance:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">EnumValue</span>(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>){
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span> <span class="pl-k">=</span> name.value
}
<span class="pl-k">object</span> <span class="pl-en">Foo</span> <span class="pl-k">extends</span> <span class="pl-e">EnumValue</span>
println(<span class="pl-en">Foo</span>.toString)
assert(<span class="pl-en">Foo</span>.toString <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>Foo<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h2><a id="user-content-debug-prints" class="anchor" href="https://github.com/lihaoyi/sourcecode#debug-prints" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Debug Prints</h2> 
  <p>How many times have you written tedious code like</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Bar</span>{
  <span class="pl-k">def</span> <span class="pl-en">foo</span>(<span class="pl-v">arg</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> {
    println(<span class="pl-s"><span class="pl-pds">"</span>Bar.foo: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> arg)
  }
}</pre>
  </div> 
  <p>Where you have to prefix every print statement with the name of the enclosing classes, objects or functions to make sure you can find your print output 2-3 minutes later? With <code>source.Enclosing</code>, you can get this for free:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">debug</span>[<span class="pl-en">V</span>](<span class="pl-v">value</span>: sourcecode.<span class="pl-en">Text</span>[<span class="pl-en">V</span>])(<span class="pl-k">implicit</span> <span class="pl-v">enclosing</span>: sourcecode.<span class="pl-en">Enclosing</span>) <span class="pl-k">=</span> {
  println(enclosing.value <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> [<span class="pl-pds">"</span></span> <span class="pl-k">+</span> value.source <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>]: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> value.value)
}

<span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">arg</span>: <span class="pl-k">Int</span>){
  debug(arg) <span class="pl-c"><span class="pl-c">//</span> sourcecode.DebugRun.main Foo [arg]: 123</span>
  <span class="pl-k">def</span> <span class="pl-en">bar</span>(<span class="pl-v">param</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> {
    debug(arg <span class="pl-k">-</span><span class="pl-k">&gt;</span> param)
  }
}
<span class="pl-k">new</span> <span class="pl-en">Foo</span>(<span class="pl-c1">123</span>).bar(<span class="pl-s"><span class="pl-pds">"</span>lol<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">//</span> sourcecode.DebugRun.main Foo#bar [arg -&gt; param]: (123,lol)</span></pre>
  </div> 
  <p>You can easily vary the amount of verbosity, e.g. by swapping the <code>sourcecode.Enclosing</code> for a `sourcecode.Name if you think it's too verbose:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">debug</span>[<span class="pl-en">V</span>](<span class="pl-v">value</span>: sourcecode.<span class="pl-en">Text</span>[<span class="pl-en">V</span>])(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>) <span class="pl-k">=</span> {
  println(name.value <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> [<span class="pl-pds">"</span></span> <span class="pl-k">+</span> value.source <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>]: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> value.value)
}

<span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">arg</span>: <span class="pl-k">Int</span>){
  debug(arg) <span class="pl-c"><span class="pl-c">//</span> Foo [arg]: 123</span>
  <span class="pl-k">def</span> <span class="pl-en">bar</span>(<span class="pl-v">param</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> {
    debug(param <span class="pl-k">-</span><span class="pl-k">&gt;</span> arg)
  }
}
<span class="pl-k">new</span> <span class="pl-en">Foo</span>(<span class="pl-c1">123</span>).bar(<span class="pl-s"><span class="pl-pds">"</span>lol<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">//</span> bar [param]: lol</span></pre>
  </div> 
  <p>Or leaving it out entirely:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">debug</span>[<span class="pl-en">V</span>](<span class="pl-v">value</span>: sourcecode.<span class="pl-en">Text</span>[<span class="pl-en">V</span>]) <span class="pl-k">=</span> {
  println(<span class="pl-s"><span class="pl-pds">"</span>[<span class="pl-pds">"</span></span> <span class="pl-k">+</span> value.source <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>]: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> value.value)
}

<span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">arg</span>: <span class="pl-k">Int</span>){
  debug(arg) <span class="pl-c"><span class="pl-c">//</span> [arg]: 123</span>
  <span class="pl-k">def</span> <span class="pl-en">bar</span>(<span class="pl-v">param</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> {
    debug(param <span class="pl-k">-</span><span class="pl-k">&gt;</span> arg)
  }
}
<span class="pl-k">new</span> <span class="pl-en">Foo</span>(<span class="pl-c1">123</span>).bar(<span class="pl-s"><span class="pl-pds">"</span>lol<span class="pl-pds">"</span></span>)  <span class="pl-c"><span class="pl-c">//</span> [param]: lol</span></pre>
  </div> 
  <p>Thus you can easily configure how much information your <code>debug</code> helper method needs, at its definition, without having to hunt all over your codebase for the various <code>debug</code> call-sites you left lying around and manually tweaking the verbosity of each one. Furthermore, if you want additional information like <code>sourcecode.Line</code> or <code>sourcecode.File</code>, that's all just one implicit away.</p> 
  <p>The <a href="http://www.lihaoyi.com/upickle-pprint/pprint" target="_blank">PPrint</a> library provides a <code>pprint.log</code> method that does exactly this: prints out the value provided (in this case pretty-printing it with colors and nice formatting &amp; indentation) together with the enclosing context and line number, so you can easily distinguish your individual prints later:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>{
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">bar</span>(<span class="pl-v">grid</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Seq</span>[<span class="pl-k">Int</span>]]) <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-c"><span class="pl-c">//</span> automatically capture and print out source context </span>
     <span class="pl-k">|</span>     pprint.log(grid, tag<span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">"</span>grid<span class="pl-pds">"</span></span>) 
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">Foo</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">new</span> <span class="pl-en">Foo</span>().bar(<span class="pl-en">Seq</span>(<span class="pl-c1">0</span> until <span class="pl-c1">10</span>, <span class="pl-c1">10</span> until <span class="pl-c1">20</span>, <span class="pl-c1">20</span> until <span class="pl-c1">30</span>))
pkg.<span class="pl-en">Foo</span>#bar <span class="pl-s"><span class="pl-pds">"</span>grid<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-c1">12</span>
<span class="pl-en">List</span>(
  <span class="pl-en">Range</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>, <span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>),
  <span class="pl-en">Range</span>(<span class="pl-c1">10</span>, <span class="pl-c1">11</span>, <span class="pl-c1">12</span>, <span class="pl-c1">13</span>, <span class="pl-c1">14</span>, <span class="pl-c1">15</span>, <span class="pl-c1">16</span>, <span class="pl-c1">17</span>, <span class="pl-c1">18</span>, <span class="pl-c1">19</span>),
  <span class="pl-en">Range</span>(<span class="pl-c1">20</span>, <span class="pl-c1">21</span>, <span class="pl-c1">22</span>, <span class="pl-c1">23</span>, <span class="pl-c1">24</span>, <span class="pl-c1">25</span>, <span class="pl-c1">26</span>, <span class="pl-c1">27</span>, <span class="pl-c1">28</span>, <span class="pl-c1">29</span>)
)</pre>
  </div> 
  <p><code>pprint.log</code> is itself defined as</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">log</span>[<span class="pl-en">T</span><span class="pl-k">:</span> <span class="pl-en">PPrint</span>](<span class="pl-v">value</span>: <span class="pl-en">T</span>, <span class="pl-v">tag</span>: <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
                  (<span class="pl-k">implicit</span> <span class="pl-v">cfg</span>: <span class="pl-en">Config</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>.<span class="pl-en">Colors</span>.<span class="pl-en">PPrintConfig</span>,
                   <span class="pl-v">path</span>: sourcecode.<span class="pl-en">Enclosing</span>,
                   <span class="pl-v">line</span>: sourcecode.<span class="pl-en">Line</span>) <span class="pl-k">=</span> ...</pre>
  </div> 
  <p>Using <code>sourcecode.Enclosing</code> and <code>sourcecode.Line</code> to provide the context to be printed. You can, or course, define your own <code>log</code> method in the same way, customizing it to print or not-print exactly what you want to see via the implicits that <code>sourcecode</code> provides!</p> 
  <p><code>sourcecode.Args</code> can be used to access all parameters that where provided to a method:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">debug</span>(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>, <span class="pl-v">args</span>: sourcecode.<span class="pl-en">Args</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
  println(name.value <span class="pl-k">+</span> args.value.map(_.map(a <span class="pl-k">=&gt;</span> a.source <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>=<span class="pl-pds">"</span></span> <span class="pl-k">+</span> a.value).mkString(<span class="pl-s"><span class="pl-pds">"</span>(<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>, <span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>)<span class="pl-pds">"</span></span>)).mkString(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>))
}

<span class="pl-k">def</span> <span class="pl-en">foo</span>(<span class="pl-v">bar</span>: <span class="pl-k">String</span>, <span class="pl-v">baz</span>: <span class="pl-k">Int</span>)(<span class="pl-v">p</span>: <span class="pl-k">Boolean</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
  debug
}

foo(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>, <span class="pl-c1">42</span>)(<span class="pl-c1">true</span>) <span class="pl-c"><span class="pl-c">//</span> foo(bar=baz, baz=42)(p=true)</span></pre>
  </div> 
  <h2><a id="user-content-embedding-domain-specific-languages" class="anchor" href="https://github.com/lihaoyi/sourcecode#embedding-domain-specific-languages" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Embedding Domain-Specific Languages</h2> 
  <p>The Scala programming is a popular choice to embed domain-specific languages: that means that you start with some external language, e.g. this <a href="http://www.slideshare.net/gerferra/an-embedded-dsl-to-manipulate-mathprog-mixed-integer-programming-models-within-scala" target="_blank">MathProg</a> example</p> 
  <div class="highlight highlight-source-scala">
   <pre>param m;
param n;
param l;

set <span class="pl-en">I</span> <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> .. m;
set <span class="pl-en">J</span> <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> .. n;
set <span class="pl-en">K</span> <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> .. l;

param c{<span class="pl-en">J</span>};
param d{<span class="pl-en">K</span>};
param a{<span class="pl-en">I</span>, <span class="pl-en">J</span>};

<span class="pl-k">var</span> <span class="pl-en">x</span>{<span class="pl-en">J</span>} integer, <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>;
<span class="pl-k">var</span> <span class="pl-en">y</span>{<span class="pl-en">K</span>} <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>;</pre>
  </div> 
  <p>The linked slides has more detail about what exactly this language does (it describes mathematical optimization problems). For a variety of reasons, you may prefer to write this as part of a Scala program instead: for example you may want Scala's IDE support, or its ability to define functions that help reduce boilerplate, or maybe you like the way the compiler provides type errors when you do the wrong thing.</p> 
  <p>A first attempt at converting this to Scala may look like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">m</span> <span class="pl-k">=</span> param(<span class="pl-s"><span class="pl-pds">"</span>m<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">n</span> <span class="pl-k">=</span> param(<span class="pl-s"><span class="pl-pds">"</span>n<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> param(<span class="pl-s"><span class="pl-pds">"</span>l<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">I</span> <span class="pl-k">=</span> set(<span class="pl-s"><span class="pl-pds">"</span>I<span class="pl-pds">"</span></span>) <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> to m
<span class="pl-k">val</span> <span class="pl-en">J</span> <span class="pl-k">=</span> set(<span class="pl-s"><span class="pl-pds">"</span>J<span class="pl-pds">"</span></span>) <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> to m
<span class="pl-k">val</span> <span class="pl-en">K</span> <span class="pl-k">=</span> set(<span class="pl-s"><span class="pl-pds">"</span>K<span class="pl-pds">"</span></span>) <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> to m

<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> param(<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>, <span class="pl-en">J</span>)
<span class="pl-k">val</span> <span class="pl-en">d</span> <span class="pl-k">=</span> param(<span class="pl-s"><span class="pl-pds">"</span>d<span class="pl-pds">"</span></span>, <span class="pl-en">K</span>)
<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> param(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-en">I</span>, <span class="pl-en">J</span>)

<span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> xvar(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>, <span class="pl-en">J</span>).integer <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>
<span class="pl-k">val</span> <span class="pl-en">y</span> <span class="pl-k">=</span> xvar(<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>, <span class="pl-en">K</span>) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span></pre>
  </div> 
  <p>There's a bunch of duplication around the names of the <code>val</code>s: each <code>val</code> has its name repeated in a string that gets passed to the expression on the right. This is for the program to use the name of the <code>val</code> later: for example when printing error messages, or the results of the computation, you want to see which <code>val</code>s are involved! Thus you end up duplicating the names over and over and over.</p> 
  <p>With sourcecode, you can easily define <code>param</code> <code>set</code> and <code>xvar</code> as taking implicit <code>sourcecode.Name</code>s, thus eliminating all the boilerplate involved in duplicating names:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">m</span> <span class="pl-k">=</span> param
<span class="pl-k">val</span> <span class="pl-en">n</span> <span class="pl-k">=</span> param
<span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> param

<span class="pl-k">val</span> <span class="pl-en">I</span> <span class="pl-k">=</span> set <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> to m
<span class="pl-k">val</span> <span class="pl-en">J</span> <span class="pl-k">=</span> set <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> to m
<span class="pl-k">val</span> <span class="pl-en">K</span> <span class="pl-k">=</span> set <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">1</span> to m

<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> param(<span class="pl-en">J</span>)
<span class="pl-k">val</span> <span class="pl-en">d</span> <span class="pl-k">=</span> param(<span class="pl-en">K</span>)
<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> param(<span class="pl-en">I</span>, <span class="pl-en">J</span>)

<span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> xvar(<span class="pl-en">J</span>).integer <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>
<span class="pl-k">val</span> <span class="pl-en">y</span> <span class="pl-k">=</span> xvar(<span class="pl-en">K</span>) <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span></pre>
  </div> 
  <p>The popular <a href="http://www.lihaoyi.com/fastparse/" target="_blank">FastParse</a> parser-combinator library uses sourcecode for exactly this use case</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">fastparse.all.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">A</span> <span class="pl-k">=</span> <span class="pl-en">P</span>( <span class="pl-s"><span class="pl-pds">"</span>aa<span class="pl-pds">"</span></span> )
<span class="pl-k">val</span> <span class="pl-en">B</span> <span class="pl-k">=</span> <span class="pl-en">P</span>( <span class="pl-s"><span class="pl-pds">"</span>bb<span class="pl-pds">"</span></span> )
<span class="pl-k">val</span> <span class="pl-en">C</span> <span class="pl-k">=</span> <span class="pl-en">P</span>( (<span class="pl-en">A</span> <span class="pl-k">|</span> <span class="pl-en">B</span>).rep(<span class="pl-c1">1</span>) )

<span class="pl-en">C</span>.parse(<span class="pl-s"><span class="pl-pds">"</span>aabb<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> Success((), 4)</span>
<span class="pl-en">C</span>.parse(<span class="pl-s"><span class="pl-pds">"</span>X<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> Failure((A | B):1:1 ..."X")</span></pre>
  </div> 
  <p>As you can see, the names of the rules <code>A</code> and <code>B</code> are embedded in the error messages for parse failures. This makes debugging parsers far easier, while saving you the effort of duplicating the name of the parser in possibly hundreds of rules in a large parser. In this case, it is the <code>P(...)</code> function which takes an implicit <code>sourcecode.Name</code> that does this work:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">P</span>[<span class="pl-en">T</span>](<span class="pl-v">p</span>: <span class="pl-k">=&gt;</span> <span class="pl-en">Parser</span>[<span class="pl-en">T</span>])(<span class="pl-k">implicit</span> <span class="pl-v">name</span>: sourcecode.<span class="pl-en">Name</span>)<span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span>
    parsers.<span class="pl-en">Combinators</span>.<span class="pl-en">Rule</span>(name.value, () <span class="pl-k">=&gt;</span> p)</pre>
  </div> 
  <p>And forwards the name on to the actual <code>Rule</code> object, which can make use of it in its <code>.toString</code> method.</p> 
  <h1><a id="user-content-version-history" class="anchor" href="https://github.com/lihaoyi/sourcecode#version-history" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Version History</h1> 
  <h2><a id="user-content-013" class="anchor" href="https://github.com/lihaoyi/sourcecode#013" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.3</h2> 
  <ul> 
   <li>Add scala 2.12.x support, thanks to <a href="https://github.com/larsrh" target="_blank">Lars Hupel</a></li> 
  </ul> 
  <h2><a id="user-content-012" class="anchor" href="https://github.com/lihaoyi/sourcecode#012" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.2</h2> 
  <ul> 
   <li> <p>Add <code>sourcecode.Args</code> implicit, which can be used to capture debugging information about the nearest enclosing function call for logging/debugging, thanks to <a href="https://github.com/benhag" target="_blank">Benjamin Hagemeister</a></p> </li> 
   <li> <p>Attempted fix for <a href="https://github.com/lihaoyi/sourcecode/issues/17" target="_blank">#17</a> and <a href="https://github.com/lihaoyi/sourcecode/issues/13" target="_blank">#13</a>, thanks to <a href="https://github.com/metasim" target="_blank">Simeon H.K. Fitch</a></p> </li> 
  </ul> 
  <h2><a id="user-content-011" class="anchor" href="https://github.com/lihaoyi/sourcecode#011" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.1</h2> 
  <ul> 
   <li> <p>Ignore <code>&lt;local foo&gt;</code> and <code>&lt;init&gt;</code> symbols when determining <code>sourcecode.Name</code>, <code>sourcecode.FullName</code> or <code>sourcecode.Enclosing</code>. If you want these, use the <code>sourcecode.Name.Machine</code>/<code>sourcecode.FullName.Machine</code>/<code>sourcecode.Enclosing.Machine</code> implicits instead.</p> </li> 
   <li> <p>Add <code>sourcecode.Text</code> implicit to capture source code of an expression</p> </li> 
   <li> <p>Add implicit conversions to <code>sourcecode.*</code>, so you can pass in a <code>String</code> to manually satisfy and implicit wanting a <code>sourcecode.Name</code> or <code>sourcecode.FullName</code> or <code>sourcecode.File</code>, an <code>Int</code> to satisfy an implicit asking for <code>sourcecode.Line</code></p> </li> 
   <li> <p><code>sourcecode.Enclosing</code> has been simplified to take a single <code>String</code> rather than the previous <code>Vector[Chunk]</code>.</p> </li> 
   <li> <p>Added the <code>sourcecode.Pkg</code> implicit, which provides the current enclosing package without any of the <code>class</code>s/<code>object</code>s/<code>def</code>s/etc.. Can be subtracted from <code>sourcecode.Enclosing</code> if you <em>only</em> want the <code>class</code>s/<code>object</code>s/<code>def</code>s/etc.</p> </li> 
  </ul> 
  <h2><a id="user-content-010" class="anchor" href="https://github.com/lihaoyi/sourcecode#010" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.0</h2> 
  <ul> 
   <li>First release</li> 
  </ul> 
 </article>
</div>