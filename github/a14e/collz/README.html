<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/a14e/collz" target="_blank"><img src="https://camo.githubusercontent.com/38dbe1b36d0208c27128deb187c1d08d98640806/68747470733a2f2f7472617669732d63692e6f72672f613134652f636f6c6c7a2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/a14e/collz.svg?branch=master" style="max-width:100%;"></a></p> 
  <p><a href="https://codecov.io/gh/a14e/collz?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/ab04a0ff4fd71b022e815de96f8ba3eb89a9ad39/68747470733a2f2f636f6465636f762e696f2f67682f613134652f636f6c6c7a2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="https://codecov.io/gh/a14e/collz/coverage.svg?branch=master" style="max-width:100%;"></a></p> 
  <h1><a id="user-content-collz" class="anchor" href="https://github.com/a14e/collz#collz" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Collz</h1> 
  <p>Custom Scala Collections</p> 
  <p>TODO english docs in few months</p> 
  <h2><a id="user-content-Библиотека-коллекций-для-scala" class="anchor" href="https://github.com/a14e/collz#Библиотека-коллекций-для-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Библиотека коллекций для Scala</h2> 
  <p>Библиотека коллекций, которых может недоставать в стандартной библиотеке Scala. Пока находится в разработке и будет готова в течении нескольких месяцев. В данный момент содержит следующие коллекции:</p> 
  <ol> 
   <li> <p>Мутабельные:</p> 
    <ol> 
     <li>VList</li> 
     <li>BoundedQueue</li> 
     <li>IntMap</li> 
     <li>IntSet</li> 
     <li>PrefixMap</li> 
     <li>PrefixSet</li> 
    </ol> </li> 
   <li> <p>Иммутабельные:</p> 
    <ol> 
     <li>BoundedQueue</li> 
     <li>BoundedBucketQueue</li> 
     <li>Router</li> 
    </ol> </li> 
  </ol> 
  <h1><a id="user-content-Использование" class="anchor" href="https://github.com/a14e/collz#Использование" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Использование</h1> 
  <p>Библиотека собрана для версий 2.11.8 и 2.12.1 Для подключения библиотки добавьте себе в .sbt файл строку</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.a14e<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>collz<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <h2><a id="user-content-Описание-реализаций" class="anchor" href="https://github.com/a14e/collz#Описание-реализаций" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Описание реализаций</h2> 
  <p>Все мутабельные коллекции не являются потокобезопасными</p> 
  <h3><a id="user-content--vlist" class="anchor" href="https://github.com/a14e/collz#-vlist" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-vlist" target="_blank" href=""></a> VList</h3> 
  <p>Класс как возможная альтернатива ListBuffer или ArrayBuffer. В отличие от ListBuffer имеет быстрый доступ к элементам по индексу и более эффективное использование памяти, а в отличие от ArrayBuffer позволяет добавлять элементы в конец без перестроения всего массива.</p> 
  <p>Реализован как VList c одним изменением: список из подмассивов заменен на массив с буффером, что позволило несколько упростить реализацию и добавить эффективно реализовать итерации в прямом и обратном направлениях. Сложность добавления в конец O(log(log(n))), что примерно ~O(1). Скорость обращения по индексу в худшем случае (для индекса 0) - O(log(n)), но в большинстве случаев - O(1), так как 50% ... 75% индексов содержатся в 2х последних подмассивах.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.mut.</span><span class="pl-v">VList</span>

<span class="pl-k">val</span> <span class="pl-en">list</span> <span class="pl-k">=</span> <span class="pl-en">VList</span>[<span class="pl-k">Int</span>](<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
list <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">//</span> list == VList(1, 2, 3, 1)</span>
list <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> list == VList(1, 2, 3, 1, 2, 3)</span>
<span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> list(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> x == 2</span>

<span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
list.foreach(sum <span class="pl-k">+</span><span class="pl-k">=</span> _) <span class="pl-c"><span class="pl-c">//</span> sum == 12</span></pre>
  </div> 
  <h3><a id="user-content--boundedqueue" class="anchor" href="https://github.com/a14e/collz#-boundedqueue" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-fixed_queue" target="_blank" href=""></a> BoundedQueue</h3> 
  <p>Представляет собой очередь типа FIFO с фиксированным размером. Новые элементы добавляются в конец методами push, pushAll, :+ и тд. Элементы из очереди извлекаются и удаляются из начала вызовами методов pull. При превышении размера удаляются элементы из начала. Реализована с быстрым добавлением в конец и извлечением из начала без перестроения всей очереди. Также реализовано с очень быстрым доступом по индексу и быстрыми итерациями по очереди.</p> 
  <p>Внутри реализовано с помощью двух массивов с размером, равным размеру очереди. В первом массиве есть указатели на начало и конец очереди, а во втором массиве только указатель на конец. (тут указателем называется номер индекса). При перепонии первого моссива начинает заполнятся второй. При превышении размера или извлечении элементов из учереди методом pull смещается указатель на начало очереди и место извдеченного элемента заполняется null, чтобы помочь сборщику мусора. Когда место во втором массиве заканчивается или указатель на начало во втором массиве доходит до конца, тогда второй массив заменяет собой первый.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.mut.</span><span class="pl-v">BoundedQueue</span>

<span class="pl-k">val</span> <span class="pl-en">queue</span> <span class="pl-k">=</span> <span class="pl-en">BoundedQueue</span>[<span class="pl-k">Int</span>](<span class="pl-c1">2</span>)
queue <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">//</span> queue == BoundedQueue(1)</span>
queue <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">//</span> queue == BoundedQueue(1, 2)</span>
queue <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">3</span> <span class="pl-c"><span class="pl-c">//</span> queue == BoundedQueue(2, 3)</span>

<span class="pl-k">val</span> <span class="pl-en">x1</span> <span class="pl-k">=</span> queue.pull() <span class="pl-c"><span class="pl-c">//</span> x1 == 2, queue == BoundedQueue(3)</span>
<span class="pl-k">val</span> <span class="pl-en">x2</span> <span class="pl-k">=</span> queue.pull() <span class="pl-c"><span class="pl-c">//</span> x2 == 3, queue == BoundedQueue()</span>

queue <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> queue == BoundedQueue(2, 3)</span>
<span class="pl-k">val</span> <span class="pl-en">x3</span> <span class="pl-k">=</span> queue(<span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">//</span> x3 == 2</span>
<span class="pl-k">val</span> <span class="pl-en">x4</span> <span class="pl-k">=</span> queue(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> x4 == 3</span>

<span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
queue.foreach(sum <span class="pl-k">+</span><span class="pl-k">=</span> _) <span class="pl-c"><span class="pl-c">//</span> sum === 5</span></pre>
  </div> 
  <p>иммутабельные реализованы схожим образом. Только вместо массивов используется класс Vector</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.immut.</span><span class="pl-v">BoundedQueue</span>

<span class="pl-k">val</span> <span class="pl-en">queue0</span> <span class="pl-k">=</span> <span class="pl-en">BoundedQueue</span>[<span class="pl-k">Int</span>](<span class="pl-c1">2</span>)
<span class="pl-k">val</span> <span class="pl-en">queue1</span> <span class="pl-k">=</span>  queue0 <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">//</span> queue1 == BoundedQueue(1)</span>
<span class="pl-k">val</span> <span class="pl-en">queue2</span> <span class="pl-k">=</span>  queue1 <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">//</span> queue2 == BoundedQueue(1, 2)</span>
<span class="pl-k">val</span> <span class="pl-en">queue3</span> <span class="pl-k">=</span>  queue1 <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">3</span> <span class="pl-c"><span class="pl-c">//</span> queue3 == BoundedQueue(2, 3)</span>

<span class="pl-k">val</span> (queue4, x1) <span class="pl-k">=</span> queue3.pull() <span class="pl-c"><span class="pl-c">//</span> x1 == 2, queue4 == BoundedQueue(3)</span>
<span class="pl-k">val</span> (queue5, x2) <span class="pl-k">=</span> queue4.pull() <span class="pl-c"><span class="pl-c">//</span> x2 == 3, queue5 == BoundedQueue()</span>

<span class="pl-k">val</span> <span class="pl-en">queue6</span> <span class="pl-k">=</span> queue5 <span class="pl-k">:</span><span class="pl-k">++</span> <span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> BoundedQueue(2, 3)</span>
<span class="pl-k">val</span> <span class="pl-en">x3</span> <span class="pl-k">=</span> queue6(<span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">//</span> x3 == 2</span>
<span class="pl-k">val</span> <span class="pl-en">x4</span> <span class="pl-k">=</span> queue6(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> x4 == 3</span>

<span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
queue6.foreach(sum <span class="pl-k">+</span><span class="pl-k">=</span> _) <span class="pl-c"><span class="pl-c">//</span> sum === 5</span></pre>
  </div> 
  <p>В иммутабельной версии часть элементов после pull() может скрыто оставаться в коллекции, стоит помнить об этом во избежание утечек памяти.</p> 
  <h3><a id="user-content--intmap" class="anchor" href="https://github.com/a14e/collz#-intmap" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-int_map" target="_blank" href=""></a> IntMap</h3> 
  <p>В стандартной библиотеке Scala есть эффективная неизменяемая реализация IntMap. Тут же преставлена эффективная изменяемая реализация.</p> 
  <p>Выполнена как префиксное дерево, в каждом узле которого до 16 ветвей, номер ветви определяется как key &amp; F, при увеличении глубины ключ сдвигается на 4 бита вправо. Очень близка к иммутабельной реазации HashMap, но имеет сильно более простую реализацию и несколько лучшую производительность при поиске и добавлении элементов.</p> 
  <p>При поиске по элементу бенчмарки большой разницы по сравнению из мутабельными AnyRefMap, HashMap и тд. Но скорость добавления и удаления элементов может быть в 4-8 раз быстрее. Сложность операций добавления, удаления, поиска по ключу имеет вид O(log16(n))</p> 
  <p>Недостатком данной реализации из-за использование массивов по 16 является более высокий расход памяти и более медленные итерации по коллеции.</p> 
  <p>Ключи или значения null недопустимы</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.mut.</span><span class="pl-v">IntMap</span>
<span class="pl-k">val</span> <span class="pl-en">map</span> <span class="pl-k">=</span> <span class="pl-en">IntMap</span>[<span class="pl-k">Int</span>](<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">3</span>, <span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>) <span class="pl-c"><span class="pl-c">//</span> IntMap(1 -&gt; 1, 2 -&gt; 2)</span>

<span class="pl-k">val</span> <span class="pl-en">x1</span> <span class="pl-k">=</span> map.get(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> x1 == Some(3)</span>
<span class="pl-k">val</span> <span class="pl-en">x2</span> <span class="pl-k">=</span> map.get(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> x2 == Some(4)</span>

<span class="pl-k">val</span> <span class="pl-en">x3</span> <span class="pl-k">=</span> map.get(<span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">//</span> x3 == None</span>
<span class="pl-k">val</span> <span class="pl-en">x4</span> <span class="pl-k">=</span> map.get(<span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> x4 == None</span>


map(<span class="pl-c1">1</span>) <span class="pl-k">=</span> <span class="pl-c1">5</span> <span class="pl-c"><span class="pl-c">//</span> map == IntMap(1 -&gt; 5, 2 -&gt; 2)</span>

map(<span class="pl-c1">6</span>) <span class="pl-k">=</span> <span class="pl-c1">7</span> <span class="pl-c"><span class="pl-c">//</span> map == IntMap(1 -&gt; 5, 2 -&gt; 2, 6 -&gt; 7)</span>

<span class="pl-k">val</span> <span class="pl-en">x5</span> <span class="pl-k">=</span> map.contains(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> x5 == true</span>
map <span class="pl-k">-</span><span class="pl-k">=</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">//</span> map == IntMap(1 -&gt; 5, 6 -&gt; 7)</span>
<span class="pl-k">val</span> <span class="pl-en">x6</span> <span class="pl-k">=</span> map.contains(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> x6 == false</span>

<span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
map.foreach{ <span class="pl-k">case</span> (key, value) <span class="pl-k">=&gt;</span> sum <span class="pl-k">+</span><span class="pl-k">=</span> value } <span class="pl-c"><span class="pl-c">//</span> sum == 12</span>

map.clear() <span class="pl-c"><span class="pl-c">//</span> map = IntMap()</span></pre>
  </div> 
  <h3><a id="user-content--intset" class="anchor" href="https://github.com/a14e/collz#-intset" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-int_map" target="_blank" href=""></a> IntSet</h3> 
  <p>Реализация mutable.Set[_], оптимизированная для работы с Int. Сделана на базе префиксных деревьев. Представляет собой легкую обертку поверх IntMap.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.mut.</span><span class="pl-v">IntSet</span>
<span class="pl-k">val</span> <span class="pl-en">set</span> <span class="pl-k">=</span> <span class="pl-en">IntSet</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>) <span class="pl-c"><span class="pl-c">//</span> IntSet(1, 2, 3, 4)</span>

<span class="pl-k">val</span> <span class="pl-en">res1</span> <span class="pl-k">=</span> set.contains(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span>res1 == true</span>
<span class="pl-k">val</span> <span class="pl-en">res2</span> <span class="pl-k">=</span> set.contains(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span>res2 == true</span>
<span class="pl-k">val</span> <span class="pl-en">res3</span> <span class="pl-k">=</span> set.contains(<span class="pl-c1">6</span>) <span class="pl-c"><span class="pl-c">//</span>res3 == false</span>

set <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">6</span> <span class="pl-c"><span class="pl-c">//</span> set == IntSet(1, 2, 3, 4, 6)</span>
<span class="pl-k">val</span> <span class="pl-en">res4</span> <span class="pl-k">=</span> set.contains(<span class="pl-c1">6</span>) <span class="pl-c"><span class="pl-c">//</span>res4 == true</span>

set <span class="pl-k">-</span><span class="pl-k">=</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">//</span> set == IntSet(2, 3, 4, 6)</span>
<span class="pl-k">val</span> <span class="pl-en">res5</span> <span class="pl-k">=</span> set.contains(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span>res5 == false</span>

<span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
set.foreach(sum <span class="pl-k">+</span><span class="pl-k">=</span> _) <span class="pl-c"><span class="pl-c">//</span> sum == 15</span>
</pre>
  </div> 
  <h3><a id="user-content--prefixmap" class="anchor" href="https://github.com/a14e/collz#-prefixmap" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-prefix_map" target="_blank" href=""></a> PrefixMap</h3> 
  <p>Реализация mutable.Map[_, _], оптимизированная для работы со строками. Сделана в виде префиксных деревьев. Для быстрого поиска элемента в узле, каждый узел содержит IntMap, что позволяет получить худшее возможное время поиска мало зависящим от колличества элементов в коллекции, а зависящим только от длинны ключа. Время поиска в худшем случае примерно равно времени поиска в лучшем случае в хэш таблице и разница будет тем больше, чем длиннее ключ. Для длинных строк типа URL с большими общими частями можно получить значительный прирост в скорости по сравнению с хэш таблицей. Также есть возможность эффективно находить все строки, начинающиеся с некоторого префикса и определять существуют ли такие строки.</p> 
  <p>Ключи или значения null недопустимы</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.mut.</span><span class="pl-v">PrefixMap</span>
<span class="pl-k">val</span> <span class="pl-en">map</span> <span class="pl-k">=</span> <span class="pl-en">PrefixMap</span>(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>stringWithSuffix<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>string2<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">3</span>, <span class="pl-s"><span class="pl-pds">"</span>anotherString<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>)
<span class="pl-k">val</span> <span class="pl-en">x1</span> <span class="pl-k">=</span> map.get(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> s1 == Some(1)</span>
<span class="pl-k">val</span> <span class="pl-en">x2</span> <span class="pl-k">=</span> map.get(<span class="pl-s"><span class="pl-pds">"</span>string2<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> s1 == Some(3)</span>
<span class="pl-k">val</span> <span class="pl-en">x3</span> <span class="pl-k">=</span> map.get(<span class="pl-s"><span class="pl-pds">"</span>string3<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> s1 == None</span>

<span class="pl-k">val</span> <span class="pl-en">x4</span> <span class="pl-k">=</span> map.hasPrefix(<span class="pl-s"><span class="pl-pds">"</span>stri<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> x4 == true</span>
<span class="pl-k">val</span> <span class="pl-en">x5</span> <span class="pl-k">=</span> map.hasPrefix(<span class="pl-s"><span class="pl-pds">"</span>unknown<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> x5 == false</span>


<span class="pl-k">val</span> <span class="pl-en">x6</span> <span class="pl-k">=</span> map.findForPrefix(<span class="pl-s"><span class="pl-pds">"</span>stri<span class="pl-pds">"</span></span>).toList 
<span class="pl-c"><span class="pl-c">//</span> x6 == List("string" -&gt; 1, "stringWithSuffix" -&gt; 2, "string2" -&gt; 3)</span>

map <span class="pl-k">-</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span> 
<span class="pl-c"><span class="pl-c">//</span> map == PrefixMap("stringWithSuffix" -&gt; 2, "string2" -&gt; 3, "anotherString" -&gt; 4)</span>
map(<span class="pl-s"><span class="pl-pds">"</span>string3<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> <span class="pl-c1">5</span> 
<span class="pl-c"><span class="pl-c">//</span> map == PrefixMap("stringWithSuffix" -&gt; 2, "string2" -&gt; 3, "anotherString" -&gt; 4, "string3" -&gt; 5)</span></pre>
  </div> 
  <h3><a id="user-content--prefixset" class="anchor" href="https://github.com/a14e/collz#-prefixset" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-prefix_map" target="_blank" href=""></a> PrefixSet</h3> 
  <p>Реализация mutable.Set[_], оптимизированная для работы со строками. Реализована в виде тонкой обертки вокруг PrefixMap.</p> 
  <p>значения null недопустимы</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.mut.</span><span class="pl-v">PrefixSet</span>
<span class="pl-k">val</span> <span class="pl-en">set</span> <span class="pl-k">=</span> <span class="pl-en">PrefixSet</span>(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>stringWithSuffix<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>string2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>anotherString<span class="pl-pds">"</span></span> )
<span class="pl-k">val</span> <span class="pl-en">x1</span> <span class="pl-k">=</span> set.contains(<span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> s1 == true</span>
<span class="pl-k">val</span> <span class="pl-en">x2</span> <span class="pl-k">=</span> set.contains(<span class="pl-s"><span class="pl-pds">"</span>string2<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> s1 == true</span>
<span class="pl-k">val</span> <span class="pl-en">x3</span> <span class="pl-k">=</span> set.contains(<span class="pl-s"><span class="pl-pds">"</span>string3<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> s1 == false</span>

<span class="pl-k">val</span> <span class="pl-en">x4</span> <span class="pl-k">=</span> set.hasPrefix(<span class="pl-s"><span class="pl-pds">"</span>stri<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> x4 == true</span>
<span class="pl-k">val</span> <span class="pl-en">x5</span> <span class="pl-k">=</span> set.hasPrefix(<span class="pl-s"><span class="pl-pds">"</span>unknown<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> x5 == false</span>


<span class="pl-k">val</span> <span class="pl-en">x6</span> <span class="pl-k">=</span> set.findForPrefix(<span class="pl-s"><span class="pl-pds">"</span>stri<span class="pl-pds">"</span></span>).toList 
<span class="pl-c"><span class="pl-c">//</span> x6 == List("string", "stringWithSuffix", "string2")</span>

set <span class="pl-k">-</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span> 
<span class="pl-c"><span class="pl-c">//</span> set == PrefixSet("stringWithSuffix", "string2", "anotherString")</span>
set <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string3<span class="pl-pds">"</span></span>
<span class="pl-c"><span class="pl-c">//</span> set == PrefixSet("stringWithSuffix", "string2", "anotherString", "string3")</span></pre>
  </div> 
  <h3><a id="user-content-boundedbucketqueue" class="anchor" href="https://github.com/a14e/collz#boundedbucketqueue" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>BoundedBucketQueue</h3> 
  <p>В целом очень похож на BoundedQueue, но не удаляет прошлые значения, а сохраняет их в корзине (bucket), которая заполняется по принцыпу стека</p> 
  <p>так как коллекция состояит из 2 подколлекций, то не имеет смысла ей наследовать разного рода Iterable[_] и тд. Поэтому для доступа к итерациям нужно сначала вызвать методы queue или bucket</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.immut.</span><span class="pl-v">BoundedBucketQueue</span>

<span class="pl-k">val</span> <span class="pl-en">queue0</span> <span class="pl-k">=</span> <span class="pl-en">BoundedBucketQueue</span>[<span class="pl-k">Int</span>](<span class="pl-c1">2</span>)
<span class="pl-k">val</span> <span class="pl-en">queue1</span> <span class="pl-k">=</span>  queue0 <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">//</span> queue1.queue == BoundedQueue(1) и queue1.bucket == Nil</span>
<span class="pl-k">val</span> <span class="pl-en">queue2</span> <span class="pl-k">=</span>  queue1 <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">2</span> <span class="pl-c"><span class="pl-c">//</span> queue2.queue == BoundedQueue(1, 2) и queue1.bucket == Nil</span>
<span class="pl-k">val</span> <span class="pl-en">queue3</span> <span class="pl-k">=</span>  queue1 <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">3</span> <span class="pl-c"><span class="pl-c">//</span> queue3.queue == BoundedQueue(2, 3) и queue1.bucket == List(1)</span>

<span class="pl-k">val</span> (queue4, x1) <span class="pl-k">=</span> queue3.pull() <span class="pl-c"><span class="pl-c">//</span> x1 == 2, queue4 == BoundedQueue(3) и queue1.bucket == List(1)</span>
<span class="pl-k">val</span> (queue5, x2) <span class="pl-k">=</span> queue4.pull() <span class="pl-c"><span class="pl-c">//</span> x2 == 3, queue5 == BoundedQueue() и queue1.bucket == List(1)</span>

<span class="pl-k">val</span> <span class="pl-en">queue6</span> <span class="pl-k">=</span> queue5 <span class="pl-k">:</span><span class="pl-k">++</span> <span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>) <span class="pl-c"><span class="pl-c">//</span> queue == BoundedQueue(2, 3) и queue1.bucket == List(1, 1)</span>
<span class="pl-k">val</span> <span class="pl-en">x3</span> <span class="pl-k">=</span> queue6(<span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">//</span> x3 == 2</span>
<span class="pl-k">val</span> <span class="pl-en">x4</span> <span class="pl-k">=</span> queue6(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> x4 == 3</span>
</pre>
  </div> 
  <h3><a id="user-content-router" class="anchor" href="https://github.com/a14e/collz#router" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Router</h3> 
  <p>Простой класс для роутинга. Нужен для случайного выбора из входящих элементов по некоторому ключу. Ключем может быть любой наследник Any. Элементы будут выбиратся примерно случайно, но однозначно для каждого ключа. Независимо от порядка добавления роутинг будет однозначным. Но при изменении даже на 1 элемент распределение по ключам может сильно изменится.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">a14e.collz.immut.</span><span class="pl-v">Router</span>


<span class="pl-k">val</span> <span class="pl-en">router</span> <span class="pl-k">=</span> <span class="pl-en">Router</span>(<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:2222<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:2223<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>127.0.0.1:2224<span class="pl-pds">"</span></span>)


<span class="pl-k">val</span> <span class="pl-en">id1</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>
<span class="pl-k">val</span> <span class="pl-en">id2</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>
<span class="pl-k">val</span> <span class="pl-en">id3</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>

router.route(id1) <span class="pl-c"><span class="pl-c">//</span> 127.0.0.1:2223</span>
router.route(id2) <span class="pl-c"><span class="pl-c">//</span> 127.0.0.1:2224</span>
router.route(id3) <span class="pl-c"><span class="pl-c">//</span> 127.0.0.1:2222</span>

</pre>
  </div> 
  <h2><a id="user-content-Сборка-из-исходных-кодов" class="anchor" href="https://github.com/a14e/collz#Сборка-из-исходных-кодов" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Сборка из исходных кодов</h2> 
  <p>Проект собирается для scala 2.11.8 и 2.12.1</p> 
  <p>скопировать исходники:<br> $ git clone <a href="https://github.com/a14e/collz.git" target="_blank">https://github.com/a14e/collz.git</a><br> $ cd collz<br> собрать:<br> $ sbt update<br> $ sbt +test<br> $ sbt +package<br> взять .jar из папки traget</p> 
  <h2><a id="user-content-roadmap" class="anchor" href="https://github.com/a14e/collz#roadmap" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Roadmap</h2> 
  <ol> 
   <li>Сделать нормальную документацию на англ языке (English docs)</li> 
   <li>Добавить новые коллекции 
    <ol> 
     <li>иммутабельные:<br> a. IntervalMap</li> 
    </ol> </li> 
   <li>Добавить бенчмарки в репозиторий</li> 
  </ol> 
 </article>
</div>