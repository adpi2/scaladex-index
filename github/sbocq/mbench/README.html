<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/sbocq/mbench#mbench" aria-hidden="true" class="anchor" id="user-content-mbench" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>mbench</h1> 
  <p>A benchmarking library for the JVM with a Gnuplot backend.</p> 
  <ul> 
   <li><a href="https://github.com/sbocq/mbench#main-features" target="_blank">Main Features</a></li> 
   <li><a href="https://github.com/sbocq/mbench#examples" target="_blank">Examples</a> 
    <ul> 
     <li><a href="https://github.com/sbocq/mbench#loops" target="_blank">Loops</a></li> 
     <li><a href="https://github.com/sbocq/mbench#parallel-loops" target="_blank">Parallel Loops</a></li> 
     <li><a href="https://github.com/sbocq/mbench#maps" target="_blank">Maps</a></li> 
    </ul> </li> 
   <li><a href="https://github.com/sbocq/mbench#installing" target="_blank">Installing</a></li> 
   <li><a href="https://github.com/sbocq/mbench#building-from-sources" target="_blank">Building From Sources</a></li> 
   <li><a href="https://github.com/sbocq/mbench#running-the-examples" target="_blank">Running The Examples</a></li> 
   <li><a href="https://github.com/sbocq/mbench#sample-sbt-project-file" target="_blank">Sample SBT Project File</a></li> 
   <li><a href="https://github.com/sbocq/mbench#projects-using-mbench" target="_blank">Projects Using Mbench</a></li> 
  </ul> 
  <h2><a href="https://github.com/sbocq/mbench#main-features" aria-hidden="true" class="anchor" id="user-content-main-features" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Main Features</h2> 
  <ul> 
   <li><strong>Simple setup</strong>. The library executes benchmarks in isolation from each other by cloning the current VM programmatically. Multiple benchmarks can then be launched directly from a main class, like any regular application, without the need to setup an additional build or script environment.</li> 
   <li><strong>Customizable results</strong>. The default benchmark definition produces the inputs passed to a test, the median execution time of the test for every input, and the coefficient of variation obtained for several runs, as columns in a table. This definition can be augmented programmatically with application specific columns (e.g. parallel speedup or throughput) that are computed in realtime using previous results, the current input of a test and/or its configuration parameters.</li> 
   <li><strong>Comparison friendly</strong>. To ease comparisons, the same benchmark definition can be reused to evaluate multiple tests in different configurations. The Gnuplot backend saves these results in separate '.dat' files and features an API to generate Gnuplot scripts that aggregate multiple results on a single plot.</li> 
  </ul> 
  <h2><a href="https://github.com/sbocq/mbench#examples" aria-hidden="true" class="anchor" id="user-content-examples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples</h2> 
  <p>The examples below are taken from the <code>mbench-benchmarks</code> project. All the benchmarks where run on a 24-cores (2200MHz each) Opteron server configured with Linux 3.8.6 and the realtime preemption patch, running Scala 2.9.3, with the following JVM flags: <code>-server</code> <code>-XX:+UseNUMA</code> <code>-XX:+UseCondCardMark</code> <code>-Xss1M</code> <code>-XX:MaxPermSize=128m</code> <code>-XX:+UseParallelGC</code> <code>-XX:+DoEscapeAnalysis</code> <code>-Xms1024m</code> <code>-Xmx1024m</code>.</p> 
  <p>The '.dat' files and the gnuplot files generated by the tool for these examples can be found in the <code>gallery</code> directory.</p> 
  <p>The latest API documentation is available online <a href="http://sbocq.github.io/mbench" target="_blank">here</a>.</p> 
  <h3><a href="https://github.com/sbocq/mbench#loops" aria-hidden="true" class="anchor" id="user-content-loops" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Loops</h3> 
  <p>The following benchmark compares the performance of several loops for different number of iterations.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Loops</span> {

  <span class="pl-k">def</span> <span class="pl-en">testWhile</span>(<span class="pl-v">cycles</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    <span class="pl-k">var</span> <span class="pl-en">ary</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Array</span>[<span class="pl-k">Int</span>](<span class="pl-c1">16</span>)
    <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> cycles) {
      ary(i &amp; <span class="pl-c1">0xF</span>) <span class="pl-k">=</span> i
      i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
    }
    println(ary(<span class="pl-c1">0</span>) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> ary(<span class="pl-c1">1</span>))
  }

  <span class="pl-k">def</span> <span class="pl-en">testFor</span>(<span class="pl-v">cycles</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    <span class="pl-k">var</span> <span class="pl-en">ary</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Array</span>[<span class="pl-k">Int</span>](<span class="pl-c1">16</span>)
    <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">0</span> until cycles) {
      ary(i &amp; <span class="pl-c1">0xF</span>) <span class="pl-k">=</span> i
    }
    println(ary(<span class="pl-c1">0</span>) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> ary(<span class="pl-c1">1</span>))
  }

  <span class="pl-k">def</span> <span class="pl-en">testWhileNew</span>(<span class="pl-v">cycles</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Box</span>(<span class="pl-v">i</span>: <span class="pl-k">Int</span>)
    <span class="pl-k">var</span> <span class="pl-en">ary</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Array</span>[<span class="pl-en">Box</span>](<span class="pl-c1">16</span>)
    <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> cycles) {
      ary(i &amp; <span class="pl-c1">0xF</span>) <span class="pl-k">=</span> <span class="pl-en">Box</span>(i)
      i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
    }
    println(ary(<span class="pl-c1">0</span>) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> ary(<span class="pl-c1">1</span>))
  }

  <span class="pl-k">import</span> <span class="pl-v">mbench.benchmark.</span><span class="pl-v">_</span>
  <span class="pl-k">import</span> <span class="pl-v">mbench.gnuplot.</span><span class="pl-v">_</span>

  <span class="pl-k">val</span> <span class="pl-en">input</span> <span class="pl-k">=</span> (<span class="pl-c1">1</span> to <span class="pl-c1">3</span>) map (_ <span class="pl-k">*</span> <span class="pl-c1">5000000</span>)
  <span class="pl-k">val</span> <span class="pl-en">cycles</span> <span class="pl-k">=</span> <span class="pl-en">Label</span>[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>cycles<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">throughput</span> <span class="pl-k">=</span> <span class="pl-en">Column</span>.throughput(cycles)

  <span class="pl-k">val</span> <span class="pl-en">benchmark</span> <span class="pl-k">=</span> <span class="pl-en">Benchmark</span>(<span class="pl-s"><span class="pl-pds">"</span>loops<span class="pl-pds">"</span></span>, input, cycles, warmups <span class="pl-k">=</span> <span class="pl-c1">2</span>, runs <span class="pl-k">=</span> <span class="pl-c1">5</span>).add(throughput)

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {

    <span class="pl-k">val</span> <span class="pl-en">tests</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(
      <span class="pl-en">Test</span>.input(<span class="pl-s"><span class="pl-pds">"</span>while<span class="pl-pds">"</span></span>, testWhile),
      <span class="pl-en">Test</span>.input(<span class="pl-s"><span class="pl-pds">"</span>for<span class="pl-pds">"</span></span>, testFor),
      <span class="pl-en">Test</span>.input(<span class="pl-s"><span class="pl-pds">"</span>while-new<span class="pl-pds">"</span></span>, testWhileNew)
    )

    <span class="pl-k">val</span> <span class="pl-en">datFiles</span> <span class="pl-k">=</span> tests.map(benchmark(_))

    <span class="pl-k">val</span> <span class="pl-en">plots</span> <span class="pl-k">=</span> <span class="pl-en">Gnuplot</span>(datFiles)
    <span class="pl-en">Gnuplot</span>.save(plots)

  }
}</pre>
  </div> 
  <p>The following plots will be automatically generated. If we look at the time plot, as expected, we see that the time increases with the number of cycles.</p> 
  <p><a href="https://camo.githubusercontent.com/8533dfafa90bd699b18f3090ef31150906327079/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6c6f6f70732f6c6f6f707325323574696d652e706e67" target="_blank"><img src="https://camo.githubusercontent.com/8533dfafa90bd699b18f3090ef31150906327079/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6c6f6f70732f6c6f6f707325323574696d652e706e67" alt="loops%time.plt" data-canonical-src="https://raw.github.com/sbocq/mbench/master/gallery/loops/loops%25time.png" style="max-width:100%;"></a></p> 
  <p>However, this does not tell us if the time increases linearly with the number of cycles. This is why generating a second plot of the throughput against the number of cycles is interesting. According to the figure below, we can see that, as expected for this high number of iterations, the number of cycles per second is independent from the number of cycles.</p> 
  <p><a href="https://camo.githubusercontent.com/f0dc61bdd0dfe0bff1ea02491d17e082e158a371/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6c6f6f70732f6c6f6f70732532357468726f7567687075742e706e67" target="_blank"><img src="https://camo.githubusercontent.com/f0dc61bdd0dfe0bff1ea02491d17e082e158a371/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6c6f6f70732f6c6f6f70732532357468726f7567687075742e706e67" alt="loops%throughput.plt" data-canonical-src="https://raw.github.com/sbocq/mbench/master/gallery/loops/loops%25throughput.png" style="max-width:100%;"></a></p> 
  <h3><a href="https://github.com/sbocq/mbench#parallel-loops" aria-hidden="true" class="anchor" id="user-content-parallel-loops" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parallel Loops</h3> 
  <p>The benchmark below measures how well executing these loops in parallel scales with the number of threads on our 24-cores server.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">ParaLoops</span> {

  <span class="pl-k">import</span> <span class="pl-v">mbench.benchmark.</span><span class="pl-v">_</span>
  <span class="pl-k">import</span> <span class="pl-v">mbench.gnuplot.</span><span class="pl-v">_</span>

  <span class="pl-k">import</span> <span class="pl-v">java.util.concurrent.</span>{ <span class="pl-v">ExecutorService</span>, <span class="pl-v">Executors</span> }

  <span class="pl-c"><span class="pl-c">/*</span> The benchmark will be configured using an executor as runtime configuration </span>
<span class="pl-c">   * and a number of loop cycles as static configuration. </span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">def</span> <span class="pl-en">runtimeConfig</span>(<span class="pl-v">executorName</span>: <span class="pl-k">String</span>, <span class="pl-v">mkExecutor</span>: <span class="pl-k">Int</span> <span class="pl-k">=&gt;</span> <span class="pl-en">ExecutorService</span>) <span class="pl-k">=</span>
    <span class="pl-en">Config</span>.runtime[<span class="pl-k">Int</span>, <span class="pl-en">ExecutorService</span>](executorName, mkExecutor, _.shutdown())

  <span class="pl-k">val</span> <span class="pl-en">threadPool</span> <span class="pl-k">=</span> runtimeConfig(<span class="pl-s"><span class="pl-pds">"</span>thread-pool<span class="pl-pds">"</span></span>, <span class="pl-en">Executors</span>.newFixedThreadPool)

  <span class="pl-k">val</span> <span class="pl-en">cycles</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>.static(<span class="pl-c1">10000000</span>)

  <span class="pl-k">import</span> <span class="pl-v">mbench.Host.Hardware.</span><span class="pl-v">cores</span>

  <span class="pl-k">val</span> <span class="pl-en">threads</span> <span class="pl-k">=</span> ((<span class="pl-c1">1</span> to <span class="pl-c1">3</span>) <span class="pl-k">++</span> (<span class="pl-c1">4</span> to cores by (<span class="pl-k">if</span> (cores <span class="pl-k">&lt;=</span> <span class="pl-c1">8</span>) <span class="pl-c1">2</span> <span class="pl-k">else</span> <span class="pl-c1">4</span>)) <span class="pl-k">++</span> (<span class="pl-en">Seq</span>(<span class="pl-c1">2</span>, <span class="pl-c1">4</span>) map (_ <span class="pl-k">+</span> cores))).distinct

  <span class="pl-k">val</span> <span class="pl-en">ilabel</span> <span class="pl-k">=</span> <span class="pl-en">Label</span>[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>threads<span class="pl-pds">"</span></span>)

  <span class="pl-c"><span class="pl-c">/*</span> This column uses the cycles in the static configuration to compute </span>
<span class="pl-c">   * the throughput in cycles per second. </span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">val</span> <span class="pl-en">throughput</span> <span class="pl-k">=</span> <span class="pl-en">Column</span>.withConfig[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>, <span class="pl-k">Double</span>](<span class="pl-s"><span class="pl-pds">"</span>throughput<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cycles<span class="pl-pds">"</span></span>.perSeconds)(
    (threads, cycles, time) <span class="pl-k">=&gt;</span> threads <span class="pl-k">*</span> (cycles <span class="pl-k">/</span> time)
  )

  <span class="pl-k">val</span> <span class="pl-en">speedup</span> <span class="pl-k">=</span> throughput.speedupHigherIsBetter

  <span class="pl-k">val</span> <span class="pl-en">benchmark</span> <span class="pl-k">=</span> <span class="pl-en">Benchmark</span>(<span class="pl-s"><span class="pl-pds">"</span>para-loops<span class="pl-pds">"</span></span>, threads, ilabel, warmups <span class="pl-k">=</span> <span class="pl-c1">5</span>, runs <span class="pl-k">=</span> <span class="pl-c1">7</span>)
    .add(throughput).add(speedup)

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {

    <span class="pl-c"><span class="pl-c">/*</span> The tests and the benchmark must use the same setup, which specifies </span>
<span class="pl-c">     * the executor and the number of cycles to execute.</span>
<span class="pl-c">     <span class="pl-c">*/</span></span>

    <span class="pl-k">def</span> <span class="pl-en">mkTest</span>(<span class="pl-v">loop</span>: <span class="pl-k">Int</span> <span class="pl-k">=&gt;</span> <span class="pl-k">Unit</span>)(<span class="pl-v">executor</span>: <span class="pl-en">ExecutorService</span>, <span class="pl-v">cycles</span>: <span class="pl-k">Int</span>, <span class="pl-v">threads</span>: <span class="pl-k">Int</span>) <span class="pl-k">=</span> {
      (<span class="pl-c1">1</span> to threads)
        .map(_ <span class="pl-k">=&gt;</span> executor.submit(<span class="pl-k">new</span> <span class="pl-en">Runnable</span> { <span class="pl-k">def</span> <span class="pl-en">run</span>() <span class="pl-k">=</span> loop(cycles) }))
        .foreach(_.get())
    }

    <span class="pl-k">val</span> <span class="pl-en">testWhile</span> <span class="pl-k">=</span> <span class="pl-en">Test</span>(<span class="pl-s"><span class="pl-pds">"</span>while<span class="pl-pds">"</span></span>, mkTest(<span class="pl-en">Loops</span>.testWhile))
    <span class="pl-k">val</span> <span class="pl-en">testWhileNew</span> <span class="pl-k">=</span> <span class="pl-en">Test</span>(<span class="pl-s"><span class="pl-pds">"</span>while-new<span class="pl-pds">"</span></span>, mkTest(<span class="pl-en">Loops</span>.testWhileNew))
    <span class="pl-k">val</span> <span class="pl-en">testFor</span> <span class="pl-k">=</span> <span class="pl-en">Test</span>(<span class="pl-s"><span class="pl-pds">"</span>for<span class="pl-pds">"</span></span>, mkTest(<span class="pl-en">Loops</span>.testFor))

    <span class="pl-k">val</span> <span class="pl-en">idealTimes</span> <span class="pl-k">=</span> benchmark.ideal(<span class="pl-s"><span class="pl-pds">"</span>speedup<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span> <span class="pl-c"><span class="pl-c">/*</span> cycles don't matter <span class="pl-c">*/</span></span> , threads <span class="pl-k">=&gt;</span> <span class="pl-k">if</span> (threads <span class="pl-k">&lt;=</span> cores) <span class="pl-c1">1</span> <span class="pl-k">else</span> (threads.toDouble <span class="pl-k">/</span> cores))

    <span class="pl-k">val</span> <span class="pl-en">tests</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(testWhile, testWhileNew, testFor)

    <span class="pl-k">val</span> <span class="pl-en">dats</span> <span class="pl-k">=</span> tests.map(benchmark(threadPool and cycles, _))

    <span class="pl-k">val</span> <span class="pl-en">settings</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Plot</span>.xtics(<span class="pl-c1">1</span>))
    <span class="pl-en">Gnuplot</span>.save(<span class="pl-en">Gnuplot</span>(dats, settings, throughput))
    <span class="pl-en">Gnuplot</span>.save(<span class="pl-en">Gnuplot</span>(dats <span class="pl-k">:</span><span class="pl-k">+</span> idealTimes, settings, speedup.label))

  }

}</pre>
  </div> 
  <p>If we loop at the throughput plot below, we see again that the while-loop wins over Scala's for-comprehension in scala 2.9.3 (contributions to migrate the build to Scala 2.10 are welcome) and that the loop that does excessive boxing is again the worst performer of the three.</p> 
  <p><a href="https://camo.githubusercontent.com/09b98241263c986f44b671bd3a60444b8396b6c7/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f706172612d6c6f6f70732f706172612d6c6f6f70735f7468726561642d706f6f6c2532357468726f7567687075742e706e67" target="_blank"><img src="https://camo.githubusercontent.com/09b98241263c986f44b671bd3a60444b8396b6c7/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f706172612d6c6f6f70732f706172612d6c6f6f70735f7468726561642d706f6f6c2532357468726f7567687075742e706e67" alt="para-loops%throughput.plt" data-canonical-src="https://raw.github.com/sbocq/mbench/master/gallery/para-loops/para-loops_thread-pool%25throughput.png" style="max-width:100%;"></a></p> 
  <p>But how well do they scale on multicore hardware with the number of threads? According to the speedup plot shown below, only the for-comprehension comes close to the ideal parallel speedup, and in all cases, it is not worth going beyond 24 threads. The while-loop, although it is the fastest, benefits from a parallel speedup up to at least 20 threads but it is less than ideal. And the version that does boxing creates so much garbage that it cannot be eliminated efficiently by the JVM between 8 and 12 threads (questions: What explains the different behaviors? Can it be improved by tuning the JVM?).</p> 
  <p><a href="https://camo.githubusercontent.com/6ec568794a4a74fbb0d301258f83f2a4995dfa35/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f706172612d6c6f6f70732f706172612d6c6f6f70735f7468726561642d706f6f6c253235737065656475702e706e67" target="_blank"><img src="https://camo.githubusercontent.com/6ec568794a4a74fbb0d301258f83f2a4995dfa35/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f706172612d6c6f6f70732f706172612d6c6f6f70735f7468726561642d706f6f6c253235737065656475702e706e67" alt="para-loops%speedup.plt" data-canonical-src="https://raw.github.com/sbocq/mbench/master/gallery/para-loops/para-loops_thread-pool%25speedup.png" style="max-width:100%;"></a></p> 
  <h3><a href="https://github.com/sbocq/mbench#maps" aria-hidden="true" class="anchor" id="user-content-maps" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Maps</h3> 
  <p>The benchmark below illustrates how to benchmark a scenario that performs side-effects that must be executed in a predefined sequence. In this scenario, we measure how fast we can add elements to a hash map and then remove them. At the same time, we compare the performance of immutable and mutable hash maps.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Maps</span> {

  <span class="pl-k">def</span> <span class="pl-en">testAdd</span>(<span class="pl-v">map</span>: <span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>], <span class="pl-v">n</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> {
    <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">var</span> <span class="pl-en">m</span> <span class="pl-k">=</span> map
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> n) {
      m <span class="pl-k">+</span><span class="pl-k">=</span> i <span class="pl-k">-</span><span class="pl-k">&gt;</span> i
      i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
    }
    m
  }

  <span class="pl-k">def</span> <span class="pl-en">testDel</span>(<span class="pl-v">map</span>: <span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>], <span class="pl-v">n</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> {
    <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">var</span> <span class="pl-en">m</span> <span class="pl-k">=</span> map
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> n) {
      m <span class="pl-k">-</span><span class="pl-k">=</span> i
      i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
    }
    m
  }

  <span class="pl-c"><span class="pl-c">/*</span> Hello static dispatch: test methods above would be extremely slow with mutable Map</span>
<span class="pl-c">   * because += must clone the map each time it is invoked. This is why we need these.</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">def</span> <span class="pl-en">testMAdd</span>(<span class="pl-v">map</span>: mutable.<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>], <span class="pl-v">n</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> mutable.<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> {
    <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">var</span> <span class="pl-en">m</span> <span class="pl-k">=</span> map
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> n) {
      m <span class="pl-k">+</span><span class="pl-k">=</span> i <span class="pl-k">-</span><span class="pl-k">&gt;</span> i
      i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
    }
    m
  }

  <span class="pl-k">def</span> <span class="pl-en">testMDel</span>(<span class="pl-v">map</span>: mutable.<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>], <span class="pl-v">n</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> mutable.<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> {
    <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
    <span class="pl-k">var</span> <span class="pl-en">m</span> <span class="pl-k">=</span> map
    <span class="pl-k">while</span> (i <span class="pl-k">&lt;</span> n) {
      m <span class="pl-k">-</span><span class="pl-k">=</span> i
      i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
    }
    m
  }

  <span class="pl-k">import</span> <span class="pl-v">mbench.benchmark.</span><span class="pl-v">_</span>
  <span class="pl-k">import</span> <span class="pl-v">mbench.gnuplot.</span><span class="pl-v">_</span>
  <span class="pl-k">import</span> <span class="pl-v">mbench.benchmark.TestSeq.</span>{ <span class="pl-v">test</span>, <span class="pl-v">ignore</span> }

  <span class="pl-k">val</span> <span class="pl-en">MapTest</span> <span class="pl-k">=</span> <span class="pl-en">TestSeq</span>.static[immutable.<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>], <span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, (map, n) <span class="pl-k">=&gt;</span>
    <span class="pl-k">for</span> {
      m <span class="pl-k">&lt;</span><span class="pl-k">-</span> test(<span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>, testAdd(map, n))
      m <span class="pl-k">&lt;</span><span class="pl-k">-</span> test(<span class="pl-s"><span class="pl-pds">"</span>del<span class="pl-pds">"</span></span>, testDel(m, n))
      _ <span class="pl-k">&lt;</span><span class="pl-k">-</span> ignore(assert(m.isEmpty))
    } <span class="pl-k">yield</span> ()
  )

  <span class="pl-k">val</span> <span class="pl-en">MMapTest</span> <span class="pl-k">=</span> <span class="pl-en">TestSeq</span>.static[mutable.<span class="pl-en">Map</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>], <span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, (map, n) <span class="pl-k">=&gt;</span>
    <span class="pl-k">for</span> {
      m <span class="pl-k">&lt;</span><span class="pl-k">-</span> test(<span class="pl-s"><span class="pl-pds">"</span>add<span class="pl-pds">"</span></span>, testMAdd(map, n))
      m <span class="pl-k">&lt;</span><span class="pl-k">-</span> test(<span class="pl-s"><span class="pl-pds">"</span>del<span class="pl-pds">"</span></span>, testMDel(m, n))
      _ <span class="pl-k">&lt;</span><span class="pl-k">-</span> ignore(assert(m.isEmpty))
    } <span class="pl-k">yield</span> ()
  )

  <span class="pl-k">val</span> <span class="pl-en">immutableMap</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>.static(<span class="pl-s"><span class="pl-pds">"</span>immutable-map<span class="pl-pds">"</span></span>, <span class="pl-en">Map</span>.empty[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>])
  <span class="pl-k">val</span> <span class="pl-en">mutableMap</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>.static(<span class="pl-s"><span class="pl-pds">"</span>mutable-map<span class="pl-pds">"</span></span>, mutable.<span class="pl-en">Map</span>.empty[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>])
  <span class="pl-k">val</span> <span class="pl-en">openMap</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>.static(<span class="pl-s"><span class="pl-pds">"</span>open-map<span class="pl-pds">"</span></span>, mutable.<span class="pl-en">OpenHashMap</span>.empty[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>])

  <span class="pl-k">val</span> <span class="pl-en">input</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-c1">1</span>, <span class="pl-c1">5</span>, <span class="pl-c1">10</span>).map(_ <span class="pl-k">*</span> <span class="pl-c1">50000</span>)
  <span class="pl-k">val</span> <span class="pl-en">elems</span> <span class="pl-k">=</span> <span class="pl-en">Label</span>[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>elems<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">throughput</span> <span class="pl-k">=</span> <span class="pl-en">Column</span>.throughput(elems)

  <span class="pl-k">val</span> <span class="pl-en">benchmark</span> <span class="pl-k">=</span> <span class="pl-en">Benchmark</span>(<span class="pl-s"><span class="pl-pds">"</span>maps<span class="pl-pds">"</span></span>, input, elems, warmups <span class="pl-k">=</span> <span class="pl-c1">2</span>, runs <span class="pl-k">=</span> <span class="pl-c1">5</span>).add(throughput)

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">ires</span> <span class="pl-k">=</span> benchmark.seq(immutableMap, <span class="pl-en">MapTest</span>)
    <span class="pl-k">val</span> <span class="pl-en">mres</span> <span class="pl-k">=</span> benchmark.seq(mutableMap, <span class="pl-en">MMapTest</span>)
    <span class="pl-k">val</span> <span class="pl-en">ores</span> <span class="pl-k">=</span> benchmark.seq(openMap, <span class="pl-en">MMapTest</span>)

    <span class="pl-k">val</span> <span class="pl-en">plots</span> <span class="pl-k">=</span> <span class="pl-en">Gnuplot</span>(ires <span class="pl-k">++</span> mres <span class="pl-k">++</span> ores, <span class="pl-en">Plot</span>.xticList(<span class="pl-v">input</span>: _<span class="pl-k">*</span>))
    <span class="pl-en">Gnuplot</span>.save(plots)
  }

}</pre>
  </div> 
  <p>The time plot below tells us that, as expected, the time increases with the number of elements and that the open hash map is the fastest of the three for <code>add</code> and <code>remove</code> operations.</p> 
  <p><a href="https://camo.githubusercontent.com/539e855c204a7074b8c653bb4b91f481650d8490/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6d6170732f6d61707325323574696d652e706e67" target="_blank"><img src="https://camo.githubusercontent.com/539e855c204a7074b8c653bb4b91f481650d8490/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6d6170732f6d61707325323574696d652e706e67" alt="maps%time.plt" data-canonical-src="https://raw.github.com/sbocq/mbench/master/gallery/maps/maps%25time.png" style="max-width:100%;"></a></p> 
  <p>If we look now at how the throughput scales with the number of elements, we see that the open hash map is not only the fastest of the pack but that its add operation is still optimized as the number of iterations increases, even above 300000 additions.</p> 
  <p><a href="https://camo.githubusercontent.com/12cf2f449a0e9ece1acb324c4bd3ff95c7936df9/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6d6170732f6d6170732532357468726f7567687075742e706e67" target="_blank"><img src="https://camo.githubusercontent.com/12cf2f449a0e9ece1acb324c4bd3ff95c7936df9/68747470733a2f2f7261772e6769746875622e636f6d2f73626f63712f6d62656e63682f6d61737465722f67616c6c6572792f6d6170732f6d6170732532357468726f7567687075742e706e67" alt="maps%throughput.plt" data-canonical-src="https://raw.github.com/sbocq/mbench/master/gallery/maps/maps%25throughput.png" style="max-width:100%;"></a></p> 
  <h2><a href="https://github.com/sbocq/mbench#installing" aria-hidden="true" class="anchor" id="user-content-installing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installing</h2> 
  <p>MBench and its benchmarks (for Scala 2.9.3, 2.10.1) are available in the Sonatype OSS Maven repository (which is mirrored on the central Maven repository as well):</p> 
  <pre><code>group id: com.github.sbocq
artifact id: mbench_2.9.3 or mbench_2.10 (or mbench-benchmarks_*)
version: 0.2.4
</code></pre> 
  <p>Alternatively you can download the Jar files directly from Sonatype:</p> 
  <ul> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/sbocq/mbench_2.9.3/0.2.4/mbench_2.9.3-0.2.4.jar" target="_blank">mbench.jar (2.9.3)</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/sbocq/mbench_2.10/0.2.4/mbench_2.10-0.2.4.jar" target="_blank">mbench.jar (2.10)</a></li> 
  </ul> 
  <h2><a href="https://github.com/sbocq/mbench#building-from-sources" aria-hidden="true" class="anchor" id="user-content-building-from-sources" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Building From Sources</h2> 
  <p>Using <a href="http://www.scala-sbt.org/release/docs/Getting-Started/Setup" target="_blank">sbt</a>:</p> 
  <pre><code>&gt; git clone https://github.com/sbocq/mbench.git
&gt; cd mbench
&gt; sbt collect-jar
</code></pre> 
  <h2><a href="https://github.com/sbocq/mbench#running-the-examples" aria-hidden="true" class="anchor" id="user-content-running-the-examples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the Examples</h2> 
  <p><strong>Prerequisite</strong>: <em>Your Java environment must point to a JDK VM because mbench forks benchmarks in a server VM.</em></p> 
  <p>The examples can be launched in several manners:</p> 
  <ul> 
   <li> <p>By importing the sources of <code>mbench</code> and <code>mbench-benchmarks</code> in your favorite IDE with the Scala plugin installed and running the examples as regular <code>main</code> classes.</p> </li> 
   <li> <p>From the command line with the Scala library (<a href="http://www.scala-lang.org/downloads" target="_blank">2.9.3</a>):</p> 
    <ul> 
     <li> <p>Running the parallel loops in Linux:</p> <p><code>$JAVA_HOME/bin/java -XX:+UseNUMA -cp mbench.jar:mbench-benchmarks.jar:scala-library.jar mbench.benchmarks.ParaLoops</code></p> </li> 
     <li> <p>Running all the examples in Windows:</p> <p><code>"%JAVA_HOME%"\bin\java -XX:+UseNUMA -cp mbench.jar;mbench-benchmarks.jar;scala-library.jar mbench.benchmarks.Benchmarks</code></p> </li> 
    </ul> </li> 
   <li> <p>From a sbt prompt:</p> <pre><code>  &gt; project mbench-benchmarks
  &gt; run
</code></pre> </li> 
  </ul> 
  <h2><a href="https://github.com/sbocq/mbench#sample-sbt-project-file" aria-hidden="true" class="anchor" id="user-content-sample-sbt-project-file" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sample SBT Project File</h2> 
  <p>Here is a simple <code>build.sbt</code> file that can be used to build a simple <code>mbench</code> project with <code>sbt</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>name <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>mybenchmarks<span class="pl-pds">"</span></span>

version <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>0.1<span class="pl-pds">"</span></span>

scalaVersion <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>2.10.1<span class="pl-pds">"</span></span>

resolvers <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
    <span class="pl-s"><span class="pl-pds">"</span>Sonatype Nexus Releases<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>https://oss.sonatype.org/content/repositories/releases<span class="pl-pds">"</span></span>)

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.sbocq<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>mbench<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.4<span class="pl-pds">"</span></span>

fork <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-c1">true</span>

javaOptions <span class="pl-k">&lt;</span><span class="pl-k">++</span><span class="pl-k">=</span> (fullClasspath in <span class="pl-en">Runtime</span>).map(cp <span class="pl-k">=&gt;</span>
    <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>-cp<span class="pl-pds">"</span></span>, cp.files.mkString(<span class="pl-en">System</span>.getProperty(<span class="pl-s"><span class="pl-pds">"</span>path.separator<span class="pl-pds">"</span></span>)),
        <span class="pl-s"><span class="pl-pds">"</span>-Dmbench.log.stdout=true<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>-Dmbench.new.date.dir=sbtrun<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>The additional options tell <code>mbench</code> to log messages on <code>stdout</code> (default is <code>stderr</code>) and to always save its reports in a directory called <code>sbtrun</code> (default is a directory named after the date of the benchmark). Mbench supports several configuration properties that can be either passed on the command line, like this, or stored in a <code>mbench.properties</code> file. These properties are listed in the <a href="http://sbocq.github.io/mbench/#mbench.MBench$" target="_blank">online documentation</a>.</p> 
  <h2><a href="https://github.com/sbocq/mbench#projects-using-mbench" aria-hidden="true" class="anchor" id="user-content-projects-using-mbench" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Projects Using MBench</h2> 
  <ul> 
   <li><a href="https://github.com/molecule-labs/molecule" target="_blank">Molecule</a>: Molecule is using extensively <code>mbench</code> to compare the scalability on multicore hardware of different runtime options and different frameworks. Its overview reports can be found <a href="https://github.com/molecule-labs/molecule/tree/benchmark-reports/megaphone/%2BUseNUMA%2BUseCondCardMark%2BUseParallelGC/overview" target="_blank">here</a>.</li> 
  </ul> 
 </article>
</div>