<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-docless" class="anchor" href="https://github.com/timeoutdigital/docless#docless" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Docless</h1> 
  <p><a href="https://travis-ci.org/timeoutdigital/docless" target="_blank"><img src="https://camo.githubusercontent.com/c6e306c2508493bc00e9dbfca7d8e11450e728c7/68747470733a2f2f7472617669732d63692e6f72672f74696d656f75746469676974616c2f646f636c6573732e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/timeoutdigital/docless.svg?branch=master" style="max-width:100%;"></a> <a href="http://search.maven.org/#search%7Cga%7C1%7Ccom.timeout.docless" target="_blank"><img src="https://camo.githubusercontent.com/32dea6e3eb9e0bd4be9f734919d7c90b4490c829/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f636f6d2e74696d656f75742f646f636c6573735f322e31322e737667" alt="Maven Central" data-canonical-src="https://img.shields.io/maven-central/v/com.timeout/docless_2.12.svg" style="max-width:100%;"></a></p> 
  <p>A scala DSL to generate JSON schema and <a href="http://swagger.io" target="_blank">swagger</a> documentation for your web services.</p> 
  <ul> 
   <li> <a href="https://github.com/timeoutdigital/docless#why-not-just-using-swagger-core" target="_blank">Why not just using Swagger-core?</a></li> 
   <li> <a href="https://github.com/timeoutdigital/docless#installation" target="_blank">Installation</a> 
    <ul> 
     <li> <a href="https://github.com/timeoutdigital/docless#json-schema-derivation" target="_blank">JSON schema derivation</a></li> 
     <li> <a href="https://github.com/timeoutdigital/docless#algebraic-data-types" target="_blank">Algebraic data types</a></li> 
     <li> <a href="https://github.com/timeoutdigital/docless#swagger-dsl" target="_blank">Swagger DSL</a></li> 
     <li> <a href="https://github.com/timeoutdigital/docless#aggregating-documentation-from-multiple-modules" target="_blank">Aggregating documentation from multiple modules</a></li> 
    </ul></li> 
   <li> <a href="https://github.com/timeoutdigital/docless#known-issues" target="_blank">Known issues</a></li> 
  </ul> 
  <h2><a id="user-content-why-not-just-using-swagger-core" class="anchor" href="https://github.com/timeoutdigital/docless#why-not-just-using-swagger-core" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why not just using Swagger-core?</h2> 
  <p>While being to some extent usable for Scala projects, <a href="https://github.com/swagger-api/swagger-core" target="_blank">swagger-core</a> suffers from some serious limitations:</p> 
  <ul> 
   <li><p>It heavily relies on Java runtime reflection to generate Json schemas for your data models. This might be fine for plain Java objects, but it does not really play well with key scala idioms such as case classes and sealed trait hierarchies.</p></li> 
   <li><p>Swagger is implemented through JAX-RS annotations. These provide way more limited means of abstraction and code reuse than a DSL directly embedded into Scala.</p></li> 
  </ul> 
  <h2><a id="user-content-installation" class="anchor" href="https://github.com/timeoutdigital/docless#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h2> 
  <p>Add the following to your <code>build.sbt</code></p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.timeout<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>docless<span class="pl-pds">"</span></span> <span class="pl-k">%</span> doclessVersion</pre>
  </div> 
  <h3><a id="user-content-json-schema-derivation" class="anchor" href="https://github.com/timeoutdigital/docless#json-schema-derivation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>JSON schema derivation</h3> 
  <p>This project uses Shapeless to automatically derive JSON schemas for case classes and ADTs at compile time. By scraping unnecessary boilerplate code, this approach helps keeping documentation in sync with the relevant business entities.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.schema.</span><span class="pl-v">_</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Pet</span>(<span class="pl-v">id</span>: <span class="pl-k">Int</span>, <span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">tag</span>: <span class="pl-en">Option</span>[<span class="pl-k">String</span>])

<span class="pl-k">val</span> <span class="pl-en">petSchema</span> <span class="pl-k">=</span> <span class="pl-en">JsonSchema</span>.deriveFor[<span class="pl-en">Pet</span>]</pre>
  </div> 
  <h4><a id="user-content-case-classes" class="anchor" href="https://github.com/timeoutdigital/docless#case-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Case classes</h4> 
  <p>Given a case class, generating a JSON schema is as easy as calling the <code>deriveFor</code> method and supplying the class as type parameter.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> petSchema.asJson
res2<span class="pl-k">:</span> io.circe.<span class="pl-en">Json</span> <span class="pl-k">=</span>
{
  <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>object<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>required<span class="pl-pds">"</span></span> <span class="pl-k">:</span> [
    <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>
  ],
  <span class="pl-s"><span class="pl-pds">"</span>properties<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
      <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>integer<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>format<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>int32<span class="pl-pds">"</span></span>
    },
    <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
      <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>
    },
    <span class="pl-s"><span class="pl-pds">"</span>tag<span class="pl-pds">"</span></span> <span class="pl-k">:</span> {
      <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>
    }
  }
}</pre>
  </div> 
  <p>The generated schema can be serialised to JSON by calling the <code>asJson</code> method, which will return a <a href="https://github.com/travisbrown/circe" target="_blank">Circe</a> JSON ast.</p> 
  <h3><a id="user-content-algebraic-data-types" class="anchor" href="https://github.com/timeoutdigital/docless#algebraic-data-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Algebraic data types</h3> 
  <p>Arguably, the idea of ADT or sum type is best expressed using JsonSchema <em>oneOf</em> keyword. However, as Swagger UI seems to only support the <code>allOf</code>,\ this library uses the latter as default. This can be easily overriden by defining an implicit instance of <code>derive.Config</code> in the local scope:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.schema.derive.</span>{<span class="pl-v">Config</span>, <span class="pl-v">Combinator</span>}

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Contact</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">EmailAndPhoneNum</span>(<span class="pl-v">email</span>: <span class="pl-k">String</span>, <span class="pl-v">phoneNum</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Contact</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">EmailOnly</span>(<span class="pl-v">email</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Contact</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">PhoneOnly</span>(<span class="pl-v">phoneNum</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Contact</span>

<span class="pl-k">object</span> <span class="pl-en">Contact</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">conf</span><span class="pl-k">:</span> <span class="pl-en">Config</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>(<span class="pl-en">Combinator</span>.<span class="pl-en">OneOf</span>)
  <span class="pl-k">val</span> <span class="pl-en">schema</span> <span class="pl-k">=</span> <span class="pl-en">JsonSchema</span>.deriveFor[<span class="pl-en">Contact</span>]
}</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">Contact</span>.schema.asJson
res5<span class="pl-k">:</span> io.circe.<span class="pl-en">Json</span> <span class="pl-k">=</span>
{
  <span class="pl-s"><span class="pl-pds">"</span>type<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>object<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>oneOf<span class="pl-pds">"</span></span> <span class="pl-k">:</span> [
    {
      <span class="pl-s"><span class="pl-pds">"</span>$ref<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>#/definitions/EmailAndPhoneNum<span class="pl-pds">"</span></span>
    },
    {
      <span class="pl-s"><span class="pl-pds">"</span>$ref<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>#/definitions/EmailOnly<span class="pl-pds">"</span></span>
    },
    {
      <span class="pl-s"><span class="pl-pds">"</span>$ref<span class="pl-pds">"</span></span> <span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>#/definitions/PhoneOnly<span class="pl-pds">"</span></span>
    }
  ]
}</pre>
  </div> 
  <p>For ADTs, as well as for case classes, the <code>JsonSchema.relatedDefinitions</code>\ method can be used to access the child definitions referenced in a schema:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">Contact</span>.schema.relatedDefinitions.map(_.id)
res6<span class="pl-k">:</span> scala.collection.immutable.<span class="pl-en">Set</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-en">Set</span>(<span class="pl-en">PhoneOnly</span>, <span class="pl-en">EmailOnly</span>, <span class="pl-en">EmailAndPhoneNum</span>)</pre>
  </div> 
  <h4><a id="user-content-enums-support" class="anchor" href="https://github.com/timeoutdigital/docless#enums-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Enums support</h4> 
  <p>Docless can automatically derive a Json schema enum for sum types consisting of case objects only:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Diet</span>

<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Herbivore</span> <span class="pl-k">extends</span> <span class="pl-e">Diet</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Carnivore</span> <span class="pl-k">extends</span> <span class="pl-e">Diet</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Omnivore</span> <span class="pl-k">extends</span> <span class="pl-e">Diet</span></pre>
  </div> 
  <p>Enumeration values can be automatically converted into a string identifier\ using one of the pre-defined formats.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.schema.PlainEnum.</span><span class="pl-v">IdFormat</span>
<span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.schema.PlainEnum.</span><span class="pl-v">IdFormat</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">format</span><span class="pl-k">:</span> <span class="pl-en">IdFormat</span> <span class="pl-k">=</span> <span class="pl-en">IdFormat</span>.<span class="pl-en">SnakeCase</span>
format<span class="pl-k">:</span> com.timeout.docless.schema.<span class="pl-en">PlainEnum</span>.<span class="pl-en">IdFormat</span> <span class="pl-k">=</span> <span class="pl-en">SnakeCase</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">schema</span> <span class="pl-k">=</span> <span class="pl-en">JsonSchema</span>.deriveEnum[<span class="pl-en">Diet</span>]
schema<span class="pl-k">:</span> com.timeout.docless.schema.<span class="pl-en">JsonSchema</span>[<span class="pl-en">Diet</span>] <span class="pl-k">=</span> com.timeout.docless.schema.<span class="pl-en">JsonSchema</span>$$anon$<span class="pl-c1">4</span><span class="pl-k">@</span>58a7e8ec

scala<span class="pl-k">&gt;</span> schema.asJson
res8<span class="pl-k">:</span> io.circe.<span class="pl-en">Json</span> <span class="pl-k">=</span>
{
  <span class="pl-s"><span class="pl-pds">"</span>enum<span class="pl-pds">"</span></span> <span class="pl-k">:</span> [
    <span class="pl-s"><span class="pl-pds">"</span>herbivore<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>carnivore<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>omnivore<span class="pl-pds">"</span></span>
  ]
}</pre>
  </div> 
  <p>Additionally, the popular library <a href="https://github.com/lloydmeta/enumeratum" target="_blank">enumeratum</a> is also supported through the <a href="https://github.com/timeoutdigital/docless/blob/master/src/main/scala/com/timeout/docless/schema/EnumSchema.scala" target="_blank">EnumSchema`</a> trait.\ The trait can be simply mixed into the enum companion object and will automatically provide a Json Schema instance.</p> 
  <h3><a id="user-content-swagger-dsl" class="anchor" href="https://github.com/timeoutdigital/docless#swagger-dsl" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Swagger DSL</h3> 
  <p>Docless provides a native scala implementation of the Swagger 2.0 model together with a DSL to easily manipulate and transform it.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.swagger.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.schema.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">PetsRoute</span> <span class="pl-k">extends</span> <span class="pl-e">PathGroup</span> {
  <span class="pl-k">val</span> <span class="pl-en">petResp</span> <span class="pl-k">=</span> petSchema.asResponse(<span class="pl-s"><span class="pl-pds">"</span>The pet<span class="pl-pds">"</span></span>)

  <span class="pl-k">val</span> <span class="pl-en">petIdParam</span> <span class="pl-k">=</span> <span class="pl-en">Parameter</span>
    .path(
      name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>,
      description <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>The pet id<span class="pl-pds">"</span></span>),
      format <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-en">Format</span>.<span class="pl-en">Int32</span>)
    ).as[<span class="pl-k">Int</span>]

  <span class="pl-k">override</span> <span class="pl-k">val</span> <span class="pl-en">definitions</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(petSchema, errSchema).map(_.definition)

  <span class="pl-k">override</span> <span class="pl-k">val</span> <span class="pl-en">paths</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(
    <span class="pl-s"><span class="pl-pds">"</span>/pets/{id}<span class="pl-pds">"</span></span>
       .<span class="pl-en">Get</span>(
         <span class="pl-en">Operation</span>(
           summary <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>info for a specific pet<span class="pl-pds">"</span></span>)
         ).withParams(petIdParam)
          .responding(errorResponse)(<span class="pl-c1">200</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> petResp)
       )
       .<span class="pl-en">Delete</span>(
         <span class="pl-en">Operation</span>() <span class="pl-c"><span class="pl-c">//</span>...</span>
       )
 )

}</pre>
  </div> 
  <p>This not only provides better means of abstraction that JSON or YAML (i.e.&nbsp;binding, high order functions, implicit conversions, etc.), but it also allows to integrate API documentation more tightly to the application code.</p> 
  <h3><a id="user-content-aggregating-documentation-from-multiple-modules" class="anchor" href="https://github.com/timeoutdigital/docless#aggregating-documentation-from-multiple-modules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Aggregating documentation from multiple modules</h3> 
  <p>Aside for using Circe for JSON serialisation, Docless is not coupled to any specific Scala web framework. Nevertheless, it does provide a generic facility to enrich separate code modules with Swagger metadata, being these routes, controllers, or whatever else your framework calls them.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.timeout.docless.swagger.</span><span class="pl-v">_</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Dino</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">extinctedSinceYears</span>: <span class="pl-k">Long</span>, <span class="pl-v">diet</span>: <span class="pl-en">Diet</span>)

<span class="pl-k">object</span> <span class="pl-en">DinosRoute</span> <span class="pl-k">extends</span> <span class="pl-e">PathGroup</span> {

  <span class="pl-k">val</span> <span class="pl-en">dinoSchema</span> <span class="pl-k">=</span> <span class="pl-en">JsonSchema</span>.deriveFor[<span class="pl-en">Dino</span>]
  <span class="pl-k">val</span> <span class="pl-en">dinoId</span> <span class="pl-k">=</span> <span class="pl-en">Parameter</span>.path(<span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>).as[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">dinoResp</span> <span class="pl-k">=</span> dinoSchema.asResponse(<span class="pl-s"><span class="pl-pds">"</span>A dinosaur!<span class="pl-pds">"</span></span>)

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">definitions</span> <span class="pl-k">=</span> <span class="pl-c1">Nil</span> <span class="pl-c"><span class="pl-c">//</span> &lt;= this should be Dino.defintions</span>

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">paths</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(
    <span class="pl-s"><span class="pl-pds">"</span>/dinos/{id}<span class="pl-pds">"</span></span>
      .<span class="pl-en">Get</span>(
        <span class="pl-en">Operation</span>(
          summary <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>info for a specific pet<span class="pl-pds">"</span></span>)
        ).withParams(dinoId)
         .responding(errorResponse)(<span class="pl-c1">200</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> dinoResp)
      )
    )
}</pre>
  </div> 
  <p>The <code>PathGroup</code> trait allows any Scala class or object to publish a list of endpoint paths and schema definitions. The <code>aggregate</code> method in the <code>PathGroup</code> companion object can then be used to merge the supplied groups into a single Swagger API description.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">apiInfo</span> <span class="pl-k">=</span> <span class="pl-en">Info</span>(<span class="pl-s"><span class="pl-pds">"</span>Example API<span class="pl-pds">"</span></span>)
apiInfo<span class="pl-k">:</span> com.timeout.docless.swagger.<span class="pl-en">Info</span> <span class="pl-k">=</span> <span class="pl-en">Info</span>(<span class="pl-en">Example</span> <span class="pl-en">API</span>,<span class="pl-c1">1.0</span>,<span class="pl-c1">None</span>,<span class="pl-c1">None</span>,<span class="pl-c1">None</span>,<span class="pl-c1">None</span>)

scala<span class="pl-k">&gt;</span> <span class="pl-en">PathGroup</span>.aggregate(apiInfo, <span class="pl-en">List</span>(<span class="pl-en">PetsRoute</span>, <span class="pl-en">DinosRoute</span>))
res12<span class="pl-k">:</span> cats.data.<span class="pl-en">ValidatedNel</span>[com.timeout.docless.swagger.<span class="pl-en">SchemaError</span>,com.timeout.docless.swagger.<span class="pl-en">APISchema</span>] <span class="pl-k">=</span> <span class="pl-en">Invalid</span>(<span class="pl-en">NonEmptyList</span>(<span class="pl-en">MissingDefinition</span>(<span class="pl-en">RefWithContext</span>(<span class="pl-en">TypeRef</span>(<span class="pl-en">Dino</span>,<span class="pl-c1">None</span>),<span class="pl-en">ResponseContext</span>(<span class="pl-en">Get</span>,<span class="pl-k">/</span>dinos<span class="pl-k">/</span>{id})))))</pre>
  </div> 
  <p>The <code>aggregate</code> method will also verify that the schema definitions referenced either in endpoint responses or in body parameters can be resolved. In the example above, the method returns a non-empty list with a single <code>ResponseRef</code> error, pointing to the missing <code>Dino</code> definition. On correct inputs, the method will return instead the resulting <code>APISchema</code> wrapped into a <code>cats.data.Validated.Valid</code>.</p> 
  <h2><a id="user-content-known-issues" class="anchor" href="https://github.com/timeoutdigital/docless#known-issues" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Known issues</h2> 
  <p>Currently Docless does not support recursive types (e.g.&nbsp;trees or linked lists). As a way around, one can always define them manually using the <code>JsonSchema.instance[A]</code> method.</p> 
 </article>
</div>