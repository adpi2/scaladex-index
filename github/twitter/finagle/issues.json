{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":190,
            "title":"What is the proper way to set the timezone of datetime columns in finagle-mysql?",
            "bodyText":"finagle-mysql writes DATETIME and TIMESTAMP columns in the current timezone and does not provide a way to specify a timezone (or force them to be in UTC).\nIs this intentional? Are there plans to provide a way to force them to be sent in UTC?",
            "url":"https://github.com/twitter/finagle/issues/190"
          },
          {
            "number":247,
            "title":"Incorrect result when a decoding exception occured",
            "bodyText":"When decoding unexpected (illegal data from the server or legal data that we just can't recognize yet) response data from a Redis server, A exception will probably be thrown from Reply.scala.\nWhen this happens, I believe the result of this service(cmd) call should be a Throw(ex) instead of a Return(Reply). But this is not what we actually got.\nHere is an example:\nBefore this empty string bug is fixed, given a MBULK input like this:\n*4\n$3\nbar\n$0\n\n$3\nfoo\n$3\nmoo\n\nAn IndexOutOfBoundsException will be thrown by val header = line(0) when decoding line 5 (empty string). But we end up with a BULK_REPLY(\"foo\") result instead of a failed Throw.\nHere is what I found, please correct me if I'm wrong:\nBy running this test:\n      \"get multiple values including one empty string\" in {\n        Await.result(client.hSet(roo, bar, StringToChannelBuffer(\"\")))\n        Await.result(client.hSet(roo, foo, moo))\n        CBToString.fromTuples(\n          Await.result(client.hGetAll(roo))) mustEqual Seq((\"bar\", \"\"), (\"foo\", \"moo\"))\n      }\nI got the following stack trace.\n[error]     x get multiple values including one empty string\n[error]       null (Client.scala:103)\n[error]       com.twitter.finagle.redis.BaseClient$$anonfun$doRequest$1.apply(Client.scala:103)\n[error]       com.twitter.finagle.redis.BaseClient$$anonfun$doRequest$1.apply(Client.scala:101)\n[error]       scala.PartialFunction$$anon$1.apply(PartialFunction.scala:76)\n[error]       com.twitter.util.Future$$anonfun$flatMap$1.apply(Future.scala:777)\n[error]       com.twitter.util.Future$$anonfun$flatMap$1.apply(Future.scala:776)\n[error]       com.twitter.util.Promise$Transformer.liftedTree1$1(Promise.scala:93)\n[error]       com.twitter.util.Promise$Transformer.k(Promise.scala:93)\n[error]       com.twitter.util.Promise$Transformer.apply(Promise.scala:102)\n[error]       com.twitter.util.Promise$Transformer.apply(Promise.scala:84)\n[error]       com.twitter.util.Promise$$anon$2.run(Promise.scala:321)\n[error]       com.twitter.concurrent.LocalScheduler$Activation.run(Scheduler.scala:124)\n[error]       com.twitter.concurrent.LocalScheduler$Activation.submit(Scheduler.scala:102)\n[error]       com.twitter.concurrent.LocalScheduler.submit(Scheduler.scala:143)\n[error]       com.twitter.concurrent.Scheduler$.submit(Scheduler.scala:55)\n[error]       com.twitter.util.Promise.runq(Promise.scala:307)\n[error]       com.twitter.util.Promise.updateIfEmpty(Promise.scala:599)\n[error]       com.twitter.util.Promise.update(Promise.scala:577)\n[error]       com.twitter.util.Promise.setValue(Promise.scala:553)\n[error]       com.twitter.concurrent.AsyncQueue.offer(AsyncQueue.scala:71)\n[error]       com.twitter.finagle.transport.ChannelTransport.handleUpstream(ChannelTransport.scala:41)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:296)\n[error]       org.jboss.netty.handler.codec.frame.FrameDecoder.unfoldAndFireMessageReceived(FrameDecoder.java:462)\n[error]       org.jboss.netty.handler.codec.frame.FrameDecoder.callDecode(FrameDecoder.java:443)\n[error]       org.jboss.netty.handler.codec.frame.FrameDecoder.cleanup(FrameDecoder.java:482)\n[error]       org.jboss.netty.handler.codec.frame.FrameDecoder.channelDisconnected(FrameDecoder.java:365)\n[error]       org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:102)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.channelDisconnected(SimpleChannelHandler.java:199)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:120)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.channelDisconnected(SimpleChannelHandler.java:199)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:120)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)\n[error]       org.jboss.netty.channel.Channels.fireChannelDisconnected(Channels.java:396)\n[error]       org.jboss.netty.channel.socket.nio.AbstractNioWorker.close(AbstractNioWorker.java:360)\n[error]       org.jboss.netty.channel.socket.nio.NioClientSocketPipelineSink.eventSunk(NioClientSocketPipelineSink.java:58)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:779)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.closeRequested(SimpleChannelHandler.java:334)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:260)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:784)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.closeRequested(SimpleChannelHandler.java:334)\n[error]       com.twitter.finagle.channel.ChannelStatsHandler.closeRequested(ChannelStatsHandler.scala:90)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleDownstream(SimpleChannelHandler.java:260)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(DefaultChannelPipeline.java:784)\n[error]       com.twitter.finagle.redis.naggati.Codec.handleDownstream(Codec.scala:139)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:591)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline.java:582)\n[error]       org.jboss.netty.channel.Channels.close(Channels.java:812)\n[error]       com.twitter.finagle.transport.ChannelTransport.close(ChannelTransport.scala:112)\n[error]       com.twitter.util.Closable$class.close(Closable.scala:17)\n[error]       com.twitter.finagle.transport.ChannelTransport.close(ChannelTransport.scala:11)\n[error]       com.twitter.finagle.transport.ChannelTransport.com$twitter$finagle$transport$ChannelTransport$$fail(ChannelTransport.scala:33)\n[error]       com.twitter.finagle.transport.ChannelTransport.handleUpstream(ChannelTransport.scala:70)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.handler.codec.frame.FrameDecoder.exceptionCaught(FrameDecoder.java:377)\n[error]       org.jboss.netty.channel.SimpleChannelUpstreamHandler.handleUpstream(SimpleChannelUpstreamHandler.java:112)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.exceptionCaught(SimpleChannelHandler.java:156)\n[error]       com.twitter.finagle.channel.ChannelStatsHandler.exceptionCaught(ChannelStatsHandler.scala:101)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:130)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.exceptionCaught(SimpleChannelHandler.java:156)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:130)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)\n[error]       org.jboss.netty.channel.Channels.fireExceptionCaught(Channels.java:525)\n[error]       org.jboss.netty.channel.AbstractChannelSink.exceptionCaught(AbstractChannelSink.java:48)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.notifyHandlerException(DefaultChannelPipeline.java:658)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:566)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.messageReceived(SimpleChannelHandler.java:142)\n[error]       com.twitter.finagle.channel.ChannelStatsHandler.messageReceived(ChannelStatsHandler.scala:81)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:88)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline$DefaultChannelHandlerContext.sendUpstream(DefaultChannelPipeline.java:791)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.messageReceived(SimpleChannelHandler.java:142)\n[error]       com.twitter.finagle.channel.ChannelRequestStatsHandler.messageReceived(ChannelRequestStatsHandler.scala:35)\n[error]       org.jboss.netty.channel.SimpleChannelHandler.handleUpstream(SimpleChannelHandler.java:88)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:564)\n[error]       org.jboss.netty.channel.DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline.java:559)\n[error]       org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:268)\n[error]       org.jboss.netty.channel.Channels.fireMessageReceived(Channels.java:255)\n[error]       org.jboss.netty.channel.socket.nio.NioWorker.read(NioWorker.java:88)\n[error]       org.jboss.netty.channel.socket.nio.AbstractNioWorker.process(AbstractNioWorker.java:108)\n[error]       org.jboss.netty.channel.socket.nio.AbstractNioSelector.run(AbstractNioSelector.java:318)\n[error]       org.jboss.netty.channel.socket.nio.AbstractNioWorker.run(AbstractNioWorker.java:89)\n[error]       org.jboss.netty.channel.socket.nio.NioWorker.run(NioWorker.java:178)\n[error]       org.jboss.netty.util.ThreadRenamingRunnable.run(ThreadRenamingRunnable.java:108)\n[error]       org.jboss.netty.util.internal.DeadLockProofWorker$1.run(DeadLockProofWorker.java:42)\n[error]       java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)\n[error]       java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:615)\n[error]       java.lang.Thread.run(Thread.java:744)\n\nIt looks like that what happened here were:\n\nAn IndexOutOfBoundsException raised\nCaught by DefaultChannelPipeline.java, then wrapped as an ChannelPipelineException and thrown into upstream\ncom.twitter.finagle.transport.ChannelTransport took control and decided to close this channel and then fail this invocation by sending downstream a close request.\nAfter the channel was closed by AbstractNioWorker, a ChannelDisconnected event sent upstream\nWhen org.jboss.netty.handler.codec.frame.FrameDecoder received this message, it did its cleanup work by decoding remaining dirty data in ChannelBuffer which happens to be foo, which was what we finally got.\n\nI believe the cleanup behavior of FrameDecoder should be overridden/modified to let the remaining dirty data be discarded if there was something bad(Exception) happened before.",
            "url":"https://github.com/twitter/finagle/issues/247"
          },
          {
            "number":357,
            "title":"Don't mess with class loaders... or do it gently",
            "bodyText":"Issue is described in following thread:\nhttps://groups.google.com/forum/#!topic/finaglers/snRvOYwljbI\nBasically Play's auto-reloading breaks Finagle's reflection based API.\nAlso @jproper gives good explanation of what's going on and how to fix it here:\nplayframework/playframework#4159",
            "url":"https://github.com/twitter/finagle/issues/357"
          },
          {
            "number":360,
            "title":"Set finagle-redis tests integration tests up to run as integration tests in SBT and Travis CI",
            "bodyText":"We're currently excluding the finagle-redis integration tests in the SBT build. We should move them to the appropriate location, configure SBT to treat them as integration tests, and set up the Travis CI build to have a Redis server available to run them. (If this has a large impact on the Travis CI testing times we might need to turn them off there, but they currently run pretty quickly on my local machine.)",
            "url":"https://github.com/twitter/finagle/issues/360"
          },
          {
            "number":438,
            "title":"[finagle-mysql] finagle-mysql 6.25.0: Can not read UNSIGNED INT columns correctly",
            "bodyText":"Given this table:\nCREATE TABLE `batches` (\n  `id`         INT UNSIGNED NOT NULL AUTO_INCREMENT,\n  PRIMARY KEY (`id`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n  COLLATE = utf8_unicode_ci;\n\nwith this data:\nINSERT INTO `batches` (`id`)\nVALUES (4294967295);\n\nTrying to load that row with finagle mysql via pseudo code:\nPreparedStatementQuery(\"SELECT * FROM batches WHERE id = ?\").select(4294967295L)\n\nresults in this value being available in the pattern matching:\nIntValue(-1)\n\nIt looks like mysql-finagle does not understand UNSIGNED int's which should result in a LongValue() or at least a Long java/scala representation. It always parses an Int which MaxValue is:\nscala> Int.MaxValue\nres0: Int = 2147483647\n\nThe problematic code I guess is this:\nhttps://github.com/twitter/finagle/blob/develop/finagle-mysql/src/main/scala/com/twitter/finagle/mysql/Row.scala#L74\nExpected behaviuor would be the that I can successfully read the value 4294967295 back somehow.",
            "url":"https://github.com/twitter/finagle/issues/438"
          },
          {
            "number":526,
            "title":"Add com.twitter.finagle.zipkin.core.Endpoint.ipv6",
            "bodyText":"We currently support logging of only IPv4 addresses. Starting with Zipkin 1.4, endpoints can omit IPv4 (by setting Endpoint.ipv4 to 0), and optionally log Endpoint.ipv6 as the raw 16byte address.\nhttps://github.com/openzipkin/zipkin-api/blob/master/thrift/zipkinCore.thrift#L276\nIt looks like the most pivotal change is updating com.twitter.finagle.zipkin.core.Endpoint.ipv6\ncc @sveinnfannar",
            "url":"https://github.com/twitter/finagle/issues/526"
          },
          {
            "number":538,
            "title":"Streaming requests with a fixed content-length are received in one large chunk",
            "bodyText":"I'm trying to stream requests for certain routes in a Finatra server, in order to pipeline the contents to a downstream http service. But the streaming option has no practical effect because Finagle constructs a Netty HttpMessageDecoder that accumulates up to maxRequestSize bytes into a buffer before firing any events.\nExpected behavior\nIn a Finatra route callback, with Finagle's streaming option configured (by specifying Finatra's streamRequest option), I expect to be able to obtain com.twitter.io.Reader that fills a buffer with bytes as they are received.\nActual behavior\nWhen the Finatra route callback is called the entire contents of the request have always been read into the reader beforehand. A debugger session shows that Netty's HttpMessageDecoder does asynchronously receive bytes, but accumulates them into a buffer rather than immediately passing them up the pipeline.\nSteps to Reproduce\nI am developing a Finatra server (2.1.6, Finagle version 6.35.0). I set streaming to true by configuring the streamRequest option in the Finatra server. One particular route callback in the Finatra server is supposed to accept POSTed files from our client app and stream them to a downstream service, preferably without buffering the entire file in memory first.\nI can reproduce by uploading a largish (<5MB) file via curl to the Finatra route mentioned above. (So, a fixed-length request, like our client app would send, with a content-length header and no transfer-encoding: chunked header.) The buffer is always filled before the route callback is invoked.\nDiscussion\nAs far as I can tell, this is because when com.twitter.finagle.http.Http constructs a Netty pipeline, it passes maxRequestSize as the maxChunkSize argument of SafeHttpServerCodec. This amounts to inserting a Netty HttpMessageDecoder that does not detect a frame and emit a messageReceived event until the entire message has been received.\nSee \n  \n    \n      finagle/finagle-http/src/main/scala/com/twitter/finagle/http/Codec.scala\n    \n    \n         Line 291\n      in\n      3bd9661\n    \n    \n    \n    \n\n        \n          \n                     pipeline.addLast(\"httpCodec\", new SafeHttpServerCodec(maxInitialLineLengthInBytes, maxHeaderSizeInBytes, maxRequestSizeInBytes)) \n        \n    \n  \n\n\nIs it possible to decouple the chunk size and request size concepts? It seems the HttpChunkAggregator, which is added to the pipeline when streaming is false, would handle aggregating smaller chunks into the completed message for the non-streaming case.\nNote: I'm mostly using Finagle via Finatra, and then at one remove via a Java wrapper library created at my company. I'm learning to read Scala, but not prepared to write any yet.",
            "url":"https://github.com/twitter/finagle/issues/538"
          },
          {
            "number":554,
            "title":"*** Finagle-mysql doesn't fully support stored procedures ***",
            "bodyText":"finagle-mysql fails when trying to execute a stored procedure that does queries.\nExpected behavior\nWhen calling a stored procedure, finagle should return the result set from all the queries being done inside the procedure.\nActual behavior\nFails with the following error:\ncom.twitter.finagle.mysql.ServerError: PROCEDURE db.st_test can't return a result set in the given context\nSteps to reproduce the behavior\nCreate a stored procedure that does queries (SELECT, UPDATE, etc)\nCall it with a mysql client using something like this:\nval future = client.select(\"CALL st_test(@msg)\") { row => row(\"message\").get }\nMore info about this can be found here: https://bugs.php.net/bug.php?id=42548\nThanks!",
            "url":"https://github.com/twitter/finagle/issues/554"
          },
          {
            "number":562,
            "title":"How to set Host header with LoadBalancing",
            "bodyText":"According to #560 you may be discussing but I got confused when using Finagle's load balancing feature.\nIn order to distribute requests to multiple servers, we instantiate a service via Http.Client#newService as follows,\nval client = Http.client.newService(\"hostA.org:80, hostB.org:80\")\nThen construct request,\nval request = Request(\"/path/to/service\")\nrequest.host = ???\n\nclient(request)\n\nWhat should we fill ??? with?\nMoreover, we're forced to pass the host addresses twice when the service creation and the building request. It's not DRY.\nAre there any reasons that the Host header automatically set that given to the Service?",
            "url":"https://github.com/twitter/finagle/issues/562"
          },
          {
            "number":616,
            "title":"ChannelStatsHandler \"connections\" gauge with negative values",
            "bodyText":"When netty starts closing connections ChannelStatsHandler doesn't not decrements connections gauge properly. When service is not used for long time connections gauge gets negative values\nExpected behavior\nProper connections count\nActual behavior\nWhen netty starts closing connections ChannelStatsHandler doesn't not decrements connections gauge properly. When service is not used for long time connections gauge gets negative values\nSteps to reproduce the behavior\n\nConfigure http client with stats receiver\nSend many concurrent requests in order to fill up connection pool\nDo not use prepared finagle service in order to allow netty to close connections",
            "url":"https://github.com/twitter/finagle/issues/616"
          }
        ]
      }
    }
  }
}