<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-scala-oriented-" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#scala-oriented-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>scala-oriented <a href="https://travis-ci.org/ThomasMeijers/scala-oriented" target="_blank"><img src="https://camo.githubusercontent.com/8ec9879edc6b86c7d42e628e6e271902b61ef1ca/68747470733a2f2f7472617669732d63692e6f72672f54686f6d61734d65696a6572732f7363616c612d6f7269656e7465642e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/ThomasMeijers/scala-oriented.svg?branch=master" style="max-width:100%;"></a></h1> 
  <p><strong><em>scala-oriented</em></strong> is a Scala wrapper for the OrientDB Java API, <em>oriented</em> on functional and typeful programming. The library uses the extended SQL queries and commands from the Java API, encapsulating side-effect and queries resulting in meaningful types. </p> 
  <h2><a id="user-content-quickstart" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#quickstart" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quickstart</h2> 
  <p>Releases and dependencies are shown below.</p> 
  <table>
   <thead> 
    <tr> 
     <th align="center">scala-oriented</th> 
     <th align="center">status</th> 
     <th align="center">JDK</th> 
     <th align="center">scala</th> 
     <th align="center">Graph-DB</th> 
     <th align="center">Server</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td align="center">0.1</td> 
     <td align="center">unstable</td> 
     <td align="center">1.8</td> 
     <td align="center">2.10 &amp; 2.11</td> 
     <td align="center">2.2.7</td> 
     <td align="center">2.2.7</td> 
    </tr> 
   </tbody>
  </table> 
  <p><em>Note that scala-orient is still in very early development and will undergo many changes.</em></p> 
  <p>To use scala-oriented add the following library dependency to your <code>build.sbt</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.itsmeijers<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scala-oriented<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Two imports are advised to use scala-orient (the rest of this readme assumes that these imports are in scope).</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">oriented.</span><span class="pl-v">_        </span><span class="pl-c"><span class="pl-c">//</span> Imports all required types</span>
<span class="pl-k">import</span> <span class="pl-v">oriented.syntax.</span><span class="pl-v">_ </span><span class="pl-c"><span class="pl-c">//</span> Imports syntax to work with scala-oriented</span></pre>
  </div> 
  <p>The API Docs can be found at <a href="http://itsmeijers.com/docs/scala-oriented/" target="_blank">itsmeijers.com/docs/scala-oriented/</a>.</p> 
  <h2><a id="user-content-common-use-cases" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#common-use-cases" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Common Use Cases</h2> 
  <p>The next sections will show code examples of common use cases, using scala-oriented. This is intended to show how the library should be used. In the examples a <em>"Twitter like"</em> graph structure will be shown, the following case classes need to be defined to follow along with the examples.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">java.util.</span><span class="pl-v">Date</span>

<span class="pl-c"><span class="pl-c">//</span> Data definitions of the Vertices</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">User</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">description</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Tweet</span>(<span class="pl-v">content</span>: <span class="pl-k">String</span>, <span class="pl-v">postDate</span>: <span class="pl-en">Date</span>)

<span class="pl-c"><span class="pl-c">//</span> Date definitions of the Edges  </span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Follows</span>(<span class="pl-v">from</span>: <span class="pl-en">Date</span>)
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Tweets</span></pre>
  </div> 
  <h3><a id="user-content-orientclient" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#orientclient" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>OrientClient</h3> 
  <p>For connections with OrientDB an <code>OrientClient</code> needs to be implicitly in scope when an action is ran. There are three types of OrientClients; <code>InMemoryClient</code>, <code>PLocalClient</code> and <code>RemoteClient</code>. For demonstration purposes the local client is used, however inialization of PLocal and Remote are almost identical.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">client</span><span class="pl-k">:</span> <span class="pl-en">OrientClient</span> <span class="pl-k">=</span> <span class="pl-en">InMemoryClient</span>(db <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>TestDB<span class="pl-pds">"</span></span>) </pre>
  </div> 
  <h3><a id="user-content-orientformat-typeclass" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#orientformat-typeclass" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>OrientFormat Typeclass</h3> 
  <p>For now, each vertex and edge needs to have its own <code>OrientFormat</code> instance (I hope to provide automatic derivation in the very near future), that needs to be implicitly in scope. The typeclass instances provide the needed information to read/write case classes to/from OrientDB.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">userFormat</span><span class="pl-k">:</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">User</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">User</span>] {
  <span class="pl-k">def</span> <span class="pl-en">name</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>User<span class="pl-pds">"</span></span>

  <span class="pl-k">def</span> <span class="pl-en">properties</span>(<span class="pl-v">user</span>: <span class="pl-en">User</span>)<span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>] <span class="pl-k">=</span> 
    <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> user.name, <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> user.description)

  <span class="pl-k">def</span> <span class="pl-en">read</span><span class="pl-k">:</span> <span class="pl-en">OrientRead</span>[<span class="pl-en">User</span>] <span class="pl-k">=</span>
    <span class="pl-k">for</span> {
      name        <span class="pl-k">&lt;</span><span class="pl-k">-</span> readString(<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>)
      description <span class="pl-k">&lt;</span><span class="pl-k">-</span> readString(<span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span>)
    } <span class="pl-k">yield</span> <span class="pl-en">User</span>(name, description)
}

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">tweetFormat</span><span class="pl-k">:</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">Tweet</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">Tweet</span>] {
  <span class="pl-k">def</span> <span class="pl-en">name</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Tweet<span class="pl-pds">"</span></span>

  <span class="pl-k">def</span> <span class="pl-en">properties</span>(<span class="pl-v">tweet</span>: <span class="pl-en">Tweet</span>)<span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>] <span class="pl-k">=</span> 
    <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> tweet.content, <span class="pl-s"><span class="pl-pds">"</span>postDate<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> tweet.postDate)

  <span class="pl-k">def</span> <span class="pl-en">read</span><span class="pl-k">:</span> <span class="pl-en">OrientRead</span>[<span class="pl-en">Tweet</span>] <span class="pl-k">=</span>
    <span class="pl-k">for</span> {
      content  <span class="pl-k">&lt;</span><span class="pl-k">-</span> readString(<span class="pl-s"><span class="pl-pds">"</span>content<span class="pl-pds">"</span></span>)
      postDate <span class="pl-k">&lt;</span><span class="pl-k">-</span> readDatetime(<span class="pl-s"><span class="pl-pds">"</span>postDate<span class="pl-pds">"</span></span>)
    } <span class="pl-k">yield</span> <span class="pl-en">Tweet</span>(content, postDate)
}

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">followsFormat</span><span class="pl-k">:</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">Follows</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">Follows</span>] {
  <span class="pl-k">def</span> <span class="pl-en">name</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Follows<span class="pl-pds">"</span></span>

  <span class="pl-k">def</span> <span class="pl-en">properties</span>(<span class="pl-v">follows</span>: <span class="pl-en">Follows</span>)<span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>from<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> follows.from)

  <span class="pl-k">def</span> <span class="pl-en">read</span><span class="pl-k">:</span> <span class="pl-en">OrientRead</span>[<span class="pl-en">Follows</span>] <span class="pl-k">=</span> readDatetime(<span class="pl-s"><span class="pl-pds">"</span>from<span class="pl-pds">"</span></span>).map(<span class="pl-en">Follows</span>)
}

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">tweetsFormat</span><span class="pl-k">:</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">Tweets</span>.type] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">OrientFormat</span>[<span class="pl-en">Tweets</span>.type] {
  <span class="pl-k">def</span> <span class="pl-en">name</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Tweets<span class="pl-pds">"</span></span>

  <span class="pl-k">def</span> <span class="pl-en">properties</span>(<span class="pl-v">tweets</span>: <span class="pl-en">Tweets</span>.type)<span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-en">Any</span>] <span class="pl-k">=</span> <span class="pl-en">Map</span>()

  <span class="pl-k">def</span> <span class="pl-en">read</span><span class="pl-k">:</span> <span class="pl-en">OrientRead</span>[<span class="pl-en">Tweets</span>.type] <span class="pl-k">=</span> read(<span class="pl-en">Tweets</span>)
}</pre>
  </div> 
  <p>As can be seen in the examples, the name represents the name of the Vertex or Edge. Properties is a function from the model to a Map where the keys are the fieldnames of the class and the values are the corresponding value of the model. Read needs an <code>OrientRead</code> instance of the model. An <code>OrientRead</code> can be constructed using the read functions, where each supported type in OrientDB has a read function. The <code>read</code> function can be used for objects or fieldless case classes, to lift the value into <code>OrientRead</code>. Each read function returns an <code>OrientRead</code>, that can be sequenced together to the model (using map, flatMap or for-comprehension). These format instances are much boilerplate, and will be changed soon into automatic derivation.</p> 
  <h3><a id="user-content-running-orientio" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#running-orientio" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running OrientIO</h3> 
  <p>Each action that is build to be sent to OrientDB is of type <code>OrientIO[A]</code>, where <code>A</code> is the result type of the graph action(s). To run these actions (and actually execute them) different functions can be used, encapsulating side effect in different ways. Each function also handles the opening/closing of the graph instances and commits plus rollbacks (on errors) when transactions are enabled.</p> 
  <p>The <code>runGraph</code> function runs the <code>OrientIO[A]</code> in a safe manner, resulting in an <code>Either[Throwable, A]</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> transaction is enabled by default</span>
<span class="pl-k">val</span> <span class="pl-en">e</span><span class="pl-k">:</span> <span class="pl-en">Either</span>[<span class="pl-en">Throwable</span>, <span class="pl-en">User</span>] <span class="pl-k">=</span> orientIO.runGraph 
<span class="pl-c"><span class="pl-c">//</span> without transactions  </span>
<span class="pl-k">val</span> <span class="pl-en">eNoTx</span><span class="pl-k">:</span> <span class="pl-en">Either</span>[<span class="pl-en">Throwable</span>, <span class="pl-en">User</span>] <span class="pl-k">=</span> orientIO.runGraph(enableTransaction <span class="pl-k">=</span> <span class="pl-c1">false</span>)</pre>
  </div> 
  <p>Below an overview of each function available on <code>OrientIO[A]</code> for running the actions. Transactions are enabled by default, for running the graph actions without transactions set the <code>enableTransactions</code> parameter to <code>false</code>. </p> 
  <table>
   <thead> 
    <tr> 
     <th>Function</th> 
     <th>Return type</th> 
     <th>Description</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>runGraph</td> 
     <td>Either[Throwable, A]</td> 
     <td>Runs the graph action(s) safely</td> 
    </tr> 
    <tr> 
     <td>runGraphUnsafe</td> 
     <td>A</td> 
     <td>Runs the graph actions(s) unsafely, this can throw errors (adviced to only use in tests)</td> 
    </tr> 
    <tr> 
     <td>tryGraphRun</td> 
     <td>Try[A]</td> 
     <td>Runs the graph action(s) safely, encapsulating side effect in a Try.</td> 
    </tr> 
    <tr> 
     <td>runGraphAsync*</td> 
     <td>EitherT[Future, Throwable, A]</td> 
     <td>Runs the graph action(s) asynchronously and safe</td> 
    </tr> 
    <tr> 
     <td>runGraphAsyncUnsafe*</td> 
     <td>Future[A]</td> 
     <td>Runs the graph action(s) asynchronously but unsafe</td> 
    </tr> 
   </tbody>
  </table> 
  <p><strong>* Experimental feature: OrientDB elements are not thread-safe.</strong></p> 
  <h3><a id="user-content-creating-a-vertextype" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#creating-a-vertextype" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Creating a VertexType</h3> 
  <p>Vertex schemas <em>can</em> be created before inserting any vertices, resulting in an <code>VertexType[A]</code>, where <code>A</code> is the vertex model. The <code>createVertexType[A]</code> function is available on the client.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Create a VertexType of type User (OrientFormat[User] needs to be implicitly in scope)</span>
<span class="pl-k">val</span> <span class="pl-en">uType</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[<span class="pl-en">VertexType</span>[<span class="pl-en">User</span>]] <span class="pl-k">=</span> client.createVertexType[<span class="pl-en">User</span>]

<span class="pl-c"><span class="pl-c">//</span> OrientIO Actions can be sequenced</span>
<span class="pl-k">val</span> <span class="pl-en">vTypes</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[(<span class="pl-en">VertexType</span>[<span class="pl-en">User</span>], <span class="pl-en">VertexType</span>[<span class="pl-en">Tweet</span>])] <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    userType  <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.createVertexType[<span class="pl-en">User</span>]
    tweetType <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.createVertexType[<span class="pl-en">Tweet</span>]
  } <span class="pl-k">yield</span> (userType, tweetType)

<span class="pl-c"><span class="pl-c">//</span> Running the action</span>
<span class="pl-k">val</span> <span class="pl-en">vTypesResult</span><span class="pl-k">:</span> (<span class="pl-en">VertexType</span>[<span class="pl-en">User</span>], <span class="pl-en">VertexType</span>[<span class="pl-en">Tweet</span>]) <span class="pl-k">=</span> 
    vertexTypes.runGraphUnsafe(enableTransactions <span class="pl-k">=</span> <span class="pl-c1">false</span>)

println(vTypesResult)
<span class="pl-c"><span class="pl-c">//</span> [info] (VertexType(User),VertexType(Tweet))</span></pre>
  </div> 
  <h3><a id="user-content-adding-a-vertex" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#adding-a-vertex" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adding a Vertex</h3> 
  <p>Adding a Vertex is done by calling the <code>addVertex[A](a: A)</code> function from the client, where <code>A</code> is the vertex you want to save to OrientDB. It results in a <code>Vertex[A]</code>, when running the graph action. Vertex is a typeclass, that provides typed functions to the OrientVertex element. You can access the model in the <code>element</code> property. For the the functions on Vertex, see the API Docs or your favourite auto-completion.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Adding a single Vertex</span>
<span class="pl-k">val</span> <span class="pl-en">user</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>]] <span class="pl-k">=</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Thom<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Noobgrammer<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">userResult</span><span class="pl-k">:</span> <span class="pl-en">Vertex</span>[<span class="pl-en">User</span>] <span class="pl-k">=</span> user.runGraphUnsafe

println(userResult)
<span class="pl-c"><span class="pl-c">//</span> [info] Vertex(User(Thomas,Noobgrammer),v(User)[#25:0])</span>

<span class="pl-c"><span class="pl-c">//</span> Sequence off adding vertices</span>
<span class="pl-k">val</span> <span class="pl-en">users</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[<span class="pl-en">List</span>[<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>]]] <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    joe    <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Manager<span class="pl-pds">"</span></span>))
    bob    <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Bob<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Programmer<span class="pl-pds">"</span></span>))
    elodie <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Elodie<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Programmer<span class="pl-pds">"</span></span>))
  } <span class="pl-k">yield</span> <span class="pl-en">List</span>(joe, bob, elodie)

<span class="pl-k">val</span> <span class="pl-en">usersResult</span><span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>]] <span class="pl-k">=</span> users.runGraphUnsafe

usersResult.foreach(println)
<span class="pl-c"><span class="pl-c">//</span> [info] Vertex(User(Joe,Manager),v(User)[#26:0])</span>
<span class="pl-c"><span class="pl-c">//</span> [info] Vertex(User(Bob,Programmer),v(User)[#27:0])</span>
<span class="pl-c"><span class="pl-c">//</span> [info] Vertex(User(Elodie,Programmer),v(User)[#28:0])</span></pre>
  </div> 
  <h3><a id="user-content-creating-an-edgetype" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#creating-an-edgetype" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Creating an EdgeType</h3> 
  <p>Same as <code>VertexType</code>, only for edges. Returns an <code>EdgeType[A]</code>, where <code>A</code> is the edge model.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">eTypes</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[(<span class="pl-en">EdgeType</span>[<span class="pl-en">Tweets</span>], <span class="pl-en">EdgeType</span>[<span class="pl-en">Follows</span>])] <span class="pl-k">=</span> 
  <span class="pl-k">for</span> {
    tweetsType  <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.createEdgeType[<span class="pl-en">Tweets</span>.type]
    followsType <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.createEdgeType[<span class="pl-en">Follows</span>]  
  } <span class="pl-k">yield</span> (tweetsType, followsType)

<span class="pl-k">val</span> <span class="pl-en">eTypesResult</span><span class="pl-k">:</span> (<span class="pl-en">EdgeType</span>[<span class="pl-en">Tweets</span>.type], <span class="pl-en">EdgeType</span>[<span class="pl-en">Follows</span>]) <span class="pl-k">=</span> 
  eTypes.runGraphUnsafe(enableTransactions <span class="pl-k">=</span> <span class="pl-c1">false</span>)

println(eTypesResult)
<span class="pl-c"><span class="pl-c">//</span> [info] (EdgeType(Tweets),EdgeType(Follows))</span></pre>
  </div> 
  <h3><a id="user-content-adding-an-edge" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#adding-an-edge" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adding an Edge</h3> 
  <p>An edge gets created between to vertices, by calling the <code>addEdge(edgeModel: A, inVertex[Vertex[B]], outVertex: Vertex[C])</code> function on client. The Edge typeclass is similair to the Vertex typeclass, but represents a typed Edge. The Edge model can be retrieved from the <code>element</code> property. The <code>Edge</code> typeclass currently has four functions: <code>getInVertex</code>, <code>getOutVertex</code>, <code>getVertices</code> (which is a combination of in and out) and <code>update(newModel: A)</code> (See updating Updating Vertices &amp; Edges).</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> User vertices taken from previous example</span>
<span class="pl-k">val</span> <span class="pl-en">thomasFollowsJoe</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[<span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>]] <span class="pl-k">=</span>
    client.addEdge(<span class="pl-en">Follows</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>()), userResult, usersResult.head)

<span class="pl-k">val</span> <span class="pl-en">tFollowsJResult</span><span class="pl-k">:</span> <span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>] <span class="pl-k">=</span> thomasFollowsJoe.runGraphUnsafe

println(tFollowsJResult)
<span class="pl-c"><span class="pl-c">//</span> [info] Edge(Follows(Mon Oct 03 15:00:42 CEST 2016),e[#49:0][#26:0-Follows-&gt;#25:0])</span></pre>
  </div> 
  <h3><a id="user-content-adding-an-edge-from-the-vertex-typeclass" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#adding-an-edge-from-the-vertex-typeclass" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adding an Edge from the Vertex Typeclass</h3> 
  <p>An edge can also be added from a Vertex instance, by calling the<code>addVertex(edgeModel: A, outVertex: Vertex[B]): Edge[C]</code> function. The function will return the created edge between the in and out vertices. Below are a couple of examples shown of creating vertices and edges.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Vertex[User] -- Edge[Follows] --&gt; Vertex[User]</span>
<span class="pl-k">val</span> <span class="pl-en">userFollowsUser</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[(<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>], <span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>], <span class="pl-en">Vertex</span>[<span class="pl-en">User</span>])] <span class="pl-k">=</span> 
  <span class="pl-k">for</span> {
    bert    <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Bert<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>DevOps<span class="pl-pds">"</span></span>))
    ernie   <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Ernie<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Manager<span class="pl-pds">"</span></span>))
    follows <span class="pl-k">&lt;</span><span class="pl-k">-</span> bert.addEdge(<span class="pl-en">Follows</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>()), ernie)
  } <span class="pl-k">yield</span> (bert, follows, ernie)

<span class="pl-k">val</span> <span class="pl-en">ufuResult</span><span class="pl-k">:</span> (<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>], <span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>], <span class="pl-en">Vertex</span>[<span class="pl-en">User</span>]) <span class="pl-k">=</span> 
  userFollowsUser.runGraphUnsafe

println(ufuResult)
<span class="pl-c"><span class="pl-c">//</span> [info] (Vertex(User(Bert,DevOps),v(User)[#25:1]),Edge(Follows(Mon Oct 03 19:31:03 CEST 2016),e[#53:0][#25:1-Follows-&gt;#26:1]),Vertex(User(Ernie,Manager),v(User)[#26:1]))</span>

<span class="pl-c"><span class="pl-c">//</span> Vertex[User] -- Edge[Tweets] --&gt; Vertex[Tweet]  </span>
<span class="pl-k">val</span> <span class="pl-en">userTweetsTweet</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[(<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>], <span class="pl-en">Edge</span>[<span class="pl-en">Tweets</span>.type], <span class="pl-en">Vertex</span>[<span class="pl-en">Tweet</span>])] <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    user   <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Erik<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>FP<span class="pl-pds">"</span></span>))
    tweet  <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">Tweet</span>(<span class="pl-s"><span class="pl-pds">"</span>Developers talk semicolons<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-en">Date</span>()))
    tweets <span class="pl-k">&lt;</span><span class="pl-k">-</span> user.addEdge(<span class="pl-en">Tweets</span>, tweet)
  } <span class="pl-k">yield</span> (user, tweets, tweet)

<span class="pl-k">val</span> <span class="pl-en">uttResult</span><span class="pl-k">:</span> (<span class="pl-en">Vertex</span>[<span class="pl-en">User</span>], <span class="pl-en">Edge</span>[<span class="pl-en">Tweets</span>.type], <span class="pl-en">Vertex</span>[<span class="pl-en">Tweet</span>]) <span class="pl-k">=</span>
  userTweetsTweet.runGraphUnsafe

println(uttResult)    
<span class="pl-c"><span class="pl-c">//</span> [info] (Vertex(User(Erik,FP),v(User)[#27:1]),Edge(Tweets,e[#41:0][#27:1-Tweets-&gt;#33:0]),Vertex(Tweet(Developers talk semicolons,Mon Oct 03 19:39:19 CEST 2016),v(Tweet)[#33:0]))</span>

<span class="pl-c"><span class="pl-c">//</span> Vertex[User] &lt;-- Edge[Follows] --&gt; Vertex[User]</span>
<span class="pl-k">val</span> <span class="pl-en">bidirectionalFollow</span><span class="pl-k">:</span> <span class="pl-en">OrientIO</span>[(<span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>], <span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>])] <span class="pl-k">=</span> 
  <span class="pl-k">for</span> {
    hank      <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Hank<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Developer<span class="pl-pds">"</span></span>))
    suzan     <span class="pl-k">&lt;</span><span class="pl-k">-</span> client.addVertex(<span class="pl-en">User</span>(<span class="pl-s"><span class="pl-pds">"</span>Suzan<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Developer<span class="pl-pds">"</span></span>))
    hFollowsS <span class="pl-k">&lt;</span><span class="pl-k">-</span> hank.addEdge(<span class="pl-en">Follows</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>()), suzan)
    sFollowsH <span class="pl-k">&lt;</span><span class="pl-k">-</span> suzan.addEdge(<span class="pl-en">Follows</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>()), hank)
  } <span class="pl-k">yield</span> (hFollowsS, sFollowsH)

<span class="pl-k">val</span> <span class="pl-en">bidirectionalResult</span><span class="pl-k">:</span> (<span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>], <span class="pl-en">Edge</span>[<span class="pl-en">Follows</span>]) <span class="pl-k">=</span>
  bidirectionalFollow.runGraphUnsafe

println(bidirectionalResult)
<span class="pl-c"><span class="pl-c">//</span> [info] (Edge(Follows(Mon Oct 03 15:16:48 CEST 2016),e[#50:0][#29:0-Follows-&gt;#30:0]),Edge(Follows(Mon Oct 03 15:16:48 CEST 2016),e[#51:0][#30:0-Follows-&gt;#29:0]))</span></pre>
  </div> 
  <h3><a id="user-content-querying-simple-types" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#querying-simple-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Querying Simple Types</h3> 
  <p>If the result type of an OrientResult is a simple type such as <code>String</code> or <code>Int</code>, then there is no need to write a special <code>OrientFormat</code> instance for these types. Instead of using the vertex or edge function on the sql query, use the <code>as[A](field)</code> function where <code>A</code> is the simple type and field is the <code>String</code> representing the field that you want to select as the simple type.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">numberOfUsers</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> sql<span class="pl-s"><span class="pl-pds">"</span>SELECT COUNT(*) as count FROM User<span class="pl-pds">"</span></span>
  .as[<span class="pl-k">Long</span>](<span class="pl-s"><span class="pl-pds">"</span>count<span class="pl-pds">"</span></span>)
  .runGraphUnsafe

println(numberOfUsers)
<span class="pl-c"><span class="pl-c">//</span> [info] 11 </span></pre>
  </div> 
  <h3><a id="user-content-querying" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#querying" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Querying</h3> 
  <p>SQL queries can be contstructed using the <code>sql</code> interpolation modifier.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">sqlStatement</span><span class="pl-k">:</span> <span class="pl-en">SQLStatement</span> <span class="pl-k">=</span> sql<span class="pl-s"><span class="pl-pds">"</span>SELECT * FROM User<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>This creates a SQLStatement object which has the following function showed in the table below.</p> 
  <table>
   <thead> 
    <tr> 
     <th>Function</th> 
     <th>Return Type</th> 
     <th>Description</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td><code>vertex[A]</code></td> 
     <td><code>VertexQuery[A]</code></td> 
     <td>Creates a query that will result in a <code>Vertex[A]</code>.</td> 
    </tr> 
    <tr> 
     <td><code>edge[A]</code></td> 
     <td><code>EdgeQuery[A]</code></td> 
     <td>Creates a query that will result in an <code>Edge[A]</code></td> 
    </tr> 
    <tr> 
     <td><code>update</code></td> 
     <td><code>Unit</code></td> 
     <td>Creates a query that will result in Unit.</td> 
    </tr> 
    <tr> 
     <td><code>as[A](field: String)</code></td> 
     <td><code>OrientIO[A]</code></td> 
     <td>See Querying Simple Types.</td> 
    </tr> 
   </tbody>
  </table> 
  <p>The <code>vertex[A]</code> and <code>edge[A]</code> function return a <code>VertexQuery[A]</code> or <code>EdgeQuery[A]</code> that needs one more function call to specify its context, resulting in an <code>OrientIO[R]</code>, where <code>R</code> is for instance <code>Option[Vertex[A]]</code>.</p> 
  <table>
   <thead> 
    <tr> 
     <th align="left">Function</th> 
     <th>Vertex Return Type</th> 
     <th>Edge Return Type</th> 
     <th>Description</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td align="left"><code>unique</code></td> 
     <td><code>Vertex[A]</code></td> 
     <td><code>Edge[A]</code></td> 
     <td>Returns a unique element.</td> 
    </tr> 
    <tr> 
     <td align="left"><code>option</code></td> 
     <td><code>Option[Vertex[A]]</code></td> 
     <td><code>Option[Edge[A]]</code></td> 
     <td>Returns a optional element. If there are more than one elements only the first gets returned as a Some.</td> 
    </tr> 
    <tr> 
     <td align="left"><code>nel</code></td> 
     <td><code>NonEmptyList[Vertex[A]]</code></td> 
     <td><code>NonEmptyList[Edge[A]]</code></td> 
     <td>Returns a non empty list.</td> 
    </tr> 
    <tr> 
     <td align="left"><code>list</code></td> 
     <td><code>List[Vertex[A]]</code></td> 
     <td><code>List[Edge[A]]</code></td> 
     <td>Returns a list.</td> 
    </tr> 
   </tbody>
  </table> 
  <h3><a id="user-content-querying-vertices-examples" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#querying-vertices-examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Querying Vertices Examples</h3> 
  <p>Below are some examples shown of querying vertices.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">TODO</span></pre>
  </div> 
  <h3><a id="user-content-querying-edges-examples" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#querying-edges-examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Querying Edges Examples</h3> 
  <p>Below are some examples shown of querying edges.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">TODO</span></pre>
  </div> 
  <h3><a id="user-content-updating-vertices--edges" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#updating-vertices--edges" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Updating Vertices &amp; Edges</h3> 
  <p>Below are some examples shown of updating edges and vertices with both queries and functions on the <code>Vertex</code> and <code>Edge</code> typeclasses. Note that the functions return the new vertices and models, where updates on queries do not.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">TODO</span></pre>
  </div> 
  <h2><a id="user-content-documentation-and-support" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#documentation-and-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Documentation and Support</h2> 
  <ul> 
   <li><a href="http://itsmeijers.com/docs/scala-oriented/" target="_blank">API Docs</a></li> 
   <li><a href="http://orientdb.com/docs/last/" target="_blank">OrientDB Documentation</a></li> 
   <li><a href="http://www.orientdb.com" target="_blank">OrientDB.com</a></li> 
   <li>Extended Guide (TODO)</li> 
  </ul> 
  <h2><a id="user-content-feature-list" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#feature-list" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Feature List</h2> 
  <p><em>TODO</em></p> 
  <h2><a id="user-content-contributing" class="anchor" href="https://github.com/thomasmeijers/scala-oriented#contributing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributing</h2> 
  <p><em>TODO</em></p> 
 </article>
</div>