{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":77,
            "title":"Migrate scripted tests that use build.sbt",
            "bodyText":"See the thread starting from sbt#73 (comment).",
            "url":"https://github.com/sbt/zinc/issues/77"
          },
          {
            "number":84,
            "title":"Scripted doesn't support multiprojects",
            "bodyText":"This doesn't let us test multi-project support in incremental compiler.\nMaybe the solution would be to port such tests to be a plain code that calls into IncHandler directly?",
            "url":"https://github.com/sbt/zinc/issues/84"
          },
          {
            "number":119,
            "title":"Don't publish repositories information (at least for releases)",
            "bodyText":"Remove all additional resolvers from build.sbt, at least for releases, because artifacts published to Maven central repository should not contain additional repositories, and in fact don't need them because all dependencies are already in Maven central repo.",
            "url":"https://github.com/sbt/zinc/issues/119"
          },
          {
            "number":123,
            "title":"ArrayStoreException when parsing Java annotation",
            "bodyText":"sbt/sbt#756\n@dotta wrote:\n\nAlright, I actually found a way to reproduce this! (Using sbt 0.13.0)\n\n\nClone https://github.com/dotta/sbt-issue-756 and checkout commit dotta/sbt-issue-756@ddc49b2\n\n\nStart sbt console and then ~test. Compilation should succeed.\n\n\nApply this commit dotta/sbt-issue-756@6c8ffef\n\n\nYou would expect compilation to fail, but it doesn't!\nTo make it fail, you need to clean first.",
            "url":"https://github.com/sbt/zinc/issues/123"
          },
          {
            "number":154,
            "title":"Port the test for warning on transitive macro recompilation, with opt-out",
            "bodyText":"See sbt/sbt#2659. I failed to figure out how to do so in #143.",
            "url":"https://github.com/sbt/zinc/issues/154"
          },
          {
            "number":299,
            "title":"Provide nailgun integration for Zinc",
            "bodyText":"Please add a built-in method to run Zinc server in the background on a Windows environment, preferably with an option to start the server on Windows login (say, a service).\nMy current workaround is quite messy; I have one .bat which runs the server via Git Bash (using the Unix command to start the server), and then another .bat which calls the first .bat from Windows startup directory, which leaves an open cmd window at the end (couldn't work around that).",
            "url":"https://github.com/sbt/zinc/issues/299"
          },
          {
            "number":332,
            "title":"Bring back sbt-header",
            "bodyText":"sbt-header was removed in #323",
            "url":"https://github.com/sbt/zinc/issues/332"
          },
          {
            "number":337,
            "title":"Document how to clean only the analysis file of Zinc",
            "bodyText":"This is a ticket for the Scala Center spree happening at Scala Wave (Gdansk, Poland).\nThe sbt docs do not document the fact that sbt allows you to remove the analysis file in Zinc, without forcing other tasks like dependency resolution to kick in.\nUsually, what people do is to run clean in the root and that means that the next time they compile, dependencies will be resolved and checked, and other tasks that were before cached need to be executed.\nHowever, what most of people don't know, and what the docs don't say, is that if you execute compile / clean, only the analysis file will be removed.\nThe goal of this ticket is to clearly document this in the sbt docs linked at the beginning of this ticket. The docs are in the following repo.\nBy doing this, you will help the community in two regards:\n\nYou will help to clear up a common source of confusion.\nThe documentation can make people's habits more efficient -- less resolution, more time to have coffee or code!\n\nContributing to docs is an important task for OSS projects, and it's really appreciated.",
            "url":"https://github.com/sbt/zinc/issues/337"
          },
          {
            "number":348,
            "title":"Avoid adding a bootclasspath if it already exists",
            "bodyText":"This is ported from sbt/sbt: sbt/sbt#762 (comment).\nIn short: even if there already exists a bootclasspath flag, Zinc adds another bootclasspath entry with the Scala library, effectively disabling the bootclasspath specified by the user. See discussion in the original issue.\nZinc should check if this flag already exists, log that it does, and then assumes that the user is passing in the scala library in the boot classpath. The log shown to the user should explicitly mention this assumption, too.",
            "url":"https://github.com/sbt/zinc/issues/348"
          },
          {
            "number":369,
            "title":"Cached doc is not using Tracked.outputChanged",
            "bodyText":"Related to sbt/util#79\nI noticed that cached doc in https://github.com/sbt/zinc/blob/1.0/zinc-compile/src/main/scala/sbt/inc/Doc.scala is not using Tracked.outputChanged.\nThe fix could wait post RC-1",
            "url":"https://github.com/sbt/zinc/issues/369"
          },
          {
            "number":395,
            "title":"\"sbt '++ 2.13.0-M2!' compile\" does not work with sbt 1.0.0",
            "bodyText":"Originally reported by @xuwei-k as sbt/sbt#3427\n/tmp/sbt_a4c7a1d5/xsbt/ConsoleInterface.scala:11: error: object ILoop is not a member of package scala.tools.nsc.interpreter\nimport scala.tools.nsc.interpreter.{ ILoop, IMain, InteractiveReader }\n       ^\n/tmp/sbt_a4c7a1d5/xsbt/ConsoleInterface.scala:41: error: not found: type ILoop\n    val loop = new ILoop {\n                   ^\nWe need a new compiler bridge for Scala 2.13.\n/cc @lrytz",
            "url":"https://github.com/sbt/zinc/issues/395"
          },
          {
            "number":403,
            "title":"Allow compiler-interface to be set up as a provided dependency",
            "bodyText":"There has been a slight change in how a custom compiler-bridge module must declare its dependency on the sbt compiler-interface. With sbt 0.13, the interface dependency could be scoped as \"provided\", but that is no longer possible with sbt 1.0. In fact, if the compiler-interface is scoped to \"provided\", sbt 1.0 will produce compile time errors when attempting to compile the custom compiler-bridge source jar, because it can't find the types that are defined in the compiler-interface module.\nIn a nutshell, in sbt 0.13 I had the following declaration for my custom compiler-bridge:\nlazy val `custom-compiler-bridge` = (project in file(\"compiler-bridge\"))\n  .settings(\n    libraryDependencies += \"org.scala-sbt\" % \"interface\" % sbtVersion.value % \"provided\", // <-- note the provided scope.\n    ...\n  )\n\nWhile in sbt 1.0 it had to be changed to:\nlazy val `custom-compiler-bridge` = (project in file(\"compiler-bridge\"))\n  .settings(\n    libraryDependencies += \"org.scala-sbt\" % \"compiler-interface\" % ZincVersion, // <-- note the missing provided scope.\n    ...\n  )\n\nI'm opening a ticket as it was demanded by @eed3si9n (https://gitter.im/sbt/sbt-contrib?at=59a4348a76a757f808f0b870)",
            "url":"https://github.com/sbt/zinc/issues/403"
          },
          {
            "number":406,
            "title":"Add a hook to filter out Scala options in every compile",
            "bodyText":"If scala options change from one run to the other one, Zinc recompiles the whole project conservatively.\nWith the advent of compilers like Dotty, Hydra and rsc, the current behaviour is too restrictive because some downstream users may want to filter out scalac options that are dependent to the way compilation should occur (like number of cores). This is safe to do because downstream users know which scala flags affect the compilation and which do not.\nYou can add this hook in ExternalHooks https://github.com/sbt/zinc/blob/1.x/internal/compiler-interface/src/main/java/xsbti/compile/ExternalHooks.java and https://github.com/sbt/zinc/blob/1.x/internal/compiler-interface/src/main/java/xsbti/compile/DefaultExternalHooks.java. The method compile in IncrementalCompilerImpl already takes an instance of IncOptions, which inside has an instance of ExternalHooks, so the last thing to do is to use the external hook we've just provided in the body of makeConfig, inside MixedAnalyzingCompiler: https://github.com/sbt/zinc/blob/1.x/zinc/src/main/scala/sbt/internal/inc/MixedAnalyzingCompiler.scala#L183-L214\n/cc @dragos",
            "url":"https://github.com/sbt/zinc/issues/406"
          },
          {
            "number":415,
            "title":"Javadoc may not logging all the errors",
            "bodyText":"When debugging an instance where javadoc produced the error \"javadoc: error - invalid flag: -target\", this error was not printed on javacLogger.flush(exitCode).\nIt was correctly added to JavacLogger.msgs with level error, so I'd expect parseAndDumpSemanticErrors to fail to parse it and log it instead, not sure why that doesn't appear to be happening.",
            "url":"https://github.com/sbt/zinc/issues/415"
          }
        ]
      }
    }
  }
}