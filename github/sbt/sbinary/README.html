<div class="announce instapaper_body markdown" data-path="README.markdown" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-sbinary" class="anchor" href="https://github.com/sbt/sbinary#sbinary" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SBinary</h1> 
  <p>SBinary is a library for describing binary protocols, in the form of mappings between Scala types and binary formats. It can be used as a robust serialization mechanism for Scala objects or a way of dealing with existing binary formats found in the wild.</p> 
  <p>It started out life as a loose port of Haskell's Data.Binary. It's since evolved a bit from there to take advantage of the features Scala implicits offer over Haskell type classes, but the core idea has remained the same.</p> 
  <h2><a id="user-content-getting-sbinary" class="anchor" href="https://github.com/sbt/sbinary#getting-sbinary" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting SBinary</h2> 
  <p>If you are using sbt with Scala 2.10.x or 2.11.x:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">sbinary</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.scala-sbt<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>sbinary<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.4.3<span class="pl-pds">"</span></span></pre>
  </div> 
  <h2><a id="user-content-credits" class="anchor" href="https://github.com/sbt/sbinary#credits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Credits</h2> 
  <ul> 
   <li>SBinary was written by David MacIver. The following is an instruction written by David.</li> 
  </ul> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/sbt/sbinary#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>The basic entry point to SBinary is the <code>Protocol</code> trait. A Protocol specifies a form of binary IO (although to be honest, you're probably just going to end up using the standard Java implementation for IO) and a number of Formats.</p> 
  <p>Binary formats are specified by the following traits:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">Reads</span>[<span class="pl-en">T</span>]{
  <span class="pl-k">def</span> <span class="pl-en">reads</span>(<span class="pl-v">in</span> : <span class="pl-en">Input</span>) <span class="pl-k">:</span> <span class="pl-en">T</span>
}

<span class="pl-k">trait</span> <span class="pl-en">Writes</span>[<span class="pl-en">T</span>]{
  <span class="pl-k">def</span> <span class="pl-en">writes</span>(<span class="pl-v">out</span> : <span class="pl-en">Output</span>, <span class="pl-v">value</span> : <span class="pl-en">T</span>)
}

<span class="pl-k">trait</span> <span class="pl-en">Format</span>[<span class="pl-en">T</span>] <span class="pl-k">extends</span> <span class="pl-e">Reads</span>[<span class="pl-en">T</span>] <span class="pl-k">with</span> <span class="pl-e">Writes</span>[<span class="pl-en">T</span>]</pre>
  </div> 
  <p>i.e. a format is something that specifies how to read an element from an input source and write an element to an output source.</p> 
  <p>You're not expected to use the reads and writes method directly. Instead Formats are typically made available implicitly and you use the methods</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">read</span>[<span class="pl-en">T</span>](<span class="pl-v">in</span> : <span class="pl-en">Input</span>)(<span class="pl-k">implicit</span> <span class="pl-v">reader</span> : <span class="pl-en">Reads</span>[<span class="pl-en">T</span>]) <span class="pl-k">=</span> reader.reads(in)
<span class="pl-k">def</span> <span class="pl-en">write</span>[<span class="pl-en">T</span>](<span class="pl-v">out</span> : <span class="pl-en">Output</span>, <span class="pl-v">value</span> : <span class="pl-en">T</span>)(<span class="pl-k">implicit</span> <span class="pl-v">writer</span> : <span class="pl-en">Writes</span>[<span class="pl-en">T</span>]) <span class="pl-k">=</span> writer.writes(out, value)</pre>
  </div> 
  <p>The example interactive sessions are self-contained. Other example code assumes these imports:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">sbinary.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">DefaultProtocol.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">Operations.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>The example code is available as a runnable project. If you have checked out the SBinary project and have sbt installed, run the examples by executing the following in the root directory:</p> 
  <pre><code>$ sbt publishLocal 'project treeExample' run
</code></pre> 
  <h3><a id="user-content-the-default-protocol" class="anchor" href="https://github.com/sbt/sbinary#the-default-protocol" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>The Default Protocol</h3> 
  <p>You're expected to define your own protocol for most uses of SBinary in order to serialize your own types. However for getting started and for simple uses SBinary provides a default protocol which lets you serialize most standard library types out of the box. It uses Java IO, but all the types it defines are available in traits if you want to use a different IO mechanism.</p> 
  <p>So, let's see some examples of how to use this:</p> 
  <pre><code>scala&gt; import sbinary.DefaultProtocol._
import sbinary.DefaultProtocol._

scala&gt; List("foo", "bar", "baz")
res0: List[java.lang.String] = List(foo, bar, baz)

scala&gt; toByteArray(res0)
res1: Array[Byte] = Array(0, 0, 0, 3, 0, 3, 102, 111, 111, 0, 3, 98, 97, 114, 0, 3, 98, 97, 122)

scala&gt; fromByteArrayList[String]
res3: List[String] = List(foo, bar, baz)
</code></pre> 
  <p>Straightforward enough. There's also some helper stuff for writing to files:</p> 
  <pre><code>scala&gt; toFile(res0)(new java.io.File("foo.bin"))

scala&gt; fromFile[List[String]](new java.io.File("foo.bin")) 
res7: List[String] = List(foo, bar, baz)
</code></pre> 
  <p>Curious fact:</p> 
  <pre><code>scala&gt; fromFile[Array[String]](new java.io.File("foo.bin"))
res8: Array[String] = Array(foo, bar, baz)
</code></pre> 
  <p>Note that this is the same file we just wrote as a <code>ListString</code> and we've just read it as an <code>ArrayString</code>!</p> 
  <p>In general, SBinary formats aim to be as straightforward as possible. Formats for similar things tend to be the same. Consequently most of the time you have a fair bit of flexibility as to whether you write things as the same type you read them as.</p> 
  <h3><a id="user-content-defining-your-own-protocols" class="anchor" href="https://github.com/sbt/sbinary#defining-your-own-protocols" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Defining your own protocols</h3> 
  <p>One way to use SBinary would just be to use the default protocol and extend the Format type it provides. This is perfectly effective, but not really the best way.</p> 
  <p>The idea is that your usage of SBinary defines a protocol for binary formats. Two different protocols might define very different formats for the same type, and as long as both are creating formats in the default protocol there's no way to distinguish between them.</p> 
  <p>Lest this sound like an obscure theoretical possibility, please consider just how many character encodings for strings there are (in fact, a very large part of the motivation for the move to protocols in 0.3 was the fact that I didn't want to force the standard Java UTF format to be used everywhere).</p> 
  <p>So, the idea is that you define a protocol. For simplicitly, let's make it a single object. We'll look into how you might modularise it later.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyProtocol</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultProtocol</span>{ }</pre>
  </div> 
  <p>(There is a trait <code>DefaultProtocol</code> as well. The <code>DefaultProtocol</code> object simply extends it and adds no additional methods).</p> 
  <p>Great. We have a protocol. It does exactly the same as the default one. But that's a start.</p> 
  <p>Now, we need something to write to it. Let's consider a simple binary tree type where the leafs are annotated by strings.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">BT</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Bin</span>(<span class="pl-v">left</span>: <span class="pl-en">BT</span>, <span class="pl-v">right</span>: <span class="pl-en">BT</span>) <span class="pl-k">extends</span> <span class="pl-e">BT</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Leaf</span>(<span class="pl-v">label</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">BT</span></pre>
  </div> 
  <p>How could we define a format for this?</p> 
  <p>Let's start by thinking about how we read this off a stream of bytes.</p> 
  <p>We first need something to distinguish what we're reading. i.e. we need to know whether we have a <code>Bin</code> or a <code>Leaf</code>. So let's start with a marker byte: If it's <code>0</code>, we have a <code>Bin</code>, otherwise we have a <code>Leaf</code>.</p> 
  <p>So, now we know whether we're reading a <code>Bin</code> or a <code>Leaf</code>. What do we do now? Easy. If we have a Bin, then we read one BT, then another. If we have a Leaf, we read a string. We then assemble these in the obvious way:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyProtocol</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultProtocol</span>{
  <span class="pl-k">implicit</span> <span class="pl-k">object</span> <span class="pl-en">BTFormat</span> <span class="pl-k">extends</span> <span class="pl-e">Format</span>[<span class="pl-en">BT</span>]{
    <span class="pl-k">def</span> <span class="pl-en">reads</span>(<span class="pl-v">in</span>: <span class="pl-en">Input</span>) <span class="pl-k">=</span> readByte <span class="pl-k">match</span> {
      <span class="pl-k">case</span> <span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Bin</span>(reads(in), reads(in))
      <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-en">Leaf</span>(readString)
    }

    <span class="pl-k">def</span> <span class="pl-en">writes</span>(<span class="pl-v">out</span> : <span class="pl-en">Output</span>, <span class="pl-v">value</span> : <span class="pl-en">BT</span>) <span class="pl-k">=</span> sys.error(<span class="pl-s"><span class="pl-pds">"</span>What do I do here?<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>Pretty straightforward. And once we've written that, it becomes obvious what to do for the <code>write</code> method:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyProtocol</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultProtocol</span>{
  <span class="pl-k">implicit</span> <span class="pl-k">object</span> <span class="pl-en">BTFormat</span> <span class="pl-k">extends</span> <span class="pl-e">Format</span>[<span class="pl-en">BT</span>] {
    <span class="pl-k">def</span> <span class="pl-en">reads</span>(<span class="pl-v">in</span>: <span class="pl-en">Input</span>) <span class="pl-k">=</span> readByte <span class="pl-k">match</span> {
      <span class="pl-k">case</span> <span class="pl-c1">0</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Bin</span>(reads(in), reads(in))
      <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-en">Leaf</span>(readString)
    }

    <span class="pl-k">def</span> <span class="pl-en">writes</span>(<span class="pl-v">out</span> : <span class="pl-en">Output</span>, <span class="pl-v">value</span> : <span class="pl-en">BT</span>) <span class="pl-k">=</span> value <span class="pl-k">match</span> {
      <span class="pl-k">case</span> <span class="pl-en">Bin</span>(left, right) <span class="pl-k">=&gt;</span>
        write[<span class="pl-k">Byte</span>](out, <span class="pl-c1">0</span>)
        writes(out, left)
        writes(out, right)
      <span class="pl-k">case</span> <span class="pl-en">Leaf</span>(label) <span class="pl-k">=&gt;</span>
        write[<span class="pl-k">Byte</span>](out, <span class="pl-c1">1</span>)
        write(out, label)
    }
  }
}</pre>
  </div> 
  <p>Now we can use this just like we would the default protocol:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">MyProtocol.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">MyProtocol.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-en">Bin</span>(<span class="pl-en">Leaf</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>), <span class="pl-en">Bin</span>(<span class="pl-en">Leaf</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>), <span class="pl-en">Leaf</span>(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>)))
res0<span class="pl-k">:</span> <span class="pl-en">Bin</span> <span class="pl-k">=</span> <span class="pl-en">Bin</span>(<span class="pl-en">Leaf</span>(foo),<span class="pl-en">Bin</span>(<span class="pl-en">Leaf</span>(bar),<span class="pl-en">Leaf</span>(baz)))

scala<span class="pl-k">&gt;</span> toByteArrayBT
res2<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">102</span>, <span class="pl-c1">111</span>, <span class="pl-c1">111</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">98</span>, <span class="pl-c1">97</span>, <span class="pl-c1">114</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">98</span>, <span class="pl-c1">97</span>, <span class="pl-c1">122</span>)

scala<span class="pl-k">&gt;</span> fromByteArrayBT
res3<span class="pl-k">:</span> <span class="pl-en">BT</span> <span class="pl-k">=</span> <span class="pl-en">Bin</span>(<span class="pl-en">Leaf</span>(foo),<span class="pl-en">Bin</span>(<span class="pl-en">Leaf</span>(bar),<span class="pl-en">Leaf</span>(baz)))</pre>
  </div> 
  <p>See, wasn't that easy? Perfectly straightforward to define a binary format, right?</p> 
  <p>Right?</p> 
  <h3><a id="user-content-generic-format-construction" class="anchor" href="https://github.com/sbt/sbinary#generic-format-construction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Generic format construction</h3> 
  <p>Ok, it wasn't particularly easy. In fact, it was massively verbose. I don't know about you, but I'd get pretty sick of writing things like the above. And I'd almost certainly make mistakes (of course, I didn't make any mistakes in SBinary, because I'm amazing. But in theory I might make mistakes. Particularly if I didn't use a lot of scalacheck tests to make sure I didn't).</p> 
  <p>So, let's write this a bit differently:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyProtocol</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultProtocol</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">BTFormat</span><span class="pl-k">:</span> <span class="pl-en">Format</span>[<span class="pl-en">BT</span>] <span class="pl-k">=</span> lazyFormat(asUnion[<span class="pl-en">BT</span>](
    asProduct2(<span class="pl-en">Bin</span>)(<span class="pl-en">Bin</span>.unapply(_).get),
    wrap[<span class="pl-en">Leaf</span>, <span class="pl-k">String</span>](_.label, <span class="pl-en">Leaf</span>)))
}</pre>
  </div> 
  <p>Which is rather nicer (not to mention shorter) I feel!</p> 
  <p>Let's unpack how this works through some simpler examples (we're going to do this in the the REPL).</p> 
  <h4><a id="user-content-wrapping-formats" class="anchor" href="https://github.com/sbt/sbinary#wrapping-formats" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Wrapping formats</h4> 
  <p>First let's look at what we did to leaves:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">LeafFormat</span> <span class="pl-k">=</span> wrap[<span class="pl-en">Leaf</span>, <span class="pl-k">String</span>](_.label, <span class="pl-en">Leaf</span>)
<span class="pl-en">LeafFormat</span><span class="pl-k">:</span> java.lang.<span class="pl-en">Object</span> <span class="pl-k">with</span> <span class="pl-e">MyProtocol2.Format</span>[<span class="pl-en">Leaf</span>] <span class="pl-k">=</span> sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">4</span><span class="pl-k">@</span>1e081c5</pre>
  </div> 
  <p>So the wrap method defines a format for Leaf.</p> 
  <p>Let's see what it looks like:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> toByteArray(<span class="pl-en">Leaf</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>))
res9<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">102</span>, <span class="pl-c1">111</span>, <span class="pl-c1">111</span>)

scala<span class="pl-k">&gt;</span> toByteArray(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
res10<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">102</span>, <span class="pl-c1">111</span>, <span class="pl-c1">111</span>)</pre>
  </div> 
  <p>The format of the <code>Leaf</code> is exactly that of the String it wraps. The two functions which we pass to wrap are simply used to pack and unpack it from the original format (which was picked up as an implicit argument).</p> 
  <h4><a id="user-content-formats-for-case-classes" class="anchor" href="https://github.com/sbt/sbinary#formats-for-case-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Formats for case classes</h4> 
  <p>First let's see how the asProduct stuff works:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">MyProtocol.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">MyProtocol.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">bar</span> : <span class="pl-k">String</span>, <span class="pl-v">baz</span> : <span class="pl-k">Int</span>);
defined <span class="pl-k">class</span> <span class="pl-en">Foo</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">Foormat</span> <span class="pl-k">=</span> asProduct2(<span class="pl-en">Foo</span>)(<span class="pl-en">Foo</span>.unapply(_).get)
<span class="pl-en">Foormat</span><span class="pl-k">:</span> java.lang.<span class="pl-en">Object</span> <span class="pl-k">with</span> <span class="pl-e">MyProtocol2.Format</span>[<span class="pl-en">Foo</span>] <span class="pl-k">=</span> sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">8</span><span class="pl-k">@</span>1f5205c

scala<span class="pl-k">&gt;</span> toByteArray(<span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>))
res4<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">98</span>, <span class="pl-c1">97</span>, <span class="pl-c1">114</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>)

scala<span class="pl-k">&gt;</span> fromByteArrayFoo
res5<span class="pl-k">:</span> <span class="pl-en">Foo</span> <span class="pl-k">=</span> <span class="pl-en">Foo</span>(bar,<span class="pl-c1">3</span>)</pre>
  </div> 
  <p><code>asProductN</code> basically defines binary formats which are concatenations of other formats. In this instance, Foo is just its components written in order:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> toByteArray(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
res6<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">98</span>, <span class="pl-c1">97</span>, <span class="pl-c1">114</span>)

scala<span class="pl-k">&gt;</span> toByteArray(<span class="pl-c1">3</span>)
res7<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>)

scala<span class="pl-k">&gt;</span> res4
res8<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">98</span>, <span class="pl-c1">97</span>, <span class="pl-c1">114</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>)</pre>
  </div> 
  <p>We give <code>asProduct</code> methods for assembling and disassembling instances of the type into their component parts. Conveniently, the <code>apply</code> and <code>unapply</code> methods generated on case classes do more or less what we want. This makes it very easy to define formats for case classes.</p> 
  <h4><a id="user-content-formats-for-unions" class="anchor" href="https://github.com/sbt/sbinary#formats-for-unions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Formats for unions</h4> 
  <p>We frequently have a setup like the following:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>
defined <span class="pl-k">class</span> <span class="pl-en">Bar</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Baz</span>(<span class="pl-v">foo</span> : <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Bar</span>
defined <span class="pl-k">class</span> <span class="pl-en">Baz</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Blib</span>(<span class="pl-v">foo</span> : <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Bar</span>
defined <span class="pl-k">class</span> <span class="pl-en">Blib</span></pre>
  </div> 
  <p>We've seen how to define formats for <code>Baz</code> and <code>Blib</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">BazFormat</span> <span class="pl-k">:</span> <span class="pl-en">Format</span>[<span class="pl-en">Baz</span>] <span class="pl-k">=</span> wrap(_.foo, <span class="pl-en">Baz</span>)
<span class="pl-en">BazFormat</span><span class="pl-k">:</span> <span class="pl-en">MyProtocol2</span>.<span class="pl-en">Format</span>[<span class="pl-en">Baz</span>] <span class="pl-k">=</span> sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">4</span><span class="pl-k">@</span>de3c87

scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">BlibFormat</span> <span class="pl-k">:</span> <span class="pl-en">Format</span>[<span class="pl-en">Blib</span>] <span class="pl-k">=</span> wrap(_.foo, <span class="pl-en">Blib</span>)
<span class="pl-en">BlibFormat</span><span class="pl-k">:</span> <span class="pl-en">MyProtocol2</span>.<span class="pl-en">Format</span>[<span class="pl-en">Blib</span>] <span class="pl-k">=</span> sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">4</span><span class="pl-k">@</span>16b0c24</pre>
  </div> 
  <p>But how do we go from there to a format for <code>Bar</code>?</p> 
  <p>Well, we basically saw how to do this with our hand written binary tree example: We define a byte tag which says which subtype we're in. So all we need to do to represent this is specify the formats for the subtypes in order and associate a tag with each. That's what <code>asUnion</code> does.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">BarFormat</span> <span class="pl-k">=</span> asUnion[<span class="pl-en">Bar</span>](<span class="pl-en">BazFormat</span>, <span class="pl-en">BlibFormat</span>)
<span class="pl-en">BarFormat</span><span class="pl-k">:</span> <span class="pl-en">MyProtocol2</span>.<span class="pl-en">Format</span>[<span class="pl-en">Bar</span>] <span class="pl-k">=</span> sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">16</span><span class="pl-k">@</span>12143d8

scala<span class="pl-k">&gt;</span> toByteArrayBar
res11<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">102</span>, <span class="pl-c1">111</span>, <span class="pl-c1">111</span>)

scala<span class="pl-k">&gt;</span> toByteArrayBlib
res12<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">3</span>, <span class="pl-c1">102</span>, <span class="pl-c1">111</span>, <span class="pl-c1">111</span>)

scala<span class="pl-k">&gt;</span> toByteArrayBar
res13<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>)

scala<span class="pl-k">&gt;</span> toByteArrayBaz
res14<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">3</span>)</pre>
  </div> 
  <p>Note how in each case the Bar format is just a tag prepended to the subformat?</p> 
  <p>Another important thing to notice: The format depends on the static type of the argument, not the runtime type. The format written as a Bar is not the same as the format written as a Baz Because of this you should try to only make formats you actually care about visible, otherwise type inference can occasionally screw you over. This means that the approach taken in the binary tree example where the subtypes do not have their own explicit format is generally a better default than defining a format for each type as in this example.</p> 
  <h4><a id="user-content-self-referential-formats" class="anchor" href="https://github.com/sbt/sbinary#self-referential-formats" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Self referential formats</h4> 
  <p>Suppose we had the following linked list type:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">LL</span>
defined <span class="pl-k">class</span> <span class="pl-en">LL</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Nope</span> <span class="pl-k">extends</span> <span class="pl-e">LL</span>
defined module <span class="pl-en">Nope</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Yup</span>(<span class="pl-v">car</span> : <span class="pl-k">Int</span>, <span class="pl-v">cdr</span> : <span class="pl-en">LL</span>) <span class="pl-k">extends</span> <span class="pl-e">LL</span>
defined <span class="pl-k">class</span> <span class="pl-en">Yup</span></pre>
  </div> 
  <p>Great. This looks like stuff we've seen before. We know how to write a format for it.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">LLFormat</span> <span class="pl-k">:</span> <span class="pl-en">Format</span>[<span class="pl-en">LL</span>] <span class="pl-k">=</span> asUnion[<span class="pl-en">LL</span>](<span class="pl-en">Nope</span>, asProduct2(<span class="pl-en">Yup</span>)(<span class="pl-en">Yup</span>.unapply(_).get))

scala<span class="pl-k">&gt;</span> toByteArrayLL
res16<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">0</span>)</pre>
  </div> 
  <p>So far so good...</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> toByteArray[<span class="pl-en">LL</span>](<span class="pl-en">Yup</span>(<span class="pl-c1">1</span>, <span class="pl-en">Nope</span>))
java.lang.<span class="pl-en">NullPointerException</span> at sbinary.<span class="pl-en">Protocol</span>$class.write(protocol.scala<span class="pl-k">:</span><span class="pl-c1">27</span>)
at <span class="pl-en">MyProtocol2</span>$.write(binarytree.scala<span class="pl-k">:</span><span class="pl-c1">7</span>)
at sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">8.</span>writes(generic.scala<span class="pl-k">:</span><span class="pl-c1">111</span>)
at sbinary.<span class="pl-en">Protocol</span>$class.write(protocol.scala<span class="pl-k">:</span><span class="pl-c1">27</span>)
at <span class="pl-en">MyProtocol2</span>$.write(binarytree.scala<span class="pl-k">:</span><span class="pl-c1">7</span>)
at sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">16</span>$$anonfun$writes$<span class="pl-c1">3.</span>apply(generic.scala<span class="pl-k">:</span><span class="pl-c1">361</span>)
at sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">16</span>$$anonfun$wr...</pre>
  </div> 
  <p>Oops. What happened here? :-(</p> 
  <p>Well, the problem is that <code>asProduct2</code> takes a bunch of implicit arguments: Two in fact. One for the format for its first argument, one for the format for its second argument.</p> 
  <p>Unfortunately the format for its second argument is the format currently being defined! It hasn't been initialised yet, so we got a null when calling asProduct2 and it all went wrong.</p> 
  <p>Let's fix it:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">LLFormat</span> <span class="pl-k">:</span> <span class="pl-en">Format</span>[<span class="pl-en">LL</span>] <span class="pl-k">=</span>lazyFormat(asUnion[<span class="pl-en">LL</span>](<span class="pl-en">Nope</span>, asProduct2(<span class="pl-en">Yup</span>)(<span class="pl-en">Yup</span>.unapply(_).get)))
<span class="pl-en">LLFormat</span><span class="pl-k">:</span> <span class="pl-en">MyProtocol2</span>.<span class="pl-en">Format</span>[<span class="pl-en">LL</span>] <span class="pl-k">=</span> sbinary.<span class="pl-en">Generic</span>$$anon$<span class="pl-c1">5</span><span class="pl-k">@</span>17ce686

scala<span class="pl-k">&gt;</span> toByteArrayLL 
res18<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">1</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">0</span>)</pre>
  </div> 
  <p><code>lazyFormat</code> basically performs magic to make cases like this work. It takes a call by name argument which will produce a format and returns a format which delegates to that. This means that it's ok to reference the format currently being defined inside the body because the body is not called during initialisation, only when the format is first used.</p> 
  <h4><a id="user-content-putting-it-all-together" class="anchor" href="https://github.com/sbt/sbinary#putting-it-all-together" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Putting it all together</h4> 
  <p>Let's look at it again:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyProtocol</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultProtocol</span> {
 <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">BTFormat</span> <span class="pl-k">:</span> <span class="pl-en">Format</span>[<span class="pl-en">BT</span>] <span class="pl-k">=</span> lazyFormat(asUnion[<span class="pl-en">BT</span>](
   asProduct2(<span class="pl-en">Bin</span>)(<span class="pl-en">Bin</span>.unapply(_).get),
   wrap[<span class="pl-en">Leaf</span>, <span class="pl-k">String</span>](_.label, <span class="pl-en">Leaf</span>) ))
}</pre>
  </div> 
  <p>Hopefully, it should all make sense now. We use <code>asProduct2</code> and wrap to define formats for the two subtypes, use <code>asUnion</code> to glue them together and then use <code>lazyFormat</code> to allow the format to still refer to itself.</p> 
  <p>Easy, right?</p> 
 </article>
</div>