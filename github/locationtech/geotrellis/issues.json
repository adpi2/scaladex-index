{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":1993,
            "title":"Implement \"overzooming\" in the library",
            "bodyText":"We have implemented \"overzooming\" (satisfying a tile request of a higher zoom level with the data from a lower zoom level) in a couple of places. We should codify this in the library.\nSee: https://github.com/geotrellis/geotrellis-landsat-emr-demo/blob/c1afd8c9c8e9b41545264ba3e9c1a6d9f30e7e7a/server/src/main/scala/demo/ReaderSet.scala#L22-L80\ntrait ReaderSet {\n  val layoutScheme = ZoomedLayoutScheme(WebMercator, 256)\n  def attributeStore: AttributeStore\n  def metadataReader: MetadataReader\n  def layerReader: FilteringLayerReader[LayerId]\n  def layerCReader: CollectionLayerReader[LayerId]\n  def singleBandTileReader: TileReader[SpaceTimeKey, Tile]\n  def multiBandTileReader: TileReader[SpaceTimeKey, MultibandTile]\n\n  /** Do \"overzooming\", where we resample lower zoom level tiles to serve out higher zoom level tiles. */\n  def readSinglebandTile(layer: String, zoom: Int, x: Int, y: Int, time: ZonedDateTime): Option[Tile] =\n    try {\n      val z = metadataReader.layerNamesToMaxZooms(layer)\n\n      if(zoom > z) {\n        val layerId = LayerId(layer, z)\n\n        val meta = metadataReader.read(layerId)\n        val rmd = meta.rasterMetaData\n\n        val requestZoomMapTransform = layoutScheme.levelForZoom(zoom).layout.mapTransform\n        val requestExtent = requestZoomMapTransform(x, y)\n        val centerPoint = requestZoomMapTransform(x, y).center\n        val SpatialKey(nx, ny) = rmd.mapTransform(centerPoint)\n        val sourceExtent = rmd.mapTransform(nx, ny)\n\n\n        val largerTile =\n          singleBandTileReader.read(layerId, SpaceTimeKey(nx, ny, time))\n\n        Some(largerTile.resample(sourceExtent, RasterExtent(requestExtent, 256, 256), Bilinear))\n      } else {\n        Some(singleBandTileReader.read(LayerId(layer, zoom), SpaceTimeKey(x, y, time)))\n      }\n    } catch {\n      case e: TileNotFoundError =>\n        None\n    }\n\n  /** Do \"overzooming\", where we resample lower zoom level tiles to serve out higher zoom level tiles. */\n  def readMultibandTile(layer: String, zoom: Int, x: Int, y: Int, time: ZonedDateTime): Option[MultibandTile] =\n    try {\n      val z = metadataReader.layerNamesToMaxZooms(layer)\n\n      if(zoom > z) {\n        val layerId = LayerId(layer, z)\n\n        val meta = metadataReader.read(layerId)\n        val rmd = meta.rasterMetaData\n\n        val requestZoomMapTransform = layoutScheme.levelForZoom(zoom).layout.mapTransform\n        val requestExtent = requestZoomMapTransform(x, y)\n        val centerPoint = requestZoomMapTransform(x, y).center\n        val SpatialKey(nx, ny) = rmd.mapTransform(centerPoint)\n        val sourceExtent = rmd.mapTransform(nx, ny)\n\n\n        val largerTile =\n          multiBandTileReader.read(layerId, SpaceTimeKey(nx, ny, time))\n\n        Some(largerTile.resample(sourceExtent, RasterExtent(requestExtent, 256, 256), Bilinear))\n      } else {\n        Some(multiBandTileReader.read(LayerId(layer, zoom), SpaceTimeKey(x, y, time)))\n      }\n    } catch {\n      case e: TileNotFoundError =>\n        None\n    }\n}",
            "url":"https://github.com/locationtech/geotrellis/issues/1993"
          }
        ]
      }
    }
  }
}