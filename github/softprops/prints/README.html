<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/softprops/prints#prints" aria-hidden="true" class="anchor" id="user-content-prints" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Prints</h1> 
  <p><a href="https://travis-ci.org/softprops/prints" target="_blank"><img src="https://camo.githubusercontent.com/565054273e07efe6e7087fd3b4027774cb069735/68747470733a2f2f7472617669732d63692e6f72672f736f667470726f70732f7072696e74732e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/softprops/prints.svg" style="max-width:100%;"></a></p> 
  <p>a <a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank">jwt</a> finger printer</p> 
  <h2><a href="https://github.com/softprops/prints#background" aria-hidden="true" class="anchor" id="user-content-background" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>background</h2> 
  <p><a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32" target="_blank">jwt</a> evolved out of a family of web oriented specfications targeting the second major version of oauth, <a href="http://oauth.net/2/" target="_blank">oauth2</a> as a means of encoding structured data in a compact and tamper-proof format.</p> 
  <p>In short, jwt defines a standard means of signing arbirary data in JSON format.</p> 
  <h2><a href="https://github.com/softprops/prints#install" aria-hidden="true" class="anchor" id="user-content-install" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>install</h2> 
  <p>At the following to your sbt project's <code>build.sbt</code></p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>softprops-maven<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>http://dl.bintray.com/content/softprops/maven<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>me.lessis<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>prints<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.1.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <h2><a href="https://github.com/softprops/prints#usage" aria-hidden="true" class="anchor" id="user-content-usage" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>usage</h2> 
  <p>A jwt token is made up of 3 parts. A (JOSE) <a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-5" target="_blank">header</a> declaring information about how verify the signature of a set of claims, a set of <a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4" target="_blank">claims</a> this can actually be any arbitrary JSON data, and a signature, generated with a private key using a method specified in header information.</p> 
  <h3><a href="https://github.com/softprops/prints#headers" aria-hidden="true" class="anchor" id="user-content-headers" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>headers</h3> 
  <p>The only required property of a header is a signing algorithm identifier. This library current supports "none" (no signing), "HS256" (HmacSHA256), "HS384" (HmacSHA384), "HS512" (HmacSHA512), "RS256" (SHA256withRSA), "RS384" (SHA384withRSA), and "RS512" (SHA512withRSA). There's room to support more. Feel free to <a href="https://github.com/softprops/prints/pulls" target="_blank">open a pull request</a> and do so!</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">header</span> <span class="pl-k">=</span> prints.<span class="pl-en">Header</span>(<span class="pl-s"><span class="pl-pds">"</span>HS256<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h3><a href="https://github.com/softprops/prints#claims" aria-hidden="true" class="anchor" id="user-content-claims" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>claims</h3> 
  <p>Claims represent some metadata meant for passing between two parties. In practice this can be any arbitrary data. Prints provides factory methods for creating sets of claims from simple <code>String</code> key-value pairs or a <code>org.json4s.JValue</code> value.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">simpleClaims</span> <span class="pl-k">=</span> prints.<span class="pl-en">Claims</span>(
  <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>
)</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.json4s.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">org.json4s.JsonDSL.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">complexClaims</span> <span class="pl-k">=</span> prints.<span class="pl-en">Claims</span>(
  (<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>) <span class="pl-k">~</span>
  (<span class="pl-s"><span class="pl-pds">"</span>nbf<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> notBeforeTimestamp) <span class="pl-k">~</span> 
  (<span class="pl-s"><span class="pl-pds">"</span>scope<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>read<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>write<span class="pl-pds">"</span></span>))
)</pre>
  </div> 
  <p>Because claims can contain arbitrary constraints, a <code>prints.Claims</code> instance provides a simple query interface with a few typed helpers. A primative query method <code>get</code> defined as</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">get</span>(<span class="pl-v">f</span>: <span class="pl-en">JField</span> <span class="pl-k">=&gt;</span> <span class="pl-k">Boolean</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">JValue</span>]</pre>
  </div> 
  <p>provides a base for typed helpers like <code>str</code> (returns option of String), <code>long</code> (returns option of Long), <code>seconds</code> returns a finite duration representing seconds. This typed query methods are all implemented in terms of <code>get</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> complexClaims.str(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>) <span class="pl-c"><span class="pl-c">//</span> Some("bar")</span>
<span class="pl-k">val</span> <span class="pl-en">scopes</span> <span class="pl-k">=</span> complexClaims.get(_ <span class="pl-k">match</span> {
  <span class="pl-k">case</span> (<span class="pl-s"><span class="pl-pds">"</span>scope<span class="pl-pds">"</span></span>, <span class="pl-en">JArray</span>(_)) <span class="pl-k">=&gt;</span> <span class="pl-c1">true</span>
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>
}).collect {
  <span class="pl-k">case</span> <span class="pl-en">JArray</span>(scopes) <span class="pl-k">=&gt;</span> <span class="pl-k">for</span> {
    <span class="pl-en">JString</span>(scope) <span class="pl-k">&lt;</span><span class="pl-k">-</span> scopes
  } <span class="pl-k">yield</span> scope
} <span class="pl-c"><span class="pl-c">//</span> Some(List("read", "write"))</span></pre>
  </div> 
  <h3><a href="https://github.com/softprops/prints#making-tokens" aria-hidden="true" class="anchor" id="user-content-making-tokens" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>making tokens</h3> 
  <p>Given a <code>Header</code>, set of <code>Claims</code> and a private key you can then create a signed token. The type of header algorithm used dictates the type of key used to sign a set of claims. An <code>HS*</code> header can be signed with an <code>Algorithm.Key.Bytes</code> key and a <code>RS*</code> header can be signed with an Algorithm.Key.Rsa` key.</p> 
  <p>The result is an <code>Option</code> type because a header-defined signing algorithm may not be supported</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">token</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]] <span class="pl-k">=</span>
  prints.<span class="pl-en">JWT</span>(header, claims, prints.<span class="pl-en">Algorithm</span>.<span class="pl-en">Key</span>.<span class="pl-en">Bytes</span>(<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span>.getBytes))</pre>
  </div> 
  <p>A valid result can then be safely used for HTTP or other transports. The result is URL safe so no additional encoding is required.</p> 
  <div class="highlight highlight-source-scala">
   <pre>token.map(<span class="pl-k">new</span> <span class="pl-en">String</span>(_)) <span class="pl-c"><span class="pl-c">//</span> eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ==.88HN1LmGMYQTD4CYwnOoM9EqFWqSv6G1kkGI0EjNOmA=</span></pre>
  </div> 
  <h3><a href="https://github.com/softprops/prints#consuming-validating-tokens" aria-hidden="true" class="anchor" id="user-content-consuming-validating-tokens" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>consuming (validating) tokens</h3> 
  <p>Prints provides an extractor for jwt strings that unpacks the token into the 3 canonical parts. A <code>Header</code>, a <code>Claims</code> set, and a string signature</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">jwt</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmb28iOiJiYXIifQ==.88HN1LmGMYQTD4CYwnOoM9EqFWqSv6G1kkGI0EjNOmA=<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">decoded</span> <span class="pl-k">=</span> jwt <span class="pl-k">match</span> {
  <span class="pl-k">case</span> prints.<span class="pl-en">JWT</span>(header, claims, sig) <span class="pl-k">=&gt;</span>
    <span class="pl-c"><span class="pl-c">//</span> to application specific validation</span>
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">None</span>
}</pre>
  </div> 
  <p>You can verify jwt tokens in two forms by supplying a string jwt and key or the tuple of unpacked components and key. For former is useful if you know the key a head of time, otherwise you may more commonly derive a key to verify based on the <code>aud</code> of the claim, in which case you need to first unpack the jwt components. In each case the result is Option of the unpacked contents of the jwt</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">validated</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[(<span class="pl-en">Header</span>, <span class="pl-en">Claims</span>, <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>])] <span class="pl-k">=</span> prints.<span class="pl-en">JWT</span>.verify(jwt, algo, key)</pre>
  </div> 
  <p>Doug Tangren (softprops) 2015</p> 
 </article>
</div>