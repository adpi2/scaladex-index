<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <pre><code>                        . . . .
                        ,`,`,`,`,
  . . . .               `\`\`\`\;
  `\`\`\`\`,            ~|;!;!;\!
   ~\;\;\;\|\          (--,!!!~`!       .
  (--,\\\===~\         (--,|||~`!     ./
   (--,\\\===~\         `,-,~,=,:. _,//
    (--,\\\==~`\        ~-=~-.---|\;/J,       Welcome to the Unicorn Database
     (--,\\\((```==.    ~'`~/       a |         BigTable, Document and Graph
       (-,.\\('('(`\\.  ~'=~|     \_.  \              Full Text Search
          (,--(,(,(,'\\. ~'=|       \\_;&gt;
            (,-( ,(,(,;\\ ~=/        \                  Haifeng Li
            (,-/ (.(.(,;\\,/          )             ADP Innovation Lab
             (,--/,;,;,;,\\         ./------.
               (==,-;-'`;'         /_,----`. \
       ,.--_,__.-'                    `--.  ` \
      (='~-_,--/        ,       ,!,___--. \  \_)
     (-/~(     |         \   ,_-         | ) /_|
     (~/((\    )\._,      |-'         _,/ /
      \\))))  /   ./~.    |           \_\;
   ,__/////  /   /    )  /
    '===~'   |  |    (, &lt;.
             / /       \. \
           _/ /          \_\
          /_!/            &gt;_\

  Welcome to Unicorn Shell; enter ':help&lt;RETURN&gt;' for the list of commands.
  Type ":quit&lt;RETURN&gt;" to leave the Unicorn Shell
  Version 2.1.0, Scala 2.11.7, SBT 0.13.8, Built at 2016-07-04 03:42:14.238
===============================================================================

unicorn&gt;
</code></pre> 
  <h1><a href="https://github.com/haifengl/unicorn#unicorn" aria-hidden="true" class="anchor" id="user-content-unicorn" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>UNICORN</h1> 
  <p><a href="https://gitter.im/haifengl/unicorn?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/ec308e48378b296dcc35a98fce2a9b77475ce718/68747470733a2f2f6261646765732e6769747465722e696d2f68616966656e676c2f756e69636f726e2e737667" alt="Join the chat at https://gitter.im/haifengl/unicorn" data-canonical-src="https://badges.gitter.im/haifengl/unicorn.svg" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/com.github.haifengl/unicorn-unibase_2.11" target="_blank"><img src="https://camo.githubusercontent.com/2dc6a4270b02e1031916dd987b5f4ab27793e309/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e6769746875622e68616966656e676c2f756e69636f726e2d756e69626173655f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.github.haifengl/unicorn-unibase_2.11/badge.svg" style="max-width:100%;"></a></p> 
  <p>Unicorn is a simple and flexible abstraction of BigTable-like database such as Cassandra, HBase, Accumulo, and RocksDB. Beyond a unified interface to various database systems, Unicorn provides easy-to-use document data model and MongoDB-like API. Moreover, Unicorn supports directed property multigraphs and documents can just be vertices in a graph.</p> 
  <p>Agility, flexibility and easy to use are our key design goals. With different storage engine, we can achieve different strategies on consistency, replication, etc.</p> 
  <p>With the built-in document and graph data models, developers can focus on the business logic rather than work with tedious key-value pair manipulations. Of course, developers are still free to use key-value pairs for flexibility in some special cases.</p> 
  <p>Unicorn is implemented in Scala and can be used as a client-side library without overhead. Unicorn also provides a shell for quick access of database. The code snippets in this document can be directly run in the Shell. A HTTP API, in the module <code>Rhino</code>, is also provided to non-Scala users.</p> 
  <p>For analytics, Unicorn data can be exported as RDDs in Spark. These RDDs can also be converted to DataFrames or Datasets, which support SQL queries. Unicorn graphs can be analyzed by Spark GraphX too.</p> 
  <p>To use Unicorn as a library, add the following to SBT build file.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.haifengl<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>unicorn-unibase_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>If you need additional HBase-only features, please link to the module <code>Narwhal</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.haifengl<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>unicorn-narwhal_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>With the module <code>Narwhal</code> that is specialized for HBase, advanced features such as time travel, rollback, counters, server side filter, Spark integration, etc. are available.</p> 
  <p>To support the document model, Unicorn has a very rich and advanced JSON library. With it, the users can operate JSON data just like in JavaScript. Moreover, it supports JSONPath for flexibly analyse, transform and selectively extract data out of JSON objects. Meanwhile, it is type safe and may capture many errors during the compile time. To use only the JSON library,</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.github.haifengl<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>unicorn-json_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.1<span class="pl-pds">"</span></span></pre>
  </div> 
  <h1><a href="https://github.com/haifengl/unicorn#download" aria-hidden="true" class="anchor" id="user-content-download" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Download</h1> 
  <p>Get pre-packaged Unicorn in universal tarball from the <a href="https://github.com/haifengl/unicorn/releases" target="_blank">releases page</a>.</p> 
  <p>If you would like to build Unicorn from source, please first install Java, Scala and SBT. Then clone the repo and build the package:</p> 
  <div class="highlight highlight-source-shell">
   <pre>git clone https://github.com/haifengl/unicorn.git
<span class="pl-c1">cd</span> unicorn
./unicorn.sh</pre>
  </div> 
  <p>which also starts the Shell.</p> 
  <p>Unicorn runs on both Windows and UNIX-like systems (e.g. Linux, Mac OS). All you need is to have Java installed on your system <code>PATH</code>, or the <code>JAVA_HOME</code> environment variable pointing to a Java installation.</p> 
  <p>If you want to work on the Unicorn code with IntelliJ, please first <a href="https://www.jetbrains.com/help/idea/2016.1/getting-started-with-sbt.html" target="_blank">install SBT plugin</a>. To import the project, on the main menu select File | New | Project from Existing Sources.</p> 
  <h1><a href="https://github.com/haifengl/unicorn#shell" aria-hidden="true" class="anchor" id="user-content-shell" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Shell</h1> 
  <p>Unicorn comes with an interactive shell. In the home directory of Unicorn, type</p> 
  <div class="highlight highlight-source-shell">
   <pre>./bin/unicorn</pre>
  </div> 
  <p>to enter the shell, which is based on Scala interpreter. So you can run any valid Scala expressions in the shell. In the simplest case, you can use it as a calculator. Besides, all high-level Unicorn operators are predefined in the shell. Be default, the shell uses up to 4GB memory. If you need more memory to handle large data, use the option <code>-J-Xmx</code>. For example,</p> 
  <div class="highlight highlight-source-shell">
   <pre>./bin/unicorn -J-Xmx8192M</pre>
  </div> 
  <p>You can also modify the configuration file <code>./conf/unicorn.ini</code> for the memory and other JVM settings.</p> 
  <p>In the shell, type :help to print Scala interpreter help information. To exit the shell, type :quit.</p> 
  <h1><a href="https://github.com/haifengl/unicorn#connecting-to-database" aria-hidden="true" class="anchor" id="user-content-connecting-to-database" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Connecting to Database</h1> 
  <p>Suppose that <code>hbase-site.xml</code> and <code>hbase-default.xml</code> can be found on the <code>CLASSPATH</code>, one can connect to HBase as simple as</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">HBase</span>()</pre>
  </div> 
  <p>The user may also pass a Configuration object to <code>HBase()</code> if HBase configuration files are not in the <code>CLASSPATH</code>.</p> 
  <p>To connect to Cassandra, please enable the Thrift API by configuring <code>start_rpc</code> to <code>true</code> in the <code>cassandra.yaml</code> file, which is <code>false</code> by default after Cassandra 2.0.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Cassandra</span>(<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-c1">9160</span>)</pre>
  </div> 
  <p>To connect to Accumulo,</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Accumulo</span>(<span class="pl-s"><span class="pl-pds">"</span>instance<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>zookeeper<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>user<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>password<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>where the first parameter is the Accumulo instance name and the second is the ZooKeeper connection string.</p> 
  <p>An interesting feature of Accumulo is to create a mock instance that holds all data in memory, and will not retain any data or settings between runs. It presently does not enforce users, logins, permissions, etc. This is very convenient for test. This doesn't even require an installation of Accumulo. To create a mock instance, simply do</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Accumulo</span>()</pre>
  </div> 
  <p>RocksDB is an embeddable persistent key-value store for fast storage. RocksDB builds on LevelDB to be scalable to run on servers with many CPU cores, to efficiently use fast storage, to support IO-bound, in-memory and write-once workloads.</p> 
  <p>If your data can be fit in one machine and low latency (in microseconds) is important to your applications, RocksDB is a great choice. Especially for graph database use cases, a graph traversal may touch thousands or event millions vertices, the cost of IPC to a distributed database will be too high. In this case, RocksDB will easily outperformance other distributed storage engine.</p> 
  <p>There is no concept of tables in RocksDB. In fact, a RocksDB is like a table in HBase. Therefore, we create a higher level concept of database that contains multiple RocksDB databases in a directory. Each RocksDB is actually a subdirectory, which is encapsulated in RocksTable. To create RocksDB, simply provides a directory path.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Unibase</span>(<span class="pl-en">RocksDB</span>.create(<span class="pl-s"><span class="pl-pds">"</span>/tmp/unicorn-twitter<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>To use an existing database,</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Unibase</span>(<span class="pl-en">RocksDB</span>(<span class="pl-s"><span class="pl-pds">"</span>/tmp/unicorn-twitter<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>With a database instance, we can create, drop, truncate, and compact a table. We can also test if a table exists.</p> 
  <div class="highlight highlight-source-scala">
   <pre>db.createTable(<span class="pl-s"><span class="pl-pds">"</span>test_table<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cf1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cf2<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">table</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>test_table<span class="pl-pds">"</span></span>)
table(<span class="pl-s"><span class="pl-pds">"</span>row1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>cf1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c1<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>data<span class="pl-pds">"</span></span>
db.dropTable(<span class="pl-s"><span class="pl-pds">"</span>test_table<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Here we first create a table with two column families. We can also pass a <code>Properties</code> object for additional table configuration, which usually depends on the backend system. For example, sharding and replication strategies, compression, time-to-live (TTL), etc. Then we get the table object, put some data, and finally drop the table. In what follows, we will go through the data manipulation APIs.</p> 
  <h1><a href="https://github.com/haifengl/unicorn#bigtable-like-api" aria-hidden="true" class="anchor" id="user-content-bigtable-like-api" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>BigTable-like API</h1> 
  <p>In BigTable-like databases, data are stored in tables, which are made of rows and columns. Columns are grouped into column families. A column name is made of its column family prefix and a qualifier. The column family prefix must be composed of printable characters. The column qualifiers can be made of any arbitrary bytes. In Cassandra and HBase, column families must be declared up front at schema definition time whereas new columns can be added to any column family without pre-announcing them. In contrast, column family are not static in Accumulo and can be created on the fly. The only way to get a complete set of columns that exist for a column family is to process all the rows.</p> 
  <p>A cell’s content is an uninterpreted array of bytes. And table cells are versioned. A <code>(row, column, version)</code> tuple exactly specifies a cell. The version is specified using a <code>long</code> integer. Typically this <code>long</code> contains timestamps.</p> 
  <p>The trait <code>unicorn.bigtable.BigTable</code> defines basic operations on a table such as <code>Get</code>, <code>Put</code>, and <code>Delete</code>. The corresponding implementations are in <code>unicorn.bigtable.cassandra.CassandraTable</code>, <code>unicorn.bigtable.hbase.HBaseTable</code>, and <code>unicorn.bigtable.accumulo.AccumuloTable</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">/**</span> Get one or more columns of a column family. If columns is empty, get all columns in the column family. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">get</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">family</span>: <span class="pl-k">String</span>, <span class="pl-v">columns</span>: <span class="pl-en">ByteArray</span><span class="pl-k">*</span>)<span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Column</span>]

<span class="pl-c"><span class="pl-c">/**</span> Get all columns in one or more column families. If families is empty, get all column families. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">get</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">families</span>: <span class="pl-en">Seq</span>[(<span class="pl-k">String</span>, <span class="pl-en">Seq</span>[<span class="pl-en">ByteArray</span>])] <span class="pl-k">=</span> <span class="pl-en">Seq</span>.empty)<span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">ColumnFamily</span>]

<span class="pl-c"><span class="pl-c">/**</span> Upsert a value. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">put</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">family</span>: <span class="pl-k">String</span>, <span class="pl-v">column</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">value</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">timestamp</span>: <span class="pl-k">Long</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>

<span class="pl-c"><span class="pl-c">/**</span> Upsert values. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">put</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">family</span>: <span class="pl-k">String</span>, <span class="pl-v">columns</span>: <span class="pl-en">Column</span><span class="pl-k">*</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>

<span class="pl-c"><span class="pl-c">/**</span> Upsert values. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">put</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">families</span>: <span class="pl-en">Seq</span>[<span class="pl-en">ColumnFamily</span>] <span class="pl-k">=</span> <span class="pl-en">Seq</span>.empty)<span class="pl-k">:</span> <span class="pl-k">Unit</span>

<span class="pl-c"><span class="pl-c">/**</span> Delete the columns of a row. If columns is empty, delete all columns in the family. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">delete</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">family</span>: <span class="pl-k">String</span>, <span class="pl-v">columns</span>: <span class="pl-en">ByteArray</span><span class="pl-k">*</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>

<span class="pl-c"><span class="pl-c">/**</span> Delete the columns of a row. If families is empty, delete the whole row. <span class="pl-c">*/</span></span>
<span class="pl-k">def</span> <span class="pl-en">delete</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">families</span>: <span class="pl-en">Seq</span>[(<span class="pl-k">String</span>, <span class="pl-en">Seq</span>[<span class="pl-en">ByteArray</span>])] <span class="pl-k">=</span> <span class="pl-en">Seq</span>.empty)<span class="pl-k">:</span> <span class="pl-k">Unit</span></pre>
  </div> 
  <p>Setting <code>timestamp</code> as <code>0L</code>, <code>Put</code> creates a new version of a cell with the server’s currentTimeMillis (for Cassandra, it is caller's machine time). But the user may specify the version on a per-column level. The user-provided version may be a time in the past or the future, or a non-time purpose long value.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">update</span>(<span class="pl-v">row</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">family</span>: <span class="pl-k">String</span>, <span class="pl-v">column</span>: <span class="pl-en">ByteArray</span>, <span class="pl-v">value</span>: <span class="pl-en">ByteArray</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span></pre>
  </div> 
  <p>The helper function <code>update</code> is provided as a syntactic sugar so that the user can put a value in the way</p> 
  <div class="highlight highlight-source-scala">
   <pre>table(row, family, column) <span class="pl-k">=</span> value</pre>
  </div> 
  <p>In this case, timestamp is always set as the current machine time.</p> 
  <p><code>Delete</code> can happen on a specific version of a cell or all versions. Deletes work by creating tombstone markers. Once a tombstone marker is set, the "deleted" cells become effectively invisible for <code>Get</code> operations but are not immediately removed from store files. Note that there is a snag with the tombstone approach, namely "deletes mask puts". Once a tombstone marker is set, even puts after the delete will be masked by the delete tombstone. Performing the put will not fail. However when you do a <code>Get</code>, the <code>Put</code> has no effect but will start working after the major compaction, which will really remove deletes and tombstone markers.</p> 
  <p>For these APIs, there are also corresponding batch mode operations that work on multiple rows. However, the implementation may or may not optimize the batch operations. In particular, Accumulo does optimize it in parallel.</p> 
  <p>Besides the basic operations, advanced features that are not available on all backend systems are organized into various traits.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#time-travel" aria-hidden="true" class="anchor" id="user-content-time-travel" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Time Travel</h2> 
  <p>By default, when doing a <code>Get</code>, the cell whose version has the largest value is returned. It is possible to return more than one version or to return versions other than the latest. These special methods are defined in trait <code>TimeTravel</code>, which is supported by HBase.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#scan" aria-hidden="true" class="anchor" id="user-content-scan" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scan</h2> 
  <p>HBase and Accumulo support the <code>Scan</code> operation that fetches zero or more rows of a table. In fact, A <code>Get</code> is simply a <code>Scan</code> limited by the API to one row in these systems. The trait <code>RowScan</code> provides operations to scan the whole table, or a range specified by the start and stop row key, or rows with a given prefix.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#filter-scan" aria-hidden="true" class="anchor" id="user-content-filter-scan" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Filter Scan</h2> 
  <p>HBase provides advanced filtering functionality when reading data using <code>Get</code> or <code>Scan</code> operations, which return a subset of results to the client. While this does not reduce server-side IO, it does reduce network bandwidth and reduces the amount of data the client needs to process.</p> 
  <p>The filter operators (<code>Equal</code>, <code>NotEqual</code>, <code>Greater</code>, <code>GreaterOrEqual</code>, <code>Less</code>, <code>LessOrEqual</code>) and logic operators (<code>And</code>, <code>Or</code>) are defined in trait <code>ScanFilter</code>. The enhanced <code>Get</code> and <code>Scan</code> operators with filter parameter are defined in <code>FilterScan</code>.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#intra-row-scan" aria-hidden="true" class="anchor" id="user-content-intra-row-scan" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Intra Row Scan</h2> 
  <p>In BigTable, a row could have millions columns. Cassandra actually supports up to 2 billions columns. In such a wide columnar environment, intra row scan is an useful operation in some use cases. Both HBase and Cassandra support <code>IntraRowScan</code> trait that can scan columns of given range in a row (inside a column family).</p> 
  <h2><a href="https://github.com/haifengl/unicorn#rollback" aria-hidden="true" class="anchor" id="user-content-rollback" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Rollback</h2> 
  <p><code>HBaseTable</code> implements the <code>Rollback</code> trait that defines the methods to rollback cell(s) to previous version.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#counter" aria-hidden="true" class="anchor" id="user-content-counter" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Counter</h2> 
  <p>A counter is a special column used to store a 64 bit integer that is changed in increments. Both HBase and Cassandra support counters.</p> 
  <p>To use counters in Cassandra, the user has to define a column family whose columns will act as counters.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#append" aria-hidden="true" class="anchor" id="user-content-append" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Append</h2> 
  <p>HBase support the <code>Append</code> operation that appends data to a cell. Note that this operation does not appear atomic to readers. Appends are done under a single row lock, so write operations to a row are synchronized, but readers do not take row locks so get and scan operations can see this operation partially completed.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#cell-level-security" aria-hidden="true" class="anchor" id="user-content-cell-level-security" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cell Level Security</h2> 
  <p>Accumulo and HBase support cell level security that provides fine grained access control. Cells can have visibility labels, which is used to determine whether a given user meets the security requirements to read the value. This enables data of various security levels to be stored within the same row, and users of varying degrees of access to query the same table, while preserving data confidentiality.</p> 
  <p>Security labels consist of a set of user-defined tokens that are required to read the value the label is associated with. The set of tokens required can be specified using syntax that supports logical <code>AND</code> and <code>OR</code> combinations of tokens, as well as nesting groups of tokens together.</p> 
  <h1><a href="https://github.com/haifengl/unicorn#json" aria-hidden="true" class="anchor" id="user-content-json" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>JSON</h1> 
  <p>Although Unicorn provides a modular and unified interface to various BigTable-like systems, it is still a very low level API to manipulate data. A more productive way to use Unicorn is through the rich, flexible, and easy-to-use document data model. A document is essentially a JSON object with a unique key (corresponding to the row key). With document data model, the application developers will focus on the business logic while Unicorn efficiently maps documents to key-value pairs in BigTable. In this section, we first introduce Unicorn's JSON data types and APIs. In the next section, we will discuss the document API, which is compatible with MongoDB.</p> 
  <p>JSON (JavaScript Object Notation) is a lightweight data-interchange format. It is easy for humans to read and write. It is easy for machines to parse and generate. JSON is a text format that is completely language independent but uses conventions that are familiar to programmers of the C-family of languages,</p> 
  <p>JSON has only types of <code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code>, <code>array</code>, and <code>null</code>. Unicorn includes additional types such as <code>date</code>, <code>int</code>, <code>long</code>, <code>double</code>, <code>counter</code>, <code>binary</code>, <code>UUID</code>, <code>ObjectId</code> (as in BSON), etc.</p> 
  <p>In Unicorn, it is very easy to parse a JSON object:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">doc</span> <span class="pl-k">=</span>
  json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "store": {</span>
<span class="pl-s">      "book": [</span>
<span class="pl-s">        {</span>
<span class="pl-s">          "category": "reference",</span>
<span class="pl-s">          "author": "Nigel Rees",</span>
<span class="pl-s">          "title": "Sayings of the Century",</span>
<span class="pl-s">          "price": 8.95</span>
<span class="pl-s">        },</span>
<span class="pl-s">        {</span>
<span class="pl-s">          "category": "fiction",</span>
<span class="pl-s">          "author": "Evelyn Waugh",</span>
<span class="pl-s">          "title": "Sword of Honour",</span>
<span class="pl-s">          "price": 12.99</span>
<span class="pl-s">        },</span>
<span class="pl-s">        {</span>
<span class="pl-s">          "category": "fiction",</span>
<span class="pl-s">          "author": "Herman Melville",</span>
<span class="pl-s">          "title": "Moby Dick",</span>
<span class="pl-s">          "isbn": "0-553-21311-3",</span>
<span class="pl-s">          "price": 8.99</span>
<span class="pl-s">        },</span>
<span class="pl-s">        {</span>
<span class="pl-s">          "category": "fiction",</span>
<span class="pl-s">          "author": "J. R. R. Tolkien",</span>
<span class="pl-s">          "title": "The Lord of the Rings",</span>
<span class="pl-s">          "isbn": "0-395-19395-8",</span>
<span class="pl-s">          "price": 22.99</span>
<span class="pl-s">        }</span>
<span class="pl-s">      ],</span>
<span class="pl-s">      "bicycle": {</span>
<span class="pl-s">        "color": "red",</span>
<span class="pl-s">        "price": 19.95</span>
<span class="pl-s">      }</span>
<span class="pl-s">    }</span>
<span class="pl-s">  }</span>
<span class="pl-s">  <span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>The interpolator <code>json</code> parse a string to <code>JsObject</code>. It is also okay to embed variable references directly in processed string literals.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> <span class="pl-c1">1</span>
json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "x": $x</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>If the string is not a JSON object but any other valid JSON expression, one may use <code>parseJson</code> method to convert the string to a <code>JsValue</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>.parseJson</pre>
  </div> 
  <p>The <code>json</code> interpolator can only be applied to string literals. If you want to parse a string variable, the <code>parseJson</code> method can always be employed. If you know the string contains a JSON object, you may also use the method <code>parseJsObject</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"""</span>{"x":1}<span class="pl-pds">"""</span></span>
s.parseJsObject</pre>
  </div> 
  <p>To serialize a JSON value (of type <code>JsValue</code>) in compact mode, you can just use <code>toString</code>. To pretty print, use the method <code>prettyPrint</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>doc.toString
doc.prettyPrint</pre>
  </div> 
  <p>With a <code>JsObject</code> or <code>JsArray</code>, you can refer to the individual elements with a variation of array syntax, like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>doc(<span class="pl-s"><span class="pl-pds">"</span>store<span class="pl-pds">"</span></span>)(<span class="pl-s"><span class="pl-pds">"</span>bicycle<span class="pl-pds">"</span></span>)(<span class="pl-s"><span class="pl-pds">"</span>color<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">//</span> Use symbol instead of string</span>
doc(<span class="pl-en">'store</span>)(<span class="pl-en">'bicycle</span>)(<span class="pl-en">'color</span>)</pre>
  </div> 
  <p>Note that we follow Scala's array access convention by <code>()</code> rather than <code>[]</code> in JavaScript.</p> 
  <p>Besides, you can use the dot notation to access its fields/elements just like in JavaScript:</p> 
  <div class="highlight highlight-source-scala">
   <pre>doc.store.bicycle.color
doc.store.book(<span class="pl-c1">0</span>).author</pre>
  </div> 
  <p>It is worth noting that we didn't define the type/schema of the document while Scala is a strong type language. In other words, we have both the type safe features of strong type language and the flexibility of dynamic language in Unicorn's JSON library.</p> 
  <p>If you try to access a non-exist field, <code>JsUndefined</code> is returned.</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> doc.book
res11<span class="pl-k">:</span> unicorn.json.<span class="pl-en">JsValue</span> <span class="pl-k">=</span> undefined</pre>
  </div> 
  <p>Although there are already several nice JSON libraries for Scala, the JSON objects are immutable by design, which is a natural choice for a functional language. However, Unicorn is designed for database, where data mutation is necessary. Therefore, <code>JsObject</code> and <code>JsArray</code> are mutable data structures in Unicorn. You can set/add a field just like in JavaScript:</p> 
  <div class="highlight highlight-source-scala">
   <pre>json.store.bicycle.color <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>green<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>To delete a field from <code>JsObject</code>, use <code>remove</code> method:</p> 
  <div class="highlight highlight-source-scala">
   <pre>doc.store.book(<span class="pl-c1">0</span>) remove <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>It is same as setting it <code>JsUndefined</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>doc.store.book(<span class="pl-c1">0</span>).price <span class="pl-k">=</span> <span class="pl-en">JsUndefined</span></pre>
  </div> 
  <p>To delete an element from <code>JsArray</code>, the <code>remove</code> method will effectively remove it from the array. However, setting an element to <code>undefined</code> doesn't reduce the array size.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> delete the first element and array size is smaller</span>
doc.store.book.remove(<span class="pl-c1">0</span>)
<span class="pl-c"><span class="pl-c">//</span> set the first element to undefined but array size keeps same</span>
doc.store.book(<span class="pl-c1">0</span>) <span class="pl-k">=</span> <span class="pl-en">JsUndefined</span></pre>
  </div> 
  <p>It is also possible to append an element or another array to <code>JsArray</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> <span class="pl-en">JsArray</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)
a <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">5</span>

a <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">JsArray</span>(<span class="pl-c1">5</span>, <span class="pl-c1">6</span>)</pre>
  </div> 
  <p>Common iterative operations such as <code>foreach</code>, <code>map</code>, <code>reduce</code> can be applied to <code>JsArray</code> too.</p> 
  <div class="highlight highlight-source-scala">
   <pre>doc.store.book.<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">JsArray</span>].foreach { book <span class="pl-k">=&gt;</span>
 println(book.price)
}</pre>
  </div> 
  <p>Because Scala is a static language, it is impossible to know <code>doc.store.book</code> is an array at compile time. So it is typed as generic <code>JsValue</code>, which is the parent type of specific JSON data types. Therefore, we use <code>asInstanceOf[JsArray]</code> to convert it to <code>JsArray</code> in order to use <code>foreach</code>.</p> 
  <p>With Unicorn, we can also look up field in the current object and all descendants:</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> doc \\ <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span>
res29<span class="pl-k">:</span> unicorn.json.<span class="pl-en">JsArray</span> <span class="pl-k">=</span> [<span class="pl-c1">8.95</span>,<span class="pl-c1">12.99</span>,<span class="pl-c1">8.99</span>,<span class="pl-c1">22.99</span>,<span class="pl-c1">19.95</span>]</pre>
  </div> 
  <p>For more advanced query operations, JSONPath can be employed.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#jsonpath" aria-hidden="true" class="anchor" id="user-content-jsonpath" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>JSONPath</h2> 
  <p><a href="http://goessner.net/articles/JsonPath/" target="_blank">JSONPath</a> is a means of using XPath-like syntax to query JSON structures. JSONPath expressions always refer to a JSON structure in the same way as XPath expression are used in combination with an XML document.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">jspath</span> <span class="pl-k">=</span> <span class="pl-en">JsonPath</span>(doc)</pre>
  </div> 
  <p>Since a JSON structure is usually anonymous and doesn't necessarily have a "root member object" JSONPath assumes the abstract name <code>$</code> assigned to the outer level object. Besides, <code>@</code> refers to the current object/element.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> the authors of all books in the store</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$.store.book[*].author<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> all authors</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..author<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> all things in store</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$.store.*<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> the price of everything in the store</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$.store..price<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> the third book</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..book[2]<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> the last book in order</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..book[-1:]<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> the first two books</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..book[0,1]<span class="pl-pds">"</span></span>)
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..book[:2]<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> filter all books with isbn number</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..book[?(@.isbn)]<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span>filter all books cheaper than 10</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..book[?(@.price&lt;10)]<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> all members of JSON structure</span>
jspath(<span class="pl-s"><span class="pl-pds">"</span>$..*<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Our JSONPath parser supports all queries except for queries that rely on expressions of the underlying language like <code>$..book[(@.length-1)]</code>. However, there’s usually a ready workaround as you can execute the same query using <code>$..book[-1:]</code>.</p> 
  <p>Another deviation from JSONPath is to always flatten the results of a recursive query. Using the bookstore example, typically a query of <code>$..book</code> will return an array with one element, the array of books. If there was another book array somewhere in the document, then <code>$..book</code> will return an array with two elements, both arrays of books. However, if you were to query <code>$..book[2]</code> for our example, you would get the second book in the first array, which assumes that the <code>$..book</code> result has been flattened. In Unicorn, we always flatten the result of recursive queries regardless of the context.</p> 
  <p>It is also possible to update fields with JSONPath. Currently, we support only child and array slice operators for update.</p> 
  <div class="highlight highlight-source-scala">
   <pre>jspath(<span class="pl-s"><span class="pl-pds">"</span>$['store']['book'][1:3]['price']<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> <span class="pl-c1">30.0</span></pre>
  </div> 
  <h1><a href="https://github.com/haifengl/unicorn#document-api" aria-hidden="true" class="anchor" id="user-content-document-api" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Document API</h1> 
  <p>Unicorn's document APIs are defined in package <code>unicorn.unibase</code>, which is independent of backend storage engine. Simply pass a reference to storage engine to <code>Unibase()</code>, which provides the interface of document model.</p> 
  <p>In relational database, a table is a set of tuples that have the same attributes. In Unibase, a table contains documents, which are JSON objects and may have nested objects and/or arrays. Besides, the tables in Unibase do not enforce a schema. Documents in a table may have different fields. Typically, all documents in a collection are of similar or related purpose. Moreover, documents in a table must have unique IDs/keys, which is not necessary in relational databases.</p> 
  <p>In MongoDB, such a group of documents is called collection. In order to avoid the confusion with Java/Scala's collection data structures, Unibase simply calls it table.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Unibase</span>(<span class="pl-en">Accumulo</span>())
db.createTable(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">workers</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>In above, we create a table <code>worker</code> in Unibase. Then we create a JSON object and insert it into the worker table as following. Note that we explicitly create the <code>JsObject</code> by specifying the fields and values instead of parsing from a JSON string. This way provides fine controls on the data types of fields.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">joe</span> <span class="pl-k">=</span> <span class="pl-en">JsObject</span>(
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Male<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">50000.0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsObject</span>(
    <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>
  ),
  <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsArray</span>(<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>)
)

<span class="pl-k">val</span> <span class="pl-en">key</span> <span class="pl-k">=</span> workers.upsert(joe)</pre>
  </div> 
  <p>Each document should have a field <code>_id</code> as the primary key. If it is missing, the <code>upsert</code> operation will generate a random UUID as <code>_id</code>, which is returned and also added into the input JSON object:</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> joe.prettyPrint
res1<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span>
{
  <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>
  },
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Male<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">50000.0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span><span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>],
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>cc8a6a6d-4305-4b77-a776-6f70f2306d06<span class="pl-pds">"</span></span>
}</pre>
  </div> 
  <p>If the input object includes <code>_id</code> and the table already contains a document with same key, the document will be overwritten by <code>upsert</code>. If this is not the preferred behavior, one may use <code>insert</code>, which checks if the document already exists and throws an exception if so.</p> 
  <p>To make the code future proof, it is recommended to use the constant value <code>$id</code>, defined in <code>Unibase</code> package object, instead of <code>_id</code> in the code.</p> 
  <p>Besides UUID, one may also <code>Int</code>, <code>Long</code>, <code>Date</code>, <code>String</code>, and BSON' <code>ObjectId</code> (12 bytes including 4 bytes timestamp, 3 bytes machine id, 2 bytes process id, and 3 bytes incrementer) as the primary key. One may even use a complex JSON data type such as object or array as the primary key. However, this is NOT recommended because primary keys cannot be updated once a document inserted. To achieve similar effects, the old document has to be delete and inserted again with new key. However, the old document will be permanently deleted after the major compaction, which may not be desired. Even before the document be permanently deleted, the time travel functionality is broken for this document.</p> 
  <p>To get the document back, simply treat the table as a map and use <code>_id</code> as the key:</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> workers(key).get.prettyPrint
res3<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span>
{
  <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span> {
    <span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>
  },
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>Male<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-c1">50000.0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span><span class="pl-k">:</span> [<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>],
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">"</span>cc8a6a6d-4305-4b77-a776-6f70f2306d06<span class="pl-pds">"</span></span>
}</pre>
  </div> 
  <p>If the document doesn't exist, <code>None</code> is returned.</p> 
  <p>To update a document, we use a MongoDB-like API:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">update</span> <span class="pl-k">=</span> <span class="pl-en">JsObject</span>(
   <span class="pl-s"><span class="pl-pds">"</span>$id<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> key,
   <span class="pl-s"><span class="pl-pds">"</span>$set<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsObject</span>(
     <span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">100000.0</span>,
     <span class="pl-s"><span class="pl-pds">"</span>address.street<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>5 ADP Blvd<span class="pl-pds">"</span></span>
   ),
   <span class="pl-s"><span class="pl-pds">"</span>$unset<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsObject</span>(
     <span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsTrue</span>
   )
)

workers.update(update)</pre>
  </div> 
  <p>The <code>$set</code> operator replaces the value of a field with the specified value, provided that the new field does not violate a type constraint (and the document key <code>_id</code> should not be set). If the field does not exist, <code>$set</code> will add a new field with the specified value. To specify a field in an embedded object or in an array, use dot notation. To be compatible to MongoDB, we concatenate the array name with the dot (.) and zero-based index position to specify an element of an array by the zero-based index position, which is different from the <code>[]</code> convention in JavaScript and JSONPath.</p> 
  <p>In MongoDB, <code>$set</code> will create the embedded objects as needed to fulfill the dotted path to the field. For example, for a <code>$set {"a.b.c" : "abc"}</code>, MongoDB will create the embedded object "a.b" if it doesn't exist. However, we don't support this behavior because of the performance considerations. We suggest the the alternative syntax <code>{"a.b" : {"c" : "abc"}}</code>, which has the equivalent effect.</p> 
  <p>If you want to use <code>json</code> string interpolation to create a JSON object for <code>update</code>, remember to escape <code>$set</code> and <code>$unset</code> by double dollar sign, e.g. <code>$$set</code> and <code>$$unset</code>.</p> 
  <p>To delete a document, use the method <code>delete</code> with the document key:</p> 
  <div class="highlight highlight-source-scala">
   <pre>workers.delete(key)</pre>
  </div> 
  <h2><a href="https://github.com/haifengl/unicorn#append-only" aria-hidden="true" class="anchor" id="user-content-append-only" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Append Only</h2> 
  <p>When creating a table, we may declare it append only. Such a table is write-once (i.e. the same document is never updated). Any updates to existing documents will throw exceptions. Deletes are not allowed either.</p> 
  <div class="highlight highlight-source-scala">
   <pre>db.createTable(<span class="pl-s"><span class="pl-pds">"</span>stock<span class="pl-pds">"</span></span>, appendOnly <span class="pl-k">=</span> <span class="pl-c1">true</span>)
<span class="pl-k">val</span> <span class="pl-en">prices</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>stock<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">trade</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "ticker": "GOOG",</span>
<span class="pl-s">    "price": 700.0,</span>
<span class="pl-s">    "timestamp": ${System.currentTimeMillis}</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-k">val</span> <span class="pl-en">key</span> <span class="pl-k">=</span> prices.upsert(trade)
prices.update(<span class="pl-en">JsObject</span>(
  <span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> key,
  <span class="pl-s"><span class="pl-pds">"</span>$set<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsObject</span>(
    <span class="pl-s"><span class="pl-pds">"</span>price<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsDouble</span>(<span class="pl-c1">800.0</span>)
  )
))


java.lang.<span class="pl-en">UnsupportedOperationException</span>
  at unicorn.unibase.<span class="pl-en">Table</span>.update(<span class="pl-en">Table</span>.scala<span class="pl-k">:</span><span class="pl-c1">320</span>)
  ... <span class="pl-c1">52</span> elided</pre>
  </div> 
  <h2><a href="https://github.com/haifengl/unicorn#multi-tenancy" aria-hidden="true" class="anchor" id="user-content-multi-tenancy" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Multi-Tenancy</h2> 
  <p>Multi-tenant tables are regular tables that enables views to be created over the table across different tenants. This option is useful to share the same physical BigTable table across many different tenants.</p> 
  <p>To use a multi-tenant table, the user must firstly set the tenant id, which cannot be <code>undefined</code>, <code>null</code>, <code>boolean</code>, <code>counter</code>, <code>date</code>, or <code>double</code>. The tenats only see their data in such tables.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">workers</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)
workers.tenant <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>IBM<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">ibmer</span> <span class="pl-k">=</span> workers.upsert(json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "name": "Tom",</span>
<span class="pl-s">    "age": 40</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>)

workers.tenant <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Google<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">googler</span> <span class="pl-k">=</span> workers.upsert(json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "name": "Tom",</span>
<span class="pl-s">    "age": 30</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>)</pre>
  </div> 
  <p>Because the tenant is "Google" now, the data of tenant "IBM" are not visible.</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> workers(ibmer)
res5<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span>
unicorn<span class="pl-k">&gt;</span> workers(googler)
res6<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>({<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Tom<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-c1">30</span>,<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>545ed4d1-280c-4b6a-a3cc-e0a3c5fc5b43<span class="pl-pds">"</span></span>})</pre>
  </div> 
  <p>Switch back to "IBM", the view is different:</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> workers.tenant <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>IBM<span class="pl-pds">"</span></span>
workers.tenant<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsValue</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-en">IBM</span>)
unicorn<span class="pl-k">&gt;</span> workers(ibmer)
res8<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>({<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Tom<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>age<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-c1">40</span>,<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>2b7fb69f-810f-4ca7-a70f-5db767bc8e49<span class="pl-pds">"</span></span>})
unicorn<span class="pl-k">&gt;</span> workers(googler)
res9<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span></pre>
  </div> 
  <p>As a client-side solution, Unicorn does not enforce security on multi-tenant tables. In fact, there are no concepts of user and/or role. It is the application's responsibility to ensure the authorization and the authentication on the access of multi-tenant tables.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#locality" aria-hidden="true" class="anchor" id="user-content-locality" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Locality</h2> 
  <p>When Unicorn creates a document table, it creates only one column family by default.</p> 
  <div class="highlight highlight-source-scala">
   <pre>db.createTable(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>,
  families <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Unibase</span>.<span class="pl-en">DocumentColumnFamily</span>),
  locality <span class="pl-k">=</span> <span class="pl-en">Map</span>().withDefaultValue(<span class="pl-en">Unibase</span>.<span class="pl-en">DocumentColumnFamily</span>))</pre>
  </div> 
  <p>where the parameter <code>families</code> is the list of column families, and the parameter <code>locality</code>, a map, tells Unicorn how to map the data to different column families. Because we have only one column families here, we simply set the default value of map is the only column family.</p> 
  <p>This schema can be customized. When documents in a table have a lot of fields and only a few fields are needed in many situations, it is a good idea to organize them into different column families based on business logic and access patterns. Such a design is more efficient because the storage engine needs scan only the necessary column family. It also limits the network data transmission.</p> 
  <div class="highlight highlight-source-scala">
   <pre>db.createTable(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>,
  families <span class="pl-k">=</span> <span class="pl-en">Seq</span>(
    <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>person<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span>),
  locality <span class="pl-k">=</span> <span class="pl-en">Map</span>(
    $id <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span>
  ).withDefaultValue(<span class="pl-s"><span class="pl-pds">"</span>person<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>For simplicity, Unicorn uses only the top level fields of documents to determine the locality mapping.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">joe</span> <span class="pl-k">=</span> <span class="pl-en">JsObject</span>(
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Male<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">50000.0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsObject</span>(
    <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>
  ),
  <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsArray</span>(<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>)
)

<span class="pl-k">val</span> <span class="pl-en">key</span> <span class="pl-k">=</span> workers.upsert(joe)</pre>
  </div> 
  <p>We can retrieve partial documents as following, which is known as "projection" in relational database and MongoDB.</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> workers(key)
res17<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>({<span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span>{<span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>},<span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span><span class="pl-k">:</span>[<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>],<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>6df63cf3-e4dd-4381-8276-ac0c0626dc78<span class="pl-pds">"</span></span>})
unicorn<span class="pl-k">&gt;</span> workers(key, <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span>)
res19<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>({<span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span>{<span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>},<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>6df63cf3-e4dd-4381-8276-ac0c0626dc78<span class="pl-pds">"</span></span>})
unicorn<span class="pl-k">&gt;</span> workers(key, <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span>)
res20<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>({<span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span><span class="pl-k">:</span>[<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>],<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>6df63cf3-e4dd-4381-8276-ac0c0626dc78<span class="pl-pds">"</span></span>})</pre>
  </div> 
  <p>You can retrieve data from multiple column families too.</p> 
  <div class="highlight highlight-source-scala">
   <pre>unicorn<span class="pl-k">&gt;</span> workers(key, <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span>)
res21<span class="pl-k">:</span> <span class="pl-en">Option</span>[unicorn.json.<span class="pl-en">JsObject</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>({<span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span><span class="pl-k">:</span>{<span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>},<span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>Male<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-c1">50000.0</span>,<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span><span class="pl-k">:</span><span class="pl-s"><span class="pl-pds">"</span>6df63cf3-e4dd-4381-8276-ac0c0626dc78<span class="pl-pds">"</span></span>})</pre>
  </div> 
  <p>However, there is a semantic difference from regular projection as you may notice in the above. Even though the user asks for only <code>name</code>, all other fields in the same column family are returned. This is due to the design of BigTable and the mapping from document fields to columns. For example, if a specified field is a nested object, there is no easy way to read only the specified object in BigTable. Intra-row scan may help but not all BigTable implementations support it. And if there are multiple nested objects in request, we have to send multiple <code>Get</code> requests, which is not efficient. Instead, we return the whole object of a column family if some of its fields are in request. This is usually good enough for hot-cold data scenario. For instance of a table of events, each event has a header in a column family and event body in another column family. In many reads, we only need to access the header (the hot data). When only user is interested in the event details, we go to read the event body (the cold data). Such a design is simple and efficient. Another difference from MongoDB is that we do not support the <code>excluded</code> fields.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#script" aria-hidden="true" class="anchor" id="user-content-script" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Script</h2> 
  <p>We may also run Unicorn code as a shell script or batch command. The following bash script can be run directly from the command shell:</p> 
  <div class="highlight highlight-source-scala">
   <pre>#<span class="pl-k">!</span><span class="pl-k">/</span>bin<span class="pl-k">/</span>bash
exec unicorn <span class="pl-k">-</span>nc <span class="pl-s"><span class="pl-pds">"</span>$0<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>$@<span class="pl-pds">"</span></span>
<span class="pl-k">!</span>#

<span class="pl-k">import</span> <span class="pl-v">unicorn.json.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">unicorn.bigtable.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">unicorn.bigtable.accumulo.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">unicorn.bigtable.hbase.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">unicorn.unibase.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Unibase</span>(<span class="pl-en">Accumulo</span>())
db.createTable(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">workers</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">joe</span> <span class="pl-k">=</span> <span class="pl-en">JsObject</span>(
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Joe<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>gender<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Male<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>salary<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">50000.0</span>,
  <span class="pl-s"><span class="pl-pds">"</span>address<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsObject</span>(
    <span class="pl-s"><span class="pl-pds">"</span>street<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1 ADP Blvd<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Roseland<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>state<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>NJ<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>zip<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>07068<span class="pl-pds">"</span></span>
  ),
  <span class="pl-s"><span class="pl-pds">"</span>project<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsArray</span>(<span class="pl-s"><span class="pl-pds">"</span>HCM<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>NoSQL<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Analytics<span class="pl-pds">"</span></span>)
)

workers.upsert(joe)</pre>
  </div> 
  <h1><a href="https://github.com/haifengl/unicorn#narwhal" aria-hidden="true" class="anchor" id="user-content-narwhal" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Narwhal</h1> 
  <p>Advanced document API with HBase is available in the package <code>unicorn.narwhal</code>. To use these features, the user should use the class <code>Narwhal</code> and <code>HTable</code>, which are subclasses of <code>Unibase</code> and <code>Table</code>, respectively.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Narwhal</span>(<span class="pl-en">HBase</span>())
db.createTable(<span class="pl-s"><span class="pl-pds">"</span>narwhal<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">rich</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "owner": "Rich",</span>
<span class="pl-s">    "phone": "123-456-7890",</span>
<span class="pl-s">    "address": {</span>
<span class="pl-s">      "street": "1 ADP Blvd.",</span>
<span class="pl-s">      "city": "Roseland",</span>
<span class="pl-s">      "state": "NJ"</span>
<span class="pl-s">    },</span>
<span class="pl-s">    "children": 2C</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>

<span class="pl-k">val</span> <span class="pl-en">bucket</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>narwhal<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">key</span> <span class="pl-k">=</span> bucket.upsert(rich)</pre>
  </div> 
  <h2><a href="https://github.com/haifengl/unicorn#counter-1" aria-hidden="true" class="anchor" id="user-content-counter-1" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Counter</h2> 
  <p>The usage of <code>Narwhal</code> and <code>HTable</code> are similar to their parent classes. Besides, additional operators are available by taking advantage of HBase's features. Note that in the above the field <code>children</code> takes the value of <code>2C</code>. The suffix <code>C</code> indicates it is a counter. You may use <code>JsCounter</code> to create a counter directly too. With counters, we may update them in an atomic operation. For a regular integer, we instead have to read, update, and write back, which may cause consistency problems.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">increment</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$inc": {</span>
<span class="pl-s">      "children": 1</span>
<span class="pl-s">    }</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>

increment(<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> key
bucket.update(increment)

<span class="pl-k">val</span> <span class="pl-en">doc</span> <span class="pl-k">=</span> bucket(key).get
println(doc.children)</pre>
  </div> 
  <p>This example will print out the new value, i.e. 3, of <code>children</code>. It is also possible to use a negative value in <code>$inc</code> operations, which effectively decreases the counter.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#rollback-1" aria-hidden="true" class="anchor" id="user-content-rollback-1" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Rollback</h2> 
  <p>Another interesting feature is that we can rollback document fields back to previous values. If a user accidentally changes a value, don't worry. The old values are still in HBase and we can easily rollback.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">update</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$set": {</span>
<span class="pl-s">      "phone": "212-456-7890",</span>
<span class="pl-s">      "gender": "M",</span>
<span class="pl-s">      "address.street": "5 ADP Blvd."</span>
<span class="pl-s">    }</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>

update(<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> key
bucket.update(update)</pre>
  </div> 
  <p>In the above example, we update three fields <code>phone</code>, <code>gender</code>, and <code>address.street</code>. Note that <code>gender</code> is actually a new filed. Let's verify these fields be updated.</p> 
  <pre><code>unicorn&gt; bucket(key).get
res11: unicorn.json.JsObject = {"children":2,"address":{"city":"Roseland","state":"NJ","street":"5 ADP Blvd."},"owner":"Rich","gender":"M","_id":"0c354c07-6e25-4b30-9cf3-9a508b6868fd","phone":"212-456-7890"}
</code></pre> 
  <p>Now we rollback <code>phone</code> and <code>gender</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">rollback</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$rollback": {</span>
<span class="pl-s">      "phone": 1,</span>
<span class="pl-s">      "gender": 1</span>
<span class="pl-s">    }</span>
<span class="pl-s"> }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>
rollback(<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> key
bucket.update(rollback)</pre>
  </div> 
  <p>Printing out the document, we can find that <code>phone</code> has the previous value and <code>gender</code> disappears now. Of course, <code>address.street</code> still keeps the latest values.</p> 
  <pre><code>unicorn&gt; bucket(key).get
res15: unicorn.json.JsObject = {"children":4,"address":{"city":"Roseland","state":"NJ","street":"5 ADP Blvd."},"owner":"Rich","_id":"0c354c07-6e25-4b30-9cf3-9a508b6868fd","phone":"123-456-7890"}
</code></pre> 
  <p>This example shows how we can rollback <code>$set</code> operations. We actually can also rollback <code>$unset</code> operations.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">update</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$unset": {</span>
<span class="pl-s">      "owner": 1,</span>
<span class="pl-s">      "address": 1</span>
<span class="pl-s">    }</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>

update(<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> key
bucket.update(update)

<span class="pl-k">val</span> <span class="pl-en">rollback</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$rollback": {</span>
<span class="pl-s">      "owner": 1,</span>
<span class="pl-s">      "address": 1</span>
<span class="pl-s">    }</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>

rollback(<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> key
bucket.update(rollback)</pre>
  </div> 
  <h2><a href="https://github.com/haifengl/unicorn#time-travel-1" aria-hidden="true" class="anchor" id="user-content-time-travel-1" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Time Travel</h2> 
  <p>Another cool feature of Narwhal is time travel. Because HBase stores multiple timestamped values, we can query the snapshot of a document at a given time point.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">asOfDate</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Date</span>

<span class="pl-k">val</span> <span class="pl-en">update</span> <span class="pl-k">=</span> json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$set": {</span>
<span class="pl-s">      "phone": "212-456-7890",</span>
<span class="pl-s">      "gender": "M",</span>
<span class="pl-s">      "address.street": "5 ADP Blvd."</span>
<span class="pl-s">    },</span>
<span class="pl-s">    "$$inc": {</span>
<span class="pl-s">      "children": 1</span>
<span class="pl-s">    }</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>

update(<span class="pl-s"><span class="pl-pds">"</span>_id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> key
bucket.update(update)

bucket(asOfDate, key)</pre>
  </div> 
  <p>Besides the plain <code>Get</code>, we can supply an as-of-date parameter in a time travel <code>Get</code>, which will retrieval document's value at that time point.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#filter" aria-hidden="true" class="anchor" id="user-content-filter" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Filter</h2> 
  <p>So far, we get documents by their keys. With HBase, we can also query documents with method <code>find</code> by filtering field values. The <code>find</code> method returns an iterator to the documents that match the query criteria.</p> 
  <div class="highlight highlight-source-scala">
   <pre>bucket.upsert(json<span class="pl-s"><span class="pl-pds">"""</span>{"name":"Tom","age":30,"state":"NY"}<span class="pl-pds">"""</span></span>)
bucket.upsert(json<span class="pl-s"><span class="pl-pds">"""</span>{"name":"Mike","age":40,"state":"NJ"}<span class="pl-pds">"""</span></span>)
bucket.upsert(json<span class="pl-s"><span class="pl-pds">"""</span>{"name":"Chris","age":30,"state":"NJ"}<span class="pl-pds">"""</span></span>)

<span class="pl-k">val</span> <span class="pl-en">it</span> <span class="pl-k">=</span> bucket.find(json<span class="pl-s"><span class="pl-pds">"""</span>{"name": "Tom"}<span class="pl-pds">"""</span></span>)
it.foreach(println(_))</pre>
  </div> 
  <p>Optionally, the <code>find</code> method takes the second parameter for projection, which is an object that specifies the fields to return.</p> 
  <p>The <code>find</code> method with no parameters returns all documents from a table and returns all fields for the documents.</p> 
  <p>The syntax of filter object is similar to MongoDB. Supported operators include <code>$and</code>, <code>$or</code>, <code>$eq</code>, <code>$ne</code>, <code>$gt</code>, <code>$gte</code> (or <code>$ge</code>), <code>$lt</code>, <code>$lte</code> (or <code>$le</code>).</p> 
  <div class="highlight highlight-source-scala">
   <pre>bucket.find(json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  {</span>
<span class="pl-s">    "$$or": [</span>
<span class="pl-s">      {</span>
<span class="pl-s">        "age": {"$$gt": 30}</span>
<span class="pl-s">      },</span>
<span class="pl-s">      {</span>
<span class="pl-s">        "state": "NY"</span>
<span class="pl-s">      }</span>
<span class="pl-s">    ]</span>
<span class="pl-s">  }</span>
<span class="pl-s"><span class="pl-pds">"""</span></span>)</pre>
  </div> 
  <p>If you prefer SQL-like query, just do it as follows:</p> 
  <div class="highlight highlight-source-scala">
   <pre>bucket.find(<span class="pl-s"><span class="pl-pds">"""</span>age &gt; 30 OR stage = "NY"<span class="pl-pds">"""</span></span>)</pre>
  </div> 
  <p>Note that the query operation is based on server side filters. Although it minimizes the network transmission, it is still a costly full table scan. If the table is multi-tenanted and each tenant does not have too much data (e.g. SaaS solutions for small business), however, the scan will be usually localized to one or a few nodes and often quite fast. Compared to secondary index, this approach does not have penalty on the write performance and still provides fairly good performance on queries in such a situation.</p> 
  <p>For general purpose queries, secondary index should be built to accelerate frequent queries. We will discuss our secondary index design in the below.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#sql" aria-hidden="true" class="anchor" id="user-content-sql" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SQL</h2> 
  <p>In fact, you can do a SQL-like query in the code or shell, which returns a <code>DataFrame</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>db.sql(<span class="pl-s"><span class="pl-pds">"""</span>SELECT address.state,</span>
<span class="pl-s">            COUNT(address.state),</span>
<span class="pl-s">            MAX(age),</span>
<span class="pl-s">            AVG(salary) as avg_salary</span>
<span class="pl-s">          FROM worker</span>
<span class="pl-s">          GROUP BY address.state</span>
<span class="pl-s">          ORDER By avg_salary<span class="pl-pds">"""</span></span>)</pre>
  </div> 
  <p>Although filtering is done on the server side, all other heavy computation such as <code>SUM</code>, <code>GROUP BY</code>, <code>ORDER BY</code>, etc. are done on the client side. So this is only useful for small operational queries that involves a handful rows. For large scale analytics queries, we should use Spark as discussed below.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#spark" aria-hidden="true" class="anchor" id="user-content-spark" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Spark</h2> 
  <p>For large scale analytics, Narwhal supports Spark. A table can be exported to Spark as <code>RDD[JsObject]</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.apache.spark.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.spark.rdd.</span><span class="pl-v">RDD</span>

<span class="pl-k">val</span> <span class="pl-en">conf</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SparkConf</span>().setAppName(<span class="pl-s"><span class="pl-pds">"</span>unicorn<span class="pl-pds">"</span></span>).setMaster(<span class="pl-s"><span class="pl-pds">"</span>local[4]<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">sc</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SparkContext</span>(conf)

<span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Narwhal</span>(<span class="pl-en">HBase</span>())
<span class="pl-k">val</span> <span class="pl-en">table</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)
table.tenant <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>IBM<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">rdd</span> <span class="pl-k">=</span> table.rdd(sc)
rdd.count()</pre>
  </div> 
  <p>In the above example, we first create a <code>SparkContext</code>. To export a table to spark, simply pass the <code>SparkContext</code> object to the <code>rdd</code> method of a table object. In this example, we only export the data of tenant <code>IBM</code>.</p> 
  <p>Although Spark has filter functions on <code>RDDs</code>, it is better to use HBase's server side filter at beginning to reduce network transmission. The <code>rdd</code> method can take the second optional parameter for filtering, same syntax as in <code>find</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">table</span> <span class="pl-k">=</span> db(<span class="pl-s"><span class="pl-pds">"</span>narwhal<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">rdd</span> <span class="pl-k">=</span> table.rdd(sc, json<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">                          {</span>
<span class="pl-s">                            "$$or": [</span>
<span class="pl-s">                              {</span>
<span class="pl-s">                                "age": {"$$gt": 30}</span>
<span class="pl-s">                              },</span>
<span class="pl-s">                              {</span>
<span class="pl-s">                                "state": "NJ"</span>
<span class="pl-s">                              }</span>
<span class="pl-s">                            ]</span>
<span class="pl-s">                          }</span>
<span class="pl-s">                        <span class="pl-pds">"""</span></span>)
rdd.count()</pre>
  </div> 
  <p>For analytics, <code>SQL</code> is still the best language. We can easily convert <code>RDD[JsObject]</code> to a strong-typed <code>DataFrame</code> to be analyzed in <code>SparkSQL</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">sqlContext</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">org.apache.spark.sql.SQLContext</span>(sc)
<span class="pl-k">import</span> <span class="pl-v">sqlContext.implicits.</span><span class="pl-v">_</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Worker</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>)
<span class="pl-k">val</span> <span class="pl-en">workers</span> <span class="pl-k">=</span> rdd.map { js <span class="pl-k">=&gt;</span> <span class="pl-en">Worker</span>(js.name, js.age) }
<span class="pl-k">val</span> <span class="pl-en">df</span> <span class="pl-k">=</span> sqlContext.createDataFrame(workers)
df.cache
df.show

df.registerTempTable(<span class="pl-s"><span class="pl-pds">"</span>worker<span class="pl-pds">"</span></span>)
sqlContext.sql(<span class="pl-s"><span class="pl-pds">"</span>SELECT * FROM worker WHERE age &gt; 30<span class="pl-pds">"</span></span>).show</pre>
  </div> 
  <p>In the above example, we create a <code>SQLContext</code> on top of <code>SparkContext</code> to use SparkSQL features. Then we create a <code>DataFrame</code> of case class <code>Worker</code> with type information. Since we will use this <code>DataFrame</code> many times in analysis, we also <code>cache</code> it with an in-memory columnar format. To do SQL queries, we also register this <code>DataFrame</code> as a temporary table.</p> 
  <h1><a href="https://github.com/haifengl/unicorn#graph" aria-hidden="true" class="anchor" id="user-content-graph" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Graph</h1> 
  <p>Graphs are mathematical structures used to model pairwise relations between objects. A graph is made up of vertices (nodes) which are connected by edges (lines). A graph may be undirected, meaning that there is no distinction between the two vertices associated with each edge, or its edges may be directed from one vertex to another. Directed graphs are also called digraphs and directed edges are also called arcs or arrows.</p> 
  <p>A multigraph is a graph which is permitted to have multiple edges (also called parallel edges), that is, edges that have the same end nodes. The ability to support parallel edges simplifies modeling scenarios where there can be multiple relationships (e.g., co-worker and friend) between the same vertices.</p> 
  <p>In a property graph, the generic mathematical graph is often extended to support user defined objects attached to each vertex and edge. The edges also have associated labels denoting the relationships, which are important in a multigraph.</p> 
  <p>Unicorn supports directed property multigraphs. Documents from different tables can be added as vertices to a multigraph. It is also okay to add vertices without corresponding to documents. Each relationship/edge has a label and optional data (any valid JsValue, default value JsInt(1)).</p> 
  <p>Unicorn stores graphs in adjacency lists. That is, a graph is stored as a BigTable whose rows are vertices with their adjacency list. The adjacency list of a vertex contains all of the vertex’s incident edges (incoming and outgoing edges are in different column families).</p> 
  <p>Because large graphs are usually very sparse, an adjacency list is significantly more space-efficient than an adjacency matrix. Besides, the neighbors of each vertex may be listed efficiently with an adjacency list, which is important in graph traversals. With our design, it is also possible to test whether two vertices are adjacent to each other for a given relationship in constant time.</p> 
  <p>In what follows, we create a graph of gods, an example from Titan graph database.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> <span class="pl-en">Unibase</span>(<span class="pl-en">Accumulo</span>())
db.createGraph(<span class="pl-s"><span class="pl-pds">"</span>gods<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">gods</span> <span class="pl-k">=</span> db.graph(<span class="pl-s"><span class="pl-pds">"</span>gods<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-en">Snowflake</span>(<span class="pl-c1">0</span>))</pre>
  </div> 
  <p>Because each vertex in the graph must have a unique 64-bit ID, we should provide a (distributed) ID generator when we go to mutate a graph. We currently provide the Snowflake ID generator, designed by Twitter. Each Snowflake worker should have a unique worker ID so that multiple worker won't generate duplicate IDs in parallel. In a small system, these worker IDs may be hand picked. For a large system, it is better coordinated by ZooKeeper. In this demo, we simply use <code>0</code> as the worker ID in the shell. For production, you may do things like</p> 
  <div class="highlight highlight-source-scala">
   <pre>db.graph(<span class="pl-s"><span class="pl-pds">"</span>gods<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>zookeeper connection string<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>If no ID generator is provided, <code>db.graph("gods")</code> returns a read only instance for graph traversal or analytics.</p> 
  <p>In the next, we will add several vertices with properties stored in a <code>JsObject</code>. The function <code>addVertex</code> returns the ID of type <code>Long</code> of new vertex.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">saturn</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "titan", "name": "saturn", "age": 10000}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">sky</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "location", "name": "sky"}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">sea</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "location", "name": "sea"}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">jupiter</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "god", "name": "jupiter", "age": 5000}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">neptune</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "god", "name": "neptune", "age": 4500}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">hercules</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "demigod", "name": "hercules", "age": 30}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">alcmene</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "human", "name": "alcmene", "age": 45}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">pluto</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "god", "name": "pluto", "age": 4000}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">nemean</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "monster", "name": "nemean"}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">hydra</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "monster", "name": "hydra"}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">cerberus</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "monster", "name": "cerberus"}<span class="pl-pds">"""</span></span>)
<span class="pl-k">val</span> <span class="pl-en">tartarus</span> <span class="pl-k">=</span> gods.addVertex(json<span class="pl-s"><span class="pl-pds">"""</span>{"label": "location", "name": "tartarus"}<span class="pl-pds">"""</span></span>)</pre>
  </div> 
  <p>Of course, we will also add edges between vertices. It is important that edges have direction. With <code>addEdge(jupiter, "father", saturn)</code>, we add an edge from <code>jupiter</code> to <code>saturn</code> with label <code>father</code>. For this edge, <code>jupiter</code> is called out vertex while <code>saturn</code> is in vertex. From the point view of vertex, this edge is an outgoing edge of <code>jupiter</code> while the incoming edge of <code>saturn</code>.</p> 
  <p>Besides, we may also associate any <code>JsValue</code> to an edge. If no value is provided, the default value is <code>1</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>gods.addEdge(jupiter, <span class="pl-s"><span class="pl-pds">"</span>father<span class="pl-pds">"</span></span>, saturn)
gods.addEdge(jupiter, <span class="pl-s"><span class="pl-pds">"</span>lives<span class="pl-pds">"</span></span>, sky, json<span class="pl-s"><span class="pl-pds">"""</span>{"reason": "loves fresh breezes"}<span class="pl-pds">"""</span></span>)
gods.addEdge(jupiter, <span class="pl-s"><span class="pl-pds">"</span>brother<span class="pl-pds">"</span></span>, neptune)
gods.addEdge(jupiter, <span class="pl-s"><span class="pl-pds">"</span>brother<span class="pl-pds">"</span></span>, pluto)

gods.addEdge(neptune, <span class="pl-s"><span class="pl-pds">"</span>lives<span class="pl-pds">"</span></span>, sea, json<span class="pl-s"><span class="pl-pds">"""</span>{"reason": "loves waves"}<span class="pl-pds">"""</span></span>)
gods.addEdge(neptune, <span class="pl-s"><span class="pl-pds">"</span>brother<span class="pl-pds">"</span></span>, jupiter)
gods.addEdge(neptune, <span class="pl-s"><span class="pl-pds">"</span>brother<span class="pl-pds">"</span></span>, pluto)

gods.addEdge(hercules, <span class="pl-s"><span class="pl-pds">"</span>father<span class="pl-pds">"</span></span>, jupiter)
gods.addEdge(hercules, <span class="pl-s"><span class="pl-pds">"</span>mother<span class="pl-pds">"</span></span>, alcmene)
gods.addEdge(hercules, <span class="pl-s"><span class="pl-pds">"</span>battled<span class="pl-pds">"</span></span>, nemean, json<span class="pl-s"><span class="pl-pds">"""</span>{"time": 1, "place": {"latitude": 38.1, "longitude": 23.7}}<span class="pl-pds">"""</span></span>)
gods.addEdge(hercules, <span class="pl-s"><span class="pl-pds">"</span>battled<span class="pl-pds">"</span></span>, hydra, json<span class="pl-s"><span class="pl-pds">"""</span>{"time": 2, "place": {"latitude": 37.7, "longitude": 23.9}}<span class="pl-pds">"""</span></span>)
gods.addEdge(hercules, <span class="pl-s"><span class="pl-pds">"</span>battled<span class="pl-pds">"</span></span>, cerberus, json<span class="pl-s"><span class="pl-pds">"""</span>{"time": 12, "place": {"latitude": 39.0, "longitude": 22.0}}<span class="pl-pds">"""</span></span>)

gods.addEdge(pluto, <span class="pl-s"><span class="pl-pds">"</span>brother<span class="pl-pds">"</span></span>, jupiter)
gods.addEdge(pluto, <span class="pl-s"><span class="pl-pds">"</span>brother<span class="pl-pds">"</span></span>, neptune)
gods.addEdge(pluto, <span class="pl-s"><span class="pl-pds">"</span>lives<span class="pl-pds">"</span></span>, tartarus, json<span class="pl-s"><span class="pl-pds">"""</span>{"reason": "no fear of death"}<span class="pl-pds">"""</span></span>)
gods.addEdge(pluto, <span class="pl-s"><span class="pl-pds">"</span>pet<span class="pl-pds">"</span></span>, cerberus)

gods.addEdge(cerberus, <span class="pl-s"><span class="pl-pds">"</span>lives<span class="pl-pds">"</span></span>, tartarus)</pre>
  </div> 
  <p>Correspondingly, <code>deleteEdge</code> removes an edge and <code>deleteVertex</code> removes the vertex and all associated edges.</p> 
  <p>To retrieve a vertex and its edge, <code>gods(jupiter)</code> will return a <code>Vertex</code> object containing its ID, properties, and associated edges. One can also directly access the data of an edge by <code>gods(pluto, "brother", jupiter)</code>. If the edge doesn't exist, <code>None</code> is returned.</p> 
  <p>Although some graphs (e.g. Twitter graph) natively use <code>Long</code> integer as vertex IDS, many graphs use Strings as vertex IDs. In RDF (Resource Description Framework), for example, vertices are encoded as URI. In Unicorn, we can use strings as vertex keys too. Internally, Unicorn translates them to the corresponding <code>Long</code> vertex IDs. However, it is recommended to use <code>Long</code> vertex ID directly if possible because it provides better performance.</p> 
  <p>It is also possible to add a document (in another table) as a vertex to a graph.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> key is the document key in the table "person"</span>
<span class="pl-k">val</span> <span class="pl-en">id</span> <span class="pl-k">=</span> gods.addVertex(<span class="pl-s"><span class="pl-pds">"</span>person<span class="pl-pds">"</span></span>, key)</pre>
  </div> 
  <p>If the <code>person</code> table is multi-tenanted, remember to use tenant id as the third argument. To access the vertex, it is simply as <code>gods("person", key)</code>.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#gremlin-like-api" aria-hidden="true" class="anchor" id="user-content-gremlin-like-api" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Gremlin-like API</h2> 
  <p>For graph traversal, we support a <a href="http://tinkerpop.apache.org" target="_blank">Gremlin</a>-like API. To start a traversal,</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">g</span> <span class="pl-k">=</span> gods.traversal</pre>
  </div> 
  <p>Then we can start with one or more vertex by the method <code>v</code>,</p> 
  <div class="highlight highlight-source-scala">
   <pre>g.v(saturn)</pre>
  </div> 
  <p>A Traversal is essentially an Iterator of vertices or edges. On a vertex, we can call <code>outE()</code> and <code>inE()</code> to access its outgoing edges or incoming edges, respectively. On an edge, <code>inV()</code> and <code>outV()</code> returns its in vertex and out vertex, respectively. For vertex, <code>out()</code> is a shortcut to <code>outE().inV()</code> and similarly <code>in()</code> is shortcut to <code>inE().outV()</code>. All these functions may take a set of labels to filter relationships.</p> 
  <p>The following example shows how to get saturn's grandchildren's name.</p> 
  <div class="highlight highlight-source-scala">
   <pre>g.v(saturn).in(<span class="pl-s"><span class="pl-pds">"</span>father<span class="pl-pds">"</span></span>).in(<span class="pl-s"><span class="pl-pds">"</span>father<span class="pl-pds">"</span></span>).name</pre>
  </div> 
  <p>For detailed information on Gremlin, please refer its <a href="http://tinkerpop.apache.org" target="_blank">website</a>.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#graph-search" aria-hidden="true" class="anchor" id="user-content-graph-search" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Graph Search</h2> 
  <p>Beyond simple graph traversal, Unicorn supports DFS, BFS, A* search, Dijkstra algorithm, etc.</p> 
  <p>The below example searches for the shortest path between jupiter and cerberus with Dijkstra algorithm.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">path</span> <span class="pl-k">=</span> <span class="pl-en">GraphOps</span>.dijkstra(jupiter, cerberus, <span class="pl-k">new</span> <span class="pl-en">SimpleTraveler</span>(gods)).map { edge <span class="pl-k">=&gt;</span>
  (edge.from, edge.label, edge.to)
}

path.foreach(println(_))</pre>
  </div> 
  <p>Note that this search is performed by a single machine. For very large graph, it is better to use some distributed graph computing engine such as Spark GraphX.</p> 
  <h2><a href="https://github.com/haifengl/unicorn#spark-graphx" aria-hidden="true" class="anchor" id="user-content-spark-graphx" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Spark GraphX</h2> 
  <p>With HBase/Narwhal, we can export a graph to Spark GraphX for advanced analytics such as PageRank, triangle count, SVD++, etc.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.apache.spark.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">conf</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SparkConf</span>().setAppName(<span class="pl-s"><span class="pl-pds">"</span>unicorn<span class="pl-pds">"</span></span>).setMaster(<span class="pl-s"><span class="pl-pds">"</span>local[4]<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">sc</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SparkContext</span>(conf)

<span class="pl-k">val</span> <span class="pl-en">graph</span> <span class="pl-k">=</span> db.graph(<span class="pl-s"><span class="pl-pds">"</span>gods<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">graphx</span> <span class="pl-k">=</span> graph.graphx(sc)

<span class="pl-c"><span class="pl-c">//</span> Run PageRank</span>
<span class="pl-k">val</span> <span class="pl-en">ranks</span> <span class="pl-k">=</span> graphx.pageRank(<span class="pl-c1">0.0001</span>).vertices</pre>
  </div> 
  <h1><a href="https://github.com/haifengl/unicorn#http-api" aria-hidden="true" class="anchor" id="user-content-http-api" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>HTTP API</h1> 
  <p>So far we access Unicorn through its Scala APIs. For other programming language users, we can manipulate documents with the HTTP API, which is provided by the Rhino module.</p> 
  <p>In the configuration file <code>conf/rhino.conf</code>, the underlying BigTable database engine should be configured in the section <code>uncorn.rhino</code>. The configuration file is in the format of <a href="https://github.com/typesafehub/config" target="_blank">Typesafe Config</a>. For example,</p> 
  <pre><code>unicorn.rhino {
  bigtable = "hbase"
  accumulo {
    instance = "local-poc"
    zookeeper = "127.0.0.1:2181"
    user = "root"
    password = "secret"
  }
  cassandra {
    host = "127.0.0.1"
    port = 9160
  }
}
</code></pre> 
  <p>In this example, we use HBase as the BigTable engine. Note that the configuration of HBase is in its own configuration files, which should be in the <code>CLASSPATH</code> of Rhino. Sample configurations of Accumulo and Cassandra are provided in the example for demonstration.</p> 
  <p>Currently, Rhino provides only data manipulation operations. Other operations such as table creation/drop should be done in the Unicorn Shell.</p> 
  <table> 
   <thead> 
    <tr> 
     <th>Method</th> 
     <th>URL</th> 
     <th>Operation</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>PUT</td> 
     <td>/table/[table name]</td> 
     <td>Insert</td> 
    </tr> 
    <tr> 
     <td>POST</td> 
     <td>/table/[table name]</td> 
     <td>Upsert</td> 
    </tr> 
    <tr> 
     <td>PATCH</td> 
     <td>/table/[table name]</td> 
     <td>Update</td> 
    </tr> 
    <tr> 
     <td>DELETE</td> 
     <td>/table/[table name]</td> 
     <td>Delete</td> 
    </tr> 
    <tr> 
     <td>DELETE</td> 
     <td>/table/[table name]/key</td> 
     <td>Delete</td> 
    </tr> 
    <tr> 
     <td>GET</td> 
     <td>/table/[table name]</td> 
     <td>Get</td> 
    </tr> 
    <tr> 
     <td>GET</td> 
     <td>/table/[table name]/key</td> 
     <td>Get</td> 
    </tr>
   </tbody>
  </table> 
  <p>The API is simple and easy to use. To insert a document, use the <code>PUT</code> method with the JSON object as entity-body.</p> 
  <div class="highlight highlight-source-shell">
   <pre>curl -X PUT -H <span class="pl-s"><span class="pl-pds">"</span>Content-Type: application/json<span class="pl-pds">"</span></span> -d <span class="pl-s"><span class="pl-pds">'</span>{"_id":"dude","username":"xyz","password":"xyz"}<span class="pl-pds">'</span></span> http://localhost:8080/table/rhino_test_table</pre>
  </div> 
  <p>To read it back, simply use <code>GET</code> method. If the key is a string, the key can be part of the URI. Otherwise, the key should be set in the entity-body. The same rule applies to the <code>DELETE</code> method.</p> 
  <div class="highlight highlight-source-shell">
   <pre>curl -X GET http://localhost:8080/table/unicorn_rhino_test/dude</pre>
  </div> 
  <p>To update a document, use the <code>PATCH</code> method.</p> 
  <div class="highlight highlight-source-shell">
   <pre>curl -X PATCH -H <span class="pl-s"><span class="pl-pds">"</span>Content-Type: application/json<span class="pl-pds">"</span></span> -d <span class="pl-s"><span class="pl-pds">'</span>{"_id":"dude","$set":{"password":"abc"}}<span class="pl-pds">'</span></span> http://localhost:8080/table/rhino_test_table</pre>
  </div> 
  <p>In case of multi-tenancy, the tenant id should be set in the header.</p> 
  <div class="highlight highlight-source-shell">
   <pre>curl -X PUT -H <span class="pl-s"><span class="pl-pds">"</span>Content-Type: application/json<span class="pl-pds">"</span></span> --header <span class="pl-s"><span class="pl-pds">'</span>tenant: "IBM"<span class="pl-pds">'</span></span> -d <span class="pl-s"><span class="pl-pds">'</span>{"_id":"dude","username":"xyz","password":"xyz"}<span class="pl-pds">'</span></span> http://localhost:8080/table/rhino_test_table

curl -X GET --header <span class="pl-s"><span class="pl-pds">'</span>tenant: "IBM"<span class="pl-pds">'</span></span> http://localhost:8080/table/rhino_test_table/dude

curl -X GET --header <span class="pl-s"><span class="pl-pds">'</span>tenant: "MSFT"<span class="pl-pds">'</span></span> http://localhost:8080/table/rhino_test_table/dude

curl -X DELETE --header <span class="pl-s"><span class="pl-pds">'</span>tenant: "IBM"<span class="pl-pds">'</span></span> http://localhost:8080/table/rhino_test_table/dude</pre>
  </div> 
 </article>
</div>