<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-smile" class="anchor" href="https://github.com/haifengl/smile#smile" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Smile</h1> 
  <p><a href="https://gitter.im/haifengl/smile?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/723f768014a5a468cff2852c18b5c30627c9fec1/68747470733a2f2f6261646765732e6769747465722e696d2f68616966656e676c2f736d696c652e737667" alt="Join the chat at https://gitter.im/haifengl/smile" data-canonical-src="https://badges.gitter.im/haifengl/smile.svg" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/com.github.haifengl/smile-core" target="_blank"><img src="https://camo.githubusercontent.com/ab31cc6104c65ee96227258c538a24b5cbdfdc4a/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e6769746875622e68616966656e676c2f736d696c652d636f72652f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.github.haifengl/smile-core/badge.svg" style="max-width:100%;"></a></p> 
  <p>Smile (Statistical Machine Intelligence and Learning Engine) is a fast and comprehensive machine learning system. With advanced data structures and algorithms, Smile delivers state-of-art performance.</p> 
  <p>Smile covers every aspect of machine learning, including classification, regression, clustering, association rule mining, feature selection, manifold learning, multidimensional scaling, genetic algorithms, missing value imputation, efficient nearest neighbor search, etc.</p> 
  <p>The core algorithms are implemented in Java and self contained.</p> 
  <ul> 
   <li><strong>Core</strong> The core machine learning library.</li> 
   <li><strong>Scala</strong> The high level operators in Scala.</li> 
   <li><strong>Math</strong> Linear algebra, statistical distribution, hypothesis tests, random number generators, sorting, special functions, various kernels, distance and rbf functions.</li> 
   <li><strong>Data</strong> Parsers for arff, libsvm, delimited text, sparse matrix, microarray gene expression data.</li> 
   <li><strong>Graph</strong> Graph algorithms on adjacency list and matrix.</li> 
   <li><strong>Interpolation</strong> One and two dimensional interpolation.</li> 
   <li><strong>NLP</strong> Natural language processing.</li> 
   <li><strong>Plot</strong> Swing-based data visualization library.</li> 
  </ul> 
  <p>Smile is well documented and please check out the <a href="http://haifengl.github.io/smile/" target="_blank">project website</a> for programming guides and more information.</p> 
  <p>You can use the libraries through Maven central repository by adding the following to your project pom.xml file.</p> 
  <pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;com.github.haifengl&lt;/groupId&gt;
      &lt;artifactId&gt;smile-core&lt;/artifactId&gt;
      &lt;version&gt;1.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre> 
  <p>For NLP, use the artifactId smile-nlp.</p> 
  <p>For Scala API, please use</p> 
  <pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;com.github.haifengl&lt;/groupId&gt;
      &lt;artifactId&gt;smile-scala_2.11&lt;/artifactId&gt;
      &lt;version&gt;1.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre> 
  <p>Smile comes with an interactive shell. Download pre-packaged Smile from the <a href="https://github.com/haifengl/smile/releases" target="_blank">releases page</a>. In the home directory of Smile, type</p> 
  <pre><code>    ./bin/smile
</code></pre> 
  <p>to enter the shell, which is based on Scala interpreter. So you can run any valid Scala expressions in the shell. In the simplest case, you can use it as a calculator. Besides, all high-level Smile operators are predefined in the shell. Be default, the shell uses up to 4GB memory. If you need more memory to handle large data, use the option <code>-J-Xmx</code>. For example,</p> 
  <pre><code>    ./bin/smile -J-Xmx8192M
</code></pre> 
  <p>You can also modify the configuration file <code>./conf/application.ini</code> for the memory and other JVM settings. For detailed helps, checkout the <a href="http://haifengl.github.io/smile/" target="_blank">project website</a>.</p> 
  <p>Smile implements the following major machine learning algorithms:</p> 
  <ul> 
   <li> <p><strong>Classification</strong> Support Vector Machines, Decision Trees, AdaBoost, Gradient Boosting, Random Forest, Logistic Regression, Neural Networks, RBF Networks, Maximum Entropy Classifier, KNN, Na√Øve Bayesian, Fisher/Linear/Quadratic/Regularized Discriminant Analysis.</p> </li> 
   <li> <p><strong>Regression</strong> Support Vector Regression, Gaussian Process, Regression Trees, Gradient Boosting, Random Forest, RBF Networks, OLS, LASSO, Ridge Regression.</p> </li> 
   <li> <p><strong>Feature Selection</strong> Genetic Algorithm based Feature Selection, Ensemble Learning based Feature Selection, Signal Noise ratio, Sum Squares ratio.</p> </li> 
   <li> <p><strong>Clustering</strong> BIRCH, CLARANS, DBScan, DENCLUE, Deterministic Annealing, K-Means, X-Means, G-Means, Neural Gas, Growing Neural Gas, Hierarchical Clustering, Sequential Information Bottleneck, Self-Organizing Maps, Spectral Clustering, Minimum Entropy Clustering.</p> </li> 
   <li> <p><strong>Association Rule &amp; Frequent Itemset Mining</strong> FP-growth mining algorithm</p> </li> 
   <li> <p><strong>Manifold learning</strong> IsoMap, LLE, Laplacian Eigenmap, PCA, Kernel PCA, Probabilistic PCA, GHA, Random Projection</p> </li> 
   <li> <p><strong>Multi-Dimensional Scaling</strong> Classical MDS, Isotonic MDS, Sammon Mapping</p> </li> 
   <li> <p><strong>Nearest Neighbor Search</strong> BK-Tree, Cover Tree, KD-Tree, LSH</p> </li> 
   <li> <p><strong>Sequence Learning</strong> Hidden Markov Model, Conditional Random Field.</p> </li> 
   <li> <p><strong>Natural Language Processing</strong> Sentence Splitter and Tokenizer, Bigram Statistical Test, Phrase Extractor, Keyword Extractor, Stemmer, POS Tagging, Relevance Ranking</p> </li> 
  </ul> 
  <h1><a id="user-content-model-serialization" class="anchor" href="https://github.com/haifengl/smile#model-serialization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Model Serialization</h1> 
  <p>You may notice that most models support the Java <code>Serializable</code> interface (all classifiers do support <code>Serializable</code> interface). It is because the exact format is hard to keep stable, class changes can easily make your serialized data unreadable, reading/writing the data in non-Java code is almost impossible. Currently, we suggest <a href="http://xstream.codehaus.org" target="_blank">XStream</a> to serialize the trained models. XStream is a simple library to serialize objects to XML and back again. XStream is easy to use and doesn't require mappings (actually requires no modifications to objects). <a href="http://code.google.com/p/protostuff/" target="_blank">Protostuff</a> is a nice alternative that supports forward-backward compatibility (schema evolution) and validation. Beyond XML, Protostuff supports many other formats such as JSON, YAML, protobuf, etc. For some predictive models, we look forward to supporting PMML (Predictive Model Markup Language), an XML-based file format developed by the Data Mining Group.</p> 
  <p>Smile Scala API provides read and write functions in package smile.io to read and save models by XStream.</p> 
  <h1><a id="user-content-smileplot" class="anchor" href="https://github.com/haifengl/smile#smileplot" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SmilePlot</h1> 
  <p>Smile also has a Swing-based data visualization library SmilePlot, which provides scatter plot, line plot, staircase plot, bar plot, box plot, histogram, 3D histogram, dendrogram, heatmap, hexmap, QQ plot, contour plot, surface, and wireframe. The class PlotCanvas provides builtin functions such as zoom in/out, export, print, customization, etc.</p> 
  <p>SmilePlot requires SwingX library for JXTable. But if your environment cannot use SwingX, it is easy to remove this dependency by using JTable.</p> 
  <p>To use SmilePlot, add the following to dependencies</p> 
  <pre><code>    &lt;dependency&gt;
      &lt;groupId&gt;com.github.haifengl&lt;/groupId&gt;
      &lt;artifactId&gt;smile-plot&lt;/artifactId&gt;
      &lt;version&gt;1.3.1&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre> 
  <h1><a id="user-content-demo-gallery" class="anchor" href="https://github.com/haifengl/smile#demo-gallery" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Demo Gallery</h1> 
  <table width="100%"> 
   <tbody>
    <tr> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-kpca.png" target="_blank"><img src="https://camo.githubusercontent.com/804437c14e211371e3f8c8bb517e6d75c2ba56e0/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d6b7063612d736d616c6c2e706e67" alt="Kernel PCA" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-kpca-small.png" style="max-width:100%;"></a> <h2><a id="user-content-kernel-pca" class="anchor" href="https://github.com/haifengl/smile#kernel-pca" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Kernel PCA</h2> </td> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-isomap.png" target="_blank"><img src="https://camo.githubusercontent.com/a99188ce09cf30da7d78d01702911b88e8d90a50/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d69736f6d61702d736d616c6c2e706e67" alt="IsoMap" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-isomap-small.png" style="max-width:100%;"></a> <h2><a id="user-content-isomap" class="anchor" href="https://github.com/haifengl/smile#isomap" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>IsoMap</h2> </td> 
    </tr> 
    <tr> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-mds.png" target="_blank"><img src="https://camo.githubusercontent.com/cf8f85d9c5bb289ad0d3924905d967d841f07fcf/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d6d64732d736d616c6c2e706e67" alt="MDS" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-mds-small.png" style="max-width:100%;"></a> <h2><a id="user-content-multi-dimensional-scaling" class="anchor" href="https://github.com/haifengl/smile#multi-dimensional-scaling" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Multi-Dimensional Scaling</h2> </td> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-som.png" target="_blank"><img src="https://camo.githubusercontent.com/39035f580e9f2bf7b1dfa04832546257d14f0285/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d736f6d2d736d616c6c2e706e67" alt="SOM" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-som-small.png" style="max-width:100%;"></a> <h2><a id="user-content-som" class="anchor" href="https://github.com/haifengl/smile#som" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>SOM</h2> </td> 
    </tr> 
    <tr> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-ann.png" target="_blank"><img src="https://camo.githubusercontent.com/5fbe44fe78341142196e0434554bfb6787158242/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d616e6e2d736d616c6c2e706e67" alt="Neural Network" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-ann-small.png" style="max-width:100%;"></a> <h2><a id="user-content-neural-network" class="anchor" href="https://github.com/haifengl/smile#neural-network" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Neural Network</h2> </td> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-svm.png" target="_blank"><img src="https://camo.githubusercontent.com/81aae2742bcc9635039a9df0007741035bc7cc5b/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d73766d2d736d616c6c2e706e67" alt="SVM" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-svm-small.png" style="max-width:100%;"></a> <h2><a id="user-content-svm" class="anchor" href="https://github.com/haifengl/smile#svm" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>SVM</h2> </td> 
    </tr> 
    <tr> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-agglomerative-clustering.png" target="_blank"><img src="https://camo.githubusercontent.com/af9c7e30f4d6d391ac6b679fa6f401c82f844c5d/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d6167676c6f6d657261746976652d636c7573746572696e672d736d616c6c2e706e67" alt="Agglomerative Clustering" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-agglomerative-clustering-small.png" style="max-width:100%;"></a> <h2><a id="user-content-agglomerative-clustering" class="anchor" href="https://github.com/haifengl/smile#agglomerative-clustering" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Agglomerative Clustering</h2> </td> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-xmeans.png" target="_blank"><img src="https://camo.githubusercontent.com/89c7dc576e45771d749b20c6f2ab6b5e615abc70/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d786d65616e732d736d616c6c2e706e67" alt="X-Means" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-xmeans-small.png" style="max-width:100%;"></a> <h2><a id="user-content-x-means" class="anchor" href="https://github.com/haifengl/smile#x-means" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>X-Means</h2> </td> 
    </tr> 
    <tr> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-dbscan.png" target="_blank"><img src="https://camo.githubusercontent.com/24254568949007ba651b2acda125ebcb88e0931f/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d64627363616e2d736d616c6c2e706e67" alt="DBScan" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-dbscan-small.png" style="max-width:100%;"></a> <h2><a id="user-content-dbscan" class="anchor" href="https://github.com/haifengl/smile#dbscan" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>DBScan</h2> </td> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-neural-gas.png" target="_blank"><img src="https://camo.githubusercontent.com/2bbd7265a0d69b3f34e10b53a03489d141ee8b3a/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d6e657572616c2d6761732d736d616c6c2e706e67" alt="Neural Gas" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-neural-gas-small.png" style="max-width:100%;"></a> <h2><a id="user-content-neural-gas" class="anchor" href="https://github.com/haifengl/smile#neural-gas" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Neural Gas</h2> </td> 
    </tr> 
    <tr> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-wavelet.png" target="_blank"><img src="https://camo.githubusercontent.com/853451eb5204c4903d0b6682a965fdc84ba15a80/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d776176656c65742d736d616c6c2e706e67" alt="Wavelet" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-wavelet-small.png" style="max-width:100%;"></a> <h2><a id="user-content-wavelet" class="anchor" href="https://github.com/haifengl/smile#wavelet" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Wavelet</h2> </td> 
     <td width="50%"> <a href="http://haifengl.github.io/smile/gallery/smile-demo-mixture.png" target="_blank"><img src="https://camo.githubusercontent.com/ca7942d092f2f4fe2da11c377924b61dbea05830/687474703a2f2f68616966656e676c2e6769746875622e696f2f736d696c652f67616c6c6572792f736d696c652d64656d6f2d6d6978747572652d736d616c6c2e706e67" alt="Mixture" data-canonical-src="http://haifengl.github.io/smile/gallery/smile-demo-mixture-small.png" style="max-width:100%;"></a> <h2><a id="user-content-exponential-family-mixture" class="anchor" href="https://github.com/haifengl/smile#exponential-family-mixture" aria-hidden="true" target="_blank">
        <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
         <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
        </svg></a>Exponential Family Mixture</h2> </td> 
    </tr> 
   </tbody>
  </table> 
  <h1><a id="user-content-tutorial" class="anchor" href="https://github.com/haifengl/smile#tutorial" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Tutorial</h1> 
  <p>This tutorial shows how to use the Smile Java API for predictive modeling (classification and regression). It includes loading data, training and testing the model, and applying the model. If you use Scala, we strongly recommend the new high level Scala API, which is similar to R and Matlab. The programming guide with Scala API is available at <a href="http://haifengl.github.io/smile/" target="_blank">project website</a>.</p> 
  <h2><a id="user-content-load-data" class="anchor" href="https://github.com/haifengl/smile#load-data" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Load Data</h2> 
  <p>Most Smile algorithms take simple double[] as input so you can use your favorite methods or library to import the data as long as the samples are in double arrays. To make life easier, Smile does provide a couple of parsers for popular data formats, such as Weka's ARFF files, LibSVM's file format, delimited text files, and binary sparse data. These classes are in the package smile.data.parser. The package smile.data.parser.microarray also provides several parsers for microarray gene expression datasets, including GCT, PCL, RES, and TXT files. In the following example, we use the ARFF parser to load the weather dataset:</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-smi">ArffParser</span> arffParser <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ArffParser</span>();
arffParser<span class="pl-k">.</span>setResponseIndex(<span class="pl-c1">4</span>);
<span class="pl-smi">AttributeDataset</span> weather <span class="pl-k">=</span> arffParser<span class="pl-k">.</span>parse(<span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>data/weka/weather.nominal.arff<span class="pl-pds">"</span></span>));
<span class="pl-k">double</span>[][] x <span class="pl-k">=</span> weather<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">double</span>[weather<span class="pl-k">.</span>size()][]);
<span class="pl-k">int</span>[] y <span class="pl-k">=</span> weather<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">int</span>[weather<span class="pl-k">.</span>size()]);</pre>
  </div> 
  <p>Note that the data file weather.nominal.arff is in Smile distribution package. After unpacking the package, there is a lot of testing data in the directory of <code>$smile/data</code>, where <code>$smile</code> is the the root of Smile package.</p> 
  <p>In the second line, we use <code>setResponseIndex</code> to set the column index (starting at 0) of the dependent/response variable. In supervised learning, we need a response variable for each sample to train the model. Basically, it is the <em>y</em> in the mathematical model. For classification, it is the class label. For regression, it is of real value. Without setting it, the data assumes no response variable. In that case, the data can be used for testing or unsupervised learning.</p> 
  <p>The parse method can take a <code>URI</code>, <code>File</code>, path string, or <code>InputStream</code> as an input argument. And it returns an <code>AttributeDataset</code> object, which is a dataset of a number of attributes. All attribute values are stored as double even if the attribute may be nominal, ordinal, string, or date. The first call of <code>toArray</code> taking a <code>double[][]</code> argument fills the array with all the parsed data and returns it, of which each row is a sample/object. The second call of <code>toArray</code> taking an int array fills it with the class labels of the samples and then returns it.</p> 
  <p>The <code>AttributeDataset.attributes</code> method returns the list of <code>Attribute</code> objects in the dataset. The <code>Attribute</code> object contains the type information (and optional weight), which is needed in some algorithms (e.g. decision trees). The <code>Attribute</code> object also contains variable name and description, which are useful in the output or UI.</p> 
  <p>Similar to <code>ArffParser</code>, we can also use the <code>DelimitedTextParser</code> class to parse plain delimited text files. By default, the parser expects a white-space-separated-values file. Each line in the file corresponds to a row in the table. Within a line, fields are separated by white spaces, each field belonging to one table column. This class can also be used to read other text tabular files by setting the delimiter character such as ','. The file may contain comment lines (starting with '%') and missing values (indicated by placeholder '?'), which can both be parameterized.</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-smi">DelimitedTextParser</span> parser <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DelimitedTextParser</span>();
parser<span class="pl-k">.</span>setResponseIndex(<span class="pl-k">new</span> <span class="pl-smi">NominalAttribute</span>(<span class="pl-s"><span class="pl-pds">"</span>class<span class="pl-pds">"</span></span>), <span class="pl-c1">0</span>);
<span class="pl-smi">AttributeDataset</span> usps <span class="pl-k">=</span> parser<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>USPS Train<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>data/usps/zip.train<span class="pl-pds">"</span></span>));</pre>
  </div> 
  <p>where the <code>setResponseIndex</code> also takes an extra parameter about the attribute of the response variable. Because this is a classification problem, we set it to a <code>NominalAttribute</code> with name "class". In case of regression, we should use <code>NumericAttribute</code> instead.</p> 
  <p>If your input data contains different types of attributes (e.g. <code>NumericAttribute</code>, <code>NominalAttribute</code>, <code>StringAttribute</code>, <code>DateAttribute</code>, etc), you should pass an array of <code>Attribute[]</code> to the constructor of <code>DelimitedTextParser</code> to indicate the data types of each column. By default, <code>DelimitedTextParser</code> assumes all columns as <code>NumericAttribute</code>.</p> 
  <h2><a id="user-content-train-the-model" class="anchor" href="https://github.com/haifengl/smile#train-the-model" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Train The Model</h2> 
  <p>Smile implements a variety of classification and regression algorithms. In what follows, we train a support vector machine (SVM) on the USPS zip code handwriting dataset. The SVM employs a Gaussian kernel and one-to-one strategy as this is a multi-class problem. Different from LibSVM or other popular SVM library, Smile implements an online learning algorithm for training SVM. The method <code>learn</code> trains the SVM with the given dataset for one epoch. The caller may call this method multiple times to obtain better accuracy although one epoch is usually sufficient. Note that after calling <code>learn</code>, we need to call the <code>finish</code> method, which processes support vectors until they converge. As it is an online algorithm, the user may update the model anytime by calling <code>learn</code> even after calling the <code>finish</code> method. In the example, we show another way of learning by working on single sample. As shown in the example, we simply call the <code>predict</code> method on a testing sample. Both <code>learn</code> and <code>predict</code> methods are generic for all classification and regression algorithms.</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-smi">DelimitedTextParser</span> parser <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">DelimitedTextParser</span>();
parser<span class="pl-k">.</span>setResponseIndex(<span class="pl-k">new</span> <span class="pl-smi">NominalAttribute</span>(<span class="pl-s"><span class="pl-pds">"</span>class<span class="pl-pds">"</span></span>), <span class="pl-c1">0</span>);
<span class="pl-k">try</span> {
    <span class="pl-smi">AttributeDataset</span> train <span class="pl-k">=</span> parser<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>USPS Train<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>/data/usps/zip.train<span class="pl-pds">"</span></span>));
    <span class="pl-smi">AttributeDataset</span> test <span class="pl-k">=</span> parser<span class="pl-k">.</span>parse(<span class="pl-s"><span class="pl-pds">"</span>USPS Test<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>/data/usps/zip.test<span class="pl-pds">"</span></span>));

    <span class="pl-k">double</span>[][] x <span class="pl-k">=</span> train<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">double</span>[train<span class="pl-k">.</span>size()][]);
    <span class="pl-k">int</span>[] y <span class="pl-k">=</span> train<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">int</span>[train<span class="pl-k">.</span>size()]);
    <span class="pl-k">double</span>[][] testx <span class="pl-k">=</span> test<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">double</span>[test<span class="pl-k">.</span>size()][]);
    <span class="pl-k">int</span>[] testy <span class="pl-k">=</span> test<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">int</span>[test<span class="pl-k">.</span>size()]);
            
    <span class="pl-k">SVM&lt;double[]&gt;</span> svm <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">SVM&lt;double[]&gt;</span>(<span class="pl-k">new</span> <span class="pl-smi">GaussianKernel</span>(<span class="pl-c1">8.0</span>), <span class="pl-c1">5.0</span>, <span class="pl-smi">Math</span><span class="pl-k">.</span>max(y)<span class="pl-k">+</span><span class="pl-c1">1</span>, <span class="pl-c1">SVM</span><span class="pl-k">.</span><span class="pl-smi">Multiclass</span><span class="pl-c1"><span class="pl-k">.</span>ONE_VS_ONE</span>);
    svm<span class="pl-k">.</span>learn(x, y);
    svm<span class="pl-k">.</span>finish();
            
    <span class="pl-k">int</span> error <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> testx<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (svm<span class="pl-k">.</span>predict(testx[i]) <span class="pl-k">!=</span> testy[i]) {
            error<span class="pl-k">++</span>;
        }
    }

    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>format(<span class="pl-s"><span class="pl-pds">"</span>USPS error rate = %.2f%%<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">100.0</span> <span class="pl-k">*</span> error <span class="pl-k">/</span> testx<span class="pl-k">.</span>length);
            
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>USPS one more epoch...<span class="pl-pds">"</span></span>);
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> x<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
        <span class="pl-k">int</span> j <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>randomInt(x<span class="pl-k">.</span>length);
        svm<span class="pl-k">.</span>learn(x[j], y[j]);
    }
            
    svm<span class="pl-k">.</span>finish();

    error <span class="pl-k">=</span> <span class="pl-c1">0</span>;
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> testx<span class="pl-k">.</span>length; i<span class="pl-k">++</span>) {
        <span class="pl-k">if</span> (svm<span class="pl-k">.</span>predict(testx[i]) <span class="pl-k">!=</span> testy[i]) {
            error<span class="pl-k">++</span>;
        }
    }
    <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>format(<span class="pl-s"><span class="pl-pds">"</span>USPS error rate = %.2f%%<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">100.0</span> <span class="pl-k">*</span> error <span class="pl-k">/</span> testx<span class="pl-k">.</span>length);
} <span class="pl-k">catch</span> (<span class="pl-smi">Exception</span> ex) {
    <span class="pl-smi">System</span><span class="pl-k">.</span>err<span class="pl-k">.</span>println(ex);
}</pre>
  </div> 
  <p>As aforementioned, tree based methods need the type information of attributes. In the next example, we train an <code>AdaBoost</code> model on the weather dataset.</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-smi">ArffParser</span> arffParser <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">ArffParser</span>();
arffParser<span class="pl-k">.</span>setResponseIndex(<span class="pl-c1">4</span>);
<span class="pl-smi">AttributeDataset</span> weather <span class="pl-k">=</span> arffParser<span class="pl-k">.</span>parse(<span class="pl-k">new</span> <span class="pl-smi">FileInputStream</span>(<span class="pl-s"><span class="pl-pds">"</span>/data/weka/weather.nominal.arff<span class="pl-pds">"</span></span>));
<span class="pl-k">double</span>[][] x <span class="pl-k">=</span> weather<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">double</span>[weather<span class="pl-k">.</span>size()][]);
<span class="pl-k">int</span>[] y <span class="pl-k">=</span> weather<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">int</span>[weather<span class="pl-k">.</span>size()]);

<span class="pl-smi">AdaBoost</span> forest <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">AdaBoost</span>(weather<span class="pl-k">.</span>attributes(), x, y, <span class="pl-c1">200</span>, <span class="pl-c1">4</span>);</pre>
  </div> 
  <p>In the example, we set the number of trees to 200 and the maximum number of leaf nodes in the trees to 4, which works as a regularization control.</p> 
  <h2><a id="user-content-model-validation" class="anchor" href="https://github.com/haifengl/smile#model-validation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Model Validation</h2> 
  <p>In the example of USPS, we have both training and test datasets. However, we frequently have only a single dataset for building models. For model validation, Smile provide LOOCV (leave-one-out cross validation), cross validation, and bootstrap in the package smile.validation. Additionally, the package also has various measures to evaluate classification, regression, and clustering. For example, we have accuracy, fallout, FDR, F-measure (F1 score or F-score), precision, recall, sensitivity, specificity for classification; absolute deviation, MSE, RMSE, RSS for regression; rand index, adjust rand index for clustering. The following is an example how to use LOOCV.</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">double</span>[][] x <span class="pl-k">=</span> weather<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">double</span>[weather<span class="pl-k">.</span>size()][]);
<span class="pl-k">int</span>[] y <span class="pl-k">=</span> weather<span class="pl-k">.</span>toArray(<span class="pl-k">new</span> <span class="pl-smi">int</span>[weather<span class="pl-k">.</span>size()]);

<span class="pl-k">int</span> n <span class="pl-k">=</span> x<span class="pl-k">.</span>length;
<span class="pl-smi">LOOCV</span> loocv <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">LOOCV</span>(n);
<span class="pl-k">int</span> error <span class="pl-k">=</span> <span class="pl-c1">0</span>;
<span class="pl-k">for</span> (<span class="pl-k">int</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> n; i<span class="pl-k">++</span>) {
    <span class="pl-k">double</span>[][] trainx <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>slice(x, loocv<span class="pl-k">.</span>train[i]);
    <span class="pl-k">int</span>[] trainy <span class="pl-k">=</span> <span class="pl-smi">Math</span><span class="pl-k">.</span>slice(y, loocv<span class="pl-k">.</span>train[i]);
                
    <span class="pl-smi">AdaBoost</span> forest <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-smi">AdaBoost</span>(weather<span class="pl-k">.</span>attributes(), trainx, trainy, <span class="pl-c1">200</span>, <span class="pl-c1">4</span>);
    <span class="pl-k">if</span> (y[loocv<span class="pl-k">.</span>test[i]] <span class="pl-k">!=</span> forest<span class="pl-k">.</span>predict(x[loocv<span class="pl-k">.</span>test[i]]))
        error<span class="pl-k">++</span>;
}
            
<span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>Decision Tree error = <span class="pl-pds">"</span></span> <span class="pl-k">+</span> error);</pre>
  </div> 
  <h2><a id="user-content-use-the-trained-model" class="anchor" href="https://github.com/haifengl/smile#use-the-trained-model" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Use The Trained Model</h2> 
  <p>All classifiers in Smile implement the following interface.</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">public</span> <span class="pl-k">interface</span> <span class="pl-en">Classifier</span>&lt;T&gt; {
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">predict</span>(<span class="pl-smi">T</span> <span class="pl-v">x</span>);
    <span class="pl-k">public</span> <span class="pl-k">int</span> <span class="pl-en">predict</span>(<span class="pl-smi">T</span> <span class="pl-v">x</span>, <span class="pl-k">double</span>[] <span class="pl-v">posteriori</span>);
}</pre>
  </div> 
  <p>To use the trained model, we can apply the method <code>predict</code> on a new sample. Besides just returning the class label, many methods (e.g. neural networks) can also output the posteriori probabilities of each class.</p> 
 </article>
</div>