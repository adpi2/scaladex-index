<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-streamz" class="anchor" href="https://github.com/krasserm/streamz#streamz" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Streamz</h1> 
  <p><a href="https://gitter.im/krasserm/streamz?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge" target="_blank"><img src="https://camo.githubusercontent.com/562dc9528099f138263b73aa23434e70089427f9/68747470733a2f2f6261646765732e6769747465722e696d2f6b7261737365726d2f73747265616d7a2e737667" alt="Gitter" data-canonical-src="https://badges.gitter.im/krasserm/streamz.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/krasserm/streamz" target="_blank"><img src="https://camo.githubusercontent.com/42f05adbb24ef05606758c69dc26a5e11b74e9f1/68747470733a2f2f7472617669732d63692e6f72672f6b7261737365726d2f73747265616d7a2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/krasserm/streamz.svg?branch=master" style="max-width:100%;"></a></p> 
  <p>Streamz is a combinator library for integrating <a href="https://github.com/functional-streams-for-scala/fs2" target="_blank">Functional Streams for Scala</a> (FS2), <a href="http://doc.akka.io/docs/akka/2.4/scala/stream/index.html" target="_blank">Akka Streams</a> and <a href="http://camel.apache.org/" target="_blank">Apache Camel</a>. It integrates</p> 
  <ul> 
   <li><strong>FS2 with Akka Streams:</strong> FS2 <code>Stream</code>s, <code>Pipe</code>s and <code>Sink</code>s can be converted to Akka Stream <code>Source</code>s, <code>Flow</code>s and <code>Sink</code>s, respectively, and vice versa with <a href="https://github.com/krasserm/streamz#stream-converters" target="_blank">Stream converters</a>.</li> 
   <li><strong>FS2 with Apache Camel:</strong> <a href="http://camel.apache.org/components.html" target="_blank">Camel endpoints</a> can be integrated into FS2 streams with the <a href="https://github.com/krasserm/streamz#dsl-for-fs2" target="_blank">Camel DSL for FS2</a>.</li> 
   <li><strong>Akka Streams with Apache Camel:</strong> Camel endpoints can be integrated into Akka Streams with the <a href="https://github.com/krasserm/streamz#dsl-for-as" target="_blank">Camel DSL for Akka Streams</a>.</li> 
  </ul> 
  <p><a href="https://github.com/krasserm/streamz/blob/master/images/streamz-intro.png" target="_blank"><img src="https://github.com/krasserm/streamz/raw/master/images/streamz-intro.png" alt="Streamz intro" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-api-docs" class="anchor" href="https://github.com/krasserm/streamz#api-docs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>API docs</h2> 
  <ul> 
   <li><a href="http://krasserm.github.io/streamz/scala-2.12/unidoc/index.html" target="_blank">API docs for Scala 2.12</a></li> 
   <li><a href="http://krasserm.github.io/streamz/scala-2.11/unidoc/index.html" target="_blank">API docs for Scala 2.11</a></li> 
  </ul> 
  <h2><a id="user-content-dependencies" class="anchor" href="https://github.com/krasserm/streamz#dependencies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependencies</h2> 
  <p>Streamz artifacts are available for Scala 2.11 and 2.12:</p> 
  <pre><code>resolvers += "krasserm at bintray" at "http://dl.bintray.com/krasserm/maven"

// transitively depends on akka-stream 2.4.14
libraryDependencies += "com.github.krasserm" %% "streamz-akka" % "0.6"

// transitively depends on Apache Camel 2.18.0
libraryDependencies += "com.github.krasserm" %% "streamz-camel" % "0.6"
</code></pre> 
  <p><a name="user-content-stream-converters" target="_blank" href=""></a></p>
  <a name="user-content-stream-converters" target="_blank" href=""> </a>
  <h2><a name="user-content-stream-converters" target="_blank" href=""></a><a id="user-content-stream-converters" class="anchor" href="https://github.com/krasserm/streamz#stream-converters" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Stream converters</h2> 
  <p>Stream converters convert FS2 <code>Stream</code>s, <code>Pipe</code>s and <code>Sink</code>s to Akka Stream <code>Source</code>s, <code>Flow</code>s and <code>Sink</code>s, respectively, and vice versa. They are provided by the <code>streamz-akka</code> artifact and can be imported with </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">streamz.akka.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>and require the following <code>implicit</code>s in scope:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">akka.actor.</span><span class="pl-v">ActorRefFactory</span>
<span class="pl-k">import</span> <span class="pl-v">akka.stream.</span><span class="pl-v">ActorMaterializer</span>

<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">ExecutionContext</span>

<span class="pl-k">val</span> <span class="pl-en">factory</span><span class="pl-k">:</span> <span class="pl-en">ActorRefFactory</span> <span class="pl-k">=</span> ...

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">executionContext</span><span class="pl-k">:</span> <span class="pl-en">ExecutionContext</span> <span class="pl-k">=</span> factory.dispatcher
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">materializer</span><span class="pl-k">:</span> <span class="pl-en">ActorMaterializer</span> <span class="pl-k">=</span> <span class="pl-en">ActorMaterializer</span>()(factory)</pre>
  </div> 
  <h3><a id="user-content-conversions-from-akka-stream-to-fs2" class="anchor" href="https://github.com/krasserm/streamz#conversions-from-akka-stream-to-fs2" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Conversions from Akka Stream to FS2</h3> 
  <p><strong>Overview</strong>:</p> 
  <table>
   <thead> 
    <tr> 
     <th>From</th> 
     <th>With</th> 
     <th>To</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td><code>Graph[SourceShape[O], M]</code></td> 
     <td><code>toStream()</code></td> 
     <td><code>Stream[Task, O]</code></td> 
    </tr> 
    <tr> 
     <td><code>Graph[SinkShape[I], M]</code></td> 
     <td><code>toSink()</code></td> 
     <td><code>Sink[Task, I]</code></td> 
    </tr> 
    <tr> 
     <td><code>Graph[FlowShape[I, O], M]</code></td> 
     <td><code>toPipe()</code></td> 
     <td><code>Pipe[Task, I, O]</code></td> 
    </tr> 
   </tbody>
  </table> 
  <p><a name="user-content-stream-converters" target="_blank" href=""><strong>Examples</strong> (</a><a href="https://github.com/krasserm/streamz/blob/master/streamz-examples/src/main/scala/streamz/examples/akka/ConverterExample.scala" target="_blank">source code</a>):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">akka.stream.scaladsl.</span>{ <span class="pl-v">Flow</span> <span class="pl-k">=&gt;</span> <span class="pl-v">AkkaFlow</span>, <span class="pl-v">Sink</span> <span class="pl-k">=&gt;</span> <span class="pl-v">AkkaSink</span>, <span class="pl-v">Source</span> <span class="pl-k">=&gt;</span> <span class="pl-v">AkkaSource</span> }
<span class="pl-k">import</span> <span class="pl-v">akka.</span>{ <span class="pl-v">Done</span>, <span class="pl-v">NotUsed</span> }

<span class="pl-k">import</span> <span class="pl-v">fs2.</span>{ <span class="pl-v">Pipe</span>, <span class="pl-v">Sink</span>, <span class="pl-v">Stream</span>, <span class="pl-v">Task</span> }

<span class="pl-k">import</span> <span class="pl-v">scala.collection.immutable.</span><span class="pl-v">Seq</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>

<span class="pl-k">val</span> <span class="pl-en">numbers</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span> to <span class="pl-c1">10</span>
<span class="pl-k">def</span> <span class="pl-en">f</span>(<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=</span> <span class="pl-en">List</span>(s<span class="pl-s"><span class="pl-pds">"</span>$i-1<span class="pl-pds">"</span></span>, s<span class="pl-s"><span class="pl-pds">"</span>$i-2<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">aSink1</span><span class="pl-k">:</span> <span class="pl-en">AkkaSink</span>[<span class="pl-k">Int</span>, <span class="pl-en">Future</span>[<span class="pl-en">Done</span>]] <span class="pl-k">=</span> <span class="pl-en">AkkaSink</span>.foreach[<span class="pl-k">Int</span>](println)
<span class="pl-k">val</span> <span class="pl-en">fSink1</span><span class="pl-k">:</span> <span class="pl-en">Sink</span>[<span class="pl-en">Task</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> aSink1.toSink()

<span class="pl-k">val</span> <span class="pl-en">aSource1</span><span class="pl-k">:</span> <span class="pl-en">AkkaSource</span>[<span class="pl-k">Int</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> <span class="pl-en">AkkaSource</span>(numbers)
<span class="pl-k">val</span> <span class="pl-en">fStream1</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> aSource1.toStream()

<span class="pl-k">val</span> <span class="pl-en">aFlow1</span><span class="pl-k">:</span> <span class="pl-en">AkkaFlow</span>[<span class="pl-k">Int</span>, <span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> <span class="pl-en">AkkaFlow</span>[<span class="pl-k">Int</span>].mapConcat(f)
<span class="pl-k">val</span> <span class="pl-en">fPipe1</span><span class="pl-k">:</span> <span class="pl-en">Pipe</span>[<span class="pl-en">Task</span>, <span class="pl-k">Int</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span> aFlow1.toPipe()

fStream1.to(fSink1).run.unsafeRun() <span class="pl-c">// prints numbers</span>
assert(fStream1.runLog.unsafeRun() <span class="pl-k">==</span> numbers)
assert(fStream1.through(fPipe1).runLog.unsafeRun() <span class="pl-k">==</span> numbers.flatMap(f))</pre>
  </div> 
  <p><code>aSink1</code>, <code>aSource1</code> and <code>aFlow1</code> are materialized when the <code>Task</code>s of the FS2 streams that compose <code>fSink1</code>, <code>fStream1</code> and <code>fPipe1</code> are run. Their materialized value can be obtained via the <code>onMaterialization</code> callback that is a parameter of <code>toStream(onMaterialization: M =&gt; Unit)</code>, <code>toSink(onMaterialization: M =&gt; Unit)</code> and <code>toPipe(onMaterialization: M =&gt; Unit)</code> (not shown in the examples). </p> 
  <h3><a id="user-content-conversions-from-fs2-to-akka-stream" class="anchor" href="https://github.com/krasserm/streamz#conversions-from-fs2-to-akka-stream" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Conversions from FS2 to Akka Stream</h3> 
  <p><strong>Overview</strong>:</p> 
  <table>
   <thead> 
    <tr> 
     <th>From</th> 
     <th>With</th> 
     <th>To</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td><code>Stream[F[_], O]</code></td> 
     <td><code>toSource()</code></td> 
     <td><code>Graph[SourceShape[O], NotUsed]</code></td> 
    </tr> 
    <tr> 
     <td><code>Sink[F[_], I]</code></td> 
     <td><code>toSink()</code></td> 
     <td><code>Graph[SinkShape[I], Future[Done]]</code></td> 
    </tr> 
    <tr> 
     <td><code>Pipe[F[_], I, O]</code></td> 
     <td><code>toFlow()</code></td> 
     <td><code>Graph[FlowShape[I, O], NotUsed]</code></td> 
    </tr> 
   </tbody>
  </table> 
  <p><strong>Examples</strong> (<a href="https://github.com/krasserm/streamz/blob/master/streamz-examples/src/main/scala/streamz/examples/akka/ConverterExample.scala" target="_blank">source code</a>):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">akka.stream.scaladsl.</span>{ <span class="pl-v">Flow</span> <span class="pl-k">=&gt;</span> <span class="pl-v">AkkaFlow</span>, <span class="pl-v">Sink</span> <span class="pl-k">=&gt;</span> <span class="pl-v">AkkaSink</span>, <span class="pl-v">Source</span> <span class="pl-k">=&gt;</span> <span class="pl-v">AkkaSource</span>, <span class="pl-v">Keep</span> }
<span class="pl-k">import</span> <span class="pl-v">akka.</span>{ <span class="pl-v">Done</span>, <span class="pl-v">NotUsed</span> }

<span class="pl-k">import</span> <span class="pl-v">fs2.</span>{ <span class="pl-v">Pipe</span>, <span class="pl-v">Pure</span>, <span class="pl-v">Sink</span>, <span class="pl-v">Stream</span>, <span class="pl-v">pipe</span> }

<span class="pl-k">import</span> <span class="pl-v">scala.collection.immutable.</span><span class="pl-v">Seq</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span>{ <span class="pl-v">Await</span>, <span class="pl-v">Future</span> }
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">numbers</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-c1">1</span> to <span class="pl-c1">10</span>
<span class="pl-k">def</span> <span class="pl-en">g</span>(<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">=</span> i <span class="pl-k">+</span> <span class="pl-c1">10</span>

<span class="pl-k">val</span> <span class="pl-en">fSink2</span><span class="pl-k">:</span> <span class="pl-en">Sink</span>[<span class="pl-en">Pure</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> s <span class="pl-k">=&gt;</span> pipe.lift(g)(s).map(println)
<span class="pl-k">val</span> <span class="pl-en">aSink2</span><span class="pl-k">:</span> <span class="pl-en">AkkaSink</span>[<span class="pl-k">Int</span>, <span class="pl-en">Future</span>[<span class="pl-en">Done</span>]] <span class="pl-k">=</span> <span class="pl-en">AkkaSink</span>.fromGraph(fSink2.toSink)

<span class="pl-k">val</span> <span class="pl-en">fStream2</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Pure</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Stream</span>.emits(numbers)
<span class="pl-k">val</span> <span class="pl-en">aSource2</span><span class="pl-k">:</span> <span class="pl-en">AkkaSource</span>[<span class="pl-k">Int</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> <span class="pl-en">AkkaSource</span>.fromGraph(fStream2.toSource)

<span class="pl-k">val</span> <span class="pl-en">fpipe2</span><span class="pl-k">:</span> <span class="pl-en">Pipe</span>[<span class="pl-en">Pure</span>, <span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> pipe.lift[<span class="pl-en">Pure</span>, <span class="pl-k">Int</span>, <span class="pl-k">Int</span>](g)
<span class="pl-k">val</span> <span class="pl-en">aFlow2</span><span class="pl-k">:</span> <span class="pl-en">AkkaFlow</span>[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> <span class="pl-en">AkkaFlow</span>.fromGraph(fpipe2.toFlow)

aSource2.toMat(aSink2)(<span class="pl-en">Keep</span>.right).run() <span class="pl-c">// prints numbers</span>
assert(<span class="pl-en">Await</span>.result(aSource2.toMat(<span class="pl-en">AkkaSink</span>.seq)(<span class="pl-en">Keep</span>.right).run(), <span class="pl-c1">5.</span>seconds) <span class="pl-k">==</span> numbers)
assert(<span class="pl-en">Await</span>.result(aSource2.via(aFlow2).toMat(<span class="pl-en">AkkaSink</span>.seq)(<span class="pl-en">Keep</span>.right).run(), <span class="pl-c1">5.</span>seconds) <span class="pl-k">==</span> numbers.map(g))</pre>
  </div> 
  <p><code>fSink2</code>, <code>fStream2</code> and <code>fPipe2</code> are run when the Akka Streams that compose <code>aSink2</code>, <code>aSource2</code> and <code>aFlow2</code> are materialized.</p> 
  <h3><a id="user-content-backpressure-cancellation-completion-and-errors" class="anchor" href="https://github.com/krasserm/streamz#backpressure-cancellation-completion-and-errors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Backpressure, cancellation, completion and errors</h3> 
  <p>Downstream demand and cancellation as well as upstream completion and error signals are properly mediated between Akka Stream and FS2 (see also <a href="https://github.com/krasserm/streamz/blob/master/streamz-akka/src/test/scala/streamz/akka/ConverterSpec.scala" target="_blank">ConverterSpec</a>). </p> 
  <h2><a id="user-content-apache-camel-integration" class="anchor" href="https://github.com/krasserm/streamz#apache-camel-integration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Apache Camel integration</h2> 
  <p>Apache Camel endpoints can be integrated into FS2 streams and Akka Streams with a Camel DSL that is provided by the <code>streamz-camel</code> artifact. The Camel DSL requires an implicit <a href="http://krasserm.github.io/streamz/scala-2.12/unidoc/streamz/camel/StreamContext.html" target="_blank"><code>StreamContext</code></a> in scope. A <code>StreamContext</code> uses a <code>CamelContext</code> to manage the endpoints referenced by FS2 streams and Akka Streams. A <code>StreamContext</code> with an internally managed <code>CamelContext</code> can be created with <code>StreamContext()</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">streamz.camel.</span><span class="pl-v">StreamContext</span>

<span class="pl-c">// contains an internally managed CamelContext </span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">streamContext</span><span class="pl-k">:</span> <span class="pl-en">StreamContext</span> <span class="pl-k">=</span> <span class="pl-en">StreamContext</span>()</pre>
  </div> 
  <p>Applications that want to re-use an existing, externally managed <code>CamelContext</code> should create a <code>StreamContext</code> with <code>StreamContext(camelContext: CamelContext)</code>: </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.apache.camel.</span><span class="pl-v">CamelContext</span>
<span class="pl-k">import</span> <span class="pl-v">streamz.camel.</span><span class="pl-v">StreamContext</span>

<span class="pl-c">// an externally managed CamelContext</span>
<span class="pl-k">val</span> <span class="pl-en">camelContext</span><span class="pl-k">:</span> <span class="pl-en">CamelContext</span> <span class="pl-k">=</span> ...

<span class="pl-c">// re-uses the externally managed CamelContext</span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">streamContext</span><span class="pl-k">:</span> <span class="pl-en">StreamContext</span> <span class="pl-k">=</span> <span class="pl-en">StreamContext</span>(camelContext)</pre>
  </div> 
  <p>After usage, a <code>StreamContext</code> should be stopped with <code>streamContext.stop()</code>. </p> 
  <p>The following two subsections introduce the Camel DSL; a more realistic usage example is given in subsection <a href="https://github.com/krasserm/streamz#example-application" target="_blank">Example application</a>. The full source code presented in these subsections is available <a href="https://github.com/krasserm/streamz/blob/master/streamz-examples/src/main/scala/streamz/examples/camel" target="_blank">here</a>.</p> 
  <p><a name="user-content-dsl-for-fs2" target="_blank" href=""></a></p>
  <a name="user-content-dsl-for-fs2" target="_blank" href=""> </a>
  <h3><a name="user-content-dsl-for-fs2" target="_blank" href=""></a><a id="user-content-camel-dsl-for-fs2" class="anchor" href="https://github.com/krasserm/streamz#camel-dsl-for-fs2" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Camel DSL for FS2</h3> 
  <p>The Camel DSL for FS2 can be imported with:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">streamz.camel.fs2dsl.</span><span class="pl-v">_</span></pre>
  </div> 
  <h4><a id="user-content-consuming-from-an-endpoint" class="anchor" href="https://github.com/krasserm/streamz#consuming-from-an-endpoint" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Consuming from an endpoint</h4> 
  <p><a name="user-content-dsl-for-fs2" target="_blank" href="">An FS2 stream that emits messages consumed from a Camel endpoint can be created with <code>receive</code>. Endpoints are referenced by their </a><a href="http://camel.apache.org/uris.html" target="_blank">endpoint URI</a>. For example,</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">streamz.camel.</span><span class="pl-v">StreamMessage</span>

<span class="pl-k">val</span> <span class="pl-en">s1</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-en">StreamMessage</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> receive[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>seda:q1<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>creates an FS2 stream that consumes messages from the <a href="http://camel.apache.org/seda.html" target="_blank">SEDA endpoint</a> <code>seda:q1</code> and converts them to <code>StreamMessage[String]</code>s. A <a href="http://krasserm.github.io/streamz/scala-2.12/unidoc/streamz/camel/StreamMessage.html" target="_blank"><code>StreamMessage[A]</code></a> contains a message <code>body</code> of type <code>A</code> and message <code>headers</code>. Calling <code>receive</code> with a <code>String</code> type parameter creates an FS2 stream that converts consumed message bodies to type <code>String</code> before emitting them as <code>StreamMessage[String]</code>. Type conversion internally uses a Camel <a href="http://camel.apache.org/type-converter.html" target="_blank">type converter</a>. An FS2 stream that only emits the converted message bodies can be created with <code>receiveBody</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s1b</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span> receiveBody[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>seda:q1<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This is equivalent to <code>receive[String]("seda:q1").map(_.body)</code>.</p> 
  <h4><a id="user-content-sending-to-an-endpoint" class="anchor" href="https://github.com/krasserm/streamz#sending-to-an-endpoint" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sending to an endpoint</h4> 
  <p>For sending a <code>StreamMessage</code> to a Camel endpoint, the <code>send</code> combinator should be used:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s2</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-en">StreamMessage</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> s1.send(<span class="pl-s"><span class="pl-pds">"</span>seda:q2<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This initiates an in-only message <a href="http://camel.apache.org/exchange.html" target="_blank">exchange</a> with an endpoint and continues the stream with the sent <code>StreamMessage</code>. The <code>send</code> combinator is also available for streams of message bodies:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s2b</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span> s1b.send(<span class="pl-s"><span class="pl-pds">"</span>seda:q2<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h4><a id="user-content-requesting-from-an-endpoint" class="anchor" href="https://github.com/krasserm/streamz#requesting-from-an-endpoint" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Requesting from an endpoint</h4> 
  <p>For requesting a reply from an endpoint to an input <code>StreamMessage</code>, the <code>request</code> combinator should be used:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s3</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-en">StreamMessage</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span> s2.request[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>bean:service?method=weight<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This initiates an in-out message exchange with the endpoint and continues the stream with the output <code>StreamMessage</code>. Here, a <a href="https://camel.apache.org/bean.html" target="_blank">Bean endpoint</a> is used to call the <code>weight(String): Int</code> method on an object that is registered in the <code>CamelContext</code> under the name <code>service</code>. The input message body is used as <code>weight</code> call argument, the output message body is assigned the return value. The <code>receive</code> type parameter (<code>Int</code>) specifies the expected output value type. The output message body can also be converted to another type provided that an appropriate Camel type converter is available (<code>Double</code>, for example). The <code>request</code> combinator is also available for streams of message bodies:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s3b</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">Int</span>] <span class="pl-k">=</span> s2b.request[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>bean:service?method=weight<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p><a name="user-content-dsl-for-as" target="_blank" href=""></a></p>
  <a name="user-content-dsl-for-as" target="_blank" href=""> </a>
  <h3><a name="user-content-dsl-for-as" target="_blank" href=""></a><a id="user-content-camel-dsl-for-akka-streams" class="anchor" href="https://github.com/krasserm/streamz#camel-dsl-for-akka-streams" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Camel DSL for Akka Streams</h3> 
  <p>The Camel DSL for Akka Streams can be imported with:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">streamz.camel.akkadsl.</span><span class="pl-v">_</span></pre>
  </div> 
  <h4><a id="user-content-consuming-from-an-endpoint-1" class="anchor" href="https://github.com/krasserm/streamz#consuming-from-an-endpoint-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Consuming from an endpoint</h4> 
  <p><a name="user-content-dsl-for-as" target="_blank" href="">An Akka Stream <code>Source</code> that emits messages consumed from a Camel endpoint can be created with <code>receive</code>. Endpoints are referenced by their </a><a href="http://camel.apache.org/uris.html" target="_blank">endpoint URI</a>. For example,</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">akka.</span><span class="pl-v">NotUsed</span>
<span class="pl-k">import</span> <span class="pl-v">akka.stream.scaladsl.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">streamz.camel.</span><span class="pl-v">StreamMessage</span>

<span class="pl-k">val</span> <span class="pl-en">s1</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-en">StreamMessage</span>[<span class="pl-k">String</span>], <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> receive[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>seda:q1<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>creates an Akka Stream <code>Source</code> that consumes messages from the <a href="http://camel.apache.org/seda.html" target="_blank">SEDA endpoint</a> <code>seda:q1</code> and converts them to <code>StreamMessage[String]</code>s. A <a href="http://krasserm.github.io/streamz/scala-2.12/unidoc/streamz/camel/StreamMessage.html" target="_blank"><code>StreamMessage[A]</code></a> contains a message <code>body</code> of type <code>A</code> and message <code>headers</code>. Calling <code>receive</code> with a <code>String</code> type parameter creates an Akka Stream <code>Source</code> that converts consumed message bodies to type <code>String</code> before emitting them as <code>StreamMessage[String]</code>. Type conversion internally uses a Camel <a href="http://camel.apache.org/type-converter.html" target="_blank">type converter</a>. An Akka Stream <code>Source</code> that only emits the converted message bodies can be created with <code>receiveBody</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s1b</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> receiveBody[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>seda:q1<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This is equivalent to <code>receive[String]("seda:q1").map(_.body)</code>.</p> 
  <h4><a id="user-content-sending-to-an-endpoint-1" class="anchor" href="https://github.com/krasserm/streamz#sending-to-an-endpoint-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sending to an endpoint</h4> 
  <p>For sending a <code>StreamMessage</code> to a Camel endpoint, the <code>send</code> combinator should be used:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s2</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-en">StreamMessage</span>[<span class="pl-k">String</span>], <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> s1.send(<span class="pl-s"><span class="pl-pds">"</span>seda:q2<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This initiates an in-only message <a href="http://camel.apache.org/exchange.html" target="_blank">exchange</a> with an endpoint and continues the stream with the sent <code>StreamMessage</code>. The <code>send</code> combinator is not only available for <code>Source</code>s, <code>Flow</code>s and <code>SubFlow</code>s of <code>StreamMessage</code>s but also for <code>Source</code>s, <code>Flow</code>s and <code>SubFlow</code>s of message bodies:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s2b</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> s1b.send(<span class="pl-s"><span class="pl-pds">"</span>seda:q2<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h4><a id="user-content-requesting-from-an-endpoint-1" class="anchor" href="https://github.com/krasserm/streamz#requesting-from-an-endpoint-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Requesting from an endpoint</h4> 
  <p>For requesting a reply from an endpoint to an input <code>StreamMessage</code>, the <code>request</code> combinator should be used:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s3</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-en">StreamMessage</span>[<span class="pl-k">Int</span>], <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> s2.request[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>bean:service?method=weight<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This initiates an in-out message exchange with the endpoint and continues the stream with the output <code>StreamMessage</code>. Here, a <a href="https://camel.apache.org/bean.html" target="_blank">Bean endpoint</a> is used to call the <code>weight(String): Int</code> method on an object that is registered in the <code>CamelContext</code> under the name <code>service</code>. The input message body is used as <code>weight</code> call argument, the output message body is assigned the return value. The <code>receive</code> type parameter (<code>Int</code>) specifies the expected output value type. The output message body can also be converted to another type provided that an appropriate Camel type converter is available, (<code>Double</code>, for example). The <code>request</code> combinator is not only available for <code>Source</code>s, <code>Flow</code>s and <code>SubFlow</code>s of <code>StreamMessage</code>s but also for <code>Source</code>s, <code>Flow</code>s and <code>SubFlow</code>s of message bodies:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s3b</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">Int</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span> s2b.request[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>bean:service?method=weight<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>A Java version of the Camel DSL for Akka Streams is coming soon.</p> 
  <p><a name="user-content-example-application" target="_blank" href=""></a></p>
  <a name="user-content-example-application" target="_blank" href=""> </a>
  <h3><a name="user-content-example-application" target="_blank" href=""></a><a id="user-content-example-application" class="anchor" href="https://github.com/krasserm/streamz#example-application" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example application</h3> 
  <p>The example application consumes file content line by line, either from a TCP endpoint or a from file endpoint, and prints the consumed lines prefixed with a formatted line number to <code>stdout</code>:</p> 
  <p><img src="https://github.com/krasserm/streamz/raw/master/images/streamz-example.png" alt="Streamz example" style="max-width:100%;"></p> 
  <ul>
   <a name="user-content-example-application" target="_blank" href=""> </a>
   <li><a name="user-content-example-application" target="_blank" href="">The TCP endpoint is implemented with the </a><a href="http://camel.apache.org/netty4.html" target="_blank">Netty4 component</a>. It listens on <code>localhost:5051</code> and is configured to use a text line codec (see <code>tcpEndpointUri</code> below) so that consumers receive a separate message for each line.</li> 
   <li>The file endpoint is implemented with the <a href="http://camel.apache.org/file2.html" target="_blank">File component</a>. It scans the <code>input</code> directory for new files and serves them as <code>String</code>s to consumers. The consumed file content is split into lines in a separate <em>Line Split</em> step.</li> 
   <li>Lines consumed from both endpoints are merged into a single stream in a <em>Merge</em> step.</li> 
   <li>To generate line numbers for the consumed lines, a <em>Line Number Source</em> is configured to generate numbers 1, 2, ..., n. These numbers are then formatted to a line prefix using the <code>[$lineNumber]</code> template. The line number formatter is an object registered in the <code>CamelContext</code> under the name <code>exampleService</code> and accessed with a <a href="https://camel.apache.org/bean.html" target="_blank">Bean endpoint</a> configured to call the <code>linePrefix</code> method.</li> 
   <li>The line prefixes are then concatenated with the actual lines in a <em>ZipWith</em> step.</li> 
   <li>Finally, the concatenation results are sent to <code>stream:out</code>, a <a href="http://camel.apache.org/stream.html" target="_blank">Stream endpoint</a> that writes messages to <code>stdout</code>.</li> 
  </ul> 
  <p>In the following two subsections, the implementations for both, FS2 and Akka Streams, are shown which closely match the above diagram. Both implementations share the definitions of <code>ExampleService</code>, <code>StreamContext</code> and endpoint URIs:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">ExampleService</span> {
  <span class="pl-k">def</span> <span class="pl-en">linePrefix</span>(<span class="pl-v">lineNumber</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> s<span class="pl-s"><span class="pl-pds">"</span>[$lineNumber] <span class="pl-pds">"</span></span>
}

<span class="pl-k">trait</span> <span class="pl-en">ExampleContext</span> {
  <span class="pl-k">import</span> <span class="pl-v">org.apache.camel.impl.</span>{ <span class="pl-v">DefaultCamelContext</span>, <span class="pl-v">SimpleRegistry</span> }
  <span class="pl-k">import</span> <span class="pl-v">streamz.camel.</span><span class="pl-v">StreamContext</span>

  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">camelRegistry</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SimpleRegistry</span>
  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">camelContext</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DefaultCamelContext</span>

  camelContext.start()
  camelContext.setRegistry(camelRegistry)
  camelRegistry.put(<span class="pl-s"><span class="pl-pds">"</span>exampleService<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-en">ExampleService)</span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">context</span><span class="pl-k">:</span> <span class="pl-en">StreamContext</span> <span class="pl-k">=</span>
    <span class="pl-en">StreamContext</span>(camelContext)

  <span class="pl-k">val</span> <span class="pl-en">tcpEndpointUri</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span>
    <span class="pl-s"><span class="pl-pds">"</span>netty4:tcp://localhost:5150?sync=false&amp;textline=true&amp;encoding=utf-8<span class="pl-pds">"</span></span>

  <span class="pl-k">val</span> <span class="pl-en">fileEndpointUri</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span>
    <span class="pl-s"><span class="pl-pds">"</span>file:input?charset=utf-8<span class="pl-pds">"</span></span>

  <span class="pl-k">val</span> <span class="pl-en">serviceEndpointUri</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span>
    <span class="pl-s"><span class="pl-pds">"</span>bean:exampleService?method=linePrefix<span class="pl-pds">"</span></span>

  <span class="pl-k">val</span> <span class="pl-en">printerEndpointUri</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span>
    <span class="pl-s"><span class="pl-pds">"</span>stream:out<span class="pl-pds">"</span></span>
}</pre>
  </div> 
  <h4><a id="user-content-implementation-for-fs2" class="anchor" href="https://github.com/krasserm/streamz#implementation-for-fs2" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementation for FS2</h4> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">CamelFs2Example</span> <span class="pl-k">extends</span> <span class="pl-e">ExampleContext</span> <span class="pl-k">with</span> <span class="pl-e">App</span> {
  <span class="pl-k">import</span> <span class="pl-v">fs2.</span><span class="pl-v">_</span>

  <span class="pl-c">// import Camel DSL for FS2</span>
  <span class="pl-k">import</span> <span class="pl-v">streamz.camel.fs2dsl.</span><span class="pl-v">_</span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">strategy</span><span class="pl-k">:</span> <span class="pl-en">Strategy</span> <span class="pl-k">=</span>
    <span class="pl-en">Strategy</span>.fromExecutionContext(scala.concurrent.<span class="pl-en">ExecutionContext</span>.global)

  <span class="pl-k">val</span> <span class="pl-en">tcpLineStream</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span>
    receiveBody[<span class="pl-k">String</span>](tcpEndpointUri)

  <span class="pl-k">val</span> <span class="pl-en">fileLineStream</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span>
    receiveBody[<span class="pl-k">String</span>](fileEndpointUri).through(text.lines)

  <span class="pl-k">val</span> <span class="pl-en">linePrefixStream</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span>
    <span class="pl-en">Stream</span>.iterate(<span class="pl-c1">1</span>)(_ <span class="pl-k">+</span> <span class="pl-c1">1</span>).request[<span class="pl-k">String</span>](serviceEndpointUri)

  <span class="pl-k">val</span> <span class="pl-en">stream</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, <span class="pl-k">String</span>] <span class="pl-k">=</span>
    tcpLineStream
      .merge(fileLineStream)
      .zipWith(linePrefixStream)((l, n) <span class="pl-k">=&gt;</span> n concat l)
      .send(printerEndpointUri)

  stream.run.unsafeRun
}</pre>
  </div> 
  <h4><a id="user-content-implementation-for-akka-streams" class="anchor" href="https://github.com/krasserm/streamz#implementation-for-akka-streams" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementation for Akka Streams</h4> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">CamelAkkaExample</span> <span class="pl-k">extends</span> <span class="pl-e">ExampleContext</span> <span class="pl-k">with</span> <span class="pl-e">App</span> {
  <span class="pl-k">import</span> <span class="pl-v">akka.</span><span class="pl-v">NotUsed</span>
  <span class="pl-k">import</span> <span class="pl-v">akka.actor.</span><span class="pl-v">ActorSystem</span>
  <span class="pl-k">import</span> <span class="pl-v">akka.stream.</span><span class="pl-v">ActorMaterializer</span>
  <span class="pl-k">import</span> <span class="pl-v">akka.stream.scaladsl.</span>{ <span class="pl-v">Sink</span>, <span class="pl-v">Source</span> }
  <span class="pl-k">import</span> <span class="pl-v">scala.collection.immutable.</span><span class="pl-v">Iterable</span>

  <span class="pl-c">// import Camel DSL for Akka Streams</span>
  <span class="pl-k">import</span> <span class="pl-v">streamz.camel.akkadsl.</span><span class="pl-v">_</span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>(<span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>)
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">materializer</span> <span class="pl-k">=</span> <span class="pl-en">ActorMaterializer</span>()

  <span class="pl-k">val</span> <span class="pl-en">tcpLineSource</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span>
    receiveBody[<span class="pl-k">String</span>](tcpEndpointUri)

  <span class="pl-k">val</span> <span class="pl-en">fileLineSource</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span>
    receiveBody[<span class="pl-k">String</span>](fileEndpointUri).mapConcat(_.lines.to[<span class="pl-en">Iterable</span>])

  <span class="pl-k">val</span> <span class="pl-en">linePrefixSource</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span>
    <span class="pl-en">Source</span>.fromIterator(() <span class="pl-k">=&gt;</span> <span class="pl-en">Iterator</span>.from(<span class="pl-c1">1</span>)).request[<span class="pl-k">String</span>](serviceEndpointUri)

  <span class="pl-k">val</span> <span class="pl-en">stream</span><span class="pl-k">:</span> <span class="pl-en">Source</span>[<span class="pl-k">String</span>, <span class="pl-en">NotUsed</span>] <span class="pl-k">=</span>
    tcpLineSource
      .merge(fileLineSource)
      .zipWith(linePrefixSource)((l, n) <span class="pl-k">=&gt;</span> n concat l)
      .send(printerEndpointUri)

  stream.runWith(<span class="pl-en">Sink</span>.ignore)
}</pre>
  </div> 
  <h4><a id="user-content-example-application-usage" class="anchor" href="https://github.com/krasserm/streamz#example-application-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example application usage</h4> 
  <p>Depending on the implementation, the example application can be started with</p> 
  <pre><code>$ sbt 'examples/runMain streamz.examples.camel.CamelFs2Example'
</code></pre> 
  <p>or </p> 
  <pre><code>$ sbt 'examples/runMain streamz.examples.camel.CamelAkkaExample'
</code></pre> 
  <p>Before submitting data to the application, let’s create an input file with two lines:</p> 
  <pre><code>$ cat &gt;&gt; example.txt
hello
streamz
^D
</code></pre> 
  <p>Copy the generated file to the <code>input</code> directory so that it can be consumed by the file endpoint:</p> 
  <pre><code>$ cp example.txt input/
</code></pre> 
  <p>You should see the following stream output:</p> 
  <pre><code>[1] hello
[2] streamz
</code></pre> 
  <p>Then send the file content to the TCP endpoint (with <code>nc</code> on Mac OS X or <code>netcat</code> on Linux):</p> 
  <pre><code>$ cat example.txt | nc localhost 5150
</code></pre> 
  <p>You should see the following stream output:</p> 
  <pre><code>[3] hello
[4] streamz
</code></pre> 
 </article>
</div>