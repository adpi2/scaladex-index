<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-scala-rules" class="anchor" href="https://github.com/scala-rules/scala-rules#scala-rules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>scala-rules</h1> 
  <p>Scala-Rules is a forward chaining rule engine, built in <a href="https://www.scala-lang.org" target="_blank">Scala</a>. The engine comes with a DSL with which derivations can be modelled as small steps that combine into large derived networks of facts.</p> 
  <p>The project started with a Dutch DSL to facilitate bankers writing mortgage-related calculations. The development of an English DSL is currently in progress (see <a href="https://github.com/scala-rules/scala-rules#future" target="_blank">Future Work</a>).</p> 
  <p><a href="https://codeship.com/projects/146192" target="_blank"><img src="https://camo.githubusercontent.com/3c4506b3a5cbbe9742880b908160cd080e707a21/68747470733a2f2f636f6465736869702e636f6d2f70726f6a656374732f36323864656365302d653365382d303133332d613965382d3361613366323232623166312f7374617475733f6272616e63683d6d6173746572" alt="Codeship Status for scala-rules/scala-rules" data-canonical-src="https://codeship.com/projects/628dece0-e3e8-0133-a9e8-3aa3f222b1f1/status?branch=master" style="max-width:100%;"></a></p> 
  <h1><a id="user-content-getting-started" class="anchor" href="https://github.com/scala-rules/scala-rules#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h1> 
  <p>The minimal requirement to get started is to add the artifact containing the rule engine to your project. Below are snippets for SBT and Maven. Be sure to check if any newer versions are available and adjust the snippets accordingly.</p> 
  <p><strong>SBT</strong> - <code>build.sbt</code></p> 
  <pre><code>libraryDependencies += "org.scala-rules" %% "rule-engine" % "0.2.6"
</code></pre> 
  <p><strong>Maven</strong> - <code>pom.xml</code></p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;org.scala-rules&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;rule-engine_2.11&lt;/<span class="pl-ent">artifactId</span>&gt;
    &lt;<span class="pl-ent">version</span>&gt;0.2.6&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre>
  </div> 
  <h1><a id="user-content-concepts" class="anchor" href="https://github.com/scala-rules/scala-rules#concepts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Concepts</h1> 
  <p>The rule engine uses a <code>Fact</code> as the base for all of its derivations. A <code>Fact</code> defines its name and type so it can be referenced in evaluations down the road. <code>Facts</code> are best defined inside a <code>Glossary</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyGlossary</span> <span class="pl-k">extends</span> <span class="pl-e">Glossary</span> {
    <span class="pl-k">val</span> <span class="pl-en">factA</span> <span class="pl-k">=</span> defineFact[<span class="pl-k">Int</span>]
    <span class="pl-k">val</span> <span class="pl-en">factB</span> <span class="pl-k">=</span> defineFact[<span class="pl-k">Int</span>]
    <span class="pl-k">val</span> <span class="pl-en">factC</span> <span class="pl-k">=</span> defineFact[<span class="pl-k">Int</span>]
}</pre>
  </div> 
  <p><em>Note: the name of the fact is automatically deduced from the variable it is assigned to. <code>defineFact</code> has an optional parameter for a description of the fact.</em></p> 
  <p>Using this glossary, it is now possible to define derivations. The Scala Rules DSL provides an easy way to express how facts interact and come together to form your logic. To enable the DSL, create a class that extends <code>Berekening</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.scalarules.dsl.nl.grammar.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">MyGlossary.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">MyArithmetics</span> <span class="pl-k">extends</span> <span class="pl-e">Berekening</span> (
    <span class="pl-en">Gegeven</span> (factA <span class="pl-k">&gt;</span> <span class="pl-c1">0</span>) <span class="pl-en">Bereken</span> factC is factB <span class="pl-k">-</span> factA 
)</pre>
  </div> 
  <p><em>Note the parenthesis behind <code>Berekening</code>, using braces wonâ€™t work. The <code>Berekening</code> constructor requires a series of <code>DslDerivations</code>, using braces causes this argument to be an empty list and yields you no executable derivations.</em></p> 
  <p><em>Note 2: for more information about the possibilities of the DSL, see the <a href="https://github.com/scala-rules/rule-engine/wiki/DSL-Description---Dutch" target="_blank">Wiki page about it</a></em></p> 
  <p>The two listings above are actually all you need to define your calculations, validations or evaluations. The engine will have enough information to start working for you. Only one thing is still missing for the scenario to make sense to you: values.</p> 
  <p>The engine requires you to construct a <code>Context</code> mapping a set of initial <code>Facts</code> to their values. When you have that, you can let the engine do the rest:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">initialContext</span><span class="pl-k">:</span> <span class="pl-en">Context</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>(
  factA <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>,
  factB <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>
)
<span class="pl-k">val</span> <span class="pl-en">derivations</span><span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-en">Derivation</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyArithmetics</span>().berekeningen

<span class="pl-k">val</span> <span class="pl-en">resultContext</span><span class="pl-k">:</span> <span class="pl-en">Context</span> <span class="pl-k">=</span> <span class="pl-en">FactEngine</span>.runNormalDerivations(initialContext, derivations)

println(<span class="pl-en">PrettyPrinter</span>.printContext(resultContext))</pre>
  </div> 
  <p>Executing the above code will yield the following:</p> 
  <pre><code>Values in context:
  factA = 4
  factB = 10
  factC = 6
Done.
</code></pre> 
  <h1><a id="user-content-debugging" class="anchor" href="https://github.com/scala-rules/scala-rules#debugging" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Debugging</h1> 
  <p>If you want to see exactly what the engine is doing, you can replace the <code>runNormalDerivations</code> with <code>runDebugDerivations</code>. The return type of that function is a tuple containing the resulting <code>Context</code> and a list of <code>Step</code> objects. The latter describe exactly what actions the engine performed and why:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">initialContext</span><span class="pl-k">:</span> <span class="pl-en">Context</span> <span class="pl-k">=</span> <span class="pl-en">Context</span>(
  factA <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>,
  factB <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>
)
<span class="pl-k">val</span> <span class="pl-en">derivations</span><span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-en">Derivation</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyArithmetics</span>().berekeningen

<span class="pl-k">val</span> (resultContext, steps) <span class="pl-k">=</span> <span class="pl-en">FactEngine</span>.runDebugDerivations(initialContext, derivations)

println(<span class="pl-en">PrettyPrinter</span>.printSteps(steps))</pre>
  </div> 
  <p>Executing this snippet will yield an overview of the steps taken by the engine:</p> 
  <pre><code>Steps taken:
 * Evaluate: factC
   * Result: Evaluated
   * Change: Map(factC -&gt; 6)
Done.
</code></pre> 
  <p>For each step there is the <code>Fact</code> that was about to be evaluated (<code>factC</code>). Next is the status of the evaluation. The engine might indicate that the condition was false and thus the evaluation was skipped. Finally the <code>change</code> field shows what is added to the <code>Context</code> as a result of this evaluation.</p> 
  <h1><a id="user-content-going-hardcore" class="anchor" href="https://github.com/scala-rules/scala-rules#going-hardcore" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Going Hardcore</h1> 
  <p>If you have complicated tasks to perform, or our DSL simply does not fit your needs, you can write custom evaluations.</p> 
  <p>The DSL in the <code>Berekening</code> class yields a list of <code>Derivation</code>-objects. Constructing one yourself is not difficult, but requires some explanation:</p> 
  <pre><code>case class DefaultDerivation(
  input: List[Fact[Any]], 
  output: Fact[Any], 
  condition: Context =&gt; Boolean, 
  operation: Evaluation[Any]) extends Derivation
</code></pre> 
  <p>For a derivation to work, the engine must know all the <code>Facts</code> it uses as input. The <code>input</code> parameter requires you to provide these <code>Facts</code> as a list.</p> 
  <p>The <code>output</code> allows the engine to store the result of the derivation in the <code>Context</code>. The <code>output</code> fact is the key for this.</p> 
  <p>The <code>condition</code> is a function to decide whether the <code>operation</code> should be executed. The function is provided with the current <code>Context</code> containing all values known at the point of execution. Returning <code>true</code> causes the <code>operation</code> to be executed, <code>false</code> will cause it to be skipped.</p> 
  <p>Finally, the <code>operation</code> is the function which will result in the value assigned to the <code>output</code> fact. You need to instantiate or extend any of the available <code>Evaluation</code> classes.</p> 
  <p><a name="user-content-future" target="_blank" href=""></a># Future Work</p> 
  <p>The DSL is currently being translated into English and we expect to release this in July 2016.</p> 
  <p>In the project for which Scala Rules was originally developed, we have incorporated a utility project to visualise the dependency graphs generated by the engine. These graphs provide great insights in the execution order of the engine and allow for easy review of derivations by non-programmers. This project cannot as of yet be released as an open source module, because it is too strongly tied to the original project. We are making the graph visualisation more generally applicable for Scala Rules and expect to release it in the summer of 2016. Hereâ€™s an example visualisation of a derivation graph:</p> 
  <p><a href="https://github.com/scala-rules/scala-rules/blob/master/docs/images/example_graph.png" target="_blank"><img src="https://github.com/scala-rules/scala-rules/raw/master/docs/images/example_graph.png" alt="Example Dependency Graph showing Execution Order of derivations" style="max-width:100%;"></a></p> 
 </article>
</div>