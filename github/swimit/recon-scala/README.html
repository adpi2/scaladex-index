<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-record-notation-recon" class="anchor" href="https://github.com/swimit/recon-scala#record-notation-recon" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Record Notation (RECON)</h1> 
  <p><a href="https://travis-ci.org/swimit/recon-scala" target="_blank"><img src="https://camo.githubusercontent.com/ee9ac21fc37debb1afcf347c9f26d6f0e1af677e/68747470733a2f2f7472617669732d63692e6f72672f7377696d69742f7265636f6e2d7363616c612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/swimit/recon-scala.svg?branch=master" style="max-width:100%;"></a></p> 
  <p>RECON brings attributes into the era of object notation, and provides a simple grammar and uniform tree model for attributed text markup. RECON aims to combine the minimalism of JSON with the expressiveness of XML in a human-friendly syntax.</p> 
  <h2><a id="user-content-getting-started" class="anchor" href="https://github.com/swimit/recon-scala#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h2> 
  <p>To get started with the RECON Scala library, add the <code>recon-scala</code> dependency to your SBT build.</p> 
  <pre><code>libraryDependencies += "it.swim" %% "recon-scala" % "0.2.0"
</code></pre> 
  <h2><a id="user-content-language-primer" class="anchor" href="https://github.com/swimit/recon-scala#language-primer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Language Primer</h2> 
  <h3><a id="user-content-primtives" class="anchor" href="https://github.com/swimit/recon-scala#primtives" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Primtives</h3> 
  <p>RECON has three primitive datatypes: <em>text</em>, <em>number</em>, and <em>data</em>.</p> 
  <h4><a id="user-content-text" class="anchor" href="https://github.com/swimit/recon-scala#text" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Text</h4> 
  <p>Text values take one of two forms: a quoted <em>string</em>, or an unquoted <em>identifier</em>.</p> 
  <pre lang="recon"><code>"string"
identifier
</code></pre> 
  <h4><a id="user-content-numbers" class="anchor" href="https://github.com/swimit/recon-scala#numbers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Numbers</h4> 
  <p>Numbers serialize as decimal literals.</p> 
  <pre lang="recon"><code>-1
3.14
6.02e23
</code></pre> 
  <h4><a id="user-content-data" class="anchor" href="https://github.com/swimit/recon-scala#data" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Data</h4> 
  <p>Binary data serializes as a leading '%' symbol, followed by a base64 literal.</p> 
  <pre lang="recon"><code>%AA==
</code></pre> 
  <h3><a id="user-content-records" class="anchor" href="https://github.com/swimit/recon-scala#records" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Records</h3> 
  <p>RECON's sole aggregate datatype, the <em>record</em>, plays the combined role of array and associative array. Think of a record as a partially keyed list. The example record below contains two ordered items, first a "subject" field with value "Greetings", then the unkeyed string "Hello, Earthlings!".</p> 
  <pre lang="recon"><code>{ subject: "Greetings", "Hello, Earthlings!" }
</code></pre> 
  <p>A single comma, a single semicolon, or one or more newlines separate items. Newline separated records provide a clean syntax for pretty-printed documents.</p> 
  <pre lang="recon"><code>{
  subject: "Re: Greetings"
  "Hi Martians!"
}
</code></pre> 
  <p>Records support arbitrary values as slot keys.</p> 
  <pre lang="recon"><code>{
  @planet Jupiter: {}
  @god Jupiter: {}
}
</code></pre> 
  <h3><a id="user-content-blocks" class="anchor" href="https://github.com/swimit/recon-scala#blocks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Blocks</h3> 
  <p>Top-level documents can omit the curly braces around their root record. We call the content of a record, sans curly braces, a <em>block</em>. When a block contains only a single item, the value of the block reduces to just the value of the item it contains. The example block below is equivalent to the sample record above.</p> 
  <pre lang="recon"><code>subject: "Re: Greetings"
"Hi Martians!"
</code></pre> 
  <h3><a id="user-content-attributes" class="anchor" href="https://github.com/swimit/recon-scala#attributes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Attributes</h3> 
  <p>The @ sign introduces an attribute. Attributes call out key fields of a record. The previous markup example further reduces to the form below.</p> 
  <pre lang="recon"><code>{
  "Hello, "
  {
    "@em":
    "world"
  }
  "!"
}
</code></pre> 
  <p>Note that the <code>@em</code> field above has no explicit value. The RECON data model refers to unspecified–but existent–values as <em>extant</em>. We say that the record <code>@em[world]</code> has an extant attribute named <code>em</code>.</p> 
  <p>Of course, attributes can have associated values too. Place attribute parameters in parentheses, following the attribute's name.</p> 
  <pre lang="recon"><code>@answer(42)
@event("onClick")
</code></pre> 
  <p>The above attributes are structurally equivalent to:</p> 
  <pre lang="recon"><code>{"@answer":42}
{"@event":"onClick"}
</code></pre> 
  <p>Attribute parentheses enclose a block, meaning attribute values construct an implicit record when needed. An example, with its desugared equivalent, follows.</p> 
  <pre lang="recon"><code>@img(src: "tesseract.png", width: 10, height: 10, depth: 10, time: -1)

{
  "@img": {
    src: "tesseract.png"
    width: 10
    height: 10
    depth: 10
    time: -1
  }
}
</code></pre> 
  <p>Attributes <em>modify</em> adjacent values. Modified values interpolate into the record formed by their adjacent attributes. Here are some examples of values with prefix, postfix, and circumfix attributes:</p> 
  <pre lang="recon"><code>@duration 30
30 @seconds
@duration 30 @seconds
@relative @duration 30 @seconds
</code></pre> 
  <p>The above attribute expressions desugar to the following records:</p> 
  <pre lang="recon"><code>{ "@duration":, 30 }
{ 30, "@seconds": }
{ "@duration":, 30, "@seconds": }
{ "@relative":, "@duration":, 30, "@seconds": }
</code></pre> 
  <p>Modified records flatten into the record formed by their adjacent attributes. So <code>@point{x:0,y:0}</code>, reduces to <code>{"@point":,x:0,y:0}</code>, not <code>{"@point":,{x:0,y:0}}</code>.</p> 
  <h3><a id="user-content-markup" class="anchor" href="https://github.com/swimit/recon-scala#markup" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Markup</h3> 
  <p>Square brackets denote <em>markup</em>. Markup offers an inverted syntax for records, with values embedded in text, as opposed to text embedded in records.</p> 
  <pre lang="recon"><code>[Hello, @em[world]!]
</code></pre> 
  <p>Markup is really just syntactic sugar for records. The above example expresses the exact same structure as the one below.</p> 
  <pre lang="recon"><code>{ "Hello, "; @em "world"; "!" }
</code></pre> 
  <p>Curly braces within markup lift the enclosed block into the markup's record. The following records are equivalent.</p> 
  <pre lang="recon"><code>[Answer: {42}.]
{ "Answer", 42, "." }
</code></pre> 
  <p>Square brackets lift nested markup into the enclosing record. Make sure to backslash escape square brackets if you want to include them verbatim.</p> 
  <pre lang="recon"><code>[Say [what]?]
{ "Say ", "what", "?"}

[Say \[what\]?]
{ "Say [what]?" }
</code></pre> 
  <p>Sequential attributes within markup don't chain; each markup-embedded attribute inserts a nested record.</p> 
  <pre lang="recon"><code>[http@colon@slash@slash]
{ "http", @colon, @slash, @slash }
</code></pre> 
  <p>Attributes in markup can prefix curly brace enclosed blocks, and nested markup.</p> 
  <pre lang="recon"><code>[Goals: @select(max:2){fast,good,cheap}.]
{ "Goals: ", @select(max:2){fast,good,cheap}, "." }
</code></pre> 
  <p>Beware that whitespace inside markup is significant. Notice how the single space added to the example below completely changes its meaning, when compared to the previous example.</p> 
  <pre lang="recon"><code>[Goals: @select(max:2) {fast,good,cheap}.]
{ "Goals: ", @select(max:2), " ", {fast,good,cheap}, "." }
</code></pre> 
  <h2><a id="user-content-tutorial" class="anchor" href="https://github.com/swimit/recon-scala#tutorial" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Tutorial</h2> 
  <p>The Scala library support compile-time RECON string interpolation.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">label</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Example<span class="pl-pds">"</span></span>
label<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-en">Example</span>

scala<span class="pl-k">&gt;</span> recon<span class="pl-s"><span class="pl-pds">"""</span>@a(href:"example.com")[$label]<span class="pl-pds">"""</span></span>
res0<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-en">Record</span>(<span class="pl-en">Slot</span>(<span class="pl-s"><span class="pl-pds">"</span>href<span class="pl-pds">"</span></span>, <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>example.com<span class="pl-pds">"</span></span>)))), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>Example<span class="pl-pds">"</span></span>))

scala<span class="pl-k">&gt;</span> recon<span class="pl-s"><span class="pl-pds">"""</span>{1, 2 3, 4}<span class="pl-pds">"""</span></span>
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">11</span><span class="pl-k">:</span> <span class="pl-v">error</span>: expected <span class="pl-c1">'}'</span>, <span class="pl-c1">';'</span>, <span class="pl-c1">','</span>, or newline, but found <span class="pl-c1">'3'</span>
       recon<span class="pl-s"><span class="pl-pds">"""</span>{1, 2 3, 4}<span class="pl-pds">"""</span></span>
                     ^</pre>
  </div> 
  <p>Of course, you can parse and serialize RECON at runtime too.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">event</span> <span class="pl-k">=</span> <span class="pl-en">Value</span>.parseRecon(<span class="pl-s"><span class="pl-pds">"</span>@event(onClick)<span class="pl-pds">"</span></span>)
event<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>event<span class="pl-pds">"</span></span>, <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>onClick<span class="pl-pds">"</span></span>)))

scala<span class="pl-k">&gt;</span> event.toRecon
res0<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-k">@</span>event(onClick)</pre>
  </div> 
  <p>Use the <code>/</code> operator to select keyed fields:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">msg</span> <span class="pl-k">=</span> recon<span class="pl-s"><span class="pl-pds">"</span>{from: me, to: you}<span class="pl-pds">"</span></span>
msg<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Record</span>(<span class="pl-en">Slot</span>(<span class="pl-s"><span class="pl-pds">"</span>from<span class="pl-pds">"</span></span>, <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>)), <span class="pl-en">Slot</span>(<span class="pl-s"><span class="pl-pds">"</span>to<span class="pl-pds">"</span></span>, <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>you<span class="pl-pds">"</span></span>)))

scala<span class="pl-k">&gt;</span> msg <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>from<span class="pl-pds">"</span></span>
res0<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>)

scala<span class="pl-k">&gt;</span> msg <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>to<span class="pl-pds">"</span></span>
res1<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>you<span class="pl-pds">"</span></span>)

scala<span class="pl-k">&gt;</span> msg <span class="pl-k">/</span> <span class="pl-s"><span class="pl-pds">"</span>body<span class="pl-pds">"</span></span>
res2<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Absent</span></pre>
  </div> 
  <p>Higher order collection operations and transformations on records just work. The lightweight basis collections library provides collection utilities as unintrusive implicit extension methods, and implements them using fast, inlined macros.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">list</span> <span class="pl-k">=</span> recon<span class="pl-s"><span class="pl-pds">"</span>@ol{@li[a],@li[b],@li[c]}<span class="pl-pds">"</span></span>
list<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>ol<span class="pl-pds">"</span></span>), <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)), <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)), <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)))

scala<span class="pl-k">&gt;</span> list.asRecord.map {
     <span class="pl-k">|</span>   <span class="pl-k">case</span> <span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>ol<span class="pl-pds">"</span></span>, _) <span class="pl-k">=&gt;</span> <span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>ul<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   <span class="pl-k">case</span> item <span class="pl-k">=&gt;</span> item
     <span class="pl-k">|</span> }
res0<span class="pl-k">:</span> recon.<span class="pl-en">Record</span> <span class="pl-k">=</span> <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>ul<span class="pl-pds">"</span></span>), <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>)), <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)), <span class="pl-en">Record</span>(<span class="pl-en">Attr</span>(<span class="pl-s"><span class="pl-pds">"</span>li<span class="pl-pds">"</span></span>), <span class="pl-en">Text</span>(<span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)))</pre>
  </div> 
  <p>The <code>Form</code> typeclass projects RECON values to Scala values, and vice versa. The pattern of projecting weakly typed structural values to strongly typed objects allows the RECON language to serve as an expressive and malleable syntax for domain specific data formats.</p> 
  <p><code>Item.cast[T]</code> converts a RECON item to a Scala value of type <code>Maybe[T]</code> using an implicitly available <code>Form[T]</code>. <code>Item.coerce[T]</code> converts an item to a plain <code>T</code> value, returning <code>Form[T].unit</code> if the conversion fails.</p> 
  <p>Use the <code>Value</code> factory method to marshal Scala values to RECON values.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>; <span class="pl-k">import</span> <span class="pl-v">basis.collections.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">basis.collections.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> recon<span class="pl-s"><span class="pl-pds">"""</span>{ 1, @prime 2, "3" }<span class="pl-pds">"""</span></span>.coerce[<span class="pl-en">Array</span>[<span class="pl-k">Int</span>]]
res0<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Array</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)

scala<span class="pl-k">&gt;</span> recon<span class="pl-s"><span class="pl-pds">"""</span>@alpha { a: 1, b: 2 }<span class="pl-pds">"""</span></span>.coerce[<span class="pl-en">Map</span>[<span class="pl-k">String</span>, <span class="pl-k">Int</span>]]
res1<span class="pl-k">:</span> basis.collections.<span class="pl-en">Map</span>[<span class="pl-k">String</span>,<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">HashTrieMap</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>)

scala<span class="pl-k">&gt;</span> recon<span class="pl-s"><span class="pl-pds">"</span>beta<span class="pl-pds">"</span></span>.cast[<span class="pl-k">Int</span>]
res2<span class="pl-k">:</span> basis.<span class="pl-en">Maybe</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Trap</span></pre>
  </div> 
  <p>Use the <code>Value</code> factory to marshal Scala values to RECON values by way of implicit <code>Form</code> typeclass instances.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>; <span class="pl-k">import</span> <span class="pl-v">basis.collections.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">recon.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">basis.collections.</span><span class="pl-v">_</span>

scala<span class="pl-k">&gt;</span> <span class="pl-en">Value</span>(<span class="pl-en">Seq</span>(<span class="pl-c1">0.5</span>, <span class="pl-c1">0.25</span>))
res0<span class="pl-k">:</span> recon.<span class="pl-en">Value</span> <span class="pl-k">=</span> <span class="pl-en">Record</span>(<span class="pl-en">Number</span>(<span class="pl-c1">0.5</span>), <span class="pl-en">Number</span>(<span class="pl-c1">0.25</span>))</pre>
  </div> 
  <h3><a id="user-content-data-model" class="anchor" href="https://github.com/swimit/recon-scala#data-model" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Data Model</h3> 
  <p>To a first approximation, the RECON data model has the following structure:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Item</span>                              <span class="pl-c"><span class="pl-c">//</span> |-- Item</span>
<span class="pl-k">sealed</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Field</span> <span class="pl-k">extends</span> <span class="pl-e">Item</span>                <span class="pl-c"><span class="pl-c">//</span> |   |-- Field</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Attr</span>(<span class="pl-v">key</span>: <span class="pl-en">Text</span>, <span class="pl-v">value</span>: <span class="pl-en">Value</span>) <span class="pl-k">extends</span> <span class="pl-e">Field</span>  <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Attr</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Slot</span>(<span class="pl-v">key</span>: <span class="pl-en">Value</span>, <span class="pl-v">value</span>: <span class="pl-en">Value</span>) <span class="pl-k">extends</span> <span class="pl-e">Field</span> <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Slot</span>
<span class="pl-k">sealed</span> <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Value</span> <span class="pl-k">extends</span> <span class="pl-e">Item</span>                <span class="pl-c"><span class="pl-c">//</span> |   |-- Value</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Record</span>(<span class="pl-v">items</span>: <span class="pl-en">Item</span><span class="pl-k">*</span>) <span class="pl-k">extends</span> <span class="pl-e">Value</span>           <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Record</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Text</span>(<span class="pl-v">toString</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Value</span>         <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Text</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Data</span>(<span class="pl-v">toArray</span>: <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]) <span class="pl-k">extends</span> <span class="pl-e">Value</span>     <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Data</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Number</span>(<span class="pl-v">toDouble</span>: <span class="pl-k">Double</span>) <span class="pl-k">extends</span> <span class="pl-e">Value</span>       <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Number</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Extant</span> <span class="pl-k">extends</span> <span class="pl-e">Value</span>                        <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Extant</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Absent</span> <span class="pl-k">extends</span> <span class="pl-e">Value</span>                        <span class="pl-c"><span class="pl-c">//</span> |   |   |-- Absent</span></pre>
  </div> 
  <h3><a id="user-content-ordering" class="anchor" href="https://github.com/swimit/recon-scala#ordering" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Ordering</h3> 
  <p>RECON defines a total ordering over all items. Items of different types sort in the following relative order: attributes, slots, records, data, text, numbers, extant, then absent.</p> 
  <h2><a id="user-content-language-grammar" class="anchor" href="https://github.com/swimit/recon-scala#language-grammar" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Language Grammar</h2> 
  <pre><code>SP ::= #x20 | #x9

NL ::= #xA | #xD

WS ::= SP | NL

Char ::= [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

NameStartChar ::=
  [A-Z] | "_" | [a-z] |
  [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] |
  [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] |
  [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] |
  [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

NameChar ::=  NameStartChar | '-' | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]

MarkupChar ::= Char - ('\\' | '@' | '{' | '}' | '[' | ']')

StringChar ::= Char - ('"' | '\\' | '@' | '{' | '}' | '[' | ']' | '\b' | '\f' | '\n' | '\r' | '\t')

CharEscape ::= '\\' ('"' | '\\' | '/' | '@' | '{' | '}' | '[' | ']' | 'b' | 'f' | 'n' | 'r' | 't')

Base64Char ::= [A-Za-z0-9+/]

Block ::= WS* Slots WS*

Slots ::= Slot SP* ((',' | ';' | NL) WS* Slots)?

Slot ::= BlockValue (SP* ':' SP* BlockValue?)?

Attr ::= '@' Ident ('(' Block ')')?

BlockValue ::=
  Attr SP* BlockValue? |
  (Record | Markup | Ident | String | Number | Data) SP* (Attr SP* BlockValue?)?

InlineValue ::= Attr (Record | Markup)? | Record | Markup

Record ::= '{' Block '}'

Markup ::= '[' (MarkupChar* | CharEscape | InlineValue)* ']'

Ident ::= NameStartChar NameChar*

String ::= '"' (StringChar* | CharEscape)* '"'

Number ::= '-'? (([1-9] [0-9]*) | [0-9]) ('.' [0-9]+)? (('E' | 'e') ('+' | '-')? [0-9]+)?

Data ::= '%' (Base64Char{4})* (Base64Char Base64Char ((Base64Char '=') | ('=' '=')))?
</code></pre> 
 </article>
</div>