<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-simplespec" class="anchor" href="https://github.com/simplefinance/simplespec#simplespec" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>simplespec</h1> 
  <p>(<strong>NOTE</strong>: This project is <strong>no longer actively maintained</strong>. For an actively developed replacement, we recommend <a href="http://www.scalatest.org" target="_blank">ScalaTest</a>. If you have any interest in taking over maintenance and development, please <a href="https://github.com/SimpleFinance/simplespec/issues/new" target="_blank">file an issue</a>.)</p> 
  <p><em>No seriously, keep it simple.</em></p> 
  <p><strong>simplespec</strong> is a thin Scala wrapper over <a href="http://www.junit.org/" target="_blank">JUnit</a>, the most commonly-used test framework on the JVM. simplespec was originally written by Coda Hale and was subsequently maintained and developed by Simple until June 2016. The library features extensible Hamcrest matchers, easy mocks, and other niceties.</p> 
  <p><a href="https://camo.githubusercontent.com/9b3fd522e07783430824fa4f647dc224ea6d0505/68747470733a2f2f7472617669732d63692e6f72672f53696d706c6546696e616e63652f73696d706c65737065632e706e67" target="_blank"><img src="https://camo.githubusercontent.com/9b3fd522e07783430824fa4f647dc224ea6d0505/68747470733a2f2f7472617669732d63692e6f72672f53696d706c6546696e616e63652f73696d706c65737065632e706e67" data-canonical-src="https://travis-ci.org/SimpleFinance/simplespec.png" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-requirements" class="anchor" href="https://github.com/simplefinance/simplespec#requirements" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Requirements</h2> 
  <ul> 
   <li>Scala 2.11.0</li> 
   <li>JUnit 4.11</li> 
   <li>Mockito 1.9.5</li> 
  </ul> 
  <p>(Scala 2.10.2, 2.9.1, and 2.9.2 are supported in simplespec 0.8.4, 0.6.0, and 0.7.0, respectively.)</p> 
  <h2><a id="user-content-getting-started" class="anchor" href="https://github.com/simplefinance/simplespec#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h2> 
  <p><strong>First</strong>, specify simplespec as a dependency.</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependencies</span>&gt;
    &lt;<span class="pl-ent">dependency</span>&gt;
        &lt;<span class="pl-ent">groupId</span>&gt;com.simple&lt;/<span class="pl-ent">groupId</span>&gt;
        &lt;<span class="pl-ent">artifactId</span>&gt;simplespec_2.11.0&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.8.4&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;
&lt;/<span class="pl-ent">dependencies</span>&gt;</pre>
  </div> 
  <p>If you are on Scala 2.10.2, you should use:</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependencies</span>&gt;
    &lt;<span class="pl-ent">dependency</span>&gt;
        &lt;<span class="pl-ent">groupId</span>&gt;com.simple&lt;/<span class="pl-ent">groupId</span>&gt;
        &lt;<span class="pl-ent">artifactId</span>&gt;simplespec_2.10.2&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.8.4&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;
&lt;/<span class="pl-ent">dependencies</span>&gt;</pre>
  </div> 
  <p>If you are on Scala 2.9.2, you should use:</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependencies</span>&gt;
    &lt;<span class="pl-ent">dependency</span>&gt;
        &lt;<span class="pl-ent">groupId</span>&gt;com.simple&lt;/<span class="pl-ent">groupId</span>&gt;
        &lt;<span class="pl-ent">artifactId</span>&gt;simplespec_2.9.2&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.7.0&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;
&lt;/<span class="pl-ent">dependencies</span>&gt;</pre>
  </div> 
  <p>And for 2.9.1:</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependencies</span>&gt;
    &lt;<span class="pl-ent">dependency</span>&gt;
        &lt;<span class="pl-ent">groupId</span>&gt;com.simple&lt;/<span class="pl-ent">groupId</span>&gt;
        &lt;<span class="pl-ent">artifactId</span>&gt;simplespec_2.9.1&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.6.0&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;
&lt;/<span class="pl-ent">dependencies</span>&gt;</pre>
  </div> 
  <p><strong>Second</strong>, write a spec:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.example.</span><span class="pl-v">Stack</span>
<span class="pl-k">import</span> <span class="pl-v">org.junit.</span><span class="pl-v">Test</span>
<span class="pl-k">import</span> <span class="pl-v">com.simple.simplespec.</span><span class="pl-v">Spec</span>

<span class="pl-k">class</span> <span class="pl-en">StackSpec</span> <span class="pl-k">extends</span> <span class="pl-e">Spec</span> {
  <span class="pl-k">class</span> <span class="pl-en">`An</span> empty stack` {
    <span class="pl-k">val</span> <span class="pl-en">stack</span> <span class="pl-k">=</span> <span class="pl-en">Stack</span>()

    <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">`has a size of zero`</span> <span class="pl-k">=</span> {
      stack.size.must(be(<span class="pl-c1">0</span>))
    }

    <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">`is empty`</span> <span class="pl-k">=</span> {
      stack.isEmpty.must(be(<span class="pl-c1">true</span>))
    }

    <span class="pl-k">class</span> <span class="pl-en">`with</span> an item added to it` {
      stack <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>woo<span class="pl-pds">"</span></span>

      <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">`might have an item in it`</span> <span class="pl-k">=</span> {
        stack.must(be(empty))
      }
    }
  }
}</pre>
  </div> 
  <h2><a id="user-content-execution-model" class="anchor" href="https://github.com/simplefinance/simplespec#execution-model" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Execution Model</h2> 
  <p>The execution model for a <code>Spec</code> is just a logical extension of how JUnit itself works -- a <code>Spec</code> class contains one or more regular classes, each of which can contain zero or more <code>@Test</code>-annotated methods or further nested classes.</p> 
  <p>When JUnit runs the <code>Spec</code> class, it creates new instances of each class for each test method run, allowing for full test isolation. In the above example, first an instance of <code>StackSpec</code> would be created, then an instance of <code>StackSpec#`An empty stack`</code>, then an instance of <code>StackSpec#`An empty stack`#`with an item added to it`</code>, and finally its <code>`might have an item in it`</code> method is run as a test.</p> 
  <p>The tradeoff of this execution model (vs. one which shares state between test invocation) is that tests which create a substantial amount of shared state (e.g., data-intensive tests) spend a lot of time setting up or tearing down state.</p> 
  <p>Unlike JUnit, simplespec doesn't require your test methods to return void.</p> 
  <p>The outer <code>Spec</code> instance has <code>beforeEach</code> and <code>afterEach</code> methods which can be overridden to perform setup and teardown tasks for each test contained in the context. simplespec also provides <code>BeforeEach</code>, <code>AfterEach</code>, and <code>BeforeAndAfterEach</code> traits which inner classes can extend to perform more tightly-scoped setup and teardown tasks.</p> 
  <h2><a id="user-content-matchers" class="anchor" href="https://github.com/simplefinance/simplespec#matchers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Matchers</h2> 
  <p>simplespec provides a thin layer over <a href="http://code.google.com/p/hamcrest/" target="_blank">Hamcrest matchers</a> to allow for declarative assertions in your tests:</p> 
  <div class="highlight highlight-source-scala">
   <pre>stack.must(be(empty))</pre>
  </div> 
  <p>simplespec includes the following matchers by default, but you're encouraged to write your own:</p> 
  <ul> 
   <li><code>x.must(equal(y))</code>: Asserts <code>x == y</code>.</li> 
   <li><code>x.must(be(y))</code>: A synonym for <code>equal</code>.</li> 
   <li><code>x.must(beA(klass))</code>: Asserts that <code>x</code> is assignable as an instance of <code>klass</code>.</li> 
   <li><code>x.must(be(matcher))</code>: Asserts that <code>matcher</code> applies to <code>x</code>.</li> 
   <li><code>x.must(not(be(matcher)))</code>: Asserts that <code>matcher</code> does <em>not</em> apply to <code>x</code>.</li> 
   <li><code>x.must(be(empty))</code>: Asserts that <code>x</code> is a <code>TraversableLike</code> which is empty.</li> 
   <li><code>x.must(haveSize(n))</code>: Asserts that <code>x</code> is a <code>TraversableLike</code> which has <code>n</code> elements.</li> 
   <li><code>x.must(contain(y))</code>: Asserts that <code>x</code> is a <code>SeqLike</code> which contains the element <code>y</code>.</li> 
   <li><code>x.must(be(notNull))</code>: Asserts that <code>x</code> is not <code>null</code>.</li> 
   <li><code>x.must(be(approximately(y, delta)))</code>: Asserts that <code>x</code> is within <code>delta</code> of <code>y</code>. Useful for floating-point math.</li> 
   <li><code>x.must(be(lessThan(2)))</code>: Asserts that <code>x</code> is less than <code>2</code>.</li> 
   <li><code>x.must(be(greaterThan(2)))</code>: Asserts that <code>x</code> is greater than <code>2</code>.</li> 
   <li><code>x.must(be(lessThanOrEqualTo(2)))</code>: Asserts that <code>x</code> is less than or equal to <code>2</code>.</li> 
   <li><code>x.must(be(greaterThanOrEqualTo(2)))</code>: Asserts that <code>x</code> is greater than or equal to <code>2</code>.</li> 
   <li><code>x.must(startWith("woo"))</code>: Asserts that string <code>x</code> starts with <code>"woo"</code>.</li> 
   <li><code>x.must(endWith("woo"))</code>: Asserts that string <code>x</code> ends with <code>"woo"</code>.</li> 
   <li><code>x.must(contain("woo"))</code>: Asserts that string <code>x</code> contains with <code>"woo"</code>.</li> 
   <li><code>x.must(`match`(".*oo".r))</code>: Asserts that string <code>x</code> matches the regular expression <code>.*oo</code>.</li> 
  </ul> 
  <p>Matchers like <code>be</code> and <code>not</code> take matchers as their arguments, which means you can write domain-specific matchers for your tests:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">IsSufficientlyCromulentMatcher</span> <span class="pl-k">extends</span> <span class="pl-e">BaseMatcher</span>[<span class="pl-en">Fromulator</span>] {
  <span class="pl-k">def</span> <span class="pl-en">describeTo</span>(<span class="pl-v">description</span>: <span class="pl-en">Description</span>) {
    description.appendText(<span class="pl-s"><span class="pl-pds">"</span>a cromulemnt fromulator<span class="pl-pds">"</span></span>)
  }

  <span class="pl-k">def</span> <span class="pl-en">matches</span>(<span class="pl-v">item</span>: <span class="pl-en">AnyRef</span>) <span class="pl-k">=</span> item <span class="pl-k">match</span> {
    <span class="pl-k">case</span> <span class="pl-v">fromulator</span>: <span class="pl-en">Fromulator</span> <span class="pl-k">=&gt;</span> fromulator.isCromulent
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>
  }
}

<span class="pl-k">trait</span> <span class="pl-en">CromulentMatcher</span> {
  <span class="pl-k">def</span> <span class="pl-en">cromulent</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">IsSufficientlyCromulentMatcher</span>
}

<span class="pl-k">class</span> <span class="pl-en">BlahBlahSpec</span> <span class="pl-k">extends</span> <span class="pl-e">Spec</span> <span class="pl-k">with</span> <span class="pl-e">CromulentMatcher</span> {
  <span class="pl-k">class</span> <span class="pl-en">`A</span> <span class="pl-en">Fromulator</span>` {
    <span class="pl-k">val</span> <span class="pl-en">fromulator</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Fromulator</span>

    <span class="pl-k">def</span> <span class="pl-en">`is cromulent`</span> <span class="pl-k">=</span> {
      fromulator.must(be(cromulent)
    }
  }
}</pre>
  </div> 
  <p>simplespec also includes two helper methods: <code>evaluating</code> and <code>eventually</code>.</p> 
  <p><code>evaluating</code> captures a closure and allows you to make assertions about what happens when it's evaluated:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">`throws an exception`</span> <span class="pl-k">=</span> {
  evaluating {
    dooHicky.stop()
  }.must(throwAn[<span class="pl-en">UnsupportedOperationException</span>])
}</pre>
  </div> 
  <p><code>eventually</code> also captures a closure, but allows you to assert things about what happens when the closure is evaluated which might not be true the first few times:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">`decay to zero`</span> <span class="pl-k">=</span> {
  eventually {
    thingy.rate
  }.must(be(approximately(<span class="pl-c1">0.0</span>, <span class="pl-c1">0.001</span>)))
}</pre>
  </div> 
  <p>See <code>Matchers.scala</code> for the full run-down.</p> 
  <h2><a id="user-content-mocks" class="anchor" href="https://github.com/simplefinance/simplespec#mocks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Mocks</h2> 
  <p>SimpleSpec uses <a href="http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html" target="_blank">Mockito</a> for mocking stuff. It has its own wrappers around Mockito to make things a bit easier.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">PublisherSpec</span> <span class="pl-k">extends</span> <span class="pl-e">Spec</span> {
  <span class="pl-k">class</span> <span class="pl-en">`A</span> publisher` {
    <span class="pl-k">val</span> <span class="pl-en">message</span> <span class="pl-k">=</span> mock[<span class="pl-en">Message</span>]

    <span class="pl-k">val</span> <span class="pl-en">queue</span> <span class="pl-k">=</span> mock[<span class="pl-en">Queue</span>]
    queue.enqueue(any).returns(<span class="pl-c1">0</span>, <span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)

    <span class="pl-k">val</span> <span class="pl-en">publisher</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Publisher</span>(queue)

    <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">`sends a message to the queue`</span> <span class="pl-k">=</span> {
      publisher.receive(message)

      verify.one(queue).enqueue(message)
    }
  }
}</pre>
  </div> 
  <h3><a id="user-content-mock-stubbing" class="anchor" href="https://github.com/simplefinance/simplespec#mock-stubbing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Mock Stubbing</h3> 
  <p>By default, when you mock something and call a method on it, the call will return <code>null</code> or a basic value like <code>0</code> or <code>false</code> for primitives.</p> 
  <p>If you want to control what the mocked object returns for a given method call, you can use <code>returns</code>, <code>throws</code>, or <code>answersWith</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> mock[<span class="pl-en">FooService</span>]

<span class="pl-c"><span class="pl-c">//</span> .returns() can be used when you just want to return a static value</span>
foo.getNumber(<span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>).returns(<span class="pl-c1">1</span>)
foo.getNumber(<span class="pl-s"><span class="pl-pds">"</span>two<span class="pl-pds">"</span></span>).returns(<span class="pl-c1">2</span>)

<span class="pl-c"><span class="pl-c">//</span> .throws() will make the call throw the given exception.</span>
<span class="pl-c"><span class="pl-c">//</span> Note: if Mockito complains about a checked exception being invalid, you'll</span>
<span class="pl-c"><span class="pl-c">//</span> need to use .answersWith() to throw the exception instead.</span>
foo.getNumber(<span class="pl-s"><span class="pl-pds">"</span>dogs<span class="pl-pds">"</span></span>).throws(<span class="pl-k">new</span> <span class="pl-en">NumberFormatException)</span>

<span class="pl-c"><span class="pl-c">//</span> .answersWith() will call the function you pass it and use its result</span>
<span class="pl-c"><span class="pl-c">//</span> as the mocked return value.</span>
foo.getNumber(<span class="pl-s"><span class="pl-pds">"</span>three<span class="pl-pds">"</span></span>).answersWith(_ <span class="pl-k">=&gt;</span> <span class="pl-c1">3</span>)
foo.getNumber(<span class="pl-s"><span class="pl-pds">"</span>dogs<span class="pl-pds">"</span></span>).answersWith(_ <span class="pl-k">=&gt;</span> <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">NumberFormatException)</span></pre>
  </div> 
  <p>These stubbing functions are sensitive to order. So this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>foo.get(<span class="pl-c1">1</span>).returns(<span class="pl-s"><span class="pl-pds">"</span>cats<span class="pl-pds">"</span></span>)
foo.get(<span class="pl-c1">1</span>).returns(<span class="pl-s"><span class="pl-pds">"</span>dogs<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Will return <code>"dogs"</code> every time you call <code>foo.get(1)</code>.</p> 
  <p>You can also dynamically match arguments in method calls. The simplest way is to use <code>any</code> to match any argument of a given type:</p> 
  <div class="highlight highlight-source-scala">
   <pre>foo.get(any[<span class="pl-k">Int</span>]).returns(<span class="pl-c1">None</span>)
foo.get(<span class="pl-c1">1</span>).returns(<span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>dogs<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>This example uses the fact that stubs are sensitive to ordering to its advantage.</p> 
  <p>Note that if you match <em>any</em> of the method's arguments with a dymanic matcher like <code>any</code>, you'll need to match them <em>all</em> dynamically. For example, this does <strong>not</strong> work:</p> 
  <div class="highlight highlight-source-scala">
   <pre>foo.get(any[<span class="pl-k">Int</span>], <span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>).returns(...)</pre>
  </div> 
  <p>You can use <code>equalTo</code> to get around this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>foo.get(any[<span class="pl-k">Int</span>], equalTo[<span class="pl-k">String</span>](<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>)).returns(...)</pre>
  </div> 
  <p>Available dynamic matchers:</p> 
  <ul> 
   <li><code>any[A](implicit mf: Manifest[A])</code>: A matcher which will accept any instance.</li> 
   <li><code>isA[A](implicit mf: Manifest[A])</code>: A matcher which will accept any instance of the given type.</li> 
   <li><code>equalTo[A](value: A)</code>: A matcher which will accept any instance of the given type which is equal to the given value.</li> 
   <li><code>same[A](value: A)</code>: A matcher which will accept only the same instance as the given value.</li> 
   <li><code>isNull[A]</code>: A matcher which will accept only null values.</li> 
   <li><code>isNotNull[A]</code>: A matcher which will accept only non-null values.</li> 
   <li><code>contains(substring: String)</code>: A matcher which will accept only strings which contain the given substring.</li> 
   <li><code>matches(pattern: Regex)</code>: A matcher which will accept only strings which match the given pattern.</li> 
   <li><code>endsWith(suffix: String)</code>: A matcher which will accept only strings which end with the given suffix.</li> 
   <li><code>startsWith(prefix: String)</code>: A matcher which will accept only strings which start with the given prefix.</li> 
  </ul> 
  <p><strong>WARNING</strong>: Since the matchers are really Java under the hood, they do not understand Scala default arguments. If you are matching against a method with default arguments, you <em>must</em> specify the default arguments as well (Scala calls the method with <code>null</code> if the default is used.)</p> 
  <h3><a id="user-content-responding-to-invocations-with-answerswith" class="anchor" href="https://github.com/simplefinance/simplespec#responding-to-invocations-with-answerswith" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Responding to invocations with answersWith</h3> 
  <p>If you have a mock, you can invoke arbitrary behavior when it is called by using <code>answersWith</code>. This calls a function whenever the mock is used.</p> 
  <p>This can let you use a fake implementation for the mocked object. It's useful for implementing enough of the functionality to make your code work, or for doing some more advanced checks than normal matchers allow.</p> 
  <div class="highlight highlight-source-scala">
   <pre>myMock.get(any[<span class="pl-k">String</span>]).answersWith { f <span class="pl-k">=&gt;</span>
  <span class="pl-k">val</span> <span class="pl-en">stringArg</span> <span class="pl-k">=</span> f.getArguments.toSeq.head.<span class="pl-c1">asInstanceOf</span>[<span class="pl-k">String</span>]
  println(<span class="pl-s"><span class="pl-pds">"</span>I was called with <span class="pl-pds">"</span></span> <span class="pl-k">+</span> stringArg)
  <span class="pl-c1">false</span> <span class="pl-c"><span class="pl-c">//</span> your return value</span>
}</pre>
  </div> 
  <h3><a id="user-content-argument-capture" class="anchor" href="https://github.com/simplefinance/simplespec#argument-capture" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Argument Capture</h3> 
  <p>Simplespec supports Mockito's <a href="http://docs.mockito.googlecode.com/hg/org/mockito/ArgumentCaptor.html" target="_blank">ArgumentCaptor</a> to capture arguments:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">FooClass</span> {
  <span class="pl-k">def</span> <span class="pl-en">concatMethod</span>(<span class="pl-v">x</span>: <span class="pl-k">String</span>, <span class="pl-v">y</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> x <span class="pl-k">+</span> y.toString
}
<span class="pl-k">val</span> <span class="pl-en">arg3</span> <span class="pl-k">=</span> captor[<span class="pl-k">String</span>]
<span class="pl-k">val</span> <span class="pl-en">arg4</span> <span class="pl-k">=</span> captor[<span class="pl-k">Int</span>]
<span class="pl-k">val</span> <span class="pl-en">fooMock</span> <span class="pl-k">=</span> mock[<span class="pl-en">FooClass</span>]
fooMock.concatMethod(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-c1">1</span>)

verify.one(fooMock).concatMethod(arg3.capture(), arg4.capture())
arg3.getValue().must(be(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>))
arg4.getValue().must(be(<span class="pl-c1">1</span>))</pre>
  </div> 
  <h3><a id="user-content-mock-verification" class="anchor" href="https://github.com/simplefinance/simplespec#mock-verification" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Mock Verification</h3> 
  <p>TODO: Document this.</p> 
  <h2><a id="user-content-scalacheck" class="anchor" href="https://github.com/simplefinance/simplespec#scalacheck" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>ScalaCheck</h2> 
  <p>SimpleSpec includes helpers for integrating ScalaCheck properties into your tests, with the <code>hold</code> and <code>prove</code> matchers.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">StringPropertySpec</span> <span class="pl-k">extends</span> <span class="pl-e">Spec</span> {
  <span class="pl-k">import</span> <span class="pl-v">org.scalacheck.Prop.</span><span class="pl-v">_</span>

  <span class="pl-k">class</span> <span class="pl-en">`String</span> operations` {
    <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">startsWith</span> {
      forAll((<span class="pl-v">a</span>: <span class="pl-k">String</span>, <span class="pl-v">b</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> (a<span class="pl-k">+</span>b).startsWith(a)).must(hold)
    }

     <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">concatenate</span> {
      forAll((<span class="pl-v">a</span>: <span class="pl-k">String</span>, <span class="pl-v">b</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span>
        (a<span class="pl-k">+</span>b).length <span class="pl-k">&gt;</span> a.length <span class="pl-k">&amp;&amp;</span> (a<span class="pl-k">+</span>b).length <span class="pl-k">&gt;</span> b.length
      ).must(hold)
    }

    <span class="pl-k">@</span><span class="pl-en">Test</span> <span class="pl-k">def</span> <span class="pl-en">substring</span> {
      forAll((<span class="pl-v">a</span>: <span class="pl-k">String</span>, <span class="pl-v">b</span>: <span class="pl-k">String</span>, <span class="pl-v">c</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span>
        (a<span class="pl-k">+</span>b<span class="pl-k">+</span>c).substring(a.length, a.length<span class="pl-k">+</span>b.length) <span class="pl-k">==</span> b
      ).must(hold)
    }
  }
}</pre>
  </div> 
  <p>This is very convenient, since you may mix property and non-property tests freely, and produce test reports &amp; code coverage for your ScalaCheck properties.</p> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/simplefinance/simplespec#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>Copyright (c) 2010-2012 Coda Hale</p> 
  <p>Copyright (c) 2012-2014 Simple Finance Technology</p> 
  <p>Published under The MIT License, see <a href="https://github.com/simplefinance/simplespec/blob/master/LICENSE.md" target="_blank"><code>LICENSE.md</code></a></p> 
 </article>
</div>