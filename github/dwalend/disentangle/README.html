<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/dwalend/disentangle#disentangle" aria-hidden="true" class="anchor" id="user-content-disentangle" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Disentangle</h1> 
  <p>Disentangle is a kit for customizable graph algorithms in Scala. Disentangle's approach differs from other graph libraries by using Scala's existing collections and tuples wherever practical. Disentangle provides only the minimal traits and classes, and does not force you to use them. For example, Dijkstra's parAllPairsShortestPaths() requires only a GenTraversable of Tuple3 edges, and returns a ParSeq of minimal paths between nodes. A trait and class hierarchy for Graphs exist, but is not invasive and requires no type-system yoga on your part to use. Further, I only add new parts to that hierarchy when they have some pragmatic value.</p> 
  <p>Most graph libraries available on the internet provide some way to find shortest paths, almost always via Dijkstra's algorithm. However, when you try to use the algorithm provided it doesn't match your needs and is sealed up in the black box of compiled code, custom data structures, and optimistic assumptions. Disentangle's semiring-based graph minimization algorithms let you define exactly what you want to minimize. The library's core is based on ideas presented in Cormen’s massive <em>Algorithms</em>, “A general framework for solving path problems in directed graphs,” 26.4 in my 1989 copy. The high-level semiring structures are composable, which allows for a great deal of customization.</p> 
  <p>Further, the library provides support for computational stability. The same input will reliably result in the same output. Small changes in input typically result in small changes in output. The semiring-based algorithms offer an optional nodeOrder argument to provide that stability.</p> 
  <h2><a href="https://github.com/dwalend/disentangle#changes-in-021-the-fifth-release" aria-hidden="true" class="anchor" id="user-content-changes-in-021-the-fifth-release" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changes in 0.2.1, the fifth release</h2> 
  <ul> 
   <li>Added implicit methods to graphs for algorithms via pimping in net.walend.disentangle.graph.{LabelDigraphSemiringAlgorithms, LabelUndigraphSemiringAlgorithms} ** The undirected graph versions correct Brandes betweenness in undirected graphs (by dividing by 2).</li> 
   <li>Added Undigraph, a trait for undirected graphs</li> 
   <li>Added hierarchy down to AdjacencyLabelUndigraph, an immutable adjacency list labeled undirected digraph.</li> 
   <li>Added a proof-of-concept clustering algorithm. (Isolated in the graph test .jar. Definitely not ready for general use.)</li> 
  </ul> 
  <h2><a href="https://github.com/dwalend/disentangle#changes-in-020-the-forth-release" aria-hidden="true" class="anchor" id="user-content-changes-in-020-the-forth-release" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changes in 0.2.0, the forth release</h2> 
  <ul> 
   <li><a href="http://dwalend.github.io/blog/2015/11/03/Rename-to-Disentangle/" target="_blank">Renamed the project Disentangle</a> from ScalaGraphMinimizer (which was nearly impossible to say).</li> 
   <li>Added <a href="http://dwalend.github.io/blog/2015/11/10/Easy-Parallel/" target="_blank">parallel versions</a> of Dijkstra's and Brandes' algorithms for all shortest paths.</li> 
   <li>Restructured into subprojects to minimize dependencies on third-party libraries in your code ** Added an <a href="https://github.com/dwalend/Disentangle/tree/master/examples/src/main/scala/net/walend/disentangle/examples" target="_blank">example subproject</a>, <a href="https://github.com/dwalend/Disentangle/tree/master/benchmark/src/main/scala/net/walend/disentangle/graph/semiring/benchmark" target="_blank">benchmark subproject</a>, and <a href="https://github.com/dwalend/Disentangle/tree/master/toScalaGraph/src/main/scala/net/walend/disentangle/scalagraph/semiring/ConvertToLabelDigraph.scala" target="_blank">toScalaGraph subproject</a></li> 
   <li>Started tracking <a href="http://dwalend.github.io/blog/2015/11/10/Easy-Parallel/" target="_blank">performance</a> (No javascript rendering in README.mds, but <a href="https://github.com/dwalend/Disentangle/blob/master/benchmark/src/main/html/plot.html" target="_blank">try this page on your own</a>.)</li> 
   <li>Added <a href="https://github.com/dwalend/Disentangle/blob/master/examples/src/main/scala/net/walend/disentangle/examples/DijkstraExample.scala" target="_blank">helper methods</a> to some semirings to produce shortest paths.</li> 
  </ul> 
  <h2><a href="https://github.com/dwalend/disentangle#getting-disentangle" aria-hidden="true" class="anchor" id="user-content-getting-disentangle" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Disentangle</h2> 
  <p>The easiest way to include this project in yours is to add the jar files from sonatype's mvn repository.</p> 
  <pre><code>libraryDependencies += "net.walend.disentangle" %% "graph" % "0.2.1" 
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#the-latest-snapshot-when-available" aria-hidden="true" class="anchor" id="user-content-the-latest-snapshot-when-available" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>The Latest Snapshot (When Available)</h3> 
  <p>To get the latest snapshot in your build.sbt, add</p> 
  <pre><code>resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"

libraryDependencies += "net.walend.disentangle" %% "graph" % "0.2.2-SNAPSHOT"
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#clone-the-code" aria-hidden="true" class="anchor" id="user-content-clone-the-code" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Clone the Code</h3> 
  <p>If you want to change Disentangle to meet your every whim, share your changes by sending me pull requests, or just mess around, clone the git repo and have at it.</p> 
  <pre><code>git clone https://github.com/dwalend/Disentangle.git  
cd Disentangle
# bend Disentangle to your will
sbt test package
cp target/scala-2.11/scalagraphminimizer_2.11-0.2.1-SNAPSHOT.jar /your/project/lib
</code></pre> 
  <h2><a href="https://github.com/dwalend/disentangle#algorithms" aria-hidden="true" class="anchor" id="user-content-algorithms" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Algorithms</h2> 
  <p>Disentangle supplies</p> 
  <ul> 
   <li>A <a href="https://github.com/dwalend/Disentangle/blob/master.2/graph/src/main/scala/net/walend/disentangle/heap/FibonacciHeap.scala" target="_blank">Fibonacci heap</a> -- a generic heap that supports an efficient changeKey operation.</li> 
   <li>The <a href="https://github.com/dwalend/Disentangle/blob/master.2/graph/src/main/scala/net/walend/disentangle/graph/semiring/FloydWarshall.scala" target="_blank">Floyd-Warshall algorithm </a></li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master.2/graph/src/main/scala/net/walend/disentangle/graph/semiring/Dijkstra.scala" target="_blank">Dijkstra's algorithm</a> with a Fibonacci Heap</li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master.2/graph/src/main/scala/net/walend/disentangle/graph/semiring/Brandes.scala" target="_blank">Brandes' algorithm</a> for betweenness and all shortest paths</li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master.2/graph/src/main/scala/net/walend/disentangle/graph/semiring/package.scala" target="_blank">implicit pimps for Graphs</a> to access these methods.</li> 
  </ul> 
  <h3><a href="https://github.com/dwalend/disentangle#parallel-algorithms" aria-hidden="true" class="anchor" id="user-content-parallel-algorithms" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Parallel Algorithms</h3> 
  <p>Disentangle supplies</p> 
  <ul> 
   <li>A parallel version of <a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/Dijkstra.scala#L129-148" target="_blank">Dijkstra's algorithm</a></li> 
   <li>A parallel version of <a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/Brandes.scala#L142-171" target="_blank">Brandes' algorithm </a></li> 
  </ul> 
  <h3><a href="https://github.com/dwalend/disentangle#performance" aria-hidden="true" class="anchor" id="user-content-performance" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Performance</h3> 
  <p>I've used a profiler to quench hotspots where I could find ways to speed up algorithms. I've <a href="http://dwalend.github.io/blog/2015/11/10/Easy-Parallel/" target="_blank">measured performance</a> on graphs with up to 16384 nodes on an ec2 r3.8xlarge. (Don't start a machoflops digression. I just wanted to check the algorithms' time complexity. I'm not that interested in playing.)</p> 
  <h2><a href="https://github.com/dwalend/disentangle#using-disentangle" aria-hidden="true" class="anchor" id="user-content-using-disentangle" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using Disentangle</h2> 
  <p>See the <a href="http://dwalend.github.io/Disentangle/v0.2.1/#net.walend.disentangle.graph.package" target="_blank">scaladoc</a> and <a href="https://github.com/dwalend/Disentangle/tree/master/examples/src/main/scala/net/walend/disentangle/examples" target="_blank">examples</a>.</p> 
  <h3><a href="https://github.com/dwalend/disentangle#using-implicit-methods-on-netwalendgraph_-graphs-with-pimped-algorithms" aria-hidden="true" class="anchor" id="user-content-using-implicit-methods-on-netwalendgraph_-graphs-with-pimped-algorithms" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using implicit methods on net.walend.graph._ graphs with <a href="https://github.com/dwalend/Disentangle/blob/master/examples/src/main/scala/net/walend/disentangle/examples/BrandesImplicitsExample.scala" target="_blank">Pimped Algorithms</a></h3> 
  <p>If you are already using net.walend.graph._ graphs</p> 
  <pre><code>import net.walend.disentangle.graph.semiring.LabelUndigraphSemiringAlgorithms
//or
import net.walend.disentangle.graph.semiring.LabelDigraphSemiringAlgorithms

...

val graph = AdjacencyLabelUndigraph(edges,nodeOrder)

//call the implicit methods
val brandesResults = graph.allLeastPathsAndBetweenness()

val nextStepsAndCosts: IndexedSeq[(String, String, Option[BrandesSteps[String, Int]])] = brandesResults._1

val betweennessValues: Map[String, Double] = brandesResults._2
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#finding-shortest-paths-with-dijkstras-and-floyd-warshall-algorithms" aria-hidden="true" class="anchor" id="user-content-finding-shortest-paths-with-dijkstras-and-floyd-warshall-algorithms" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Finding Shortest Paths with (<a href="https://github.com/dwalend/Disentangle/blob/master/examples/src/main/scala/net/walend/disentangle/examples/DijkstraExample.scala" target="_blank">Dijkstra's</a> and <a href="https://github.com/dwalend/Disentangle/blob/master/examples/src/main/scala/net/walend/disentangle/examples/FloydWarshallExample.scala" target="_blank">Floyd-Warshall</a> Algorithms)</h3> 
  <p>You'll need to bring a GenTraversable[(Node,Node,Edge)] for your graph.</p> 
  <pre><code>val edges = Seq(
                ("A","B","ab"),
                ("B","C","bc"),
                ("C","D","cd"),
                ("D","E","de"),
                ("E","F","ef"),
                ("E","B","eb"),
                ("E","H","eh"),
                ("H","C","hc")
               )

/**
 * Generate all the shortest paths in the graph
 */
val simpleShortPathLabels = Dijkstra.allPairsShortestPaths(edges)
</code></pre> 
  <p>Or</p> 
  <pre><code>/**
 * Generate all the shortest paths in the graph in parallel
 */
val simpleShortPathLabelsFromPar = Dijkstra.parAllPairsShortestPaths(edges)
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#finding-betweenness-and-shortest-paths-with-brandes-algorithm" aria-hidden="true" class="anchor" id="user-content-finding-betweenness-and-shortest-paths-with-brandes-algorithm" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Finding Betweenness and Shortest Paths with <a href="https://github.com/dwalend/Disentangle/blob/master/examples/src/main/scala/net/walend/disentangle/examples/BrandesExample.scala" target="_blank">Brandes'</a> Algorithm</h3> 
  <pre><code>/**
 * The labels from Brandes use node indexes from a directed graph,
 * so it's best to control those via the optional nodeOrder parameter
 */
val nodeOrder = Array("A","B","C","D","E","F","H")

/**
 * Find shortest paths and betweenness for the graph
 */
val shortestPathsAndBetweenness = Brandes.allLeastPathsAndBetweenness(edges,nodeOrder)
</code></pre> 
  <p>Or</p> 
  <pre><code>/**
 * Find shortest paths and betweenness for the graph in parallel
 */
val shortestPathsAndBetweennessFromPar = Brandes.parAllLeastPathsAndBetweenness(edges,nodeOrder)
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#changing-the-semiring" aria-hidden="true" class="anchor" id="user-content-changing-the-semiring" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/dwalend/Disentangle/blob/master/examples/src/main/scala/net/walend/disentangle/examples/DijkstraLeastWeightsExample.scala" target="_blank">Changing the Semiring</a></h3> 
  <p>The methods above use a semiring that finds paths with the fewest number of nodes. You can swap out the semiring or supply your own to find least-weight paths, most-probable paths, or whatever meets your needs.</p> 
  <p>Select or create the semiring support object to use:</p> 
  <pre><code>/**
 * A semiring support instance that uses double-valued labels to find the shortest paths.
 */
val support = new AllPathsFirstSteps(LeastWeights)

/**
 * Supply a function that can convert from a String to a Double to build up the initial graph
 * of edges. You'll probably have something more significant than this hack.
 */
def stringToDouble(fromNode:String,toNode:String,edge:String):Double = edge.map(_.hashCode().toDouble).product
</code></pre> 
  <p>And create a function to convert the edges in your graph to edges that match the semiring support:</p> 
  <pre><code>/**
 * Build on AllPathsFirstSteps' convert method
 */
val labelForEdge: (String, String, String) =&gt; support.Label = support.convertEdgeToLabel[String](stringToDouble)
</code></pre> 
  <p>Then generate all of the shortest paths:</p> 
  <pre><code>/**
 * Generate the first steps for all paths in the graph
 */
val leastPathLabels: Seq[(String, String, support.Label)] = Dijkstra.allPairsLeastPaths(edges,support,labelForEdge)
</code></pre> 
  <p>Or generate them in parallel:</p> 
  <pre><code>/**
 * Generate the first steps for all paths in the graph in parallel
 */
val leastPathLabelsFromPar: ParSeq[(String, String, support.Label)] = Dijkstra.parAllPairsLeastPaths(edges,support,labelForEdge)
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#semirings" aria-hidden="true" class="anchor" id="user-content-semirings" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Semirings</h3> 
  <p>Disentangle supplies some basic semirings and associated support classes</p> 
  <ul> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/FewestNodes.scala" target="_blank">FewestNodes</a> which helps create paths that include the fewest nodes between start and end nodes</li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/LeastWeights.scala" target="_blank">LeastWeights</a> which helps create paths that have the least (positive Double) weight sum between start and end nodes</li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/MostProbable.scala" target="_blank">MostProbable</a> which helps create paths that have the most probable (Double between zero and one) path between start and end nodes</li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/TransitiveClosure.scala" target="_blank">TransitiveClosure</a> which helps create all paths that connect start and end nodes</li> 
  </ul> 
  <p>Semirings can be composed. Disentangle takes advantage of this by supplies some semirings that decorate a core semiring, and harvest additional details about the minimal paths and subgraphs explored.</p> 
  <ul> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/OnePathFirstStep.scala" target="_blank">OnePathFirstStep</a> which finds one minimal path between start and end nodes by supplying the next node as an Option[FirstStep]</li> 
   <li><a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/AllPathsFirstSteps.scala" target="_blank">AllPathsFirstSteps</a> which finds all minimal paths between start and end nodes by supplying a Set of possible next nodes within an Option[FirstSteps]. This semiring includes some helper methods to convert first steps to paths.</li> 
  </ul> 
  <h2><a href="https://github.com/dwalend/disentangle#customizing-disentangle" aria-hidden="true" class="anchor" id="user-content-customizing-disentangle" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Customizing Disentangle</h2> 
  <p>Customize Disentangle with your own conversions, Semirings, and algorithms.</p> 
  <h3><a href="https://github.com/dwalend/disentangle#converting-your-graph-to-a-sequence-of-nodenodearclabel-tuples" aria-hidden="true" class="anchor" id="user-content-converting-your-graph-to-a-sequence-of-nodenodearclabel-tuples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Converting Your Graph to a Sequence of (Node,Node,ArcLabel) Tuples</h3> 
  <p>FloydWarshall, Dijkstra, and Brandes each include a method that take sequences of (Node,Node,Edge) tuples. These methods require you to provide a function that translates your tuple into a label that fits your semiring's Label type specifier. The decorator semirings listed above each include helper functions that require a similar function to convert the tuple to the core semiring's Label. These functions are typically very straightforward to create.</p> 
  <pre><code>convertEdgeToLabelFunc:(Node,Node,Edge)=&gt;Label
</code></pre> 
  <p>These algorithms also allow for an optional Seq of nodes. This Seq controls the ordering of the algorithm's internal processing and output and can contain both extra nodes and any nodes that already exist in the edges. Take advantage of this Seq to improve computational stability.</p> 
  <p>FloydWarshall, Dijkstra, and Brandes each include a method that takes an IndexedDigraph implementation, mutable for FloydWarshall. If you use this method then you are responsible for creating the labelDigraph correctly. I included it primarily for computational efficiency, and for a possible future lazy evaluator for Dijkstra's method.</p> 
  <pre><code>labelDigraph:IndexedDigraph[Node,Label]
</code></pre> 
  <h3><a href="https://github.com/dwalend/disentangle#creating-a-custom-semiring-and-other-support-classes" aria-hidden="true" class="anchor" id="user-content-creating-a-custom-semiring-and-other-support-classes" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Creating A Custom Semiring and Other Support Classes</h3> 
  <p>You will likely want to create your own Semirings to match the problems you are solving. That will be enough to run the Floyd-Warshall algorithm. However, Dijkstra's and Brandes' algorithms requires some extra methods for the heap. Implement SemiringSupport, which includes a Semiring, a HeapOrdering, and a function to convert from Labels to the heap's Keys. Here is an example that can find the <a href="https://github.com/dwalend/Disentangle/blob/master/graph/src/main/scala/net/walend/disentangle/graph/semiring/MostProbable.scala" target="_blank">most probable paths</a>:</p> 
  <pre><code>object MostProbable extends SemiringSupport[Double,Double] {

  def semiring = MostProbableSemiring

  def heapOrdering = MostProbableOrdering

  def heapKeyForLabel = {label:Label =&gt; label}
</code></pre> 
  <p>Sometimes it can be helpful to provide a possible convertEdgeToLabel function</p> 
  <pre><code>  def convertEdgeToLabel[Node, Label](start: Node, end: Node, label: Label): MostProbable.Label = semiring.I
</code></pre> 
  <p>For your Semiring supply identity and annihilator values, a method to check that a label is in the domain, and summary and extend operators. Here's an example:</p> 
  <pre><code>  object MostProbableSemiring extends Semiring {

    def I = 1.0
    def O = 0.0

    def inDomain(label: Label): Boolean = {
      I &gt;= label &amp;&amp; label &gt; O
    }

    def summary(fromThroughToLabel:Label,
                currentLabel:Label):Label = {
      if(fromThroughToLabel &gt; currentLabel) {
        fromThroughToLabel
      }
      else currentLabel
    }

    def extend(fromThroughLabel:Label,throughToLabel:Label):Label = {
      if ((fromThroughLabel == O) || (throughToLabel == O)) O
      else {
        fromThroughLabel * throughToLabel
      }
    }
  }
</code></pre> 
  <p>The HeapOrdering is actually trickier to get right than the Semiring. The Heap needs a special Key, AlwaysTop, that will always be higher than the highest possible Label and AlwaysBottom, that will only be on the bottom of the heap. The identity and annihilator sometimes work as these special values. Watch out for strange behaviors of floating point infinities and wrap-around with integers. In this example, I want a version that has the highest values on top of the heap. Note that I took a shortcut and made AlwaysTop outside of the Semiring's domain.</p> 
  <pre><code>  /**
   * A heap ordering that puts lower numbers on the top of the heap
   */
  object MostProbableOrdering extends HeapOrdering[Double] {

    def lteq(x: Double, y: Double): Boolean = {
      x &lt;= y
    }

    /**
     * @return Some negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second, or None if they can't be compared
     */
    def tryCompare(x: Double, y: Double): Option[Int] = {
      Option(x.compareTo(y))
    }

    def keyDomainDescription = "between one and zero (the annihilator)"

    /**
     * @throws IllegalArgumentException if the key is unusable
     */
    def checkKey(key: Double): Unit = {
      require((MostProbable.MostProbableSemiring.inDomain(key)||(key == MostProbable.MostProbableSemiring.O)),s"Key must be $keyDomainDescription, not $key")
    }

    /**
     * Minimum value for the DoubleHeap
     */
    def AlwaysTop:Double = semiring.I + 0.01

    /**
     * A key that will among items on the bottom of the heap. Used primarily to add items that will eventually flow higher.
     */
    def AlwaysBottom: Double = semiring.O
  }
}
</code></pre> 
  <h2><a href="https://github.com/dwalend/disentangle#roadmap-for-future-work" aria-hidden="true" class="anchor" id="user-content-roadmap-for-future-work" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Roadmap for Future Work</h2> 
  <h3><a href="https://github.com/dwalend/disentangle#next-big-release" aria-hidden="true" class="anchor" id="user-content-next-big-release" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Next Big Release</h3> 
  <h3><a href="https://github.com/dwalend/disentangle#new-algorithms" aria-hidden="true" class="anchor" id="user-content-new-algorithms" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>New Algorithms</h3> 
  <ul> 
   <li>More development of the clustering prototype</li> 
   <li>JIT heap optimization of Dijkstra's algorithm</li> 
   <li>A*</li> 
   <li>Lazy Dijkstra's</li> 
   <li>MST using a Heap</li> 
  </ul> 
  <h3><a href="https://github.com/dwalend/disentangle#more-semirings" aria-hidden="true" class="anchor" id="user-content-more-semirings" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>More Semirings</h3> 
  <h3><a href="https://github.com/dwalend/disentangle#concurrent-graph-minization" aria-hidden="true" class="anchor" id="user-content-concurrent-graph-minization" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Concurrent Graph Minization</h3> 
  <ul> 
   <li>Concurrent Graph structure</li> 
   <li>Parallel queued graph minimization</li> 
   <li>Parallel A* variations</li> 
  </ul> 
  <h2><a href="https://github.com/dwalend/disentangle#license-and-contributions" aria-hidden="true" class="anchor" id="user-content-license-and-contributions" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License and Contributions</h2> 
  <p>Disentangle carries the MIT license and is (c) David Walend 2013,2014,2015,2016</p> 
  <p>Special thanks to Peter Empen for <a href="http://www.scala-graph.org/" target="_blank">scala-graph</a>, advice, code, and patience. And thanks to Aleksandar Prokopec for some answers about the <a href="http://docs.scala-lang.org/overviews/parallel-collections/overview.html" target="_blank">parallel collections</a>.</p> 
 </article>
</div>