<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-hubot-scala" class="anchor" href="https://github.com/denen99/hubot-scala#hubot-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Hubot Scala</h1> 
  <p>This is a (poor?) attempt at trying to write a simplified version of Hubot in Scala. It allows you to extend it by writing your own listener classes and middleware classes. Quite frankly, I found the coffeescript Hubot code a little nasty to follow and without static typing , it became a real chore trying to piece it together.</p> 
  <h3><a id="user-content-how-it-works" class="anchor" href="https://github.com/denen99/hubot-scala#how-it-works" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How it works</h3> 
  <p>The current implementation is fairly simple (explained in more detail below). There are 3 main components, Adapters, Listeners, and Middleware.</p> 
  <h3><a id="user-content-adapters" class="anchor" href="https://github.com/denen99/hubot-scala#adapters" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adapters</h3> 
  <p>Adapters (of which there can be 1), extends BaseAdapter and implements a few basic methods that is used to tie to your chat source. So there should be an adapter for XMPP, Campfire, Slack, etc. For now its simply, send() [Send a message], receive() [receive a message] and run() [Run the adapter]. Set the property hubot.adapter in application.conf using the full className.</p> 
  <h3><a id="user-content-middleware" class="anchor" href="https://github.com/denen99/hubot-scala#middleware" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Middleware</h3> 
  <p>Middleware, are simple an intermediary you can write that every message goes through. Each piece of middleware should return either a Left(MiddlewareFailure) if the message should be blocked or a Right(MiddlewareSuccess) if the message should be passed through. On the first Left() the chain is halted </p> 
  <h3><a id="user-content-listeners" class="anchor" href="https://github.com/denen99/hubot-scala#listeners" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Listeners</h3> 
  <p>Listeners, can be one of two types Respond or Hear. Hear, listens to every message in the chat, while Respond reacts when the bot is addressed by its name (configurable in appplication.conf). A Listener is a simple class you write that takes a regex string in its constructor and a runCallback() method you need to implement which is what happens when the message matches your listener regex. The Message object is passed to the callback and you can do as you please from there.</p> 
  <h3><a id="user-content-getting-started" class="anchor" href="https://github.com/denen99/hubot-scala#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting started</h3> 
  <p>To get started, first, you need to put the hubot-scala library in your build.sbt as follows</p> 
  <pre><code>    libraryDependencies += "org.dberg" % "hubot-scala_2.11" % "0.0.3"
</code></pre> 
  <p>Once you do that, in your new project create whatever classes you need. For example, here is a simple listener, that responds to hello when the Bot is addressed</p> 
  <pre><code>class TestListener() extends Listener("hello\\s+world", ListenerType.Respond) {

  def runCallback(message: Message) = {
    Logger.log("Running callback for listner TestListener","debug")
    Hubot.robot.send(Message(message.user,"Hubot says hello!""))
  }

  val helpString = Some("hello world -&gt; Allows hubot to say hello !")
}
</code></pre> 
  <p>The structure of the Message class is Message(user: User, body: String, params: Map[String,String]). The params allows the adapter a place to stick additional information that then gets passed through to the listener and middleware.</p> 
  <p>To create a middleware is similar to the listener. Create a new class that extends Middleware and do whatever you want with the message. Then simply define a method named "execute(message: Message)" and you are good to go. You can keep state, call an external service, etc. Here is an example of middleware that checks if the message matches the word "blacklist".</p> 
  <pre><code>class TestMiddleware() extends Middleware {

 def execute(message: Message) = {
  if (message.body == "blacklist") {
   Left(MiddlewareError("Sorry this is a blacklist"))
  }
  else {
   Right(MiddlewareSuccess())
  }
 }

}
</code></pre> 
  <h3><a id="user-content-configuration" class="anchor" href="https://github.com/denen99/hubot-scala#configuration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuration</h3> 
  <p>2 configuration files should be used and placed in src/main/resources. The first is application.conf (check the sample in this repo). The format is like so </p> 
  <pre><code>hubot {
   name = "scalabot"

  listeners = ["org.yourdomain.listeners.YourFirstListener",   "org.yourdomain.listeners.YourOtherListener"]

  middleware = []

  adapter = "org.dberg.hubot.adapter.ShellAdapter"
</code></pre> 
  <p>} </p> 
  <p>The second is the logback.xml file. Tweak this file depending on how you want your logging to work.</p> 
  <pre><code>&lt;configuration debug="true"&gt;

&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
  &lt;file&gt;logs/hubot.log&lt;/file&gt;

  &lt;encoder&gt;
    &lt;pattern&gt;%date %level [%file:%line] %msg%n&lt;/pattern&gt;
  &lt;/encoder&gt;
&lt;/appender&gt;

&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
 &lt;encoder&gt;
  &lt;pattern&gt;%date %level [%file:%line] %msg%n&lt;/pattern&gt;
 &lt;/encoder&gt;
&lt;/appender&gt;

 &lt;root level="DEBUG"&gt;
  &lt;appender-ref ref="FILE" /&gt;
  &lt;appender-ref ref="STDOUT" /&gt;
 &lt;/root&gt;
&lt;/configuration&gt;
</code></pre> 
  <h3><a id="user-content-running-the-bot" class="anchor" href="https://github.com/denen99/hubot-scala#running-the-bot" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the Bot</h3> 
  <p>Once you have everything configured you simply need to start the bot. Simple Main class as so </p> 
  <pre><code> object Main {
  def main(args: Array[String]) = {
     Hubot.robot.run()
  }
 }
</code></pre> 
 </article>
</div>