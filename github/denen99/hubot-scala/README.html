<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p>#Hubot Scala</p> 
  <p>This is a (poor?) attempt at trying to write a simplified version of Hubot in Scala. It allows you to extend it by writing your own listener classes and middleware classes. Quite frankly, I found the coffeescript Hubot code a little nasty to follow and without static typing , it became a real chore trying to piece it together.</p> 
  <h3><a id="user-content-how-it-works" class="anchor" href="https://github.com/denen99/hubot-scala#how-it-works" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How it works</h3> 
  <p>The current implementation is fairly simple (explained in more detail below). There are 4 main components, Adapters, Listeners, Brain and Middleware.</p> 
  <h3><a id="user-content-adapters" class="anchor" href="https://github.com/denen99/hubot-scala#adapters" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adapters</h3> 
  <p>Adapters (of which there can be 1), extends BaseAdapter and implements a few basic methods that is used to tie to your chat source. So there could be an adapter for XMPP, Campfire, Slack, etc. For now its simply, send() [Send a message], receive() [receive a message] and run() [Run the adapter]. Set the property hubot.adapter in application.conf using the full className.</p> 
  <h3><a id="user-content-middleware" class="anchor" href="https://github.com/denen99/hubot-scala#middleware" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Middleware</h3> 
  <p>Middleware, are simple an intermediary you can write that every message goes through. Each piece of middleware should return either a Left(MiddlewareFailure) if the message should be blocked or a Right(MiddlewareSuccess) if the message should be passed through. On the first Left() the chain is halted. Useful for things like rate limiting, blocking certain users, etc.</p> 
  <h3><a id="user-content-listeners" class="anchor" href="https://github.com/denen99/hubot-scala#listeners" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Listeners</h3> 
  <p>Listeners, can be one of two types Respond or Hear. Hear, listens to every message in the chat, while Respond reacts when the bot is addressed by its name (configurable in appplication.conf). A Listener is a simple class you write that takes a regex string in its constructor and a runCallback() method you need to implement which is what happens when the message matches your listener regex. The Message object is passed to the callback and you can do as you please from there. Additionally, any groupings you used in your regex are passed back as a groups Seq[String] so you can obtain access to those references.</p> 
  <h3><a id="user-content-brain" class="anchor" href="https://github.com/denen99/hubot-scala#brain" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Brain</h3> 
  <p>Brain, is a configurable backend that allows you to have persistence. Currently, hubot-scala ships with MapDB as a default brain backend, but you are free to write your own. Simply extend BrainBackendBase and implement 3 methods, getKey, setKey and shutdown().</p> 
  <p>Also note, that for serialization purposes, mostly to allow the storing of complex types as values (like List() and Map()), Scodec is used as the serialization. The gets are also wrapped in a Try{} since a NullPointer is returned when trying to deserialize to an invalid type. This means the syntax for getting a value from the brain would be something like:</p> 
  <pre><code>brain.get[A](someKey).getOrElse(defaultValue)
</code></pre> 
  <p>where A is the type you are deserializing to (String, List[Int]), someKey is the key to your hash and defaultValue is the value to return if the key is not found. Additionally to store a value, the format would be</p> 
  <pre><code>brain.set[A](someKey, someValue)
</code></pre> 
  <p>Again, someValue needs to be of type A, and someKey is a String.</p> 
  <h3><a id="user-content-getting-started" class="anchor" href="https://github.com/denen99/hubot-scala#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting started</h3> 
  <p>To get started, first, you need to put the hubot-scala library in your build.sbt as follows</p> 
  <pre><code>    libraryDependencies += "org.dberg" % "hubot-scala_2.11" % "${latest}"
</code></pre> 
  <p>Once you do that, in your new project create whatever classes you need. For example, here is a simple listener, that responds to hello when the Bot is addressed</p> 
  <pre><code>class TestListener(hubot: Hubot) extends Listener(hubot,"hello\\s+world", ListenerType.Respond) {

  def runCallback(message: Message, groups: Seq[String]) = {
    Logger.log("Running callback for listner TestListener","debug")
    robot.send(Message(message.user,"Hubot says hello!"", message.messageType))
  }

  val helpString = Some("hello world -&gt; Allows hubot to say hello !")
}
</code></pre> 
  <p>The structure of the Message class is Message(user: User, body: String, messageType: MessageTypeValue, params: Map[String,String]). The params allows the adapter a place to stick additional information that then gets passed through to the listener and middleware.</p> 
  <p>To create a middleware is similar to the listener. Create a new class that extends Middleware and do whatever you want with the message. Then simply define a method named "execute(message: Message)" and you are good to go. You can keep state, call an external service, etc. Here is an example of middleware that checks if the message matches the word "blacklist".</p> 
  <pre><code>class TestMiddleware(hubot: Hubot) extends Middleware(hubot) {

 def execute(message: Message) = {
  if (message.body == "blacklist") {
   Left(MiddlewareError("Sorry this is a blacklist"))
  }
  else {
   Right(MiddlewareSuccess())
  }
 }
 
}
</code></pre> 
  <h3><a id="user-content-configuration" class="anchor" href="https://github.com/denen99/hubot-scala#configuration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuration</h3> 
  <p>2 configuration files should be used and placed in src/main/resources. The first is application.conf (check the sample in this repo). The format is like so</p> 
  <pre><code>hubot {
  name = "yourbotname"

  listeners = ["org.yourdomain.listeners.YourFirstListener",   "org.yourdomain.listeners.YourOtherListener"]

  middleware = []

  adapter = "org.dberg.hubot.adapter.ShellAdapter"
</code></pre> 
  <p>}</p> 
  <p>The second is the logback.xml file. Tweak this file depending on how you want your logging to work.</p> 
  <pre><code>&lt;configuration debug="true"&gt;

&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
  &lt;file&gt;logs/hubot.log&lt;/file&gt;

  &lt;encoder&gt;
    &lt;pattern&gt;%date %level [%file:%line] %msg%n&lt;/pattern&gt;
  &lt;/encoder&gt;
&lt;/appender&gt;

&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
 &lt;encoder&gt;
  &lt;pattern&gt;%date %level [%file:%line] %msg%n&lt;/pattern&gt;
 &lt;/encoder&gt;
&lt;/appender&gt;

 &lt;root level="DEBUG"&gt;
  &lt;appender-ref ref="FILE" /&gt;
  &lt;appender-ref ref="STDOUT" /&gt;
 &lt;/root&gt;
&lt;/configuration&gt;
</code></pre> 
  <h3><a id="user-content-running-the-bot" class="anchor" href="https://github.com/denen99/hubot-scala#running-the-bot" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the Bot</h3> 
  <p>Once you have everything configured you simply need to start the bot. Create a simple Main class as so</p> 
  <pre><code> import org.dberg.hubot.HubotRunner

 object Main {
  def main(args: Array[String]) = {
     HubotRunner.start
  }
 }
</code></pre> 
 </article>
</div>