<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p>#Hubot Scala</p> 
  <p>This is a (poor?) attempt at trying to write a simplified version of Hubot in Scala. It allows you to extend it by writing your own listener classes and middleware classes. Quite frankly, I found the coffeescript Hubot code a little nasty to follow and without static typing , it became a real chore trying to piece it together.</p> 
  <h3><a id="user-content-how-it-works" class="anchor" href="https://github.com/denen99/hubot-scala#how-it-works" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How it works</h3> 
  <p>The current implementation is fairly simple (explained in more detail below). There are 4 main components, Adapters, Listeners, Brain and Middleware.</p> 
  <h3><a id="user-content-adapters" class="anchor" href="https://github.com/denen99/hubot-scala#adapters" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adapters</h3> 
  <p>Adapters (of which there can be 1), extends BaseAdapter and implements a few basic methods that is used to tie to your chat source. So there could be an adapter for XMPP, Campfire, Slack, etc. For now its simply, send() [Send a message], receive() [receive a message] and run() [Run the adapter]. Set the property hubot.adapter in application.conf using the full className.</p> 
  <h3><a id="user-content-middleware" class="anchor" href="https://github.com/denen99/hubot-scala#middleware" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Middleware</h3> 
  <p>Middleware, are simply an intermediary you can write that every message goes through. Each piece of middleware should return either a Left(MiddlewareFailure) if the message should be blocked or a Right(MiddlewareSuccess) if the message should be passed through. On the first Left() the chain is halted. Useful for things like rate limiting, blocking certain users, etc. You get full access to the brain, etc for persistent data if needed.</p> 
  <h3><a id="user-content-listeners" class="anchor" href="https://github.com/denen99/hubot-scala#listeners" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Listeners</h3> 
  <p>Listeners, can be one of two types Respond or Hear. Hear, listens to every message in the chat, while Respond reacts when the bot is addressed by its name (configurable in appplication.conf). A Listener is a simple class you write that defines a callback method (which returns a PartialFunction[Message,Unit]) that you need to implement. Each message is passed through this callback and the callback method can match against anything available (sender, message body, etc). Additionally, any groupings you used in your regex are passed back as a groups Seq[String] so you can obtain access to those references.</p> 
  <h3><a id="user-content-brain" class="anchor" href="https://github.com/denen99/hubot-scala#brain" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Brain</h3> 
  <p>Brain, is a configurable backend that allows you to have persistence. Currently, hubot-scala ships with MapDB as a default brain backend, but you are free to write your own. Simply extend BrainBackendBase and implement 3 methods, getKey, setKey and shutdown().</p> 
  <p>Also note, that for serialization purposes, mostly to allow the storing of complex types as values (like List() and Map()), Scodec is used as the serialization. The gets are also wrapped in a Try{} since a NullPointer is returned when trying to deserialize to an invalid type. This means the syntax for getting a value from the brain would be something like:</p> 
  <div class="highlight highlight-source-scala">
   <pre>brain.get[<span class="pl-en">A</span>](someKey).getOrElse(defaultValue)</pre>
  </div> 
  <p>where A is the type you are deserializing to (String, List[Int]), someKey is the key to your hash and defaultValue is the value to return if the key is not found. Additionally to store a value, the format would be</p> 
  <div class="highlight highlight-source-scala">
   <pre>brain.set[<span class="pl-en">A</span>](someKey, someValue)</pre>
  </div> 
  <p>Again, someValue needs to be of type A, and someKey is a String.</p> 
  <h3><a id="user-content-getting-started" class="anchor" href="https://github.com/denen99/hubot-scala#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting started</h3> 
  <p>To get started, first, you need to put the hubot-scala library in your build.sbt as follows</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.dberg<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>hubot-scala_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>${latest}<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Once you do that, in your new project create whatever classes you need. For example, here is a simple listener, that responds to hello when the Bot is addressed</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">TestListener</span>(<span class="pl-v">hubot</span>: <span class="pl-en">HubotBase</span>) <span class="pl-k">extends</span> <span class="pl-e">Listener</span>(hubot, <span class="pl-en">ListenerType</span>.<span class="pl-en">Respond</span>) {
  <span class="pl-k">val</span> <span class="pl-en">callback</span><span class="pl-k">:</span> <span class="pl-en">Callback</span> <span class="pl-k">=</span> {
  <span class="pl-k">case</span> r<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-ii">\s</span>+world<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span>
    <span class="pl-en">Logger</span>.log(<span class="pl-s"><span class="pl-pds">"</span>Running callback for listner TestListener<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>debug<span class="pl-pds">"</span></span>)
    robot.send(<span class="pl-en">Message</span>(message.user,<span class="pl-s"><span class="pl-pds">"</span>Hubot says hello!<span class="pl-pds">"</span><span class="pl-pds">"</span>, message.messageType))</span>
<span class="pl-s">  }</span>
<span class="pl-s">  val helpString = Some(<span class="pl-pds">"</span></span>hello world <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">Allows</span> hubot to say hello <span class="pl-k">!</span><span class="pl-s"><span class="pl-pds">"</span>)</span>
<span class="pl-s">}</span></pre>
  </div> 
  <p>The structure of the Message class is Message(user: User, body: String, messageType: MessageTypeValue, params: Map[String,String]). The params allows the adapter a place to stick additional information that then gets passed through to the listener and middleware.</p> 
  <p>To create a middleware is similar to the listener. Create a new class that extends Middleware and do whatever you want with the message. Then simply define a method named "execute(message: Message)" and you are good to go. You can keep state, call an external service, etc. Here is an example of middleware that checks if the message matches the word "blacklist".</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">TestMiddleware</span>(<span class="pl-v">hubot</span>: <span class="pl-en">HubotBase</span>) <span class="pl-k">extends</span> <span class="pl-e">Middleware</span>(hubot) {

 <span class="pl-k">def</span> <span class="pl-en">execute</span>(<span class="pl-v">message</span>: <span class="pl-en">Message</span>) <span class="pl-k">=</span> {
  <span class="pl-k">if</span> (message.body <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>blacklist<span class="pl-pds">"</span></span>) {
   <span class="pl-en">Left</span>(<span class="pl-en">MiddlewareError</span>(<span class="pl-s"><span class="pl-pds">"</span>Sorry this is a blacklist<span class="pl-pds">"</span></span>))
  }
  <span class="pl-k">else</span> {
   <span class="pl-en">Right</span>(<span class="pl-en">MiddlewareSuccess</span>())
  }
 }
 
}</pre>
  </div> 
  <h3><a id="user-content-configuration" class="anchor" href="https://github.com/denen99/hubot-scala#configuration" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuration</h3> 
  <p>2 configuration files should be used and placed in src/main/resources. The first is application.conf (check the sample in this repo). The format is like so</p> 
  <pre><code>hubot {
  name = "yourbotname"

  listeners = ["org.yourdomain.listeners.YourFirstListener",   "org.yourdomain.listeners.YourOtherListener"]

  middleware = []

  adapter = "org.dberg.hubot.adapter.ShellAdapter"
</code></pre> 
  <p>}</p> 
  <p>The second is the logback.xml file. Tweak this file depending on how you want your logging to work.</p> 
  <pre><code>&lt;configuration debug="true"&gt;

&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;
  &lt;file&gt;logs/hubot.log&lt;/file&gt;

  &lt;encoder&gt;
    &lt;pattern&gt;%date %level [%file:%line] %msg%n&lt;/pattern&gt;
  &lt;/encoder&gt;
&lt;/appender&gt;

&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
 &lt;encoder&gt;
  &lt;pattern&gt;%date %level [%file:%line] %msg%n&lt;/pattern&gt;
 &lt;/encoder&gt;
&lt;/appender&gt;

 &lt;root level="DEBUG"&gt;
  &lt;appender-ref ref="FILE" /&gt;
  &lt;appender-ref ref="STDOUT" /&gt;
 &lt;/root&gt;
&lt;/configuration&gt;
</code></pre> 
  <h3><a id="user-content-running-the-bot" class="anchor" href="https://github.com/denen99/hubot-scala#running-the-bot" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the Bot</h3> 
  <p>Once you have everything configured you simply need to start the bot. Create a simple Main class as so</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.dberg.hubot.</span><span class="pl-v">HubotRunner</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> {
  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
    <span class="pl-en">HubotRunner</span>.start
  }
}</pre>
  </div> 
 </article>
</div>