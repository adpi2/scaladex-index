<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/stripe/dagon" target="_blank"><img src="https://camo.githubusercontent.com/225e4283790058086409c4a518b3b0944f8366c5/68747470733a2f2f6170692e7472617669732d63692e6f72672f7374726970652f6461676f6e2e737667" alt="Build Status" data-canonical-src="https://api.travis-ci.org/stripe/dagon.svg" style="max-width:100%;"></a> <a href="http://codecov.io/github/stripe/dagon?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/fa29b2b41cf8cc03735682ea2006a9beee6031c2/687474703a2f2f636f6465636f762e696f2f6769746875622f7374726970652f6461676f6e2f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="http://codecov.io/github/stripe/dagon/coverage.svg?branch=master" style="max-width:100%;"></a> <a href="https://index.scala-lang.org/stripe/dagon/dagon-core" target="_blank"><img src="https://camo.githubusercontent.com/575a4aad88ca5bcb12a3bab274146bc22bd0f831/68747470733a2f2f696e6465782e7363616c612d6c616e672e6f72672f7374726970652f6461676f6e2f6461676f6e2d636f72652f6c61746573742e7376673f636f6c6f723d6f72616e6765" alt="Latest version" data-canonical-src="https://index.scala-lang.org/stripe/dagon/dagon-core/latest.svg?color=orange" style="max-width:100%;"></a></p> 
  <h2><a href="https://github.com/stripe/dagon#dagon" aria-hidden="true" class="anchor" id="user-content-dagon" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dagon</h2> 
  <blockquote> 
   <p>Dagon [...] is an ancient Mesopotamian Assyro-Babylonian and Levantine (Canaanite) deity. He appears to have been worshipped as a fertility god in Ebla, Assyria, Ugarit and among the Amorites. The Hebrew Bible mentions him as the national god of the Philistines with temples at Ashdod and elsewhere in Gaza.</p> 
   <p>-- <a href="https://en.wikipedia.org/wiki/Dagon" target="_blank">Dagon Wikipedia entry</a></p> 
  </blockquote> 
  <h3><a href="https://github.com/stripe/dagon#overview" aria-hidden="true" class="anchor" id="user-content-overview" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h3> 
  <p>Dagon is a library for rewriting <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank">directed acyclic graphs</a> (i.e. DAGs).</p> 
  <h3><a href="https://github.com/stripe/dagon#quick-start" aria-hidden="true" class="anchor" id="user-content-quick-start" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick Start</h3> 
  <p>Dagon supports Scala 2.10, 2.11, and 2.12. It supports both the JVM and JS platforms.</p> 
  <p>To use Dagon in your own project, you can include this snippet in your <code>build.sbt</code> file:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> use this snippet for the JVM</span>
libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">List</span>(
  <span class="pl-s"><span class="pl-pds">"</span>com.stripe<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>dagon-core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.0<span class="pl-pds">"</span></span>,
  compilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>kind-projector<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.9.4<span class="pl-pds">"</span></span>))

<span class="pl-c"><span class="pl-c">//</span> use this snippet for JS, or cross-building</span>
libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">List</span>(
  <span class="pl-s"><span class="pl-pds">"</span>com.stripe<span class="pl-pds">"</span></span> <span class="pl-k">%%%</span> <span class="pl-s"><span class="pl-pds">"</span>dagon-core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.0<span class="pl-pds">"</span></span>,
  compilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>kind-projector<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.9.4<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>We strongly encourage you to use <em>kind-projector</em> with Dagon. Otherwise, working with types like <code>FunctionK</code> will be signficantly more painful.</p> 
  <h3><a href="https://github.com/stripe/dagon#example" aria-hidden="true" class="anchor" id="user-content-example" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example</h3> 
  <p>To use Dagon you will need the following things:</p> 
  <ul> 
   <li>a DAG or AST type (e.g. <code>Eqn[T]</code> below).</li> 
   <li>a transformation from your DAG to Dagon's literal types (e.g. <code>toLiteral</code>)</li> 
   <li>some rewrite rules (e.g. <code>SimplifyNegation</code> and <code>SimplifyAddition</code>)</li> 
  </ul> 
  <p>Dagon allows you to write very terse, natural rules that use partial functions (similar to patttern-matching) to identify and transform some AST "shapes" while leaving others alone. These patterns will all be recursively applied until none of them match any part of the AST.</p> 
  <p>One consequence of this is that your rules should shrink the AST, or at least simplify it in some sense. If your rules do not converge on a final AST it's possible that the rewriter will not terminate (and will loop forever on an ever-changing AST).</p> 
  <p>Here's a complete, working example of using Dagon:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Example</span> {

  <span class="pl-k">import</span> <span class="pl-v">com.stripe.dagon.</span><span class="pl-v">_</span>
  
  <span class="pl-c"><span class="pl-c">//</span> 1. set up an AST type</span>

  <span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] {
    <span class="pl-k">def</span> <span class="pl-en">unary_-</span>()<span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Negate</span>(<span class="pl-c1">this</span>)
    <span class="pl-k">def</span> <span class="pl-en">+</span>(<span class="pl-v">that</span>: <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>])<span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Add</span>(<span class="pl-c1">this</span>, that)
    <span class="pl-k">def</span> <span class="pl-en">-</span>(<span class="pl-v">that</span>: <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>])<span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Add</span>(<span class="pl-c1">this</span>, <span class="pl-en">Negate</span>(that))
  }

  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Const</span>[<span class="pl-en">T</span>](<span class="pl-v">value</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Eqn</span>[<span class="pl-en">T</span>]
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Var</span>[<span class="pl-en">T</span>](<span class="pl-v">name</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Eqn</span>[<span class="pl-en">T</span>]
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Negate</span>[<span class="pl-en">T</span>](<span class="pl-v">eqn</span>: <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>]) <span class="pl-k">extends</span> <span class="pl-e">Eqn</span>[<span class="pl-en">T</span>]
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Add</span>[<span class="pl-en">T</span>](<span class="pl-v">lhs</span>: <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>], <span class="pl-v">rhs</span>: <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>]) <span class="pl-k">extends</span> <span class="pl-e">Eqn</span>[<span class="pl-en">T</span>]
  
  <span class="pl-k">object</span> <span class="pl-en">Eqn</span> {
    <span class="pl-c"><span class="pl-c">//</span> these function constructors make the definition of</span>
    <span class="pl-c"><span class="pl-c">//</span> toLiteral a lot nicer.</span>
    <span class="pl-k">def</span> <span class="pl-en">negate</span>[<span class="pl-en">T</span>]<span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] <span class="pl-k">=&gt;</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Negate</span>(_)
    <span class="pl-k">def</span> <span class="pl-en">add</span>[<span class="pl-en">T</span>]<span class="pl-k">:</span> (<span class="pl-en">Eqn</span>[<span class="pl-en">T</span>], <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>]) <span class="pl-k">=&gt;</span> <span class="pl-en">Eqn</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Add</span>(_, _)
  }
  
  <span class="pl-c"><span class="pl-c">//</span> 2. set up a transfromation from AST to Literal</span>

  <span class="pl-k">val</span> <span class="pl-en">toLiteral</span><span class="pl-k">:</span> <span class="pl-en">FunctionK</span>[<span class="pl-en">Eqn</span>, <span class="pl-en">Literal</span>[<span class="pl-en">Eqn</span>, <span class="pl-k">?</span>]] <span class="pl-k">=</span>
    <span class="pl-en">Memoize</span>.functionK[<span class="pl-en">Eqn</span>, <span class="pl-en">Literal</span>[<span class="pl-en">Eqn</span>, <span class="pl-k">?</span>]](
      <span class="pl-k">new</span> <span class="pl-en">Memoize.RecursiveK</span>[<span class="pl-en">Eqn</span>, <span class="pl-en">Literal</span>[<span class="pl-en">Eqn</span>, <span class="pl-k">?</span>]] {
        <span class="pl-k">def</span> <span class="pl-en">toFunction</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> {
          <span class="pl-k">case</span> (c <span class="pl-k">@</span> <span class="pl-en">Const</span>(_), f) <span class="pl-k">=&gt;</span> <span class="pl-en">Literal</span>.<span class="pl-en">Const</span>(c)
          <span class="pl-k">case</span> (v <span class="pl-k">@</span> <span class="pl-en">Var</span>(_), f) <span class="pl-k">=&gt;</span> <span class="pl-en">Literal</span>.<span class="pl-en">Const</span>(v)
          <span class="pl-k">case</span> (<span class="pl-en">Negate</span>(x), f) <span class="pl-k">=&gt;</span> <span class="pl-en">Literal</span>.<span class="pl-en">Unary</span>(f(x), <span class="pl-en">Eqn</span>.negate)
          <span class="pl-k">case</span> (<span class="pl-en">Add</span>(x, y), f) <span class="pl-k">=&gt;</span> <span class="pl-en">Literal</span>.<span class="pl-en">Binary</span>(f(x), f(y), <span class="pl-en">Eqn</span>.add)
        }
      })
      
  <span class="pl-c"><span class="pl-c">//</span> 3. set up rewrite rules</span>

  <span class="pl-k">object</span> <span class="pl-en">SimplifyNegation</span> <span class="pl-k">extends</span> <span class="pl-e">PartialRule</span>[<span class="pl-en">Eqn</span>] {
    <span class="pl-k">def</span> <span class="pl-en">applyWhere</span>[<span class="pl-en">T</span>](<span class="pl-v">on</span>: <span class="pl-en">Dag</span>[<span class="pl-en">Eqn</span>]) <span class="pl-k">=</span> {
      <span class="pl-k">case</span> <span class="pl-en">Negate</span>(<span class="pl-en">Negate</span>(e)) <span class="pl-k">=&gt;</span> e
      <span class="pl-k">case</span> <span class="pl-en">Negate</span>(<span class="pl-en">Const</span>(x)) <span class="pl-k">=&gt;</span> <span class="pl-en">Const</span>(<span class="pl-k">-</span>x)
    }
  }

  <span class="pl-k">object</span> <span class="pl-en">SimplifyAddition</span> <span class="pl-k">extends</span> <span class="pl-e">PartialRule</span>[<span class="pl-en">Eqn</span>] {
    <span class="pl-k">def</span> <span class="pl-en">applyWhere</span>[<span class="pl-en">T</span>](<span class="pl-v">on</span>: <span class="pl-en">Dag</span>[<span class="pl-en">Eqn</span>]) <span class="pl-k">=</span> {
      <span class="pl-k">case</span> <span class="pl-en">Add</span>(<span class="pl-en">Const</span>(x), <span class="pl-en">Const</span>(y)) <span class="pl-k">=&gt;</span> <span class="pl-en">Const</span>(x <span class="pl-k">+</span> y)
      <span class="pl-k">case</span> <span class="pl-en">Add</span>(<span class="pl-en">Add</span>(e, <span class="pl-en">Const</span>(x)), <span class="pl-en">Const</span>(y)) <span class="pl-k">=&gt;</span> <span class="pl-en">Add</span>(e, <span class="pl-en">Const</span>(x <span class="pl-k">+</span> y))
      <span class="pl-k">case</span> <span class="pl-en">Add</span>(<span class="pl-en">Add</span>(<span class="pl-en">Const</span>(x), e), <span class="pl-en">Const</span>(y)) <span class="pl-k">=&gt;</span> <span class="pl-en">Add</span>(e, <span class="pl-en">Const</span>(x <span class="pl-k">+</span> y))
      <span class="pl-k">case</span> <span class="pl-en">Add</span>(<span class="pl-en">Const</span>(x), <span class="pl-en">Add</span>(<span class="pl-en">Const</span>(y), e)) <span class="pl-k">=&gt;</span> <span class="pl-en">Add</span>(<span class="pl-en">Const</span>(x <span class="pl-k">+</span> y), e)
      <span class="pl-k">case</span> <span class="pl-en">Add</span>(<span class="pl-en">Const</span>(x), <span class="pl-en">Add</span>(e, <span class="pl-en">Const</span>(y))) <span class="pl-k">=&gt;</span> <span class="pl-en">Add</span>(<span class="pl-en">Const</span>(x <span class="pl-k">+</span> y), e)
    }
  }
  
  <span class="pl-k">val</span> <span class="pl-en">rules</span> <span class="pl-k">=</span> <span class="pl-en">SimplifyNegation</span>.orElse(<span class="pl-en">SimplifyAddition</span>)

  <span class="pl-c"><span class="pl-c">//</span> 4. apply rewrite rules to a particular AST value</span>

  <span class="pl-k">val</span> <span class="pl-en">a</span><span class="pl-k">:</span>  <span class="pl-en">Eqn</span>[<span class="pl-k">Unit</span>] <span class="pl-k">=</span> <span class="pl-en">Var</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>) <span class="pl-k">+</span> <span class="pl-en">Const</span>(<span class="pl-c1">1</span>)
  <span class="pl-k">val</span> <span class="pl-en">b1</span><span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-k">Unit</span>] <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-en">Const</span>(<span class="pl-c1">2</span>)
  <span class="pl-k">val</span> <span class="pl-en">b2</span><span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-k">Unit</span>] <span class="pl-k">=</span> a <span class="pl-k">+</span> <span class="pl-en">Const</span>(<span class="pl-c1">5</span>) <span class="pl-k">+</span> <span class="pl-en">Var</span>(<span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">c</span><span class="pl-k">:</span>  <span class="pl-en">Eqn</span>[<span class="pl-k">Unit</span>] <span class="pl-k">=</span> b1 <span class="pl-k">-</span> b2

  <span class="pl-k">val</span> <span class="pl-en">simplified</span><span class="pl-k">:</span> <span class="pl-en">Eqn</span>[<span class="pl-k">Unit</span>] <span class="pl-k">=</span>
    <span class="pl-en">Dag</span>.applyRule(c, toLiteral, rules)
}</pre>
  </div> 
  <p>Dagon assumes your AST is paramterized on a <code>T</code> type. If yours is not, you can create a new type of the correct shape using a phantom type:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Ast</span>
...

<span class="pl-k">object</span> <span class="pl-en">Ast</span> {
  <span class="pl-c"><span class="pl-c">//</span> T is a "phantom type" -- it's not actually used in the type alias.</span>
  <span class="pl-k">type</span> <span class="pl-en">Phantom</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Ast</span>
}

<span class="pl-k">val</span> <span class="pl-en">toLiteral</span><span class="pl-k">:</span> <span class="pl-en">FunctionK</span>[<span class="pl-en">Ast</span>.<span class="pl-en">Phantom</span>, <span class="pl-en">Literal</span>[<span class="pl-en">Ast</span>.<span class="pl-en">Phantom</span>, <span class="pl-k">?</span>]] <span class="pl-k">=</span> ...</pre>
  </div> 
  <h3><a href="https://github.com/stripe/dagon#implementing-toliteral" aria-hidden="true" class="anchor" id="user-content-implementing-toliteral" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementing toLiteral</h3> 
  <p>The function <code>toLiteral</code> has the type <code>FunctionK[N, Literal[N, ?]]</code>. This means that it can produce a <code>N[T] =&gt; Literal[N, T]</code>. The type <code>N[_]</code> is your AST type; in the example it was <code>Eqn[_]</code>.</p> 
  <p>Dagon's <code>Literal</code> is sealed and has three subtypes:</p> 
  <ul> 
   <li><code>Literal.Const(leaf)</code>: a <code>leaf</code> node of your AST</li> 
   <li><code>Literal.Unary(node, f)</code>: a child <code>node</code> and a unary function <code>f</code></li> 
   <li><code>Literal.Binary(lhs, rhs, g)</code>: two nodes (<code>lhs</code>, <code>rhs</code>) and a binary function <code>g</code></li> 
  </ul> 
  <p>The functions <code>f</code> and <code>g</code> are mapping from inputs of type <code>N[T1]</code> to outputs of type <code>N[T2]</code> (where <code>N[_]</code> is your AST type). In the example above <code>T1</code> and <code>T2</code> are both <code>Unit</code>.</p> 
  <p>It's important that your <code>toLiteral</code> function is invertible. That means that the following should be true:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">node</span><span class="pl-k">:</span> <span class="pl-en">Ast</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> ...
toLiteral[<span class="pl-en">T</span>](node).evaluate <span class="pl-k">==</span> node</pre>
  </div> 
  <h3><a href="https://github.com/stripe/dagon#future-work" aria-hidden="true" class="anchor" id="user-content-future-work" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Future Work</h3> 
  <p>Here are some directions possible future work could take:</p> 
  <ul> 
   <li> <p>Producing laws to generate and test your AST values against these rewrites. Many of the tests we use internally could be generalized and exported for third-party use.</p> </li> 
   <li> <p>Cost-based optimization: right now rules are applied until they don't match, which means that rules need to be conservative, and should not expand the size of the graph. Some rules could locally increase graph size but result in smaller graphs overall. One example of this would be <em>arithmetic distribution</em>, e.g. rewriting <code>x * (y + z)</code> into <code>x * z + y * z</code>.</p> </li> 
   <li> <p>Benchmarking and performance optimization. While this code performs adequately for most real-world use cases it's likely quadratic or super-quadratic in the worst-case. We could likely optimize some of the algorithms we are using as well as the actual code involved.</p> </li> 
  </ul> 
  <h3><a href="https://github.com/stripe/dagon#copyright-and-license" aria-hidden="true" class="anchor" id="user-content-copyright-and-license" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Copyright and License</h3> 
  <p>Dagon is available to you under the <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License, version 2</a>.</p> 
  <p>Copyright 2017 Stripe.</p> 
  <p>Derived from <a href="https://github.com/twitter/summingbird" target="_blank">Summingbird</a>, which is copyright 2013-2017 Twitter.</p> 
 </article>
</div>