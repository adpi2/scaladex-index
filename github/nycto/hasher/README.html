<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-hasher-" class="anchor" href="https://github.com/nycto/hasher#hasher-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Hasher <a href="http://travis-ci.org/Nycto/Hasher" target="_blank"><img src="https://camo.githubusercontent.com/139735ad89c5501444707a5fe1c372fa29bfe200/68747470733a2f2f7365637572652e7472617669732d63692e6f72672f4e7963746f2f4861736865722e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://secure.travis-ci.org/Nycto/Hasher.png?branch=master" style="max-width:100%;"></a></h1> 
  <p>Hasher is a small Scala library to make generating hashes a breeze.</p> 
  <h2><a id="user-content-supported-hashing-algorithms" class="anchor" href="https://github.com/nycto/hasher#supported-hashing-algorithms" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Supported Hashing Algorithms</h2> 
  <ul> 
   <li><code>MD5</code></li> 
   <li><code>SHA1</code></li> 
   <li><code>SHA256</code></li> 
   <li><code>SHA384</code></li> 
   <li><code>SHA512</code></li> 
   <li><code>HMAC-MD5</code></li> 
   <li><code>HMAC-SHA1</code></li> 
   <li><code>HMAC-SHA256</code></li> 
   <li><code>HMAC-SHA512</code></li> 
   <li><code>BCrypt</code></li> 
   <li><code>CRC32</code></li> 
   <li><code>PBKDF2</code></li> 
  </ul> 
  <h2><a id="user-content-adding-it-to-your-project" class="anchor" href="https://github.com/nycto/hasher#adding-it-to-your-project" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Adding it to your Project</h2> 
  <p>To import Hasher into your project, you just need to add the following directives to your <code>build.sbt</code> file:</p> 
  <pre><code>libraryDependencies ++= Seq("com.roundeights" %% "hasher" % "1.2.0")
</code></pre> 
  <h2><a id="user-content-basic-usage" class="anchor" href="https://github.com/nycto/hasher#basic-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Basic Usage</h2> 
  <p>Once you have added the Hasher package as a dependency, the easiest way to use it is by importing the implicit conversion methods. Once you have them in scope, you get a bunch of new methods attached to existing types. For each supported algorithm, you get:</p> 
  <ul> 
   <li>Methods to generate a hash</li> 
   <li>A method to compare a plain text value to an existing hash</li> 
  </ul> 
  <p>Here is a sample app showing how to use these various methods:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">org.example.hasher</span>

<span class="pl-k">import</span> <span class="pl-v">com.roundeights.hasher.Implicits.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.language.</span><span class="pl-v">postfixOps</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {

    <span class="pl-k">val</span> <span class="pl-en">hashMe</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>

    <span class="pl-c"><span class="pl-c">//</span> Generate a few hashes</span>
    <span class="pl-k">val</span> <span class="pl-en">md5</span> <span class="pl-k">=</span> hashMe.md5
    <span class="pl-k">val</span> <span class="pl-en">sha1</span> <span class="pl-k">=</span> hashMe.sha1
    <span class="pl-k">val</span> <span class="pl-en">bcrypt</span> <span class="pl-k">=</span> hashMe.bcrypt

    <span class="pl-c"><span class="pl-c">//</span> Print each hex encoded hash</span>
    println( <span class="pl-s"><span class="pl-pds">"</span>MD5: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> md5.hex )
    println( <span class="pl-s"><span class="pl-pds">"</span>SHA1: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> sha1.hex )
    println( <span class="pl-s"><span class="pl-pds">"</span>BCrypt: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> bcrypt.hex )

    <span class="pl-c"><span class="pl-c">//</span> Compare the original value to each hashed value</span>
    <span class="pl-c"><span class="pl-c">//</span> and print the boolean result</span>
    println(<span class="pl-s"><span class="pl-pds">"</span>MD5 Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (hashMe.md5 hash<span class="pl-k">=</span> md5) )
    println(<span class="pl-s"><span class="pl-pds">"</span>SHA1 Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (hashMe.sha1 hash<span class="pl-k">=</span> sha1) )
    println(<span class="pl-s"><span class="pl-pds">"</span>BCrypt Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (hashMe.bcrypt hash<span class="pl-k">=</span> bcrypt) )
}</pre>
  </div> 
  <p>The implicit methods currently work on the following types:</p> 
  <ul> 
   <li><code>String</code></li> 
   <li><code>StringBuilder</code></li> 
   <li><code>Array[Byte]</code></li> 
   <li><code>InputStream</code></li> 
   <li><code>Reader</code></li> 
   <li><code>Source</code></li> 
  </ul> 
  <h2><a id="user-content-a-note-about-resources" class="anchor" href="https://github.com/nycto/hasher#a-note-about-resources" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>A Note About Resources</h2> 
  <p>Some of the data types you can use to generate hashes are consumable. In other words, once these resources are read, they are spent. Specifically, this applies if you are hashing an <code>InputStream</code>, a <code>Reader</code>, or a <code>Source</code>.</p> 
  <p>There are two implications to this:</p> 
  <ol> 
   <li>Make sure you don't read from the resource before generating the hash. Your resource will not be automatically reset before it is read, so the resulting digest will be based on the initial offset. That's probably not what you wanted as it means the hash will only reflect part of the data.</li> 
   <li>Your resource will be consumed after generating the hash. Unfortunately, there is no way out of this. The hash is based on the content of the resource, so the resource has to be read to generate the hash.</li> 
  </ol> 
  <p>You do have options, though:</p> 
  <ol> 
   <li>Depending on the type of resource, you may be able to reset it after generating your hash.</li> 
   <li>Use a <code>Tap</code> instead of directly building the hash. This allows the digest to be constructed passively as some other piece of code reads the resource. Details and examples are available further down in this document.</li> 
  </ol> 
  <h2><a id="user-content-salting" class="anchor" href="https://github.com/nycto/hasher#salting" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Salting</h2> 
  <p>If you would like to add a salt to a hash, Hasher provides a <code>salt</code> method. Using this method will be a tiny bit faster than doing the concatenation on your own because the salt is injected directly into the hash digest rather than being prepended to the plain text value.</p> 
  <p>Here is an example app that does salting:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">org.example.hasher</span>

<span class="pl-k">import</span> <span class="pl-v">com.roundeights.hasher.Implicits.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {
    <span class="pl-k">val</span> <span class="pl-en">hashMe</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>
    println( <span class="pl-s"><span class="pl-pds">"</span>Salted MD5: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> hashMe.salt(<span class="pl-s"><span class="pl-pds">"</span>sweet<span class="pl-pds">"</span></span>).md5.hex )
}</pre>
  </div> 
  <h2><a id="user-content-getting-the-bytes-of-a-hash" class="anchor" href="https://github.com/nycto/hasher#getting-the-bytes-of-a-hash" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting the bytes of a hash</h2> 
  <p>If you need direct access to the bytes of a generated Hash instead of a hex encoded string, you can implicitly convert them to an Array of Bytes, like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">org.example.hasher</span>

<span class="pl-k">import</span> <span class="pl-v">com.roundeights.hasher.Implicits.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {
    <span class="pl-k">val</span> <span class="pl-en">hashMe</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>
    <span class="pl-k">val</span> <span class="pl-en">hashBytes</span> <span class="pl-k">=</span> hashMe.md5.bytes
    println(<span class="pl-s"><span class="pl-pds">"</span>MD5 Hash Bytes: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> hashBytes.mkString(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-pds">"</span></span>))
}</pre>
  </div> 
  <h2><a id="user-content-non-implicit-usage" class="anchor" href="https://github.com/nycto/hasher#non-implicit-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Non-Implicit Usage</h2> 
  <p>If implicit methods give you a sour taste, you don't have to use them. All they do is generate a Hasher object, which is what actually has all the methods attached to it. You can just do that on your own, if you want. Here is the same application as above, but implemented without implicits:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">org.example.hasher</span>

<span class="pl-k">import</span> <span class="pl-v">com.roundeights.hasher.</span><span class="pl-v">Hasher</span>
<span class="pl-k">import</span> <span class="pl-v">scala.language.</span><span class="pl-v">postfixOps</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span>{

    <span class="pl-k">val</span> <span class="pl-en">hashMe</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>

    <span class="pl-c"><span class="pl-c">//</span> Generate a few hashes</span>
    <span class="pl-k">val</span> <span class="pl-en">md5</span> <span class="pl-k">=</span> <span class="pl-en">Hasher</span>(hashMe).md5
    <span class="pl-k">val</span> <span class="pl-en">sha1</span> <span class="pl-k">=</span> <span class="pl-en">Hasher</span>(hashMe).sha1
    <span class="pl-k">val</span> <span class="pl-en">bcrypt</span> <span class="pl-k">=</span> <span class="pl-en">Hasher</span>(hashMe).bcrypt

    <span class="pl-c"><span class="pl-c">//</span> Print each hex encoded hash</span>
    println( <span class="pl-s"><span class="pl-pds">"</span>MD5: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> md5.hex )
    println( <span class="pl-s"><span class="pl-pds">"</span>SHA1: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> sha1.hex )
    println( <span class="pl-s"><span class="pl-pds">"</span>BCrypt: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> bcrypt.hex )

    <span class="pl-c"><span class="pl-c">//</span> Compare the original value to each hashed value</span>
    <span class="pl-c"><span class="pl-c">//</span> and print the boolean result</span>
    println(<span class="pl-s"><span class="pl-pds">"</span>MD5 Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (<span class="pl-en">Hasher</span>(hashMe).md5 hash<span class="pl-k">=</span> md5) )
    println(<span class="pl-s"><span class="pl-pds">"</span>SHA1 Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (<span class="pl-en">Hasher</span>(hashMe).sha1 hash<span class="pl-k">=</span> sha1) )
    println(<span class="pl-s"><span class="pl-pds">"</span>BCrypt Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (<span class="pl-en">Hasher</span>(hashMe).bcrypt hash<span class="pl-k">=</span> bcrypt) )
}</pre>
  </div> 
  <h2><a id="user-content-why-use-the-hash-method" class="anchor" href="https://github.com/nycto/hasher#why-use-the-hash-method" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why use the <code>hash=</code> method?</h2> 
  <p>The <code>hash=</code> method compares a plain text value to a pre-computed hash. You should be using it instead of re-generating the hash and doing a string comparison for two reasons:</p> 
  <ol> 
   <li> <p>To prevent timing attacks. These methods don't short circuit when they find a character that doesn't match. This makes it harder for a malicious individual to progressively rebuild a hash by timing how long your app takes to reject a value.</p> </li> 
   <li> <p>Some hashes, like BCrypt, salt their input. This means that if you generate a hash for the same value twice, they won't be the same. There really is no other way for you to do the comparison on your own.</p> </li> 
  </ol> 
  <h2><a id="user-content-swapping-out-algorithms" class="anchor" href="https://github.com/nycto/hasher#swapping-out-algorithms" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Swapping out Algorithms</h2> 
  <p>You might want to build your application so that you can swap out your hashing algorithm. This can be achieved by using the Algo class:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">org.example.hasher</span>

<span class="pl-k">import</span> <span class="pl-v">com.roundeights.hasher.</span>{<span class="pl-v">Hasher</span>, <span class="pl-v">Algo</span>}
<span class="pl-k">import</span> <span class="pl-v">scala.language.</span><span class="pl-v">postfixOps</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {

    <span class="pl-k">val</span> <span class="pl-en">hashMe</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>

    <span class="pl-k">def</span> <span class="pl-en">hashUsing</span> ( <span class="pl-v">algo</span>: <span class="pl-en">Algo</span> ) <span class="pl-k">=</span> {
        <span class="pl-k">val</span> <span class="pl-en">hash</span> <span class="pl-k">=</span> algo( hashMe )
        println( <span class="pl-s"><span class="pl-pds">"</span>Hashed using <span class="pl-pds">"</span></span> <span class="pl-k">+</span> algo.name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> hash.hex )
        println( <span class="pl-s"><span class="pl-pds">"</span>Matches: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (algo(hashMe) hash<span class="pl-k">=</span> hash) )
    }

    hashUsing( <span class="pl-en">Algo</span>.md5 )
    hashUsing( <span class="pl-en">Algo</span>.sha1 )
    hashUsing( <span class="pl-en">Algo</span>.sha256 )
    hashUsing( <span class="pl-en">Algo</span>.sha384 )
    hashUsing( <span class="pl-en">Algo</span>.sha512 )
    hashUsing( <span class="pl-en">Algo</span>.hmac(<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span>).md5 )
    hashUsing( <span class="pl-en">Algo</span>.hmac(<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span>).sha1 )
    hashUsing( <span class="pl-en">Algo</span>.hmac(<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span>).sha256 )
    hashUsing( <span class="pl-en">Algo</span>.hmac(<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span>).sha512 )
    hashUsing( <span class="pl-en">Algo</span>.crc32 )
    hashUsing( <span class="pl-en">Algo</span>.pbkdf2(<span class="pl-s"><span class="pl-pds">"</span>secret<span class="pl-pds">"</span></span>, <span class="pl-c1">1000</span>, <span class="pl-c1">128</span>) )
    hashUsing( <span class="pl-en">Algo</span>.bcrypt )
}</pre>
  </div> 
  <h2><a id="user-content-accumulating-a-hash" class="anchor" href="https://github.com/nycto/hasher#accumulating-a-hash" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Accumulating a Hash</h2> 
  <p>There will be times when you will want to generate a hash based on the data stored in a traversable object. Instead of joining the content into a giant string and passing it in all at once, you might want to use a <code>Foldable</code> instead. It allows you to progressively generate a hash using a fold. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">hash</span>( <span class="pl-v">list</span>: <span class="pl-en">List</span>[<span class="pl-k">String</span>] )<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> {
    list.foldLeft( <span class="pl-en">Algo</span>.sha1.foldable ){ (accum, str) <span class="pl-k">=&gt;</span> accum(str) }.done.hex
}</pre>
  </div> 
  <p>Foldables enforce ordered digest creation by disabling each instance after you add data. But when you add data, a new instance is returned that can be used to add more data. When everything has been added, you just need to call <code>done</code> and you get a fully formed digest.</p> 
  <p>Presenting an API like this provides a few benefits:</p> 
  <ol> 
   <li>Your code will be more efficient as you don't need to allocate large chunks of memory to, for example, join a string together</li> 
   <li>It presents an externally immutable API</li> 
   <li>It helps prevent race conditions by ensuring continued forward motion</li> 
  </ol> 
  <p>One trick that might come in handy is asynchronously folding over a list of futures. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">hash</span>( <span class="pl-v">list</span>: <span class="pl-en">List</span>[<span class="pl-en">Future</span>[<span class="pl-k">String</span>]] )<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> {
    <span class="pl-en">Future</span>.fold(list)( <span class="pl-en">Algo</span>.sha1.foldable ) {
        (accum, str) <span class="pl-k">=&gt;</span> accum(str)
    }.maps(_.done.hex)
}</pre>
  </div> 
  <h2><a id="user-content-tapping-into-a-data-stream" class="anchor" href="https://github.com/nycto/hasher#tapping-into-a-data-stream" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Tapping into a data stream</h2> 
  <p>When you are dealing with a data stream of some sort (Maybe an <code>InputStream</code>, a <code>Reader</code>, or a <code>Source</code>), odds are good that you are trying to do something with it besides generating a hash. If that's the case, you can use a <code>Tap</code> to build a hash while you do other stuff.</p> 
  <p><code>Tap</code>s are just decorators. When you tap into an <code>InputStream</code>, you get a new <code>InputStream</code> that has the ability to return a hash. All you have to do is to consume the new <code>InputStream</code> as you normally would. Once all the data has been read, you can call the <code>hash</code> method.</p> 
  <p>Here are a few examples using different types of streams:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Tapping an InputStream</span>
<span class="pl-k">import</span> <span class="pl-v">java.io.</span><span class="pl-v">ByteArrayInputStream</span>

<span class="pl-k">val</span> <span class="pl-en">stream</span> <span class="pl-k">=</span> <span class="pl-en">Algo</span>.sha1.tap(
    <span class="pl-k">new</span> <span class="pl-en">ByteArrayInputStream</span>( <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span>.getBytes )
)

<span class="pl-c"><span class="pl-c">//</span> Read everything out of the stream</span>
<span class="pl-k">while</span> ( stream.read() <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span> ) {}

<span class="pl-k">val</span> <span class="pl-en">hash</span> <span class="pl-k">=</span> stream.hash

println( <span class="pl-s"><span class="pl-pds">"</span>InputStream Hash: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> hash )
println( <span class="pl-s"><span class="pl-pds">"</span>InputStream Hash Compare: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (stream hash<span class="pl-k">=</span> hash) )</pre>
  </div> 
  <hr> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Tapping a Reader</span>
<span class="pl-k">import</span> <span class="pl-v">java.io.</span><span class="pl-v">StringReader</span>

<span class="pl-k">val</span> <span class="pl-en">reader</span> <span class="pl-k">=</span> <span class="pl-en">Algo</span>.sha1.tap( <span class="pl-k">new</span> <span class="pl-en">StringReader</span>( <span class="pl-s"><span class="pl-pds">"</span>Some String<span class="pl-pds">"</span></span> ) )

<span class="pl-c"><span class="pl-c">//</span> Read everything out of the reader</span>
<span class="pl-k">while</span> ( reader.read() <span class="pl-k">!=</span> <span class="pl-k">-</span><span class="pl-c1">1</span> ) {}

<span class="pl-k">val</span> <span class="pl-en">hash</span> <span class="pl-k">=</span> reader.hash

println( <span class="pl-s"><span class="pl-pds">"</span>Reader Hash: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> hash )
println( <span class="pl-s"><span class="pl-pds">"</span>Reader Hash Compare: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (reader hash<span class="pl-k">=</span> hash) )</pre>
  </div> 
  <hr> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Tapping a source</span>
<span class="pl-k">import</span> <span class="pl-v">scala.io.</span><span class="pl-v">Source</span>

<span class="pl-k">val</span> <span class="pl-en">source</span> <span class="pl-k">=</span> <span class="pl-en">Algo</span>.sha1.tap( <span class="pl-en">Source</span>.fromString( hashMe ) )

<span class="pl-c"><span class="pl-c">//</span> Read everything out of the source</span>
source.mkString

<span class="pl-k">val</span> <span class="pl-en">hash</span> <span class="pl-k">=</span> source.hash

println( <span class="pl-s"><span class="pl-pds">"</span>Source Hash: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> hash )
println( <span class="pl-s"><span class="pl-pds">"</span>Source Hash Compare: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> (source hash<span class="pl-k">=</span> hash) )</pre>
  </div> 
  <h2><a id="user-content-what-about-character-encoding" class="anchor" href="https://github.com/nycto/hasher#what-about-character-encoding" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>What about character encoding?</h2> 
  <p>Any time a string is passed into Hasher, it is internally converted to to a UTF-8 byte array. Any method that accepts a string will also accept a byte array. Thus, if UTF-8 isn't your style, you can manually convert your string to a byte array before passing it in.</p> 
  <p>For methods that can't accept a byte array, but are character encoding sensitive (for example, the <code>tap</code> methods), you can pass in a Codec instance.</p> 
  <h2><a id="user-content-bcrypt" class="anchor" href="https://github.com/nycto/hasher#bcrypt" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>BCrypt</h2> 
  <p>If you are interested in using BCrypt (Which is what you should be using for hashing passwords, by the way), you will need to add the jBCrypt package as a dependency of your project. If you are using SBT (v0.10), just add these lines to your <code>build.sbt</code> configuration:</p> 
  <pre><code>resolvers ++= Seq("jBCrypt Repository" at "http://repo1.maven.org/maven2/org/")

libraryDependencies ++= Seq("org.mindrot" % "jbcrypt" % "0.3m")
</code></pre> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/nycto/hasher#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>Hasher is released under the MIT License, which is pretty spiffy. You should have received a copy of the MIT License along with this program. If not, see <a href="http://www.opensource.org/licenses/mit-license.php" target="_blank">http://www.opensource.org/licenses/mit-license.php</a>.</p> 
 </article>
</div>