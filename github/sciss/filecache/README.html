<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-filecache" class="anchor" href="https://github.com/sciss/filecache#filecache" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>FileCache</h1> 
  <p><a href="https://travis-ci.org/Sciss/FileCache" target="_blank"><img src="https://camo.githubusercontent.com/3426c7162d1a52df406049e133266e5f6ca0d4e7/68747470733a2f2f7472617669732d63692e6f72672f53636973732f46696c6543616368652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/Sciss/FileCache.svg?branch=master" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/de.sciss/filecache-common_2.11" target="_blank"><img src="https://camo.githubusercontent.com/4a4b75caaa4e26f09ef64e6665c22869761742f4/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f64652e73636973732f66696c6563616368652d636f6d6d6f6e5f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/de.sciss/filecache-common_2.11/badge.svg" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-statement" class="anchor" href="https://github.com/sciss/filecache#statement" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>statement</h2> 
  <p>FileCache is a simple building block for the Scala programming language, managing a directory with cache files. It is (C)opyright 2013â€“2017 by Hanns Holger Rutz. All rights reserved. This project is released under the <a href="https://raw.github.com/Sciss/FileCache/master/LICENSE" target="_blank">GNU Lesser General Public License</a> v2.1+ and comes with absolutely no warranties. To contact the author, send an email to <code>contact at sciss.de</code></p> 
  <h2><a id="user-content-linking" class="anchor" href="https://github.com/sciss/filecache#linking" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>linking</h2> 
  <p>To link to this library, use either of the following artifacts:</p> 
  <pre><code>"de.sciss" %% "filecache-mutable" % v
"de.sciss" %% "filecache-txn"     % v
</code></pre> 
  <p>The current version <code>v</code> is <code>"0.3.4"</code>. The <code>-mutable</code> variant provides a (thread-safe) mutable cache object, whereas the <code>-txn</code> variant uses the <a href="https://github.com/nbronson/scala-stm" target="_blank">scala-stm</a> software transactional memory.</p> 
  <h2><a id="user-content-building" class="anchor" href="https://github.com/sciss/filecache#building" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>building</h2> 
  <p>This project currently builds against Scala 2.12, 2.11, 2.10, using sbt 0.13.</p> 
  <p>The project is documented through scaladoc run <code>sbt doc</code> to create the API docs.</p> 
  <h2><a id="user-content-documentation" class="anchor" href="https://github.com/sciss/filecache#documentation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>documentation</h2> 
  <p>Here is an example of the mutable package, the transactional package works analogously. A cache is represented by the <code>MutableProducer[Key, Value]</code> type. Therefore, a resource (the value) is identified by and can be looked up with a key. A producer is created by calling <code>apply</code> on the companion object, requiring implicit values for key and value serializers (<code>de.sciss.serial.ImmutableSerializer</code>). Serializers are readily available for primitive types and some combinators (e.g. <code>Tuple2</code> or <code>IndexedSeq</code>).</p> 
  <p>For example, let us assume the key type is <code>String</code>, and the value type is <code>IndexedSeq[Int]</code>. First of all, we need to create a configuration for the cache. A mutable <code>ConfigBuilder</code> is obtained by calling <code>Config[Key, Value]()</code>. It will be implicitly frozen as a <code>Config</code> object when the builder is passed into the producer constructor. We'll go with the defaults except changing the cache capacity to hold at maximum two entries (the default is unlimited), and we'll assign an eviction function that prints to the console when a cache entry is removed from disk.</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-k">import</span> <span class="pl-v">de.sciss.filecache.</span><span class="pl-v">_</span>

    <span class="pl-k">type</span> <span class="pl-en">Vec</span>[<span class="pl-k">+</span><span class="pl-en">A</span>] <span class="pl-k">=</span> collection.immutable.<span class="pl-en">IndexedSeq</span>[<span class="pl-en">A</span>]
    <span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> <span class="pl-en">Config</span>[<span class="pl-k">String</span>, <span class="pl-en">Vec</span>[<span class="pl-k">Int</span>]]()
    c.capacity <span class="pl-k">=</span> <span class="pl-en">Limit</span>(count <span class="pl-k">=</span> <span class="pl-c1">2</span>)
    c.evict <span class="pl-k">=</span> { (key, value) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>Evicted key $key<span class="pl-pds">"</span></span>) }
    <span class="pl-k">val</span> <span class="pl-en">p</span> <span class="pl-k">=</span> <span class="pl-en">MutableProducer</span>(c)</pre>
  </div> 
  <p>The producer is like an exclusive handle to resources. A resource can be obtained with method</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-k">def</span> <span class="pl-en">acquire</span>(<span class="pl-v">key</span>: <span class="pl-en">A</span>)(<span class="pl-v">source</span>: <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">B</span>]</pre>
  </div> 
  <p>Where the <code>source</code> thunk is executed only if the resource for <code>key</code> was not found in the cache. When the resource is not used any longer, it must be released using</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-k">def</span> <span class="pl-en">release</span>(<span class="pl-v">key</span>: <span class="pl-en">A</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span></pre>
  </div> 
  <p>If your application wants to be able to have multiple handles on a resource, a second structure <code>MutableConsumer</code> can be used which simply wraps a producer with an internal use count. Here the acquirement is a more simple method <code>def acquire(key: A): Future[B]</code> which may be called multiple times. Each acquirement should be matched with an eventual <code>release</code> call.</p> 
  <p>For our example, we will just use the exclusive producer. Cache production happens inside a <code>Future</code>, so if we want to see the result, we can use the future's <code>foreach</code> method. A suitable <code>ExecutionContext</code> can be found by importing <code>p.executionContext</code> (that context was defined in the original configuration).</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-k">import</span> <span class="pl-v">p.</span><span class="pl-v">executionContext</span>
    <span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">_</span>
    <span class="pl-k">import</span> <span class="pl-v">duration.</span><span class="pl-v">Duration</span>

    <span class="pl-k">val</span> <span class="pl-en">foo1</span> <span class="pl-k">=</span> p.acquire(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>) { println(<span class="pl-s"><span class="pl-pds">"</span>Producing...<span class="pl-pds">"</span></span>); <span class="pl-en">Vector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>) }
    <span class="pl-en">Await</span>.result(foo1, <span class="pl-en">Duration</span>.<span class="pl-en">Inf</span>)  <span class="pl-c"><span class="pl-c">//</span> Vector(1, 2, 3)</span></pre>
  </div> 
  <p>Let's release and re-acquire that resource. It should be cached:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    p.release(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">foo2</span> <span class="pl-k">=</span> p.acquire(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)(<span class="pl-k">???</span>)
    <span class="pl-en">Await</span>.result(foo2, <span class="pl-en">Duration</span>.<span class="pl-en">Inf</span>)  <span class="pl-c"><span class="pl-c">//</span> Vector(1, 2, 3)</span></pre>
  </div> 
  <p>If we release <code>"foo"</code> and produce new entries in the cache, we can witness the eviction:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    p.release(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">bar</span> <span class="pl-k">=</span> p.acquire(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>) { <span class="pl-en">Vector</span>(<span class="pl-c1">4</span>, <span class="pl-c1">5</span>, <span class="pl-c1">6</span>) }
    <span class="pl-k">val</span> <span class="pl-en">baz</span> <span class="pl-k">=</span> p.acquire(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>) { <span class="pl-en">Vector</span>(<span class="pl-c1">7</span>, <span class="pl-c1">8</span>, <span class="pl-c1">9</span>) }  <span class="pl-c"><span class="pl-c">//</span> causes eviction of "foo"</span></pre>
  </div> 
  <p>Note that an entry is never evicted while acquired.</p> 
  <p>Some more notes:</p> 
  <ul> 
   <li>the capacity <code>Limit</code> has two conditions, a <code>count</code> for the maximum number of entries and a <code>space</code> for the maximum total size in bytes. A value of <code>-1</code> for each of these (default) means no limit. Both limits work together, so if both <code>count</code> and <code>space</code> are specified, the capacity will be constrained to satisfy these two properties.</li> 
   <li>if using a <code>space</code> limit, the <code>space</code> <em>function</em> in the configuration must be provided. This function is given a key-value pair and must return the resource size in bytes. The reason this is not automatically equated with the size of the serialized value is that often a resource extends beyond the directly given value. For example, if the cache is used to produce waveform overviews for a sound file, the value might just point to the waveform file. But the size of the resource is then determined by the size of that waveform file, not the cache entry which is just the path name to that file.</li> 
   <li>a producer can be disposed calling the <code>dispose</code> method. This will release all currently acquired keys.</li> 
   <li>the cache directory is specified in the configuration using the <code>folder</code> variable. A second variable <code>extension</code> can be used to specify the file extension.</li> 
   <li>the current cache size is available through the <code>usage</code> method on a producer</li> 
   <li>cache values may become invalid for some reason. As an example, imagine again the sound file waveform cache. If the sound file whose waveform is produced has changed, then obviously the waveform overview must be re-computed. If that case may occur in your scenario, the function <code>accept</code> in the configuration should be specified. It is given a key-value pair and must return a boolean. A return value <code>true</code> indicates that the cache entry is still valid, a value of <code>false</code> will cause the re-run of the producer function and overwrite the cache entry with the new result. In the sound file example, we may store the last-modified time-stamp of the sound file in the cache value, so we can quickly determine whether the file has changed. In this scenario it is also important to use the configuration's <code>evict</code> function to delete the additional resources (the waveform file).</li> 
  </ul> 
 </article>
</div>