<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-neuroflow" class="anchor" href="https://github.com/zenecture/neuroflow#neuroflow" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>NeuroFlow</h1> 
  <p>NeuroFlow is a lightweight library to construct, sketch, train and evaluate Artificial Neural Networks (FFN, LSTM). It is written in Scala, matrix operations are performed with Breeze (+ NetLib). Type-safety, when needed, comes from Shapeless.</p> 
  <p><a href="https://raw.githubusercontent.com/zenecture/zenecture-docs/master/neuroflow/logo.png" target="_blank"><img src="https://raw.githubusercontent.com/zenecture/zenecture-docs/master/neuroflow/logo.png" width="471" height="126" style="max-width:100%;"></a></p> 
  <h1><a id="user-content-introduction" class="anchor" href="https://github.com/zenecture/neuroflow#introduction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Introduction</h1> 
  <p>This project consists of three modules:</p> 
  <ul> 
   <li>core: the building blocks to create neural network architectures</li> 
   <li>application: plugins, helpers, functionality related to various applications</li> 
   <li>playground: examples with resources</li> 
  </ul> 
  <h1><a id="user-content-getting-started" class="anchor" href="https://github.com/zenecture/neuroflow#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h1> 
  <p>To use Neuroflow within your project, add these dependencies (Scala Version 2.11.x):</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
  <span class="pl-s"><span class="pl-pds">"</span>com.zenecture<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>neuroflow-core_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.400<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>com.zenecture<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>neuroflow-application_2.11<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.400<span class="pl-pds">"</span></span>
)</pre>
  </div> 
  <p>Usually the Sonatype repository resolvers are provided by default. However, sometimes the explicit definition is needed:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
  <span class="pl-s"><span class="pl-pds">"</span>Sonatype Snapshots<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>https://oss.sonatype.org/content/repositories/snapshots/<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>Sonatype Releases<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>https://oss.sonatype.org/content/repositories/releases/<span class="pl-pds">"</span></span>
)</pre>
  </div> 
  <p>Seeing code examples is a good way to get started. You may have a look at the playground for some inspiration.</p> 
  <p>If you want to use neural nets in your project, you can expect a journey full of experiments.</p> 
  <p>Never forget, each challenge is unique.</p> 
  <h1><a id="user-content-construction-of-a-net" class="anchor" href="https://github.com/zenecture/neuroflow#construction-of-a-net" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Construction of a Net</h1> 
  <p><a href="https://raw.githubusercontent.com/zenecture/zenecture-docs/master/neuroflow/arch.png" target="_blank"><img src="https://raw.githubusercontent.com/zenecture/zenecture-docs/master/neuroflow/arch.png" width="443" height="320" style="max-width:100%;"></a></p> 
  <p>Let's construct the net depicted above. First, we have to pick the desired behavior:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">neuroflow.application.plugin.Style.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">neuroflow.core.Activator.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">neuroflow.core.FFN.WeightProvider.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">neuroflow.core.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">neuroflow.nets.DefaultNetwork.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">shapeless.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>This will give us a fully connected ANN, with random weights and standard gradient descent / backprop training.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">fn</span> <span class="pl-k">=</span> <span class="pl-en">Sigmoid</span>
<span class="pl-k">val</span> <span class="pl-en">net</span> <span class="pl-k">=</span> <span class="pl-en">Network</span>(<span class="pl-en">Input</span>(<span class="pl-c1">2</span>) <span class="pl-k">::</span> <span class="pl-en">Hidden</span>(<span class="pl-c1">3</span>, fn) <span class="pl-k">::</span> <span class="pl-en">Output</span>(<span class="pl-c1">1</span>, fn) <span class="pl-k">::</span> <span class="pl-en">HNil</span>)</pre>
  </div> 
  <p>The architecture of the net is defined here. We use a sigmoid activation function <code>fn</code> for our hidden and output layers. Also, some rates and rules need to be defined, like precision or maximum iterations through a <code>Settings</code> instance.</p> 
  <p>If we would need a more complex net, we would simply stack layers and functions:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> <span class="pl-en">Sigmoid</span>
<span class="pl-k">val</span> <span class="pl-en">g</span> <span class="pl-k">=</span> <span class="pl-en">Tanh</span>
<span class="pl-k">val</span> <span class="pl-en">settings</span> <span class="pl-k">=</span> <span class="pl-en">Settings</span>(verbose <span class="pl-k">=</span> <span class="pl-c1">true</span>, learningRate <span class="pl-k">=</span> <span class="pl-c1">0.01</span>, precision <span class="pl-k">=</span> <span class="pl-c1">0.001</span>, maxIterations <span class="pl-k">=</span> <span class="pl-c1">200</span>)
<span class="pl-k">val</span> <span class="pl-en">net</span> <span class="pl-k">=</span> <span class="pl-en">Network</span>(<span class="pl-en">Input</span>(<span class="pl-c1">50</span>) <span class="pl-k">::</span> <span class="pl-en">Hidden</span>(<span class="pl-c1">20</span>, f) <span class="pl-k">::</span> <span class="pl-en">Hidden</span>(<span class="pl-c1">10</span>, g) <span class="pl-k">::</span> <span class="pl-en">Output</span>(<span class="pl-c1">2</span>, f) <span class="pl-k">::</span> <span class="pl-en">HNil</span>, settings)</pre>
  </div> 
  <p>Be aware that a network must start with one <code>Input(i)</code> layer and end with one <code>Output(i, fn)</code> layer. If a network doesn't follow this rule, it won't compile.</p> 
  <h1><a id="user-content-training" class="anchor" href="https://github.com/zenecture/neuroflow#training" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Training</h1> 
  <p>Let's train our net with the <code>train</code> method. It expects the inputs <code>xs</code> and their desired outputs <code>ys</code>. By design, the type signature of <code>train</code> is <code>Seq[Seq[_]]</code>, because this promises the most general (Seq, List, Vector, ...) case in Scala.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">xs</span> <span class="pl-k">=</span> <span class="pl-k">--</span><span class="pl-k">&gt;</span>(<span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>), <span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">1.0</span>), <span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">0.0</span>), <span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">1.0</span>, <span class="pl-c1">1.0</span>))
<span class="pl-k">val</span> <span class="pl-en">ys</span> <span class="pl-k">=</span> <span class="pl-k">--</span><span class="pl-k">&gt;</span>(<span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">0.0</span>), <span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">1.0</span>), <span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">1.0</span>), <span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">0.0</span>))
net.train(xs, ys)</pre>
  </div> 
  <p>The learning progress will appear on console so we can track it. Bear in mind that a net may have mutable state inside and is not thread-safe.</p> 
  <h1><a id="user-content-evaluation" class="anchor" href="https://github.com/zenecture/neuroflow#evaluation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Evaluation</h1> 
  <p>Our trained net can be evaluated with the <code>evaluate</code> method.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> net.evaluate(<span class="pl-k">-</span><span class="pl-k">&gt;</span>(<span class="pl-c1">0.0</span>, <span class="pl-c1">0.0</span>))</pre>
  </div> 
  <p>This will give us a result vector (kind <code>Seq[_]</code>) with the dimension of our specified output layer.</p> 
  <h1><a id="user-content-io" class="anchor" href="https://github.com/zenecture/neuroflow#io" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>IO</h1> 
  <p>In the component <code>neuroflow.application.plugin.IO</code> we will find functionality to save and load nets, especially weights. Scala Pickling is used as the (de-)serialization framework. Example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">file</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>/path/to/net.nf<span class="pl-pds">"</span></span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">wp</span> <span class="pl-k">=</span> <span class="pl-en">File</span>.read(file)
<span class="pl-k">val</span> <span class="pl-en">net</span> <span class="pl-k">=</span> <span class="pl-en">Network</span>(layers)
<span class="pl-en">File</span>.write(net, file)</pre>
  </div> 
  <p>Here, <code>File.read</code> will yield an implicit <code>WeightProvider</code> from file to construct a net. A net is always constructed like this. Instead of initializing it with random weights, we just load them from file (or json). Afterwards it will be saved to the same file with <code>File.write</code>. If the desired target is a database, simply use <code>Json.write</code> instead and save it on string-level. However, all important types extend <code>Serializable</code>, so feel free to work with the bytes on your own.</p> 
 </article>
</div>