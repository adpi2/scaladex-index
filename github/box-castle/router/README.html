<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="http://opensource.box.com/badges" target="_blank"><img src="https://camo.githubusercontent.com/dabe9115005a5820390e20ae3bbae24e66778bcf/687474703a2f2f6f70656e736f757263652e626f782e636f6d2f6261646765732f6163746976652e737667" alt="Project Status" data-canonical-src="http://opensource.box.com/badges/active.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/Box-Castle/router" target="_blank"><img src="https://camo.githubusercontent.com/d53f4fffd132713a5c91ca4e6e56df124938dca1/68747470733a2f2f7472617669732d63692e6f72672f426f782d436173746c652f726f757465722e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/Box-Castle/router.svg?branch=master" style="max-width:100%;"></a></p> 
  <h2><a href="https://github.com/box-castle/router#overview" aria-hidden="true" class="anchor" id="user-content-overview" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h2> 
  <p>Castle Router is an efficient implementation of querying data from Kafka built on top of the Akka framework and the 0.8.1 SimpleConsumer interface and is intended for asynchronous use by Akka actors. Castle Router supports the following five operations:</p> 
  <ol> 
   <li>Committing consumer offset information</li> 
   <li>Fetching consumer offset information</li> 
   <li>Fetching offset information about a particular topic and partition</li> 
   <li>Fetching topic metadata which contains leader information (ISR currently not supported due to <a href="https://issues.apache.org/jira/browse/KAFKA-1367" target="_blank">KAFKA-1367</a>)</li> 
   <li>Fetching messages from a particular offset for a topic and partition</li> 
  </ol> 
  <p>Castle Router attempts to batch as many operations as possible into a single request to Kafka and maintains a local cache of fetched messages to minimize network use. It does not cache the result of any other operations except for fetch message. It properly handles the following scenarios:</p> 
  <ul> 
   <li>Broker failures</li> 
   <li>Leader changes</li> 
   <li>Out of range offset requests</li> 
   <li>Requests for unknown topics or partitions</li> 
   <li>Corrupt messages</li> 
   <li>Request timeouts</li> 
  </ul> 
  <h2><a href="https://github.com/box-castle/router#how-to-use-castle-router" aria-hidden="true" class="anchor" id="user-content-how-to-use-castle-router" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How To Use Castle Router</h2> 
  <p>The basic flow of using the Router by an Akka actor is:</p> 
  <ol> 
   <li>Create a request message that the Router (please see below for all the types of request messages) can understand</li> 
   <li>Send the request to the router</li> 
   <li>Handle the Router response which is sent to the originating actor as a message</li> 
  </ol> 
  <p>One big caveat here is that there is no guarantee that the Router will actually respond back with a message. There are three general approaches to handle this:</p> 
  <ol> 
   <li>Use the Akka ask pattern with expiration and handle some of the failure/timeout messages the Router can send back. There are some performance implications with doing this as well as a few other nuances around using Futures inside an actor which can be found in the Akka ask pattern documentation.</li> 
   <li>In addition to sending the request to the Router also schedule a "time out" message back to the actor. Then keep track of the outstanding request so it can be marked as no longer outstanding so that the "time out" message back to the actor can make a decision on whether it should retry sending the outstanding request. There are a bunch of tricky edge cases and other nuances that must be handled in this approach.</li> 
   <li>Mix in the RouterRequestManager trait, which does the second option for you in a standardized way by exposing two methods: <em>sendRequestToRouter()</em> and <em>checkResult()</em>. These two methods must be used in conjunction with each other to do the proper book keeping. This is illustrated in the example below. Another benefit of using RouterRequestManager is that you will automatically get all future enhancements, bug fixes, and handling of API evolution as most of the work is abstracted away.</li> 
  </ol> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">ExampleActor</span>(<span class="pl-k">val</span> <span class="pl-en">router</span><span class="pl-k">:</span> <span class="pl-en">RouterRef</span>) <span class="pl-k">extends</span> <span class="pl-e">actor</span> <span class="pl-k">with</span> <span class="pl-e">Logging</span> <span class="pl-k">with</span> <span class="pl-e">RouterRequestManager</span> {

  <span class="pl-k">val</span> <span class="pl-en">topicAndPartition</span> <span class="pl-k">=</span> <span class="pl-en">TopicAndPartition</span>(<span class="pl-s"><span class="pl-pds">"</span>MyTopic<span class="pl-pds">"</span></span>, <span class="pl-c1">3</span>)
  <span class="pl-k">val</span> <span class="pl-en">offset</span> <span class="pl-k">=</span> <span class="pl-c1">235283</span>

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">preStart</span>() <span class="pl-k">=</span> {
    <span class="pl-c"><span class="pl-c">//</span> sendRequestToRouter is provided to us by RouterRequestManager, </span>
    <span class="pl-c"><span class="pl-c">//</span> which will manage the lifecycle of the request for us</span>
    sendRequestToRouter(<span class="pl-en">FetchData</span>(topicAndPartition, offset))
  }

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">receive</span><span class="pl-k">:</span> <span class="pl-en">Receive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-v">result</span>: <span class="pl-en">FetchData</span>.<span class="pl-en">Result</span> <span class="pl-k">=&gt;</span> handleFetchDataResult(result)
  }

  <span class="pl-k">def</span> <span class="pl-en">handleFetchDataResult</span>(<span class="pl-v">result</span>: <span class="pl-en">FetchData</span>.<span class="pl-en">Result</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    <span class="pl-c"><span class="pl-c">//</span> checkResult is provided to us by RouterRequestManager, we need to call</span>
    <span class="pl-c"><span class="pl-c">//</span> it here to make sure it is able to manage the lifecycle of the request for us</span>
    checkResult(result) {
      <span class="pl-k">case</span> <span class="pl-v">success</span>: <span class="pl-en">FetchData</span>.<span class="pl-en">Success</span> <span class="pl-k">=&gt;</span>
        <span class="pl-c"><span class="pl-c">//</span> Handle success, do whatever you need to do with the actual messages</span>
        <span class="pl-c"><span class="pl-c">//</span> success.batch is guaranteed to have at least 1 message in it</span>
      <span class="pl-k">case</span> <span class="pl-v">noMessages</span>: <span class="pl-en">FetchData</span>.<span class="pl-en">NoMessages</span> <span class="pl-k">=&gt;</span>
        <span class="pl-c"><span class="pl-c">//</span> Handle no messages, perhaps backoff for some time here to </span>
        <span class="pl-c"><span class="pl-c">//</span> allow the topic to fill up with some messages</span>
      <span class="pl-k">case</span> <span class="pl-en">FetchData</span>.<span class="pl-en">UnknownTopicOrPartition</span>(failedTopicAndPartition, failedOffset) <span class="pl-k">=&gt;</span>
        <span class="pl-c"><span class="pl-c">//</span> Handle unknown topic and partition, this might be a fatal exception if </span>
        <span class="pl-c"><span class="pl-c">//</span> you really expect this topic to exist, or perhaps you can back off and try </span>
        <span class="pl-c"><span class="pl-c">//</span> getting again later if it might get created later</span>
      <span class="pl-k">case</span> <span class="pl-en">FetchData</span>.<span class="pl-en">OffsetOutOfRange</span>(_, offset) <span class="pl-k">=&gt;</span>
        <span class="pl-c"><span class="pl-c">//</span> Handle offset out of range, for example, query for the latest or earliest offset</span>
        <span class="pl-c"><span class="pl-c">//</span> and then issue the FetchData request again with the latest/earliest offset</span>
      <span class="pl-k">case</span> <span class="pl-en">FetchData</span>.<span class="pl-en">CorruptMessage</span>(_, offset, nextOffset) <span class="pl-k">=&gt;</span>
        <span class="pl-c"><span class="pl-c">//</span> Handle corrupt messages, for example, log the fact that this message is corrupt and skip it</span>
    }
  }
}

<span class="pl-c"><span class="pl-c">//</span> The clientId uniquely identifies our application</span>
<span class="pl-k">val</span> <span class="pl-en">clientId</span> <span class="pl-k">=</span> <span class="pl-en">ClientId</span>(<span class="pl-s"><span class="pl-pds">"</span>ClientIdUniqueToApplication<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">boxSimpleConsumerFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CastleSimpleConsumerFactory</span>(clientId)

<span class="pl-c"><span class="pl-c">//</span> The default logger is a no-op, you need to give your own implementation</span>
<span class="pl-c"><span class="pl-c">//</span> if you'd like to do something useful with the metrics that are being reported.</span>
<span class="pl-k">val</span> <span class="pl-en">kafkaDispatcherActorFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">KafkaDispatcherFactory</span>(boxSimpleConsumerFactory, <span class="pl-en">MetricsLogger</span>.defaultLogger)

<span class="pl-k">val</span> <span class="pl-en">cacheSize</span> <span class="pl-k">=</span> <span class="pl-c1">1024</span> <span class="pl-k">*</span> <span class="pl-c1">1024</span> <span class="pl-k">*</span> <span class="pl-c1">1024</span> <span class="pl-k">*</span> <span class="pl-c1">4</span> <span class="pl-c"><span class="pl-c">//</span> 4 GB</span>
<span class="pl-k">val</span> <span class="pl-en">consumerPoolFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">KafkaDispatcherProxyPoolFactory</span>(kafkaDispatcherActorFactory, cacheSize, <span class="pl-en">MetricsLogger</span>.defaultLogger)

<span class="pl-c"><span class="pl-c">//</span> The id for the brokers here does not matter</span>
<span class="pl-k">val</span> <span class="pl-en">brokers</span> <span class="pl-k">=</span> <span class="pl-en">Set</span>(<span class="pl-en">Broker</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>kafka-broker1000.prod.xyz.com<span class="pl-pds">"</span></span>, <span class="pl-c1">9092</span>),
                  <span class="pl-en">Broker</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>kafka-broker1001.prod.xyz.com<span class="pl-pds">"</span></span>, <span class="pl-c1">9092</span>),
                  <span class="pl-en">Broker</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>kafka-broker1002.prod.xyz.com<span class="pl-pds">"</span></span>, <span class="pl-c1">9092</span>))

<span class="pl-k">val</span> <span class="pl-en">routerFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RouterFactory</span>(consumerPoolFactory, brokers, <span class="pl-en">MetricsLogger</span>.defaultLogger)

<span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>(<span class="pl-s"><span class="pl-pds">"</span>my_system<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">routerRef</span> <span class="pl-k">=</span> <span class="pl-en">RouterRef</span>(system.actorOf(routerFactory.props()))
<span class="pl-k">val</span> <span class="pl-en">myActor</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">Props</span>(<span class="pl-k">new</span> <span class="pl-en">ExampleActor</span>(routerRef)))

</pre>
  </div> 
  <h3><a href="https://github.com/box-castle/router#supported-router-request-messages" aria-hidden="true" class="anchor" id="user-content-supported-router-request-messages" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Supported Router request messages</h3> 
  <p>All of these case classes are in the <code>com.box.castle.router.messages</code> name space:</p> 
  <h4><a href="https://github.com/box-castle/router#fetchdatatopicandpartition-offset" aria-hidden="true" class="anchor" id="user-content-fetchdatatopicandpartition-offset" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>FetchData(topicAndPartition, offset)</h4> 
  <p>Send this message to the Router to fetch data from Kafka for the given (topic, partition) and offset. The sender will most likely, but is not guaranteed to, get one of the following <em>FetchData.Response</em> messages sent back to it:</p> 
  <ol> 
   <li><em>FetchData.Success</em> - contains a CastleMessageBatch that has AT LEAST one message</li> 
   <li><em>FetchData.OffsetOutOfRange</em> - the requested offset is out of range</li> 
   <li><em>FetchData.NoMessages</em> - there are no messages at the given offset, this happens if the offset was within range, but there were simply no messages written there yet</li> 
   <li><em>FetchData.UnknownTopicOrPartition</em> - no such topic or partition exists</li> 
   <li><em>FetchData.TimedOut</em> - the request timed out while being sent to Kafka</li> 
  </ol> 
  <h4><a href="https://github.com/box-castle/router#fetchoffsetoffsettype-topicandpartition" aria-hidden="true" class="anchor" id="user-content-fetchoffsetoffsettype-topicandpartition" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>FetchOffset(offsetType, topicAndPartition)</h4> 
  <p>Send this message to the Router to get the latest/earliest offset for the given topic and partition from Kafka. The sender will most likely, but is not guaranteed to, get one of the following <em>FetchOffset.Response</em> messages sent back to it:</p> 
  <ol> 
   <li><em>FetchOffset.Success</em> - will contain the offset</li> 
   <li><em>FetchOffset.UnknownTopicOrPartition</em> - the specified topic or partition does not exist in Kafka</li> 
   <li><em>FetchOffset.TimedOut</em> - the request timed out while being sent to Kafka</li> 
  </ol> 
  <h4><a href="https://github.com/box-castle/router#fetchconsumeroffsetconsumerid-topicandpartition" aria-hidden="true" class="anchor" id="user-content-fetchconsumeroffsetconsumerid-topicandpartition" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>FetchConsumerOffset(consumerId, topicAndPartition)</h4> 
  <p>Send this message to the Router to fetch an offset for a given consumer id and (topic, partition). The sender will most likely, but is not guaranteed to, get one of the following <em>FetchConsumerOffset.Response</em> messages sent back to it:</p> 
  <ol> 
   <li><em>FetchConsumerOffset.Success</em> - will contain the offset associated with the consumer id</li> 
   <li><em>FetchConsumerOffset.NotFound</em> - no offset was found for the givent (topic, partition) and consumer id</li> 
   <li><em>FetchConsumerOffset.TimedOut</em> - the request timed out while being sent to Kafka</li> 
  </ol> 
  <h4><a href="https://github.com/box-castle/router#commitconsumeroffsetconsumerid-topicandpartition-offset" aria-hidden="true" class="anchor" id="user-content-commitconsumeroffsetconsumerid-topicandpartition-offset" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>CommitConsumerOffset(consumerId, topicAndPartition, offset)</h4> 
  <p>Send this message to the Router to commit an offset for a given consumer id. The sender will most likely, but is not guaranteed to, get one of the following <em>CommitConsumerOffset.Response</em> messages sent back to it:</p> 
  <ol> 
   <li><em>CommitConsumerOffset.Success</em> - indicates that this offset has been durably committed</li> 
   <li><em>CommitConsumerOffset.UnknownTopicOrPartition</em> - the specified topic or partition does not exist in Kafka</li> 
   <li><em>CommitConsumerOffset.Superseded</em> - there was another offset already committed that is later than the given offset</li> 
   <li><em>CommitConsumerOffset.TimedOut</em> - the request timed out while being sent to Kafka</li> 
  </ol> 
  <h4><a href="https://github.com/box-castle/router#fetchtopicmetadatarequestid" aria-hidden="true" class="anchor" id="user-content-fetchtopicmetadatarequestid" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>FetchTopicMetadata(requestId)</h4> 
  <p>Send this message to Router to fetch metadata for all topics. The sender will most likely, but is not guaranteed to, get one of the following <em>FetchTopicMetadata.Response</em> messages sent back to it:</p> 
  <ol> 
   <li><em>FetchTopicMetadata.Success</em> - contains the topic metadata for all topics in Kafka</li> 
   <li><em>FetchTopicMetadata.TimedOut</em> - the request timed out while being sent to Kafka</li> 
  </ol> 
  <h2><a href="https://github.com/box-castle/router#configuration" aria-hidden="true" class="anchor" id="user-content-configuration" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuration</h2> 
  <p>The following is a list of configuration items that Castle Router needs to operate properly:</p> 
  <h3><a href="https://github.com/box-castle/router#required" aria-hidden="true" class="anchor" id="user-content-required" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Required</h3> 
  <p><strong>Known brokers</strong> – this is a list of known brokers that Castle Router can use to bootstrap the connection to the Kafka cluster</p> 
  <p><strong>Client Id</strong> - The client id is a user-specified string sent in each request to help trace calls. It should logically identify the application making the request. (Source: <a href="http://kafka.apache.org/documentation.html" target="_blank">http://kafka.apache.org/documentation.html</a>)</p> 
  <p><strong>Cache Size</strong> – this is the amount of memory in bytes the Router will use for its cache. The router caches messages it fetches from Kafka in order to avoid network calls if there are multiple actors fetching data from the same topic and partition.</p> 
  <h3><a href="https://github.com/box-castle/router#optional" aria-hidden="true" class="anchor" id="user-content-optional" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Optional</h3> 
  <p><strong>Broker Timeout</strong> (Default: 60 seconds) - the amount of time a Kafka Broker has to respond before we consider the request to have timed out</p> 
  <p><strong>Buffer Size</strong> (Default: 1,048,576 bytes) - the maximum number of bytes that will be requested from Kafka when fetching messages, <strong>WARNING</strong> this number <strong>MUST</strong> be higher than the number specified in the <em>message.max.bytes</em> setting of Kafka's <em>server.properties</em> or topic specific configuration overrides. This buffer size has an impact on total network throughput and you might need to tweak it for your specific configuraiton.</p> 
  <h2><a href="https://github.com/box-castle/router#architecture" aria-hidden="true" class="anchor" id="user-content-architecture" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Architecture</h2> 
  <p><a href="https://github.com/box-castle/router/blob/master/img/architecture_v2.png" target="_blank"><img src="https://github.com/box-castle/router/raw/master/img/architecture_v2.png" alt="Architecture" style="max-width:100%;"></a></p> 
  <h3><a href="https://github.com/box-castle/router#overview-of-the-layout" aria-hidden="true" class="anchor" id="user-content-overview-of-the-layout" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview of the layout</h3> 
  <p>The router consists of a single root actor called the <strong>Router</strong>. The Router contains a single KafkaDispatcherProxyPool. This pool is a map between Brokers and KafkaDispatcherProxy objects.</p> 
  <p>Each KafkaDispatcherProxy contains two references to two different <strong>KafkaDispatcher</strong> actors, as a result the Router is the direct parent of all KafkaDispatcher actors and there are always twice as many KafkaDispatcher actors as there are Brokers in Kafka.</p> 
  <p>Each KafkaDispatcher contains a single CastleSimpleConsumer and five QueueProcessors:</p> 
  <ol> 
   <li>CommitConsumerOffsetProcessor</li> 
   <li>FetchConsumerOffsetProcessor</li> 
   <li>FetchOffsetProcessor</li> 
   <li>FetchTopicMetadataProcessor</li> 
   <li>FetchDataProcessor</li> 
  </ol> 
  <h3><a href="https://github.com/box-castle/router#router" aria-hidden="true" class="anchor" id="user-content-router" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Router</h3> 
  <p>The Router is the public entry point for interacting with Kafka. Akka actors may send messages to this actor to initiate an asynchronous Kafka operation. When the operation completes, the requesting actor will be sent an Akka message containing the response of the operation. The Router does not provide any kind of synchronous API. The Router’s public API consists of messages that are always a subtype <em>RouterMessage</em> and map to the five operations listed in the overview. An instance of <em>RouterResult</em> will be sent back to the requesting actor when the operation completes, but there is no guarantee of this. Please see the how to use Castle Router section for details on dealing with this issue.</p> 
  <p>When the Router receives a <em>RouterMessage</em>, it uses the KafkaDispatcherProxyPool to find out which Broker can service the request. It then sends an Akka message to the KafkaDispatcherProxy associated with this Broker. It is also responsible for keeping an up to date mapping between topics and partitions and the current leaders for those topics and partitions.</p> 
  <h3><a href="https://github.com/box-castle/router#kafkadispatcherproxypool" aria-hidden="true" class="anchor" id="user-content-kafkadispatcherproxypool" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>KafkaDispatcherProxyPool</h3> 
  <p>There is one instance of the pool in the Router, it keeps an internal mapping of Brokers to KafkaDispatcherProxy as well as a mapping of TopicAndPartition to the current leader responsible for that partition. There is always one instance of KafkaDispatcherProxy for each Broker that exists in Kafka.</p> 
  <h3><a href="https://github.com/box-castle/router#kafkadispatcherproxy" aria-hidden="true" class="anchor" id="user-content-kafkadispatcherproxy" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>KafkaDispatcherProxy</h3> 
  <p>This is NOT an actor, it is a simple object that is a very thin wrapper around two references to actual KafkaDispatcher actors. The primary job of the proxy is to route the fetch message operation to one KafkaDispatcher actor and the other four operations to the other KafkaDispatcher actor. The purpose of doing this is to always keep the fetch message channel fully saturated by not interrupting it with various small operations for offset management and metadata requests.</p> 
  <h3><a href="https://github.com/box-castle/router#kafkadispatcher" aria-hidden="true" class="anchor" id="user-content-kafkadispatcher" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>KafkaDispatcher</h3> 
  <p>This actor is responsible for issuing requests to the Broker with which it is associated. Only the Router sends messages to KafkaDispatcher, however the KafkaDispatcher sends messages back to the original issuer of an operation. The dispatcher uses a set of QueueProcessors to accomplish its work. It round robins through the processors to ensure that all operations are satisfied and do not get starved. The KafkaDispatcher itself is a FSM that can be in either the “free” state or the “busy” state. The following is the general logic it uses to process the operation messages it receives from the Router:</p> 
  <pre><code>In [FREE] state:
	Receive operation message
	Find associated QueueProcessor for the operation
	If operation can be satisfied from cache:
		Send RouterResult message back to requester immediately
	Else
		Switch to [BUSY] state
		Tell QueueProcessor to perform the operation against Kafka

In [BUSY] state:
	Receive Akka message
	If Akka message is a Kafka operation from a requester
		Find associated QueueProcessor for the operation
		If operation can be satisfied from cache:
			Send RouterResult message back to requester immediately
		Else
			Add operation to the queue of the QueueProcessor

	If Akka message is a Kafka response
		Tell the associated QueueProcessor to process the response
		Check each QueueProcessor to see if it has any queued messages in a round robin fashion, starting with the NEXT processor to avoid starvation
		If it finds a processor with pending messages
			Tell that processor to perform the operation against Kafka
		Else
			Switch to [FREE] state
</code></pre> 
  <p>The actor also handles the case where the Broker it communicates with is no longer the leader for the topic and partition it is told to process, or if its Broker is unreachable.</p> 
  <h3><a href="https://github.com/box-castle/router#queueprocessor" aria-hidden="true" class="anchor" id="user-content-queueprocessor" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>QueueProcessor</h3> 
  <p>There is a single processor responsible for each of the operations that can be issued to Kafka. The processor will queue operations if there is an already outstanding request to Kafka, it will also batch the operations in the most efficient manner possible for that operation type. When processing a response from Kafka, the queue processor will try to satisfy any outstanding requests that are in the queue with the current response if possible. FetchDataProcessor is the only one that will cache results in a local cache.</p> 
  <h2><a href="https://github.com/box-castle/router#support" aria-hidden="true" class="anchor" id="user-content-support" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Support</h2> 
  <p>Need to contact us directly? Email <a href="mailto:oss@box.com" target="_blank">oss@box.com</a> and be sure to include the name of this project in the subject.</p> 
  <h2><a href="https://github.com/box-castle/router#copyright-and-license" aria-hidden="true" class="anchor" id="user-content-copyright-and-license" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Copyright and License</h2> 
  <p>Copyright 2015 Box, Inc. All rights reserved.</p> 
  <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> 
  <p><a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">http://www.apache.org/licenses/LICENSE-2.0</a></p> 
  <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> 
 </article>
</div>