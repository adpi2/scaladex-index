<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/splink/pagelets" target="_blank"><img src="https://camo.githubusercontent.com/ca7db6895d9168b09a28f5300e1380223b620158/68747470733a2f2f7472617669732d63692e6f72672f73706c696e6b2f706167656c6574732e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/splink/pagelets.svg?branch=master" style="max-width:100%;"></a></p> 
  <h1><a id="user-content-pagelets" class="anchor" href="https://github.com/splink/pagelets#pagelets" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Pagelets</h1> 
  <p>A Module for the Play Framework to build modular applications in an elegant and concise manner.</p> 
  <p>Check out the <a href="https://github.com/splink/pagelets-seed" target="_blank">sample project</a> to see a sample application based on Play Pagelets.</p> 
  <h3><a id="user-content-idea" class="anchor" href="https://github.com/splink/pagelets#idea" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Idea</h3> 
  <p>The idea behind the Pagelets Module is to split a web page into small, composable units. Such a unit is called a pagelet. In terms of the Play Framework a pagelet is just a simple Action[AnyContent]. That means that a pagelet is basically a (small) web page. Pagelets can be arranged in a page tree. So, if a user requests a page, the page is constructed according to it's page tree. It is also possible to serve any part of the tree down to a single pagelet individually. The ordinary pagelet consists of a view, resources (JavaScript, Css), a controller action and a service to fetch data.</p> 
  <p><a href="https://github.com/splink/pagelets/blob/master/docs//pagelets-tree-vis.png" target="_blank"><img src="https://github.com/splink/pagelets/raw/master/docs//pagelets-tree-vis.png" alt="Pagelets" style="max-width:100%;"></a></p> 
  <p>Pagelets are particularly useful if you want to serve tailor-made pages to your visitors. For instance you can easily serve a slightly different page to users from different countries (i18n), or perform A/B testing, or fine-tune the page based on the user (logged-in, gender, other preferences, ...).</p> 
  <p>Pagelets comes in two flavours: <em>Async</em> and <em>Streaming</em>. <em>Async</em> composes the complete page on the server side and sends it back to the client, as soon as all pagelets are complete. <em>Streaming</em> on the other hand, begins to send the page immediately to the client and pagelets appear sequentially as soon as they complete.</p> 
  <h3><a id="user-content-traits" class="anchor" href="https://github.com/splink/pagelets#traits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Traits</h3> 
  <ul> 
   <li><strong>composable</strong>: multiple pagelets can be composed into a page. A page is just a tree of pagelets. Any part of the pagelet tree can be served to the user.</li> 
   <li><strong>resilient</strong>: if a pagelet fails, a fallback is served. Other pagelets are not affected by the failure of one or more pagelets.</li> 
   <li><strong>simple</strong>: to create a pagelet is simple compared to a whole page, because of its limited scope. To compose a page from pagelets is simple.</li> 
   <li><strong>modular</strong>: any pagelet can be easily swapped with another pagelet, removed or added to a page at runtime.</li> 
  </ul> 
  <p>Pagelets are non invasive and not opinionated: You can stick to your code style and apply the patterns you prefer. Use your favorite dependency injection mechanism and template engine. You don't need to apply the goodness of pagelets everywhere, only employ pagelets where you need them. Pagelets also do not introduce additional dependencies to your project.</p> 
  <h3><a id="user-content-usage" class="anchor" href="https://github.com/splink/pagelets#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h3> 
  <h4><a id="user-content-activator" class="anchor" href="https://github.com/splink/pagelets#activator" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Activator</h4> 
  <p>Check out the activator template to get started with a sample project and see a demonstration of Play Pagelets. The project is a small multi-language website, which shows some of the features and typical usage patterns.</p> 
  <p>Enter</p> 
  <div class="highlight highlight-source-shell">
   <pre>activator new</pre>
  </div> 
  <p>then select the play-pagelets-seed template by entering:</p> 
  <div class="highlight highlight-source-shell">
   <pre>play-pagelets-seed</pre>
  </div> 
  <p>then activator creates a new project based on the <a href="https://github.com/splink/pagelets-seed" target="_blank">play pagelets activator template</a>. To see the project in action, navigate to the play-pagelets-seed folder and enter:</p> 
  <div class="highlight highlight-source-shell">
   <pre>activator run</pre>
  </div> 
  <p>then point your browser to <a href="http://localhost:9000" target="_blank">http://localhost:9000</a></p> 
  <h3><a id="user-content-quickstart" class="anchor" href="https://github.com/splink/pagelets#quickstart" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quickstart</h3> 
  <p>To get the idea how Pagelets look in code, read on and check out the <a href="https://github.com/splink/pagelets-seed" target="_blank">play pagelets seed project</a> afterwards.</p> 
  <blockquote> 
   <p>The Pagelets Module requires Play Framework 2.5.x (0.0.3) or 2.6.x (0.0.4+) and will support future Play Versions as well. 0.0.7+ can be used with scala 2.11 and scala 2.12.</p> 
  </blockquote> 
  <p>Add the following lines to your build.sbt file:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.splink<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>pagelets<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.0.7</span>
<span class="pl-s"></span>
<span class="pl-s">routesImport += <span class="pl-pds">"</span></span>org.splink.pagelets.<span class="pl-en">Binders</span>._<span class="pl-s"><span class="pl-pds">"</span></span></pre>
  </div> 
  <p>If you want to use streaming, you will also need:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">TwirlKeys</span>.templateFormats <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>stream<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>org.splink.pagelets.twirl.HtmlStreamFormat<span class="pl-pds">"</span></span>)
<span class="pl-en">TwirlKeys</span>.templateImports <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Vector</span>(<span class="pl-s"><span class="pl-pds">"</span>org.splink.pagelets.twirl.HtmlStream<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>org.splink.pagelets.twirl.HtmlStreamFormat<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>this adds streaming capabilities to the Twirl template engine. To use the streaming template format, you must name your templates <em>name.scala.stream</em> instead of <em>name.scala.html</em></p> 
  <p>Now add the following line to your application.conf file, to enable the Pagelets module:</p> 
  <pre><code>play.modules.enabled += org.splink.pagelets.pageletModule
</code></pre> 
  <p>Create a standard Play controller and inject a <em>Pagelets</em> instance. In this example Guice is used as DI framework, but any DI mechanism works.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">@</span><span class="pl-en">Singleton</span>
<span class="pl-k">class</span> <span class="pl-en">HomeController</span> <span class="pl-k">@</span><span class="pl-en">Inject</span>()(<span class="pl-v">pagelets</span>: <span class="pl-en">Pagelets</span>)(<span class="pl-k">implicit</span> <span class="pl-v">m</span>: <span class="pl-en">Materializer</span>, <span class="pl-v">e</span>: <span class="pl-en">Environment</span>) <span class="pl-k">extends</span> <span class="pl-e">InjectedController</span></pre>
  </div> 
  <p>Bring pagelets into scope</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">pagelets.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>To use the Play's Twirl template engine, import TwirlConversions</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.splink.pagelets.twirl.TwirlCombiners.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>To use Streaming, additionally import HtmlStreamOps</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.splink.pagelets.twirl.HtmlStreamOps.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>Now create the main template inside the <em>views</em> folder. Name the file <em>wrapper.scala.html</em> or, if you want to use streaming, name it <em>wrapper.scala.stream</em></p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">@</span>(<span class="pl-v">resourceRoute</span>: <span class="pl-k">String</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Call</span>)(<span class="pl-v">page</span>: org.splink.pagelets.<span class="pl-en">Page</span>)
 
 <span class="pl-k">&lt;</span><span class="pl-k">!</span><span class="pl-en">DOCTYPE</span> html<span class="pl-k">&gt;</span>
 &lt;<span class="pl-ent">html</span>&gt;
     &lt;<span class="pl-ent">head</span>&gt;
         &lt;<span class="pl-ent">title</span>&gt;<span class="pl-k">@</span>page.head.title&lt;/<span class="pl-ent">title</span>&gt;
         &lt;<span class="pl-ent">link</span> <span class="pl-e">rel</span>=<span class="pl-s"><span class="pl-pds">"</span>stylesheet<span class="pl-pds">"</span></span> <span class="pl-e">media</span>=<span class="pl-s"><span class="pl-pds">"</span>screen<span class="pl-pds">"</span></span> <span class="pl-e">href</span>=<span class="pl-s"><span class="pl-pds">'</span>@routes.Assets.versioned("stylesheets/main.min.css")<span class="pl-pds">'</span></span>&gt;
         &lt;<span class="pl-ent">link</span> <span class="pl-e">rel</span>=<span class="pl-s"><span class="pl-pds">"</span>shortcut icon<span class="pl-pds">"</span></span> <span class="pl-e">type</span>=<span class="pl-s"><span class="pl-pds">"</span>image/png<span class="pl-pds">"</span></span> <span class="pl-e">href</span>=<span class="pl-s"><span class="pl-pds">"</span>@routes.Assets.versioned(<span class="pl-pds">"</span></span>images/favicon.png<span class="pl-s"><span class="pl-pds">"</span>)<span class="pl-pds">"</span></span>&gt;
 
         <span class="pl-k">@</span>page.head.metaTags.map { tag <span class="pl-k">=&gt;</span>
           &lt;<span class="pl-ent">meta</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>@tag.name<span class="pl-pds">"</span></span> <span class="pl-e">content</span>=<span class="pl-s"><span class="pl-pds">"</span>@tag.content<span class="pl-pds">"</span></span> /&gt;
         }
 
         <span class="pl-k">@</span>page.head.css.map { css <span class="pl-k">=&gt;</span>
             &lt;<span class="pl-ent">link</span> <span class="pl-e">rel</span>=<span class="pl-s"><span class="pl-pds">'</span>stylesheet<span class="pl-pds">'</span></span> <span class="pl-e">media</span>=<span class="pl-s"><span class="pl-pds">'</span>screen<span class="pl-pds">'</span></span> <span class="pl-e">href</span>=<span class="pl-s"><span class="pl-pds">'</span>@{resourceRoute(css.toString).url}<span class="pl-pds">'</span></span>&gt;
         }
 
         &lt;<span class="pl-ent">script</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">"</span>@routes.Assets.versioned(<span class="pl-pds">"</span></span>lib/jquery/jquery.min.js<span class="pl-s"><span class="pl-pds">"</span>)<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">script</span>&gt;
         <span class="pl-k">@</span>page.head.js.map { js <span class="pl-k">=&gt;</span>
             &lt;<span class="pl-ent">script</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">'</span>@{resourceRoute(js.toString).url}<span class="pl-pds">'</span></span>&gt;&lt;/<span class="pl-ent">script</span>&gt;
         }
     &lt;/<span class="pl-ent">head</span>&gt;
     &lt;<span class="pl-ent">body</span>&gt;
         <span class="pl-k">@</span><span class="pl-en">Html</span>(page.body)
 
         <span class="pl-k">@</span>page.js.map { js <span class="pl-k">=&gt;</span>
             &lt;<span class="pl-ent">script</span> <span class="pl-e">src</span>=<span class="pl-s"><span class="pl-pds">'</span>@{resourceRoute(js.toString).url}<span class="pl-pds">'</span></span>&gt;&lt;/<span class="pl-ent">script</span>&gt;
         }
     &lt;/<span class="pl-ent">body</span>&gt;
 &lt;/<span class="pl-ent">html</span>&gt;</pre>
  </div> 
  <p>The main template receives a resource route which is needed to reference the JavaScript and Css resources for the page. The template is also provided with a <em>Page</em> instance which contains all parts necessary to render the page: HTML body, JavaScript, Css and Meta Tags.</p> 
  <p>Create a simple pagelet template inside the views folder:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">@</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>)
&lt;<span class="pl-ent">div</span>&gt;<span class="pl-k">@</span>name&lt;/<span class="pl-ent">div</span>&gt;</pre>
  </div> 
  <p>Create a simple pagelet inside the controller:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">pagelet</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>)() <span class="pl-k">=</span> <span class="pl-en">Action</span> {
  <span class="pl-en">Ok</span>(views.html.pagelet(name))
}</pre>
  </div> 
  <p>Define the page composition:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">tree</span>(<span class="pl-v">r</span>: <span class="pl-en">RequestHeader</span>) <span class="pl-k">=</span> {
  <span class="pl-k">val</span> <span class="pl-en">tree</span> <span class="pl-k">=</span> <span class="pl-en">Tree</span>(<span class="pl-en">'root</span>, <span class="pl-en">Seq</span>(
    <span class="pl-en">Leaf</span>(<span class="pl-en">'header</span>, pagelet(<span class="pl-s"><span class="pl-pds">"</span>header<span class="pl-pds">"</span></span>) _).withJavascript(<span class="pl-en">Javascript</span>(<span class="pl-s"><span class="pl-pds">"</span>header.min.js<span class="pl-pds">"</span></span>)).setMandatory(<span class="pl-c1">true</span>),
    <span class="pl-en">Tree</span>(<span class="pl-en">'content</span>, <span class="pl-en">Seq</span>(
      <span class="pl-en">Leaf</span>(<span class="pl-en">'carousel</span>, pagelet(<span class="pl-s"><span class="pl-pds">"</span>carousel<span class="pl-pds">"</span></span>) _).withFallback(pagelet(<span class="pl-s"><span class="pl-pds">"</span>Carousel<span class="pl-pds">"</span></span>) _).withCss(<span class="pl-en">Css</span>(<span class="pl-s"><span class="pl-pds">"</span>carousel.min.css<span class="pl-pds">"</span></span>)),
      <span class="pl-en">Leaf</span>(<span class="pl-en">'text</span>, pagelet(<span class="pl-s"><span class="pl-pds">"</span>text<span class="pl-pds">"</span></span>) _).withFallback(pagelet(<span class="pl-s"><span class="pl-pds">"</span>Text<span class="pl-pds">"</span></span>) _)
    )),
    <span class="pl-en">Leaf</span>(<span class="pl-en">'footer</span>, pagelet(<span class="pl-s"><span class="pl-pds">"</span>footer<span class="pl-pds">"</span></span>) _).withCss(<span class="pl-en">Css</span>(<span class="pl-s"><span class="pl-pds">"</span>footer.min.css<span class="pl-pds">"</span></span>))
  ))
  
  <span class="pl-k">if</span>(messagesApi.preferred(r).lang.language <span class="pl-k">==</span> <span class="pl-s"><span class="pl-pds">"</span>de<span class="pl-pds">"</span></span>) tree.skip(<span class="pl-en">'carousel</span>) <span class="pl-k">else</span> tree
}</pre>
  </div> 
  <p>There are 2 different kinds of pagelets: Leaf pagelets and Tree pagelets. A Leaf pagelet references an actual Action, while a Tree pagelet combines its children into one. When a request arrives, the tree of pagelets is constructed. All Leaf pagelets are executed in parallel and as soon a the children of a Tree pagelet complete, they are combined. This process continues, until just the root pagelet remains.</p> 
  <p>Resources and fallbacks can be defined per pagelet. If a pagelet fails to render, its fallback pagelet is rendered. Resources are assembled and combined by type and references are later provided to the main template.</p> 
  <p>The <em>skip</em> and <em>replace</em> operations are available on instances of <em>Tree</em>. They allow to change the tree at runtime. For instance, the tree can be changed based on the language of an incoming request. Note that the resources for the skipped pagelet are also excluded. If the request language is "de", the carousel pagelet and all its resource dependencies are left out.</p> 
  <p>In this example the header pagelet is declared as mandatory, so if the header fails, the user is redirected to an (error) page. Note that Tree pagelets can't fail or depend on resources.</p> 
  <p>The carousel pagelet depends on <em>carousel.min.css</em> and the footer pagelet depends on <em>footer.min.css</em>. If the tree is constructed, both <em>carousel.min.css</em> and <em>footer.min.css</em> are concatenated into one file whose name is the fingerprint of its contents. This sole Css file which consists of carousel and footer styles is then served under its fingerprint.</p> 
  <p>Now add an index Action to the controller to render the complete page. If you want to use <em>async</em>, add:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">index</span> <span class="pl-k">=</span> <span class="pl-en">PageAction</span>.async(routes.<span class="pl-en">HomeController</span>.errorPage)(_ <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Page Title<span class="pl-pds">"</span></span>, tree) { (request, page) <span class="pl-k">=&gt;</span>
  views.html.wrapper(routes.<span class="pl-en">HomeController</span>.resourceFor)(page)
}</pre>
  </div> 
  <p>If you prefer to use <em>streaming</em>, add:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">index</span> <span class="pl-k">=</span> <span class="pl-en">PageAction</span>.stream(_ <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>Page Title<span class="pl-pds">"</span></span>, tree) { (request, page) <span class="pl-k">=&gt;</span>
  views.html.wrapper(routes.<span class="pl-en">HomeController</span>.resourceFor)(page)
}</pre>
  </div> 
  <p>Both flavours require the page title, the pagelet tree configuration and a function which receives the request and page as arguments. In the <em>async</em> case the function must return a <em>Writeable</em> and in the <em>streaming</em> case a <em>Source[Writeable,_]</em>. A <em>Writeable</em> is just a type class which is capable of transforming the wrapped class eventually to a HTTP response. <em>errorPage</em> is only required in the <em>async</em> case. It is called, if a mandatory pagelet and its fallback fail to render. The <em>streaming</em> case can't redirect to another page in case some mandatory pagelet failed, because at the time, the pagelet fails, parts of the page are already streaming to the client, thus it's too late.</p> 
  <p>Finally add the route to conf/routes</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">GET</span>  <span class="pl-k">/</span>                              controllers.<span class="pl-en">HomeController</span>.index
<span class="pl-en">GET</span>  <span class="pl-k">/</span>resource<span class="pl-k">/</span><span class="pl-k">:</span>fingerprint         controllers.<span class="pl-en">HomeController</span>.resourceFor(<span class="pl-v">fingerprint</span>: <span class="pl-k">String</span>)</pre>
  </div> 
  <h3><a id="user-content-details" class="anchor" href="https://github.com/splink/pagelets#details" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Details</h3> 
  <h4><a id="user-content-advantages" class="anchor" href="https://github.com/splink/pagelets#advantages" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Advantages</h4> 
  <ul> 
   <li> <p>Resilient: if one part of the page fails, the other pagelets remain unaffected. A fallback can be defined per pagelet. If a fallback fails, the pagelet is simply left out. If a pagelet is declared as mandatory and its fallback also fails, the request is redirected to a configurable error page.</p> </li> 
   <li> <p>Modular: a pagelet is an isolated and independent unit. Assets like JavaScript and Stylesheets are defined on a per pagelet basis so a pagelet is completely autonomous. A pagelet can be easily reused on any page.</p> </li> 
   <li> <p>Flexible: a page can be composed with very little code, and the composition can be changed at runtime. Specific pagelets can be replaced with others, removed or new pagelets can be added anywhere in the page with just a line of code. This is quite handy to conduct A/B tests or to serve a different page based on the user properties like locale, user-role, ...</p> </li> 
   <li> <p>Simple: to create a pagelet is much simpler then to create a complete page, because the scope of a pagelet is small. The composition of a page from pagelets is just a bit of configuration code and thus also simple. So all steps required to build a page are simple.</p> </li> 
   <li> <p>Logs: Detailed logs help to gain useful insights on the performance and to find bottlenecks quickly.</p> </li> 
   <li> <p>Performant #1: all pagelets in a page tree are executed in parallel, so splitting a page into paglets induces no perceptible overhead.</p> </li> 
   <li> <p>Performant #2: Resources are automatically concatenated and hashed as well as served with far future expiration dates. Therefore browsers need to make only few requests, and - as long as the resources haven't changed - can pull them from the local cache.</p> </li> 
   <li> <p>Performant #3: A page can optionally be streamed which effectively reduces the time to first byte to milliseconds and enables the browser to start loading resources immediately.</p> </li> 
   <li> <p>Separation of concerns: by using pagelets, you automagically end up with a clean and flexible application design.</p> </li> 
  </ul> 
  <h4><a id="user-content-fallbacks" class="anchor" href="https://github.com/splink/pagelets#fallbacks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Fallbacks</h4> 
  <p>Each pagelet can define a fallback. A fallback is just another pagelet. If the main pagelet fails, its fallback is executed. If the fallback fails too, then the pagelet is simply left out. But if the pagelet was declared mandatory, then the request is redirected to another (error) page. If the main pagelet has no fallback and fails, it's left out - unless the pagelet was declared mandatory.</p> 
  <h4><a id="user-content-resources" class="anchor" href="https://github.com/splink/pagelets#resources" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Resources</h4> 
  <p>All resources declared by the pagelets of a page (JavaScript, Css) are de-duplicated, aggregated and combined during the construction of the page. A hash is then computed for each combined resource type. Correspondingly, <em>script</em> and <em>link</em> tags which reference the combined resources by their hash are injected into the page. These resources are served with far future expiration dates. So, if the resources haven't changed, browsers can just pull them from the cache. As soon as the resources change, browsers are presented with a fresh hash value und thus fetch the new resources. This reduces the amount of requests a browser has to make to render a page to a bare minimum. This system also makes sure that only the resources which are actually needed on a page are served.</p> 
  <h4><a id="user-content-cookies--meta-tags" class="anchor" href="https://github.com/splink/pagelets#cookies--meta-tags" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cookies &amp; Meta Tags</h4> 
  <p>Each pagelet can set Cookies and Meta Tags. Just as with the resources, Cookies and Meta Tags are de-duplicated, aggregated and combined during the construction of the page.</p> 
  <h4><a id="user-content-async-vs-streaming" class="anchor" href="https://github.com/splink/pagelets#async-vs-streaming" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Async vs. Streaming</h4> 
  <h5><a id="user-content-async" class="anchor" href="https://github.com/splink/pagelets#async" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Async</h5> 
  <p>When a page is rendered in <em>async</em> mode, all pagelets are rendered and then assembled on the server into the final page. Once complete, the complete page is sent to the client.</p> 
  <h5><a id="user-content-streaming" class="anchor" href="https://github.com/splink/pagelets#streaming" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Streaming</h5> 
  <p>In <em>streaming</em> mode, the page is streamed immediately to the client. As soon the next pagelet is ready, the pagelet is streamed to the client. This is repeated until all pagelets have been streamed. Streaming seems quite advantageous because the client receives the first parts of the page immediately. Within these first parts is the HTML head, which includes references to the JavaScript and Css which is needed to render the page. This means that the browser can start loading external resources while the HTML is still streaming. This parallelization reduces the overall load time of the page. But even more perceptible is the extremely short amount of time until the first byte is received by the client, it takes only a few milliseconds. So from the perspective of the user, the page appears immediately and completes rendering progressively.</p> 
  <p>But there are also downsides to the <em>streaming</em> approach:</p> 
  <ul> 
   <li>HTTP Headers are sent first. As the headers contain the HTTP Status Code, the code is always set to 200/Ok, even though at the time the header is constructed, it is too early to safely assume that the page can be rendered correctly. So you need to make sure that you have appropriate fallbacks in place in case a pagelet fails to render.</li> 
   <li>If a page is cached, the Cache will certainly cache a page with a status code of 200/Ok. This means that fallbacks might end up being cached.</li> 
   <li>Only non-httpOnly Cookies can be set. Each pagelet can set Cookies. But only when all pagelets are complete, the Cookies to set are all present. So, it's simply not possible to set the Cookies as usual via HTTP headers, because the HTTP headers are sent first to the client. So Cookies are set with a piece of Javascript code at the end of the Html body. As setting Cookies relies on JavaScript, the Cookies can't be Http-only.</li> 
  </ul> 
  <h5><a id="user-content-when-to-choose-streaming" class="anchor" href="https://github.com/splink/pagelets#when-to-choose-streaming" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>When to choose streaming</h5> 
  <p>Choose the <em>streaming</em> if:</p> 
  <ul> 
   <li>all users have JavaScript enabled or the page does not use Cookies</li> 
   <li>the page does not rely on httpOnly Cookies</li> 
   <li>pages are not cached or it's very unlikely that some pagelets fail or it does not matter if a fallback is cached</li> 
  </ul> 
  <p>otherwise choose the caveat-free <em>async</em> mode.</p> 
  <blockquote> 
   <p>Big thanks to <a href="https://github.com/brikis98" target="_blank">brikis98</a> who originally had the idea to port <a href="https://www.facebook.com/notes/facebook-engineering/bigpipe-pipelining-web-pages-for-high-performance/389414033919/" target="_blank">Facebook's BigPipe</a> to Play and did a lot of the groundwork with his <a href="https://www.youtube.com/watch?v=4b1XLka0UIw" target="_blank">brilliant talks</a> and <a href="https://github.com/brikis98/ping-play" target="_blank">ping-play repo</a></p> 
  </blockquote> 
 </article>
</div>