{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":2581,
            "title":"Support SLF4J Mapped Diagnostic Context (MDC) on internal server error",
            "bodyText":"On this code the internal server errors are logged, before displaying an html error page (that is customizable)\nplay.api.Application#handleError\n  /**\n   * Handle a runtime error during the execution of an action\n   */\n  private[play] def handleError(request: RequestHeader, e: Throwable): Future[SimpleResult] = try {\n    e match {\n      case e: UsefulException => throw e\n      case e: Throwable => {\n\n        val source = sources.flatMap(_.sourceFor(e))\n\n        throw new PlayException.ExceptionSource(\n          \"Execution exception\",\n          \"[%s: %s]\".format(e.getClass.getSimpleName, e.getMessage),\n          e) {\n          def line = source.flatMap(_._2).map(_.asInstanceOf[java.lang.Integer]).orNull\n          def position = null\n          def input = source.map(_._1).map(scalax.file.Path(_).string).orNull\n          def sourceName = source.map(_._1.getAbsolutePath).orNull\n        }\n      }\n    }\n  } catch {\n    case NonFatal(e) => try {\n      Logger.error(\n        \"\"\"\n        |\n        |! %sInternal server error, for (%s) [%s] ->\n        |\"\"\".stripMargin.format(e match {\n          case p: PlayException => \"@\" + p.id + \" - \"\n          case _ => \"\"\n        }, request.method, request.uri),\n        e\n      )\n      global.onError(request, e)\n    } catch {\n      case NonFatal(e) => DefaultGlobal.onError(request, e)\n    }\n  }\nThe matter is that it seems impossible to me to be able to attach an MDC value to this log statement.\nTypically I want to be able to attach each technical error to a given user if the request is bound to an applicative user.\nThis forces me to log the same error another time in the Global callback:\n  override def onError(request: RequestHeader, ex: Throwable): Future[SimpleResult] = {\n    val mdcUser: Option[User] = ex match {\n      case RuntimeExceptionForStampleUser.InCausalChainExtractor(user, cause) => Some(user)\n      case _ => None\n    }\n\n    mdcUser.foreach(u => MDC.put(\"username\", u.username))\n    Logger.error(\"Internal server error:\", ex)\n    mdcUser.foreach(u => MDC.remove(\"username\"))\n\n    super.onError(request, ex)\n  }\nIs there any alternative?",
            "url":"https://github.com/playframework/playframework/issues/2581"
          },
          {
            "number":5172,
            "title":"Improve field constructor documentation",
            "bodyText":"The custom field constructor documentation neglects to say where you should (or can) put the field constructor template.  The answer is of course anywhere, but I think it would be good if the documentation suggested a filename relative to the project directory, both for the field constructor and the MyHelpers object, and a little explanation around choosing the location of the file and what would need to change if you used a different location would be good.",
            "url":"https://github.com/playframework/playframework/issues/5172"
          },
          {
            "number":5275,
            "title":"Provide helper method to parse json requests",
            "bodyText":"Right now to get the value of a JSON request you need to do:\nJson.fromJson(request().body().asJson(), Pet.class)\n\nIt seems like it'd be simpler to have a method that was something a bit more like:\nrequest().body().asJson(Pet.class)",
            "url":"https://github.com/playframework/playframework/issues/5275"
          },
          {
            "number":5546,
            "title":"[feature] Create JUnit matchers for CompletionStage, Future, Optional",
            "bodyText":"It would help with writing Java tests to have some matchers for Java 8 types. I don't think they're in JUnit or Hamcrest yet.\nE.g.\nassertThat(completionStage, futureValue(is(3)));\nassertThat(future, futureValue(is(3)));\nassertThat(optional, isEmpty());\nassertThat(optional, hasValue(\"x\"));",
            "url":"https://github.com/playframework/playframework/issues/5546"
          },
          {
            "number":5957,
            "title":"Mention scala-guice helpers in docs",
            "bodyText":"There are a few libraries with Scala DSLs for guice like https://github.com/codingwell/scala-guice. Would be good to mention some or all of them in the docs.",
            "url":"https://github.com/playframework/playframework/issues/5957"
          },
          {
            "number":6412,
            "title":"playGenerateSecret Shows No Output if logLevel := Level.Warn",
            "bodyText":"The playGenerateSecret output should not be sent to a logger. Instead, playGenerateSecret should send output to the default output mechanisms for SBT tasks.",
            "url":"https://github.com/playframework/playframework/issues/6412"
          },
          {
            "number":6573,
            "title":"[doc] Include examples of implicit request in Action documentation",
            "bodyText":"Play Version (2.5.x / etc)\ncurrent\nExpected Behavior\nThe Play documentation does not go far enough in pushing the importance of an implicit request in an action.  See #6428 for CSRF for example, and likewise Form processing and template handling is impractical without an implicit request.\nThe following pages should include references to implicit request:\n\nScalaActions\nScalaAsync\nScalaTemplates\nJavaTemplates",
            "url":"https://github.com/playframework/playframework/issues/6573"
          },
          {
            "number":7105,
            "title":"Stop exposing implementation data on 404 errors",
            "bodyText":"When no route matches, you get a page with play logo displayed.\nExposing the site was built using play framework is not ideal form the security standpoint.",
            "url":"https://github.com/playframework/playframework/issues/7105"
          },
          {
            "number":7788,
            "title":"Document usage of List in routes",
            "bodyText":"The docs mention offhand that List[String] is a valid parameter type, but don't say how to use it. I was trying a bunch of stuff like param=a,b,c,d that wasn't working. I finally saw somewhere that suggested the usage might be param=a&param=b&param=c&param=d (note I haven't tried that syntax, so am not 100% certain it works)",
            "url":"https://github.com/playframework/playframework/issues/7788"
          }
        ]
      }
    }
  }
}