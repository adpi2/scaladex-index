<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-boopickle" class="anchor" href="https://github.com/ochrons/boopickle#boopickle" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>BooPickle</h1> 
  <p><a href="https://gitter.im/ochrons/boopickle?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/c0de4d7b627d8e11acbe74d6f240a2947ee270fe/68747470733a2f2f6261646765732e6769747465722e696d2f6f6368726f6e732f626f6f7069636b6c652e737667" alt="Join the chat at https://gitter.im/ochrons/boopickle" data-canonical-src="https://badges.gitter.im/ochrons/boopickle.svg" style="max-width:100%;"></a></p> 
  <p><a href="https://travis-ci.org/ochrons/boopickle" target="_blank"><img src="https://camo.githubusercontent.com/edef5d7e21f8719a85601ba4846e92a982a8ccc2/68747470733a2f2f7472617669732d63692e6f72672f6f6368726f6e732f626f6f7069636b6c652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/ochrons/boopickle.svg?branch=master" style="max-width:100%;"></a> <a href="http://www.scala-js.org" target="_blank"><img src="https://camo.githubusercontent.com/9cd18073c81b367e28edc376992977afa15403cb/68747470733a2f2f7777772e7363616c612d6a732e6f72672f6173736574732f6261646765732f7363616c616a732d302e362e31332e737667" alt="Scala.js" data-canonical-src="https://www.scala-js.org/assets/badges/scalajs-0.6.13.svg" style="max-width:100%;"></a></p> 
  <p>BooPickle is the <a href="http://ochrons.github.io/boopickle-perftest/" target="_blank">fastest</a> and most size efficient serialization (aka pickling) library that works on both Scala and <a href="http://www.scala-js.org" target="_blank">Scala.js</a>. It encodes into a binary format instead of the more customary JSON. A binary format brings efficiency gains in both size and speed, at the cost of legibility of the encoded data. BooPickle borrows heavily from both <a href="https://github.com/lihaoyi/upickle-pprint" target="_blank">uPickle</a> and <a href="https://github.com/benhutchison/prickle" target="_blank">Prickle</a> so special thanks to Li Haoyi and Ben Hutchison for those two great libraries!</p> 
  <h2><a id="user-content-features" class="anchor" href="https://github.com/ochrons/boopickle#features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <ul> 
   <li>Supports both Scala and Scala.js (no reflection!)</li> 
   <li>Serialization support for all primitives, collections, options, tuples and case classes (including class hierarchies)</li> 
   <li>User-definable custom serializers</li> 
   <li>Transforming serializers to simplify serializing non-case classes</li> 
   <li>Handles <a href="https://github.com/ochrons/boopickle#references" target="_blank">references and deduplication of identical objects</a></li> 
   <li>Very fast</li> 
   <li>Very efficient coding</li> 
   <li>Low memory usage, no intermediate structures needed</li> 
   <li>Zero dependencies</li> 
   <li>Scala 2.11/2.12</li> 
   <li>All modern browsers are supported (not IE9 and below, though)</li> 
  </ul> 
  <h2><a id="user-content-getting-started" class="anchor" href="https://github.com/ochrons/boopickle#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting started</h2> 
  <p>Add following dependency declaration to your Scala project </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-s"><span class="pl-pds">"</span>me.chrons<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>boopickle<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.2.5<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>On a Scala.js project the dependency looks like this</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-s"><span class="pl-pds">"</span>me.chrons<span class="pl-pds">"</span></span> <span class="pl-k">%%%</span> <span class="pl-s"><span class="pl-pds">"</span>boopickle<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.2.5<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>To use it in your code, simply import the Default object contents. All examples in this document assume this import is present.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">boopickle.Default.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>To serialize (pickle) something, just call <code>Pickle.intoBytes</code> with your data. This will produce a binary <code>ByteBuffer</code> containing an encoded version of your data.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>World!<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">buf</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(data)</pre>
  </div> 
  <p>And to deserialize (unpickle) the buffer, call <code>Unpickle.fromBytes</code>, specifying the type of your data. BooPickle doesn't encode <em>any</em> type information, so you <em>must</em> use the same types when pickling and unpickling.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">helloWorld</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Seq</span>[<span class="pl-k">String</span>]].fromBytes(buf)</pre>
  </div> 
  <h2><a id="user-content-supported-types" class="anchor" href="https://github.com/ochrons/boopickle#supported-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Supported types</h2> 
  <p>BooPickle has built-in support for most of the typical Scala types, including</p> 
  <ul> 
   <li>primitives: <code>Boolean</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code> and <code>String</code></li> 
   <li>common types: <code>Tuple</code>s, <code>Option</code>, <code>Either</code>, <code>Duration</code>, <code>UUID</code>, <code>BigInt</code>, <code>BigDecimal</code> and <code>ByteBuffer</code></li> 
   <li>collections, both mutable and immutable, including: <code>Array</code>, <code>Vector</code>, <code>List</code>, <code>Set</code>s, <code>Map</code>s and any <code>Iterable</code> with a <code>CanBuildFrom</code> implementation</li> 
   <li><code>case class</code>es and <code>case object</code>s (via a macro)</li> 
   <li><code>trait</code>s as a base for a class hierarchy</li> 
  </ul> 
  <h2><a id="user-content-class-hierarchies" class="anchor" href="https://github.com/ochrons/boopickle#class-hierarchies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Class hierarchies</h2> 
  <p>By default, BooPickle encodes zero type information, which makes it impossible to directly encode a class hierarchy like below and decode it just by specifying the parent type <code>Fruit</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">Fruit</span> {
  <span class="pl-k">val</span> <span class="pl-en">weight</span><span class="pl-k">:</span> <span class="pl-k">Double</span>
  <span class="pl-k">def</span> <span class="pl-en">color</span><span class="pl-k">:</span> <span class="pl-k">String</span>
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Banana</span>(<span class="pl-v">weight</span>: <span class="pl-k">Double</span>) <span class="pl-k">extends</span> <span class="pl-e">Fruit</span> {
  <span class="pl-k">def</span> <span class="pl-en">color</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>yellow<span class="pl-pds">"</span></span>
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Kiwi</span>(<span class="pl-v">weight</span>: <span class="pl-k">Double</span>) <span class="pl-k">extends</span> <span class="pl-e">Fruit</span> {
  <span class="pl-k">def</span> <span class="pl-en">color</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>brown<span class="pl-pds">"</span></span>
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Carambola</span>(<span class="pl-v">weight</span>: <span class="pl-k">Double</span>) <span class="pl-k">extends</span> <span class="pl-e">Fruit</span> {
  <span class="pl-k">def</span> <span class="pl-en">color</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>yellow<span class="pl-pds">"</span></span>
}</pre>
  </div> 
  <p>As this is such a common situation, BooPickle provides a helper class <code>CompositePickler</code> to build a custom pickler for composite types. For the case above, all you need to do is to define an implicit pickler like this, utilizing the <code>compositePickler</code> function from <code>Default</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">fruitPickler</span> <span class="pl-k">=</span> compositePickler[<span class="pl-en">Fruit</span>].
  addConcreteType[<span class="pl-en">Banana</span>].
  addConcreteType[<span class="pl-en">Kiwi</span>].
  addConcreteType[<span class="pl-en">Carambola</span>]</pre>
  </div> 
  <p>Now you can freely pickle any <code>Fruit</code> and when unpickling, BooPickle will know what type to decode.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">fruits</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Kiwi</span>(<span class="pl-c1">0.5</span>), <span class="pl-en">Kiwi</span>(<span class="pl-c1">0.6</span>), <span class="pl-en">Carambola</span>(<span class="pl-c1">5.0</span>), <span class="pl-en">Banana</span>(<span class="pl-c1">1.2</span>))
<span class="pl-k">val</span> <span class="pl-en">bb</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(fruits)
.
.
<span class="pl-k">val</span> <span class="pl-en">u</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Seq</span>[<span class="pl-en">Fruit</span>]].fromBytes(bb)
assert(u <span class="pl-k">==</span> fruits)</pre>
  </div> 
  <p>Note that internally <code>CompositePickler</code> encodes types using indices, so they must be specified in the same order on both sides!</p> 
  <p>BooPickle needs to know the type when pickling to deserialize to the correct type, thus this fails</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> <span class="pl-en">Banana</span>(<span class="pl-c1">1.0</span>)
<span class="pl-k">val</span> <span class="pl-en">bb</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(b)
assert(<span class="pl-en">Unpickle</span>[<span class="pl-en">Banana</span>].fromBytes(bb) <span class="pl-k">==</span> b) <span class="pl-c">// This produces Banana</span>
<span class="pl-k">val</span> <span class="pl-en">bb2</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(b)
assert(<span class="pl-en">Unpickle</span>[<span class="pl-en">Fruit</span>].fromBytes(bb2) <span class="pl-k">==</span> <span class="pl-c1">null</span>) <span class="pl-c">// This produces null</span></pre>
  </div> 
  <p>Instead when pickling declare the parent type</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">f</span><span class="pl-k">:</span> <span class="pl-en">Fruit</span> <span class="pl-k">=</span> <span class="pl-en">Banana</span>(<span class="pl-c1">1.0</span>)
<span class="pl-k">val</span> <span class="pl-en">bf</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(f)
assert(<span class="pl-en">Unpickle</span>[<span class="pl-en">Fruit</span>].fromBytes(bf) <span class="pl-k">==</span> f) <span class="pl-c">// This produces a Fruit</span></pre>
  </div> 
  <h3><a id="user-content-recursive-composite-types" class="anchor" href="https://github.com/ochrons/boopickle#recursive-composite-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Recursive composite types</h3> 
  <p>If you have a recursive composite type (a sub type has a reference to the super type), you need to build the <code>CompositePickler</code> in two steps, as shown below.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Tree</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Leaf</span> <span class="pl-k">extends</span> <span class="pl-e">Tree</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Node</span>(<span class="pl-v">value</span>: <span class="pl-k">Int</span>, children<span class="pl-k">:</span><span class="pl-en">Seq</span>[<span class="pl-en">Tree</span>]) <span class="pl-k">extends</span> <span class="pl-e">Tree</span>

<span class="pl-k">object</span> <span class="pl-en">Tree</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">treePickler</span> <span class="pl-k">=</span> compositePickler[<span class="pl-en">Tree</span>]
  treePickler.addConcreteType[<span class="pl-en">Node</span>].addConcreteType[<span class="pl-en">Leaf</span>.type]
}</pre>
  </div> 
  <p>This is because the compiler must find a pickler for <code>Tree</code> when it's building a pickler for <code>Node</code>.</p> 
  <h3><a id="user-content-automatic-generation-of-hierarchy-picklers" class="anchor" href="https://github.com/ochrons/boopickle#automatic-generation-of-hierarchy-picklers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Automatic generation of hierarchy picklers</h3> 
  <p>If your type hierarchy is <code>sealed</code> then you can take advantage of the automatic pickler generation feature of BooPickle. A macro automatically generates the required <code>CompositePickler</code> for you, as long as the trait is <code>sealed</code>. For example lets change the <code>Fruit</code> trait to be sealed, so that compiler knows all its descendants will be defined in the same file and the macro can find them.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Fruit</span> {
  <span class="pl-k">val</span> <span class="pl-en">weight</span><span class="pl-k">:</span> <span class="pl-k">Double</span>
  <span class="pl-k">def</span> <span class="pl-en">color</span><span class="pl-k">:</span> <span class="pl-k">String</span>
}</pre>
  </div> 
  <p>Now you can directly pickle your fruits without manually defining a <code>CompositePickler</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">fruits</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Kiwi</span>(<span class="pl-c1">0.5</span>), <span class="pl-en">Kiwi</span>(<span class="pl-c1">0.6</span>), <span class="pl-en">Carambola</span>(<span class="pl-c1">5.0</span>), <span class="pl-en">Banana</span>(<span class="pl-c1">1.2</span>))
<span class="pl-k">val</span> <span class="pl-en">bb</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(fruits)
.
.
<span class="pl-k">val</span> <span class="pl-en">u</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Seq</span>[<span class="pl-en">Fruit</span>]].fromBytes(bb)
assert(u <span class="pl-k">==</span> fruits)</pre>
  </div> 
  <p>Note that for some hierarchies the automatic generation may not work (due to Scala compiler limitations), but you can always fall back to the manually defined <code>CompositePickler</code>.</p> 
  <p>Also note that due to the way macros generate picklers, each time you need an implicit instance of the pickler, new classes (and <code>.class</code> files) will be generated. And not just for the top level trait, but for all implementing classes as well. If you have a large class hierarchy, this adds up rather quickly! Below you can see the results of pickling a trait twice in the code.</p> 
  <pre><code> Size   Name
 2,798  MacroPickleTests$$anonfun$tests$8$$anonfun$apply$1$$anonfun$apply$14$TraitPickler$macro$25$2$CCPickler$macro$26$2$.class
 2,798  MacroPickleTests$$anonfun$tests$8$$anonfun$apply$1$$anonfun$apply$16$TraitPickler$macro$33$2$CCPickler$macro$34$2$.class
 3,498  MacroPickleTests$$anonfun$tests$8$$anonfun$apply$1$$anonfun$apply$14$TraitPickler$macro$25$2$CCPickler$macro$27$2$.class
 3,498  MacroPickleTests$$anonfun$tests$8$$anonfun$apply$1$$anonfun$apply$16$TraitPickler$macro$33$2$CCPickler$macro$35$2$.class
 4,789  MacroPickleTests$$anonfun$tests$8$$anonfun$apply$1$$anonfun$apply$14$TraitPickler$macro$25$2$.class
 4,789  MacroPickleTests$$anonfun$tests$8$$anonfun$apply$1$$anonfun$apply$16$TraitPickler$macro$33$2$.class
</code></pre> 
  <p>If this becomes an issue, you can avoid it by storing implicit picklers in the companion object of the trait. This way the code is generated only once and used whenever you need a pickler for your <code>Fruit</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Fruit</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">pickler</span><span class="pl-k">:</span> <span class="pl-en">Pickler</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> generatePickler[<span class="pl-en">Fruit</span>]
}

<span class="pl-c">// must import the companion object, otherwise the implicit macro has higher precedence and will generate another pickler!</span>
<span class="pl-k">import</span> <span class="pl-v">Fruit.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">fruits</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Kiwi</span>(<span class="pl-c1">0.5</span>), <span class="pl-en">Kiwi</span>(<span class="pl-c1">0.6</span>), <span class="pl-en">Carambola</span>(<span class="pl-c1">5.0</span>), <span class="pl-en">Banana</span>(<span class="pl-c1">1.2</span>))
<span class="pl-k">val</span> <span class="pl-en">bb</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(fruits)</pre>
  </div> 
  <p>You can prevent the implicit use of the pickler generator macro by importing <code>boopickle.DefaultBasic._</code> instead of <code>boopickle.Default._</code> as this will leave the implicit macro code out. Then you can provide specific implicit picklers for your case classes or class hierarchies.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">boopickle.DefaultBasic.</span><span class="pl-v">_</span>
<span class="pl-k">object</span> <span class="pl-en">Fruit</span> {
  <span class="pl-c">// use macro explicitly to generate the pickler</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">pickler</span><span class="pl-k">:</span> <span class="pl-en">Pickler</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> <span class="pl-en">PicklerGenerator</span>.generatePickler[<span class="pl-en">Fruit</span>]
}</pre>
  </div> 
  <p>In this case you don't need to <code>import Fruit._</code> because there is no implicit macro to compete with your pickler in the companion object.</p> 
  <p>Note that when not using implicit macro picklers, you must pay special attention to the creation order of picklers in more complex situations like below.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">boopickle.DefaultBasic.</span><span class="pl-v">_</span>
<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">MyTrait</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">TT1</span>(<span class="pl-v">i</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">MyTrait</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">TT2</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>, <span class="pl-v">next</span>: <span class="pl-en">MyTrait</span>) <span class="pl-k">extends</span> <span class="pl-e">MyTrait</span>

<span class="pl-k">class</span> <span class="pl-en">TT3</span>(<span class="pl-k">val</span> <span class="pl-en">i</span><span class="pl-k">:</span> <span class="pl-k">Int</span>, <span class="pl-k">val</span> <span class="pl-en">s</span><span class="pl-k">:</span> <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">MyTrait</span>

<span class="pl-k">object</span> <span class="pl-en">MyTrait</span> {
  <span class="pl-c">// picklers must be created in correct order, because TT2 depends on MyTrait</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">pickler</span> <span class="pl-k">=</span> compositePickler[<span class="pl-en">MyTrait</span>]
  <span class="pl-c">// use macro explicitly to generate picklers for TT1 and TT2</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">pickler1</span> <span class="pl-k">=</span> <span class="pl-en">PicklerGenerator</span>.generatePickler[<span class="pl-en">TT1</span>]
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">pickler2</span> <span class="pl-k">=</span> <span class="pl-en">PicklerGenerator</span>.generatePickler[<span class="pl-en">TT2</span>]
  <span class="pl-c">// a pickler for TT3 cannot be generated by macro, so use a transform pickler</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">pickler3</span> <span class="pl-k">=</span> transformPickler[<span class="pl-en">TT3</span>, (<span class="pl-k">Int</span>, <span class="pl-k">String</span>)](t <span class="pl-k">=&gt;</span> (t.i, t.s), t <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">TT3</span>(t._1, t._2))
  pickler.addConcreteType[<span class="pl-en">TT1</span>].addConcreteType[<span class="pl-en">TT2</span>].addConcreteType[<span class="pl-en">TT3</span>]
}</pre>
  </div> 
  <h3><a id="user-content-complex-type-hierarchies" class="anchor" href="https://github.com/ochrons/boopickle#complex-type-hierarchies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Complex type hierarchies</h3> 
  <p>When you have more complex type hierarchies with multiple levels of traits, you might need picklers for each type level. A simple example to illustrate:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Element</span>

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Document</span> <span class="pl-k">extends</span> <span class="pl-e">Element</span>

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Attribute</span> <span class="pl-k">extends</span> <span class="pl-e">Element</span>

<span class="pl-k">final</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">WordDocument</span>(text<span class="pl-k">:</span><span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Document</span>

<span class="pl-k">final</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">OwnerAttribute</span>(<span class="pl-v">owner</span>: <span class="pl-k">String</span>, <span class="pl-v">parent</span>: <span class="pl-en">Element</span>) <span class="pl-k">extends</span> <span class="pl-e">Attribute</span></pre>
  </div> 
  <p>Building a <code>CompositePickler</code> for <code>Element</code> with the two implementation classes doesn't actually give you a pickler for <code>Document</code> nor <code>Attribute</code>. So you need to define those picklers separately, duplicating the implementation classes. For this purpose <code>CompositePickler</code> allows you to join existing composite picklers to form a new one.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Element</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">documentPickler</span> <span class="pl-k">=</span> compositePickler[<span class="pl-en">Document</span>]
  documentPickler.addConcreteType[<span class="pl-en">WordDocument</span>]

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">attributePickler</span> <span class="pl-k">=</span> compositePickler[<span class="pl-en">Attribute</span>]
  attributePickler.addConcreteType[<span class="pl-en">OwnerAttribute</span>]

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">elementPickler</span> <span class="pl-k">=</span> compositePickler[<span class="pl-en">Element</span>]
  elementPickler.join[<span class="pl-en">Document</span>].join[<span class="pl-en">Attribute</span>]
}</pre>
  </div> 
  <p>With these picklers you may now pickle any trait. Note, however, that you must use the same <code>CompositePickler</code> when unpickling. You cannot pickle with <code>Element</code> and unpickle with <code>Attribute</code> even if the actual class was <code>OwnerAttribute</code> because internal indexes are different for each composite pickler.</p> 
  <h2><a id="user-content-references" class="anchor" href="https://github.com/ochrons/boopickle#references" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>References</h2> 
  <p>If your data contains the same object multiple times, BooPickle will encode it only once and use a reference for the remaining occurrences. For example the data below is correctly unpickled to contain references to the same <code>p</code> instances.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Point</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">Int</span>)

<span class="pl-k">val</span> <span class="pl-en">p</span> <span class="pl-k">=</span> <span class="pl-en">Point</span>(<span class="pl-c1">5</span>, <span class="pl-c1">10</span>)
<span class="pl-k">val</span> <span class="pl-en">points</span> <span class="pl-k">=</span> <span class="pl-en">Vector</span>(p, p, p, p)
<span class="pl-k">val</span> <span class="pl-en">bb</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(points)
.
.
<span class="pl-k">val</span> <span class="pl-en">newPoints</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Vector</span>[<span class="pl-en">Point</span>]].fromBytes(bb)
assert(newPoints(<span class="pl-c1">0</span>) eq newPoints(<span class="pl-c1">1</span>))</pre>
  </div> 
  <p>Reference identity is checked by actual object identity, not by its <code>equal</code> method, so a <code>val a = List(2)</code> and <code>val b = List(2)</code> are two different objects and will not be replaced by each other in pickling.</p> 
  <h2><a id="user-content-custom-picklers" class="anchor" href="https://github.com/ochrons/boopickle#custom-picklers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom picklers</h2> 
  <p>If you need to pickle non-case classes or for example Java classes, you can define custom picklers for them. If it's a non-generic type, use an <code>implicit object</code> and for generic types use <code>implicit def</code>. See <code>Pickler.scala</code> for more detailed examples such as <code>Either[T, S]</code> below.</p> 
  <p>In most cases, however, you can use the <code>TransformPickler</code> to create a custom pickler for a type by transforming it into another type that already has pickler support. For example you can transform a <code>java.util.Date</code> into a <code>Long</code> and back. More complex classes can be transformed to a suitable <code>Tuple</code>. </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">datePickler</span> <span class="pl-k">=</span> transformPickler((<span class="pl-v">t</span>: <span class="pl-k">Long</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">java.util.Date</span>(t))(_.getTime)</pre>
  </div> 
  <p>Note that transformation breaks reference equality, so multiple instances of the same reference will be pickled separately. Transforming picklers can also be used in <code>CompositePickler</code> with the <code>addTransform</code> method.</p> 
  <p>For a full pickler you need to do as in the example below. It's optimizing encoding size by reusing the slot for identity reference for the string length.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">Custom</span>(<span class="pl-k">val</span> <span class="pl-en">name</span><span class="pl-k">:</span> <span class="pl-k">String</span>, <span class="pl-v">value</span>: <span class="pl-k">Int</span>)

<span class="pl-k">object</span> <span class="pl-en">MyCustomPicklers</span> <span class="pl-k">extends</span> <span class="pl-e">PicklerHelper</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">object</span> <span class="pl-en">customPickler</span> <span class="pl-k">extends</span> <span class="pl-e">P</span>[<span class="pl-en">Custom</span>] {
    <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">pickle</span>(<span class="pl-v">obj</span>: <span class="pl-en">Custom</span>)(<span class="pl-k">implicit</span> <span class="pl-v">state</span>: <span class="pl-en">PickleState</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
      state.identityRefFor(obj) <span class="pl-k">match</span> {
        <span class="pl-k">case</span> <span class="pl-en">Some</span>(idx) <span class="pl-k">=&gt;</span>
          state.enc.writeInt(<span class="pl-k">-</span>idx)
        <span class="pl-k">case</span> <span class="pl-c1">None</span> <span class="pl-k">=&gt;</span>
          <span class="pl-c">// writeString will write an Int with the string length that we can</span>
          <span class="pl-c">// put at same position as identity ref</span>
          state.enc.writeString(obj.name)
          state.enc.writeInt(obj.value)
          state.addIdentityRef(obj)
      }
    }

    <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">unpickle</span>(<span class="pl-k">implicit</span> <span class="pl-v">state</span>: <span class="pl-en">UnpickleState</span>)<span class="pl-k">:</span> <span class="pl-en">Custom</span> <span class="pl-k">=</span> {
      state.dec.readInt <span class="pl-k">match</span> {
        <span class="pl-k">case</span> idx <span class="pl-k">if</span> idx <span class="pl-k">&lt;</span> <span class="pl-c1">0</span> <span class="pl-k">=&gt;</span>
          state.identityFor[<span class="pl-en">Custom</span>](<span class="pl-k">-</span>idx)
        <span class="pl-k">case</span> len <span class="pl-k">=&gt;</span>
          <span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Custom</span>(state.dec.readString(len), state.dec.readInt)
          state.addIdentityRef(c)
          c
      }
    }
  }
}</pre>
  </div> 
  <p>In principle the pickler should do following things:</p> 
  <ul> 
   <li>check if the object has been pickled already using <code>state.identityRefFor(obj)</code> (if you want deduplication)</li> 
   <li>if yes, store an index to the reference (this also takes care of <code>null</code> values)</li> 
   <li>it not, encode the class using <code>state.enc</code> and/or calling picklers for members</li> 
   <li>if your class has a <code>length</code>, you can encode it in the same space as reference index by using a non-negative value</li> 
   <li>finally add the object to the identity reference</li> 
  </ul> 
  <p>If your object is immutable, you can use <code>immutableRefFor</code> and <code>addImmutableRef</code> instead for even more efficient encoding.</p> 
  <p>On the unpickling side you'll need to do following:</p> 
  <ul> 
   <li>read reference/length using <code>state.readInt</code></li> 
   <li>depending on the result, 
    <ul> 
     <li>get an existing reference</li> 
     <li>or use length to know how much to unpickle</li> 
    </ul></li> 
   <li>unpickle class members</li> 
   <li>finally add the reference to identity table</li> 
  </ul> 
  <h2><a id="user-content-exception-picklers" class="anchor" href="https://github.com/ochrons/boopickle#exception-picklers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Exception picklers</h2> 
  <p>BooPickle has special helpers to simplify pickling most common exception types. A call to <code>exceptionPickler</code> gives you a pickler that supports all the typical Java/Scala exceptions and you can then add your own custom exceptions with <code>addException</code>. The exception pickler is a <code>CompositePickler[Throwable]</code> so your exceptions should be presented as <code>Throwable</code> to pickling functions.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">exPickler</span> <span class="pl-k">=</span> exceptionPickler.addException[<span class="pl-en">MyException</span>](m <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">MyException</span>(m))

<span class="pl-k">val</span> <span class="pl-en">ex</span><span class="pl-k">:</span> <span class="pl-en">Throwable</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">IllegalArgumentException</span>(<span class="pl-s"><span class="pl-pds">"</span>No, no, no!<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">bb</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(ex)</pre>
  </div> 
  <p>Note that the basic <code>addException</code> mechanism only pickles the exception message, not any other fields. If you wish to pickle more fields, create transform picklers described above with the <code>addTransform</code> function. The same <code>CompositePickler</code> can contain both regular exception picklers and transform picklers.</p> 
  <h2><a id="user-content-optimizations-strategies" class="anchor" href="https://github.com/ochrons/boopickle#optimizations-strategies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Optimizations strategies</h2> 
  <h3><a id="user-content-buffer-pooling" class="anchor" href="https://github.com/ochrons/boopickle#buffer-pooling" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Buffer pooling</h3> 
  <p>When BooPickle codecs allocate <code>ByteBuffer</code>s they do it via <code>BufferProvider</code> classes. The default implementations for both heap and direct buffers utilize the <code>BufferPool</code> object for recycling buffers. Buffer providers automatically release intermediate <code>ByteBuffer</code>s back to the pool when their contents is copied to a new buffer. To improve pool performance, you should release buffers that are not used anymore by calling <code>BufferPool.release</code>. Only buffers allocated through the <code>BufferProvider</code> should be released to the pool.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoBytes(fruits)
<span class="pl-c">// send data to client</span>
...
<span class="pl-c">// release buffer back to pool</span>
<span class="pl-en">BufferPool</span>.release(data)</pre>
  </div> 
  <p>The pool has a maximum size to prevent it from locking down too much memory and it also only recycles relatively small buffers.</p> 
  <p>In a multi-threaded environment you may experience some slowdown if multiple threads are actively using <code>BufferPool</code>. In these cases it may make sense to disable pooling globally with <code>BufferPool.disable()</code>.</p> 
  <h3><a id="user-content-deduplication" class="anchor" href="https://github.com/ochrons/boopickle#deduplication" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Deduplication</h3> 
  <p>BooPickle supports deduplication of pickled case classes and strings. If you know your data won't have duplicates, you can enhance performance by disabling it by setting the <code>deduplicate</code> and <code>dedupImmutable</code> parameters in <code>PickleState</code> and <code>UnpickleState</code> constructors to <code>false</code>. The effect of deduplication is that when the same object is encountered again while pickling, only a reference is stored. When unpickling the reference is used instead of unpickling the object again. This saves space and enhances performance if your data contains a lot of copies of same objects.</p> 
  <p>There are two different methods of deduplication. First one compares object identities directly and the second compares object contents. The first one can be used for any objects but the second is safe to use only with immutable objects because only a single instance is created when unpickling and is used for all references. In the provided picklers immutable deduplication is used only for <code>String</code>s, but you can use it in your own picklers if you have immutable data that is duplicated a lot.</p> 
  <p>Note that deduplication can severely affect pickling performance (not that much unpickling), especially if you are pickling a lot of non-duplicated objects in one go.</p> 
  <p>To implicitly provide non-deduplicating <code>PickleState</code> and <code>UnpickleState</code>, use following code.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">pickleState</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">PickleState</span>(<span class="pl-k">new</span> <span class="pl-en">EncoderSize,</span> <span class="pl-c1">false</span>, <span class="pl-c1">false</span>)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">unpickleState</span> <span class="pl-k">=</span> (<span class="pl-v">bb</span>: <span class="pl-en">ByteBuffer</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">UnpickleState</span>(<span class="pl-k">new</span> <span class="pl-en">DecoderSize</span>(bb), <span class="pl-c1">false</span>, <span class="pl-c1">false</span>)</pre>
  </div> 
  <h3><a id="user-content-codecs" class="anchor" href="https://github.com/ochrons/boopickle#codecs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Codecs</h3> 
  <p>Originally BooPickle had a single codec optimized for both size and speed. From 1.2.0 onwards there are now two codecs, the original one optimized for size and a new codec optimized for speed (especially in the browser).</p> 
  <p>The speed oriented codec (<code>EncodeSpeed</code> and <code>DecodeSpeed</code>) works reliably only within a single application as it may dynamically choose different encoding methods based on the environment. You should therefore not use it in network communication.</p> 
  <p>The codec is chosen as part of building an instance of <code>PickleState</code> and <code>UnpickleState</code>, which implicitly chooses the size optimized codec by default. To override this you can either manually create the instances of pickle states, or define an implicit to override the defaults. For <code>UnpickleState</code> you need to define a function taking a <code>ByteBuffer</code> and returning an instance of <code>UnpickleState</code> as in the example below. This will then be used by the <code>Unpickle[A].fromBytes</code> function.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">pickleState</span><span class="pl-k">:</span> <span class="pl-en">PickleState</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">PickleState</span>(<span class="pl-k">new</span> <span class="pl-en">EncoderSpeed)</span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">unpickleState</span> <span class="pl-k">=</span> (<span class="pl-v">b</span>: <span class="pl-en">ByteBuffer</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">UnpickleState</span>(<span class="pl-k">new</span> <span class="pl-en">DecoderSpeed</span>(b))</pre>
  </div> 
  <h3><a id="user-content-tuning-bytebuffer-performance" class="anchor" href="https://github.com/ochrons/boopickle#tuning-bytebuffer-performance" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Tuning <code>ByteBuffer</code> performance</h3> 
  <p>In the browser BooPickle uses direct <code>ByteBuffer</code>s by default, as they perform much better. On the server JVM, however, heap buffers tend to be more efficient in many cases and are used by default. The <code>Encoder</code> constructor takes a <code>BufferProvider</code> argument and you can supply your own or use one of the two predefined ones: <code>DirectByteBufferProvider</code> and <code>HeapByteBufferProvider</code>. The <code>ByteBuffer</code>s <em>must</em> use little-endian ordering.</p> 
  <p>When serializing large objects, BooPickle encodes them into multiple separate <code>ByteBuffer</code>s that are combined (copied) in the call to <code>intoBytes</code>. If you can handle a sequence of buffers (for example sending them over the network), you can use <code>intoByteBuffers</code> instead, which will avoid duplicating the serialized data.</p> 
  <h2><a id="user-content-performance-testing" class="anchor" href="https://github.com/ochrons/boopickle#performance-testing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Performance testing</h2> 
  <p>As one of the main design goals of BooPickle was performance (both in execution speed as in data size), the project includes a sub-project for comparing BooPickle performance with other common pickling libraries available for Scala.js: uPickle, Prickle, Circe and Pushka. To access the performance tests, just switch to <code>perftestsJS</code> or <code>perftestsJVM</code> project.</p> 
  <p>On the JVM you can run the tests simply with the <code>run</code> command and the output will be shown in the SBT console. You might want to run the test at least twice to ensure JVM has optimized the code properly.</p> 
  <p>On the JS side, you'll need to use <code>fullOptJS</code> and <code>package</code> to compile the code into JavaScript and then run it in your browser at <a href="http://localhost:12345/perftests/js/target/scala-2.11/classes/index.html" target="_blank">http://localhost:12345/perftests/js/target/scala-2.11/classes/index.html</a> To ensure good results, run the tests at least twice in the browser.</p> 
  <p>Both tests provide similar output, although there are small differences in the Gzipped sizes due to the use of different libraries.</p> 
  <p>In the browser (BooPickle! is using the speed optimized codec with deduplication disabled):</p> 
  <pre><code>15/16 : Encoding Seq[Book] with numerical IDs
=============================================
Library    ops/s      %          size       %          size.gz    %
BooPickle  80880      41.8%      210        100%       193        100%
BooPickle! 193416     100.0%     402        191%       210        109%
Prickle    9172       4.7%       863        411%       272        141%
uPickle    19372      10.0%      680        324%       233        121%
Circe      10096      5.2%       680        324%       233        121%
Pushka     29176      15.1%      680        324%       233        121%

16/16 : Decoding Seq[Book] with numerical IDs
=============================================
Library    ops/s      %          size       %          size.gz    %
BooPickle  85156      100.0%     210        100%       193        100%
BooPickle! 73576      86.4%      402        191%       210        109%
Prickle    1704       2.0%       863        411%       272        141%
uPickle    8872       10.4%      680        324%       233        121%
Circe      7204       8.5%       680        324%       233        121%
Pushka     18044      21.2%      680        324%       233        121%
</code></pre> 
  <p>Under JVM:</p> 
  <pre><code>15/16 : Encoding Seq[Book] with numerical IDs
=============================================
Library    ops/s      %          size       %          size.gz    %
BooPickle  548684     57.6%      210        100%       188        100%
BooPickle! 951836     100.0%     402        191%       205        109%
Prickle    44360      4.7%       879        419%       276        147%
uPickle    139328     14.6%      680        324%       234        124%
Circe      52964      5.6%       680        324%       234        124%
Pushka     151672     15.9%      680        324%       234        124%

16/16 : Decoding Seq[Book] with numerical IDs
=============================================
Library    ops/s      %          size       %          size.gz    %
BooPickle  732512     96.2%      210        100%       188        100%
BooPickle! 761296     100.0%     402        191%       205        109%
Prickle    5308       0.7%       879        419%       276        147%
uPickle    88424      11.6%      680        324%       234        124%
Circe      66248      8.7%       680        324%       234        124%
Pushka     142252     18.7%      680        324%       234        124%
</code></pre> 
  <p>Performance test suite measures how many encode or decode operations the library can do in one second and also checks the size of the raw and gzipped output. Relative speed and size are shown as percentages (bigger is better for speed, smaller is better for size). Typically BooPickle is 4 to 10 times faster than JSON pickling libraries in decoding and 2 to 5 times faster in encoding.</p> 
  <h3><a id="user-content-custom-tests" class="anchor" href="https://github.com/ochrons/boopickle#custom-tests" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom tests</h3> 
  <p>You can define your own tests by modifying the <code>Tests.scala</code> and <code>TestData.scala</code> source files. Just look at the examples provided and model your own data (as realistically as possible) to see which library works best for you.</p> 
  <h2><a id="user-content-using-boopickle-with-ajax" class="anchor" href="https://github.com/ochrons/boopickle#using-boopickle-with-ajax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using BooPickle with Ajax</h2> 
  <p>For now, see <a href="https://github.com/ochrons/scalajs-spa-tutorial" target="_blank">SPA tutorial</a> for example usage.</p> 
  <h2><a id="user-content-what-is-it-good-for" class="anchor" href="https://github.com/ochrons/boopickle#what-is-it-good-for" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>What is it good for?</h2> 
  <p>BooPickle is not a very generic serialization library, so you should think carefully before using it in your application. Typical good and bad use cases are listed below.</p> 
  <table>
   <thead> 
    <tr> 
     <th>Good</th> 
     <th>Bad</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>Mobile client/server communication</td> 
     <td>Public API for your service</td> 
    </tr> 
    <tr> 
     <td>Data transfer over Websocket binary protocol</td> 
     <td>Data storage (you will lose it if something changes!)</td> 
    </tr> 
    <tr> 
     <td>Scala &lt;-&gt; Scala communication</td> 
     <td>Scala &lt;-&gt; some-other-language communication</td> 
    </tr> 
    <tr> 
     <td>Clients with limited resources</td> 
     <td>Communication between server components</td> 
    </tr> 
   </tbody>
  </table> 
  <h2><a id="user-content-known-limitations" class="anchor" href="https://github.com/ochrons/boopickle#known-limitations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Known limitations</h2> 
  <p>BooPickle is first and foremost focused on optimization of the pickled data. This gives you good performance and small data size, but at the same time it also makes the protocol extremely fragile. Unlike JSON, which can survive quite easily from additional or missing data, the binary format employed by BooPickle will explode violently with even the slightest of change. Debugging the output of BooPickle is also very hard, first because it's in binary and second because many data types use exotic coding to reduce the size. For example an <code>Int</code> can be 1 to 5 bytes long. Since there is no type information included in the coding it's quite impossible to determine the structure of the data just by looking at the binary output.</p> 
  <p>But because there is no type information, it is also possible to benefit from this. For example you can pickle a <code>Set[String]</code> but unpickle it as a <code>Vector[String]</code> because all collections use the same serialization format internally. Note, however, that this too is rather fragile, especially for empty collections that occur multiple times in the data.</p> 
  <p>If your data contains a lot of (non-repeating) strings, then BooPickle performance is not so hot (depending on browser) as it has to do UTF-8 coding itself. Several browsers provide a <code>TextDecoder</code> interface to do this efficiently, but it's still not as fast as with <code>JSON.parse</code>. On other browsers, BooPickle relies on Scala.js' implementation for coding UTF-8.</p> 
  <p>Under Scala.js BooPickle depends indirectly on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank">typed arrays</a> because direct <code>ByteBuffer</code>s are implemented with typed arrays. These may not be available on all JS platforms (most notably old Node.js, which has its own Buffers, and IE versions 9 and below). When testing code that uses BooPickle (and direct <code>ByteBuffer</code>s), make sure your tests are run under a recent version of Node.js as Rhino doesn't support typed arrays. Alternatively make sure your tests only use heap <code>ByteBuffer</code>s.</p> 
  <h2><a id="user-content-common-issues-with-bytebuffers" class="anchor" href="https://github.com/ochrons/boopickle#common-issues-with-bytebuffers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Common issues with ByteBuffers</h2> 
  <p>As many BooPickle users have run into issues with <code>ByteBuffers</code>, here is a bit of advice on how to work with them. If you need to get data out of a <code>ByteBuffer</code>, for example into an <code>Array[Byte]</code> the safest way is to use the <code>get(array: Array[Byte])</code> method. Even when the <code>ByteBuffer</code> is backed with an <code>Array[Byte]</code> and you could access that directly with <code>array()</code>, it's very easy to make mistakes with positions, array offsets and limits.</p> 
  <p>Reading values from a <code>ByteBuffer</code> commonly changes its internal state (the <code>position</code>), so you cannot treat it as identical to the original <code>ByteBuffer</code>. Similarly writing to one also changes its state. For example if you write data to a <code>ByteBuffer</code> and pass it as such to an unpickler, it will not work. You need to call <code>flip()</code> first to reset its <code>position</code>.</p> 
  <p>In BooPickle <code>ByteBuffer</code>s use little-endian ordering, which is not the default in the JVM, but is the native ordering in majority of target platforms. If you call <code>slice</code> or <code>duplicate</code> on buffers produced by BooPickle, they will default back to big-endian ordering. You must explicitly call <code>order(ByteOrder.LITTLE_ENDIAN)</code> to get them back to correct ordering.</p> 
  <p>For more information, please refer to the <a href="http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html" target="_blank">JDK documentation on ByteBuffers</a>.</p> 
  <h3><a id="user-content-using-bytebuffers-in-network-communication" class="anchor" href="https://github.com/ochrons/boopickle#using-bytebuffers-in-network-communication" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using ByteBuffers in network communication</h3> 
  <p>BooPickle is commonly used in client/server communication, so it is important to be able to use <code>ByteBuffer</code>s efficiently in the protocol. On the JVM side things are usually quite simple as many communication methods already accept <code>ByteBuffer</code> type directly. Sometimes you do need to convert the data into an <code>Array[Byte]</code> using following piece of code:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> <span class="pl-en">Array</span>.ofDim[<span class="pl-k">Byte</span>](buffer.remaining())
buffer.get(data)</pre>
  </div> 
  <p>Conversion in the other direction is trivial with the help of <code>ByteBuffer.wrap()</code> method.</p> 
  <p>On the JS side things are a bit more complicated due to the use of JavaScript <code>ArrayBuffer</code> underneath the <code>ByteBuffer</code>.</p> 
  <h2><a id="user-content-internal-details" class="anchor" href="https://github.com/ochrons/boopickle#internal-details" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Internal details</h2> 
  <h3><a id="user-content-efficient-coding" class="anchor" href="https://github.com/ochrons/boopickle#efficient-coding" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Efficient coding</h3> 
  <p>BooPickle makes assumptions of what kind of data it needs to encode, to reach high efficiency in typical scenarios. For example an <code>Int</code> (which takes 32-bits or 4 bytes) is encoded in 1-5 bytes depending on the value. The most common values (0-127) take only a single byte, whereas larger values require more bytes. Because very large integers take 5 bytes, if you know your data consists mainly of such values, you could specifically code them using <code>raw</code> format that always takes 32-bits. Similarly <code>Long</code>s are also coded in 1-9 bytes depending on the value.</p> 
  <p>In many situations there is a need to encode a length (of String, Seq, Map, etc.) and the efficient Int coding is used. But because a length/size is always non-negative, we can use negative integers to indicate other things. BooPickle supports coding multiple instances of the same object reference by using a reference value. The length value is reused to encode the reference by just flipping it into a negative value.</p> 
  <p>Note that when using the speed optimized codecs (<code>EncodeSpeed</code> and <code>DecodeSpeed</code>) some of these size optimizations are not used.</p> 
  <h3><a id="user-content-automatic-pickler-generation-with-macros" class="anchor" href="https://github.com/ochrons/boopickle#automatic-pickler-generation-with-macros" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Automatic pickler generation with macros</h3> 
  <p>Scala features powerful <a href="http://docs.scala-lang.org/overviews/macros/overview.html" target="_blank">macros</a> to help simplifying many mundane programming tasks. One such task is writing pickling functions for classes. Consider the simple case class below:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">foreName</span>: <span class="pl-k">String</span>, <span class="pl-v">lastName</span>: <span class="pl-k">String</span>, <span class="pl-v">email</span>: <span class="pl-k">String</span>, <span class="pl-v">birthYear</span>: <span class="pl-k">Int</span>)</pre>
  </div> 
  <p>To pickle this, you'd need to write following code:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">object</span> <span class="pl-en">PersonPickler</span> <span class="pl-k">extends</span> <span class="pl-e">Pickler</span>[<span class="pl-en">Person</span>] {
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">pickle</span>(<span class="pl-v">value</span>: <span class="pl-en">Person</span>)(<span class="pl-k">implicit</span> <span class="pl-v">state</span>: <span class="pl-en">PickleState</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    state.pickle(value.foreName)
    state.pickle(value.lastName)
    state.pickle(value.email)
    state.pickle(value.birthYear)
  }
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">unpickle</span>(<span class="pl-k">implicit</span> <span class="pl-v">state</span>: <span class="pl-en">UnpickleState</span>)<span class="pl-k">:</span> <span class="pl-en">Person</span> <span class="pl-k">=</span> {
    <span class="pl-en">Person</span>( 
      state.unpickle[<span class="pl-k">String</span>],
      state.unpickle[<span class="pl-k">String</span>],
      state.unpickle[<span class="pl-k">String</span>],
      state.unpickle[<span class="pl-k">Int</span>]
    )
  }
}</pre>
  </div> 
  <p>This would be very tedious, which is why practically all serialization libraries use either reflection or macros to automate this task. BooPickle being fully compatible with Scala.js, reflection is not an option, so macros it is. Programming macros in Scala is quite difficult, because it's a very recent addition to the Scala compiler and the documentation tends to be terse and somewhat cryptic. Also many examples found in the net are already obsolete or wrong if you use Scala 2.11. Best course of action is to look at existing macro code and try to deduce what's going on. Both uPickle and Prickle provided good base for BooPickle's macros.</p> 
  <p>The macro-generated picklers are provided by a separate trait to make sure they are the last resort the compiler turns to.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">MaterializePicklerFallback</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">generatePickler</span>[<span class="pl-en">T</span>]<span class="pl-k">:</span> <span class="pl-en">Pickler</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> macro <span class="pl-en">PicklerMaterializersImpl</span>.materializePickler[<span class="pl-en">T</span>]
}</pre>
  </div> 
  <p>If no other implicit pickler can be found, the compiler will call the <code>materializePickler</code> macro function in the hope of generating a suitable one.</p> 
  <p>The <a href="https://github.com/ochrons/boopickle/blob/master/boopickle/shared/src/main/scala/boopickle/PicklerMaterializersImpl.scala" target="_blank">macro code</a> starts by checking that the given type is valid for pickling (a sealed trait or a case class). Next step is building the code for pickling individual fields of the case class, which is surprisingly simple. Scala macros use a concept called quasiquotes (<code>q"""code goes here"""</code>) to easily generate code.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">accessors</span> <span class="pl-k">=</span> (tpe.decls collect {
  <span class="pl-k">case</span> <span class="pl-v">acc</span>: <span class="pl-en">MethodSymbol</span> <span class="pl-k">if</span> acc.isCaseAccessor <span class="pl-k">=&gt;</span> acc
}).toList

<span class="pl-k">val</span> <span class="pl-en">pickleFields</span> <span class="pl-k">=</span> <span class="pl-k">for</span> {
  accessor <span class="pl-k">&lt;</span><span class="pl-k">-</span> accessors
} <span class="pl-k">yield</span>
  q<span class="pl-s"><span class="pl-pds">"""</span>state.pickle(value.${accessor.name})<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Because there might be more than one instance of the case class in the structure we are pickling, additional code is generated to check for that and to store just a reference instead, if needed. For case objects, nothing(!) needs to be stored as they are identified by their type directly.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">pickleLogic</span> <span class="pl-k">=</span> <span class="pl-k">if</span> (sym.isModuleClass) 
    q<span class="pl-s"><span class="pl-pds">"""</span>()<span class="pl-pds">"""</span></span> 
  <span class="pl-k">else</span> q<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">    state.identityRefFor(value) match {</span>
<span class="pl-s">      case Some(idx) =&gt;</span>
<span class="pl-s">        state.enc.writeInt(-idx)</span>
<span class="pl-s">      case None =&gt;</span>
<span class="pl-s">        state.enc.writeInt(0)</span>
<span class="pl-s">        ..$pickleFields</span>
<span class="pl-s">        state.addIdentityRef(value)</span>
<span class="pl-s">    }</span>
<span class="pl-s">  <span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Finally an <code>implicit object</code> is generated to provide the <code>Pickler</code> instance.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> q<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  implicit object $name extends boopickle.Pickler[$tpe] {</span>
<span class="pl-s">    import boopickle._</span>
<span class="pl-s">    override def pickle(value: $tpe)(implicit state: PickleState): Unit = $pickleLogic</span>
<span class="pl-s">    override def unpickle(implicit state: UnpickleState): $tpe = $unpickleLogic</span>
<span class="pl-s">  }</span>
<span class="pl-s">  $name</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>That's it for generating a pickler for a case class! Unpickle logic generation is pretty much the same, check out the code for details.</p> 
  <p>BooPickle also supports automatic pickler generation for sealed class hierarchies and that functionality is also implemented by the macro. When the macro first checks if it's a trait, it will continue under a different code path than for case classes. Goal of the macro is to create a <code>CompositePickler</code> for the given trait so that all implementing classes are included.</p> 
  <p>First step is to make some sanity checks and then find all the known subclasses. This is why the trait must be <em>sealed</em> so that the compiler knows all subclasses and the macro can generate correct code. Next all found subclasses are mapped to <code>addConcreteType[$s]</code> code blocks that are embedded into a generated <code>CompositePickler</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>q<span class="pl-s"><span class="pl-pds">"""</span></span>
<span class="pl-s">  implicit object $name extends boopickle.CompositePickler[$tpe] {</span>
<span class="pl-s">    ..$concreteTypes</span>
<span class="pl-s">  }</span>
<span class="pl-s">  $name</span>
<span class="pl-s"><span class="pl-pds">"""</span></span></pre>
  </div> 
  <h3><a id="user-content-fast-utf-8-coding-in-the-browser" class="anchor" href="https://github.com/ochrons/boopickle#fast-utf-8-coding-in-the-browser" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Fast UTF-8 coding in the browser</h3> 
  <p>UTF-8 is pretty much the universal character coding format used in the web. For example JSON data is always coded in UTF-8 and naturally all browsers are very good and efficient at processing UTF-8 formatted text. But when you actually have to do UTF-8 encoding or decoding in JavaScript the situation is much worse. You can have strings and arrays of bytes, but regular JavaScript doesn't provide decent methods for converting between these two.</p> 
  <p>One option is to write your own UTF-8 codec and this is exactly what the Scala.js library provides. Its performance is not so great when compared to native JSON processing but it gets the job done. </p> 
  <p>Luckily there is a JavaScript extension known as <a href="https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder" target="_blank">TextEncoder</a>, which provides native speed encoding of UTF-8 (and some other formats, too). The <code>TextEncoder</code> (and <code>TextDecoder</code>) work with typed arrays (<code>Uint8Array</code> in this case) that are a high-performance alternative to basic JS arrays.</p> 
  <p>Because these interfaces are not available on all browsers, the string codec code must check for their availability and fall back to regular implementation if they are missing.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">TextEncoder</span> <span class="pl-k">extends</span> <span class="pl-e">js.Object</span> {
  <span class="pl-k">def</span> <span class="pl-en">encode</span>(<span class="pl-v">str</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">Uint8Array</span> <span class="pl-k">=</span> js.native
}

<span class="pl-k">private</span> <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">utf8encoder</span><span class="pl-k">:</span> (<span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">Int8Array</span> <span class="pl-k">=</span> {
  <span class="pl-k">val</span> <span class="pl-en">te</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">TextEncoder</span>
  <span class="pl-c">// use native TextEncoder</span>
  (<span class="pl-v">str</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">new</span> <span class="pl-en">Int8Array</span>(te.encode(str))
}

<span class="pl-k">def</span> <span class="pl-en">encodeUTF8</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">ByteBuffer</span> <span class="pl-k">=</span> {
  <span class="pl-k">if</span> (js.isUndefined(js.<span class="pl-en">Dynamic</span>.global.<span class="pl-en">TextEncoder</span>)) {
    <span class="pl-en">StandardCharsets</span>.<span class="pl-en">UTF_8</span>.encode(s)
  } <span class="pl-k">else</span> {
    <span class="pl-en">TypedArrayBuffer</span>.wrap(utf8encoder(s))
  }
}</pre>
  </div> 
  <h2><a id="user-content-change-history" class="anchor" href="https://github.com/ochrons/boopickle#change-history" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Change history</h2> 
  <p>See a separate <a href="https://github.com/ochrons/boopickle/blob/master/CHANGES.md" target="_blank">changes document</a></p> 
  <h2><a id="user-content-contributors" class="anchor" href="https://github.com/ochrons/boopickle#contributors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributors</h2> 
  <p>BooPickle was created and is maintained by <a href="https://github.com/ochrons" target="_blank">Otto Chrons</a> - <a href="mailto:otto@chrons.me" target="_blank">otto@chrons.me</a> - Twitter: <a href="https://twitter.com/ochrons" target="_blank">@ochrons</a>.</p> 
  <p>Special thanks to Li Haoyi and Ben Hutchison for their pickling libraries, which provided more than inspiration to BooPickle.</p> 
  <p>Contributors: @japgolly, @FlorianKirmaier, @guersam, @akshaal, @cquiroz</p> 
  <h2><a id="user-content-mit-license" class="anchor" href="https://github.com/ochrons/boopickle#mit-license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MIT License</h2> 
  <p>Copyright (c) 2015, Otto Chrons (<a href="mailto:otto@chrons.me" target="_blank">otto@chrons.me</a>)</p> 
  <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> 
  <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> 
  <p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p> 
 </article>
</div>