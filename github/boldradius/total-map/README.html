<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-total-map-023" class="anchor" href="https://github.com/boldradius/total-map#total-map-023" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>total-map 0.2.3</h1> 
  <h1></h1> 
  <p>Library providing <code>Total</code>, a map-like data structure that assigns a value to every possible key.</p> 
  <h2><a id="user-content-publications" class="anchor" href="https://github.com/boldradius/total-map#publications" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Publications</h2> 
  <p>Scala Symposium 2015 paper: Referential Integrity with Scala Types</p> 
  <ul> 
   <li>A link to a free copy is available from the conference page: <a href="http://lampwww.epfl.ch/%7Ehmiller/scala2015/" target="_blank">http://lampwww.epfl.ch/~hmiller/scala2015/</a></li> 
  </ul> 
  <p>Scala by the Bay 2015 presentation: Towards Reliable Lookups</p> 
  <ul> 
   <li>Slides: <a href="http://www.slideshare.net/Tindr/towards-reliable-lookups-scala-by-the-bay" target="_blank">http://www.slideshare.net/Tindr/towards-reliable-lookups-scala-by-the-bay</a></li> 
  </ul> 
  <h2><a id="user-content-introduction" class="anchor" href="https://github.com/boldradius/total-map#introduction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Introduction</h2> 
  <p>The <code>Total</code> type can be seen as a memoized function, but it is designed to be updated as a data structure.</p> 
  <p>Insertion and deletion will add or remove keys, and must therefore produce total maps that have different key types. The key type is therefore a type member of <code>Total</code> named <code>Id</code>.</p> 
  <p>Evolving the key types allows an application to <strong>statically enforce referential integrity</strong> between data structures: every reference from one into the other is valid, there are no dangling references. This can prevent error conditions such as 'post not found' or 'user not found'. The types themselves grow or shrink appropriately during the execution the application, forcing data structures indexed on these identifier types to be updated. Using <code>Total</code> allows an application to shift the burden of proof towards the functions that update maps and away from functions that access them.</p> 
  <h2><a id="user-content-example" class="anchor" href="https://github.com/boldradius/total-map#example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example:</h2> 
  <p>Let's say you have an application that maintains a collection of users, and would to refer to users by their ids. You could do</p> 
  <pre><code>case class UserId(v: Long)
val map : Map[UserId, User] = ???
val id : UserId = ???
</code></pre> 
  <p>but then we have no compiler enforced guarantee that any particular user id is defined in the map. A <code>UserId</code> may be a dangling reference within the map data structure.</p> 
  <p>If we want to prevent that, we can instead use a <code>Total</code> map. Now the solution would look like this:</p> 
  <pre><code>val total : Total[User] = ???
val id : total.Id = ???
</code></pre> 
  <p>Now we are guaranteed that the id, of type <code>total.Id</code>, has a corresponding <code>User</code> in <code>total</code>.</p> 
  <p>This way we can have data structures that enforce referential integrity. We can safely represent relations over dynamic sets. This can eliminate one more class of bugs from our applications.</p> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/boldradius/total-map#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>Add a resolver and the library dependency to your sbt project (this resolver type is built-in to sbt starting from 0.13.6):</p> 
  <pre><code>resolvers += Resolver.bintrayRepo("boldradiussolutions", "maven")

libraryDependencies += "com.boldradius" %% "total-map" % "0.2.3"
</code></pre> 
  <p>Then import the package. You will be able to reference the <code>Total</code> type, and its empty instance:</p> 
  <pre><code>import com.boldradius.total._

class Data(val sentences: Total[String] = Total.empty)
</code></pre> 
 </article>
</div>