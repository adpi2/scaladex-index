<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-introduction-to-maxmind-geoip2-scala" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#introduction-to-maxmind-geoip2-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Introduction to maxmind-geoip2-scala</h1> 
  <p>This is a simple Scala wrapper for the MaxMind GeoIP2-java library: <a href="http://maxmind.github.io/GeoIP2-java/" target="_blank">http://maxmind.github.io/GeoIP2-java/</a> Note that the GeoIP2 is still in beta.</p> 
  <p>This project is based on the <a href="https://github.com/snowplow/scala-maxmind-geoip" target="_blank">https://github.com/snowplow/scala-maxmind-geoip</a> from Snowplow!</p> 
  <h1><a id="user-content-installation" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h1> 
  <p>I suggest that you clone this repository and publish to local repository to be used in another project.</p> 
  <p><code>sbt +publish-local</code></p> 
  <p>After that, you can use it in your sbt by adding the following dependency:</p> 
  <p><code>libraryDependencies += "com.sanoma.cda" %% "maxmind-geoip2-scala" % "1.5.1"</code></p> 
  <p>You should also be able to generate a fat jar with Assembly. We chose not to include the data file into the jar as you should update that from time to time.</p> 
  <h1><a id="user-content-data" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#data" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Data</h1> 
  <p>Download (and unzip) data from here: <a href="http://dev.maxmind.com/geoip/geoip2/geolite2/" target="_blank">http://dev.maxmind.com/geoip/geoip2/geolite2/</a> <a href="http://geolite.maxmind.com/download/geoip/database/GeoLite2-City.mmdb.gz" target="_blank">http://geolite.maxmind.com/download/geoip/database/GeoLite2-City.mmdb.gz</a></p> 
  <h1><a id="user-content-running-tests" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#running-tests" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running tests</h1> 
  <p>Before running tests download the GeoLite2-City.mmdb. There is a script in src/test/resources to help you in that (the db must be in src/test/resources). Then just run tests with:</p> 
  <p><code>sbt +test</code></p> 
  <h1><a id="user-content-usage" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h1> 
  <p>Here is a simple usage example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geoip.</span><span class="pl-v">MaxMindIpGeo</span>
<span class="pl-k">val</span> <span class="pl-en">geoIp</span> <span class="pl-k">=</span> <span class="pl-en">MaxMindIpGeo</span>(<span class="pl-s"><span class="pl-pds">"</span>/data/MaxMind/GeoLite2-City.mmdb<span class="pl-pds">"</span></span>, <span class="pl-c1">1000</span>)
println(geoIp.getLocation(<span class="pl-s"><span class="pl-pds">"</span>123.123.123.123<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>If you are going to use this in multithreaded environment (like Spark), then you'd want to use the threaded version:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">geoIp</span> <span class="pl-k">=</span> <span class="pl-en">MaxMindIpGeo</span>(<span class="pl-s"><span class="pl-pds">"</span>/data/MaxMind/GeoLite2-City.mmdb<span class="pl-pds">"</span></span>, <span class="pl-c1">1000</span>, <span class="pl-k">synchronized</span> <span class="pl-k">=</span> <span class="pl-c1">true</span>)</pre>
  </div> 
  <p>If you know that the MaxMind Lite database has some problems in the areas that you are interested in, you can specify function that is used to filter the output. Here is an example for filtering out location field from the output: NOTE: this API changed a little since 1.4.x - now you can define function that transforms the IpLocation to new one or none.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geoip.</span><span class="pl-v">MaxMindIpGeo</span>
<span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geo.</span><span class="pl-v">Point</span>
<span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geoip.</span><span class="pl-v">IpLocation</span>
<span class="pl-k">val</span> <span class="pl-en">removeIncorrectLatLong</span><span class="pl-k">:</span> <span class="pl-en">MaxMindIpGeo</span>.<span class="pl-en">IpLocationFilter</span> <span class="pl-k">=</span> loc <span class="pl-k">=&gt;</span> {
  <span class="pl-k">val</span> <span class="pl-en">geoPointBlacklist</span> <span class="pl-k">=</span> <span class="pl-en">Set</span>(<span class="pl-en">Point</span>(<span class="pl-c1">39.9289</span>,<span class="pl-c1">116.3883</span>)) <span class="pl-c">// we "know" this is never correct</span>
  loc.geoPoint <span class="pl-k">match</span> {
    <span class="pl-c">// if we get a location, but it's on black list, we just remove it</span>
    <span class="pl-k">case</span> <span class="pl-en">Some</span>(p) <span class="pl-k">if</span> geoPointBlacklist.contains(p) <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(loc.copy(geoPoint <span class="pl-k">=</span> <span class="pl-c1">None</span>))
    <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(loc)
  }
}
<span class="pl-k">val</span> <span class="pl-en">geoIpWithoutFilter</span> <span class="pl-k">=</span> <span class="pl-en">MaxMindIpGeo</span>(<span class="pl-s"><span class="pl-pds">"</span>src/test/resources/GeoLite2-City.mmdb<span class="pl-pds">"</span></span>, <span class="pl-c1">1000</span>)
<span class="pl-k">val</span> <span class="pl-en">geoIpWithFilter</span> <span class="pl-k">=</span> <span class="pl-en">MaxMindIpGeo</span>(<span class="pl-s"><span class="pl-pds">"</span>src/test/resources/GeoLite2-City.mmdb<span class="pl-pds">"</span></span>, <span class="pl-c1">1000</span>, postFilterIpLocation <span class="pl-k">=</span> removeIncorrectLatLong)

<span class="pl-c">// now calling is exactly the same way</span>
println(geoIpWithoutFilter.getLocation(<span class="pl-s"><span class="pl-pds">"</span>123.123.123.123<span class="pl-pds">"</span></span>))
println(geoIpWithFilter.getLocation(<span class="pl-s"><span class="pl-pds">"</span>123.123.123.123<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>The postFilter is a function from IpLocation to Option[IpLocation] which means that you can also make it None if you believe that none of the information in it is correct.</p> 
  <h1><a id="user-content-geo-package" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#geo-package" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Geo-package</h1> 
  <p>Version 1.2 introduces geo package that contains some geo primitives as well as some algorithms. This is the first stab at the APIs to see if they are usefull, not completely thought out yet - comments are wellcome. The main motivation of these classes were to be able to do geo fencing to see if given point (latitude, longitude) from the MaxMind library falls inside some pre-defined area. Unfortunately, this slightly changed the API of the IpLocation class. Namely the tuple that previously held latitude and longitude was changed in Point. There are implicit conversions available between Tuple2 and Point though.</p> 
  <p>The classes of the Geo package are simple. The design started out as having no direct relation to geo coordinates and worked with any coordinate system. The main use cases that we have include relatively small areas that are far from the data boundary or the poles. However, there are 2 distance functions calculating the distance between 2 points on earth. These were introduced for the circle class - which is defined by having a radius in meters around center point that is expected to be in degrees.</p> 
  <p>The GeoAreaMap is designed to hold the different geo areas, such as the circles, rectangles and simple polygons. It can give the ID of the are that the given point belongs to. Note that it will always search the areas in the same order - so remember to give the most probable areas in the beginning of the list. The data structure will not optimize this by itself.</p> 
  <p>Here is an example of doing lookup using GeoAreaMap</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geo.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">turku</span> <span class="pl-k">=</span> <span class="pl-en">Point</span>(<span class="pl-c1">60.45</span>, <span class="pl-c1">22.25</span>)
<span class="pl-k">val</span> <span class="pl-en">helsinki</span> <span class="pl-k">=</span> <span class="pl-en">Point</span>(<span class="pl-c1">60.17</span>, <span class="pl-c1">24.94</span>)
<span class="pl-k">val</span> <span class="pl-en">tamminiemi</span> <span class="pl-k">=</span> <span class="pl-en">Point</span>(<span class="pl-c1">60.1892</span>,<span class="pl-c1">24.8838</span>)
<span class="pl-k">val</span> <span class="pl-en">mantyniemi</span> <span class="pl-k">=</span> <span class="pl-en">Point</span>(<span class="pl-c1">60.1844</span>,<span class="pl-c1">24.8968</span>)
<span class="pl-k">val</span> <span class="pl-en">hCircle</span> <span class="pl-k">=</span> <span class="pl-en">Circle</span>(helsinki, <span class="pl-c1">3500</span>) <span class="pl-c">// 3.5km around Helsinki</span>
<span class="pl-k">val</span> <span class="pl-en">tCircle</span> <span class="pl-k">=</span> <span class="pl-en">Circle</span>(tamminiemi, <span class="pl-c1">1000</span>)
<span class="pl-k">val</span> <span class="pl-en">hRectangle</span> <span class="pl-k">=</span> <span class="pl-en">Rectangle</span>(lowerLeft <span class="pl-k">=</span> (<span class="pl-c1">60.15</span>, <span class="pl-c1">24.84</span>), upperRight <span class="pl-k">=</span> (<span class="pl-c1">60.20</span>, <span class="pl-c1">25.00</span>))
<span class="pl-k">val</span> <span class="pl-en">aPoly</span> <span class="pl-k">=</span> <span class="pl-en">Polygon</span>(<span class="pl-en">List</span>((<span class="pl-c1">60.30</span>, <span class="pl-c1">24.88</span>), (<span class="pl-c1">60.34</span>, <span class="pl-c1">24.95</span>), (<span class="pl-c1">60.295</span>, <span class="pl-c1">25.02</span>)))

<span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>tamminiemi<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> tCircle, <span class="pl-s"><span class="pl-pds">"</span>helsinki<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> hCircle, <span class="pl-s"><span class="pl-pds">"</span>airport<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> aPoly, <span class="pl-s"><span class="pl-pds">"</span>hRect<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> hRectangle)
<span class="pl-k">val</span> <span class="pl-en">gmap</span> <span class="pl-k">=</span> <span class="pl-en">GeoAreaMap</span>.fromSeq(data)

gmap.get(turku) <span class="pl-c">// None</span>
gmap.get(mantyniemi) <span class="pl-c">// Some("tamminiemi")</span>
gmap.getAll(mantyniemi) <span class="pl-c">// List(tamminiemi, helsinki, hRect)</span></pre>
  </div> 
  <h1><a id="user-content-geohashing" class="anchor" href="https://github.com/sanoma-cda/maxmind-geoip2-scala#geohashing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Geohashing</h1> 
  <p>Geo-package now contains also basic Geohash encoding and decoding. For more information on Geohash, see <a href="https://en.wikipedia.org/wiki/Geohash" target="_blank">https://en.wikipedia.org/wiki/Geohash</a> and <a href="http://geohash.org/" target="_blank">http://geohash.org/</a>.</p> 
  <p>This is how you can use the geohashing functions</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geo.</span><span class="pl-v">_</span>
<span class="pl-en">Point</span>(<span class="pl-c1">45.0</span>,<span class="pl-c1">88.0</span>).geoHash          <span class="pl-c">// "tzyxfrzxuxgz"</span>
<span class="pl-en">Point</span>(<span class="pl-c1">45.0</span>,<span class="pl-c1">88.0</span>).geoHash(<span class="pl-c1">5</span>)       <span class="pl-c">// "tzyxf"</span>
<span class="pl-en">Point</span>.fromGeohash(<span class="pl-s"><span class="pl-pds">"</span>tzyxfrzxu<span class="pl-pds">"</span></span>)    <span class="pl-c">// Point(45.0,88.0)</span>

<span class="pl-k">import</span> <span class="pl-v">com.sanoma.cda.geo.GeoHash.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">p</span> <span class="pl-k">=</span> <span class="pl-en">Point</span>(<span class="pl-k">-</span><span class="pl-c1">53.876953125</span>, <span class="pl-k">-</span><span class="pl-c1">155.91796875</span>)
<span class="pl-k">val</span> <span class="pl-en">h</span> <span class="pl-k">=</span> encode(p)    <span class="pl-c">// 0w3j7zzzzzzz</span>
<span class="pl-k">val</span> <span class="pl-en">h6</span> <span class="pl-k">=</span> encode(p,<span class="pl-c1">6</span>) <span class="pl-c">// 0w3j7z</span>
decode(h)       <span class="pl-c">// Point(-53.8769532,-155.917969)</span>
decode(h6)      <span class="pl-c">// Point(-53.88,-155.92)</span>
decodeFully(h6) <span class="pl-c">// (-53.87969970703125,-155.9234619140625,0.00274658203125,0.0054931640625)</span></pre>
  </div> 
  <p>About the geohash implementation in this Scala library: There are a few libraries for geohashing for different languages. Before this, there was no Scala package around, but there were a few Java-versions which could have been used. Unfortunately many of the packages gave slightly different answers when I tested them. Therefore I ended up writing scala version from scratch. Unfortunately, Geohash doesn't seem to have any reliable reference implementation or pseudo code available. This package contains some tests against Geohash.org. After getting frustrated for not being able to match results from geohash.org, this code was mostly rewritten after one of the Python versions. There I noticed that Python and Scala round differently and thus concluded that some of the differences agains geohash.org are due different roundings. But as there is no reference, I chose to continue with the JVM rounding and adjusted the tests. Also, it is notable that the geohash.org is clearly wrong in some cases. As an example, geohash.org decodes this <a href="http://geohash.org/u26r" target="_blank">http://geohash.org/u26r</a> and <a href="http://geohash.org/u26q" target="_blank">http://geohash.org/u26q</a> to the same coordinates, which is clearly wrong.</p> 
  <p>It also seems that they round coordinates probably wrongly or at least to the way the rounding is specified on the Wikipedia page. See this example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// Geohash.org decodes "uuxz" to 72.0,45.0</span>
<span class="pl-k">val</span> <span class="pl-en">full</span> <span class="pl-k">=</span> decodeFully(<span class="pl-s"><span class="pl-pds">"</span>uuxz<span class="pl-pds">"</span></span>) <span class="pl-c">// (71.630859375,44.82421875,0.087890625,0.17578125)</span>
<span class="pl-c">// latitude should be between these:</span>
full._1 <span class="pl-k">+</span> full._3 <span class="pl-c">// 71.71875</span>
full._1 <span class="pl-k">-</span> full._3 <span class="pl-c">// 71.54296875</span>
<span class="pl-c">// But latitude from geohash.org does not fall in that range </span></pre>
  </div> 
  <p>However, having said all that, this version is also not fully tested. Please do your own testing and create issues if doesn't seem right.</p> 
 </article>
</div>