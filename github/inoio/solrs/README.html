<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-solrs---async-solr-client-for-javascala" class="anchor" href="https://github.com/inoio/solrs#solrs---async-solr-client-for-javascala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>solrs - async solr client for java/scala</h1> 
  <p><a href="https://travis-ci.org/inoio/solrs" target="_blank"><img src="https://camo.githubusercontent.com/440a77136f7d680c7534bb0cc1a9c0f463c28e58/68747470733a2f2f7472617669732d63692e6f72672f696e6f696f2f736f6c72732e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/inoio/solrs.png?branch=master" style="max-width:100%;"></a> <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22io.ino%22%20AND%20a%3Asolrs*_2.11" target="_blank"><img src="https://camo.githubusercontent.com/e1ee2a580acd35615b642c01cc15cdf3a29ac176/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f696f2e696e6f2f736f6c72735f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/io.ino/solrs_2.11/badge.svg" style="max-width:100%;"></a> <a href="https://gitter.im/inoio/solrs" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/inoio/solrs" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a></p> 
  <p>This is a java/scala solr client providing a query interface like SolrJ, just asynchronously / non-blocking (built on top of <a href="https://github.com/AsyncHttpClient/async-http-client" target="_blank">async-http-client</a> / <a href="https://github.com/netty/netty" target="_blank">netty</a>). For java it supports <code>CompletableFuture</code>, for scala you can choose between twitter's <code>Future</code> or the standard/SDK <code>Future</code>.</p> 
  <h2><a id="user-content-contents" class="anchor" href="https://github.com/inoio/solrs#contents" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contents</h2> 
  <ul> 
   <li><a href="https://github.com/inoio/solrs#installation" target="_blank">Installation</a></li> 
   <li><a href="https://github.com/inoio/solrs#usage" target="_blank">Usage</a> 
    <ul> 
     <li><a href="https://github.com/inoio/solrs#load-balancing" target="_blank">Load Balancing</a></li> 
     <li><a href="https://github.com/inoio/solrs#solr-cloud--zookeeper-support" target="_blank">Solr Cloud / ZooKeeper Support</a></li> 
     <li><a href="https://github.com/inoio/solrs#retry-policy" target="_blank">Retry Policy</a></li> 
     <li><a href="https://github.com/inoio/solrs#request-interception--filtering" target="_blank">Request Interception / Filtering</a></li> 
     <li><a href="https://github.com/inoio/solrs#metrics" target="_blank">Metrics</a></li> 
    </ul></li> 
   <li><a href="https://github.com/inoio/solrs#license" target="_blank">License</a></li> 
  </ul> 
  <h2><a id="user-content-installation" class="anchor" href="https://github.com/inoio/solrs#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h2> 
  <p>You must add the library to the dependencies of the build file, e.g. add to <code>build.sbt</code>:</p> 
  <pre><code>libraryDependencies += "io.ino" %% "solrs" % "2.0.0-RC2"
</code></pre> 
  <p>or for java projects to pom.xml:</p> 
  <pre><code>&lt;dependency&gt;
  &lt;groupId&gt;io.ino&lt;/groupId&gt;
  &lt;artifactId&gt;solrs_2.12&lt;/artifactId&gt;
  &lt;version&gt;2.0.0-RC2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
  <p>solrs is published to maven central for both scala 2.11 and 2.12.</p> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/inoio/solrs#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>Solrs supports different <code>Future</code> implementations, which affects the result type of <code>AsyncSolrClient.query</code>. For scala there's support for the standard <code>scala.concurrent.Future</code> and for twitters <code>com.twitter.util.Future</code>. Which one is chosen is defined by the <code>io.ino.solrs.future.FutureFactory</code> that's in scope when building the <code>AsyncSolrClient</code> (as shown below in the code samples).</p> 
  <p>For java there's support for <code>CompletableFuture</code>. Because java does not support higher kinded types there's a separate class <code>JavaAsyncSolrClient</code> that allows to create new instances and to perform a <code>query</code>.</p> 
  <p>In the following it's shown how to use <code>JavaAsyncSolrClient</code>/<code>AsyncSolrClient</code>:</p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.JavaAsyncSolrClient</span>;
<span class="pl-k">import</span> <span class="pl-smi">org.apache.solr.client.solrj.SolrQuery</span>;
<span class="pl-k">import</span> <span class="pl-smi">org.apache.solr.client.solrj.response.QueryResponse</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.concurrent.CompletionStage</span>;

<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>);
<span class="pl-k">CompletionStage&lt;<span class="pl-smi">QueryResponse</span>&gt;</span> response <span class="pl-k">=</span> solr<span class="pl-k">.</span>query(<span class="pl-k">new</span> <span class="pl-smi">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>java<span class="pl-pds">"</span></span>));
response<span class="pl-k">.</span>thenAccept(r <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-smi">System</span><span class="pl-k">.</span>out<span class="pl-k">.</span>println(<span class="pl-s"><span class="pl-pds">"</span>found <span class="pl-pds">"</span></span> <span class="pl-k">+</span> r<span class="pl-k">.</span>getResults()<span class="pl-k">.</span>getNumFound() <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> docs<span class="pl-pds">"</span></span>));

<span class="pl-c"><span class="pl-c">//</span> At EOL...</span>
solr<span class="pl-k">.</span>shutdown();</pre>
  </div> 
  <p>[scala/SDK]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">AsyncSolrClient</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit </span><span class="pl-c"><span class="pl-c">//</span> or TwitterFutureFactory</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.solr.client.solrj.response.</span><span class="pl-v">QueryResponse</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.solr.client.solrj.</span><span class="pl-v">SolrQuery</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>

<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">response</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">QueryResponse</span>] <span class="pl-k">=</span> solr.query(<span class="pl-k">new</span> <span class="pl-en">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>scala<span class="pl-pds">"</span></span>))
response.foreach {
  qr <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>found ${qr.getResults.getNumFound} docs<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> Don't forget...</span>
solr.shutdown()</pre>
  </div> 
  <p>[scala/twitter]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">AsyncSolrClient</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.TwitterFutureFactory.</span><span class="pl-v">Implicit</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.solr.client.solrj.</span><span class="pl-v">SolrQuery</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.solr.client.solrj.response.</span><span class="pl-v">QueryResponse</span>
<span class="pl-k">import</span> <span class="pl-v">com.twitter.util.</span><span class="pl-v">Future</span>

<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">response</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">QueryResponse</span>] <span class="pl-k">=</span> solr.query(<span class="pl-k">new</span> <span class="pl-en">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>scala<span class="pl-pds">"</span></span>))
response.onSuccess {
  qr <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>found ${qr.getResults.getNumFound} docs<span class="pl-pds">"</span></span>)
}

<span class="pl-c"><span class="pl-c">//</span> Finally...</span>
solr.shutdown()</pre>
  </div> 
  <p>The <code>AsyncSolrClient</code> can further be configured with an <code>AsyncHttpClient</code> instance and the response parser via the <code>AsyncSolrClient.Builder</code> (other configuration properties are described in greater detail below):</p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.JavaAsyncSolrClient</span>;
<span class="pl-k">import</span> <span class="pl-smi">org.apache.solr.client.solrj.impl.XMLResponseParser</span>;
<span class="pl-k">import</span> <span class="pl-smi">org.asynchttpclient.DefaultAsyncHttpClient</span>;

<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>builder(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>)
            .withHttpClient(<span class="pl-k">new</span> <span class="pl-smi">DefaultAsyncHttpClient</span>())
            .withResponseParser(<span class="pl-k">new</span> <span class="pl-smi">XMLResponseParser</span>())
            .build();</pre>
  </div> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">AsyncSolrClient</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.solr.client.solrj.impl.</span><span class="pl-v">XMLResponseParser</span>
<span class="pl-k">import</span> <span class="pl-v">org.asynchttpclient.</span><span class="pl-v">DefaultAsyncHttpClient</span>

<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>)
            .withHttpClient(<span class="pl-k">new</span> <span class="pl-en">DefaultAsyncHttpClient</span>())
            .withResponseParser(<span class="pl-k">new</span> <span class="pl-en">XMLResponseParser</span>())
            .build</pre>
  </div> 
  <h3><a id="user-content-load-balancing" class="anchor" href="https://github.com/inoio/solrs#load-balancing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Load Balancing</h3> 
  <p>Solrs supports load balancing of queries over multiple solr servers. There are 2 load balancers provided out of the box, a simple round robin LB and statistics based LB that selects the "fastest" server. If none of them is suitable for you, of course you can write your own load balancer by implementing <code>io.ino.solrs.LoadBalancer</code>.</p> 
  <h4><a id="user-content-round-robin-load-balancer" class="anchor" href="https://github.com/inoio/solrs#round-robin-load-balancer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Round Robin Load Balancer</h4> 
  <p>The <code>RoundRobinLB</code> is a simple round robin load balancer. It load balances over a given list of solr server urls (if statically known), alternatively you can provide a <code>SolrServers</code> instance, which allows runtime resolution of solr server urls, e.g. by reading them from ZooKeeper (see <a href="https://github.com/inoio/solrs#solr-cloud-support" target="_blank">Solr Cloud Support</a> for more details).</p> 
  <p>To run solrs with a <code>RoundRobinLB</code> you have to pass it to the <code>Builder</code></p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.*</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Arrays</span>;

<span class="pl-smi">RoundRobinLB</span> lb <span class="pl-k">=</span> <span class="pl-smi">RoundRobinLB</span><span class="pl-k">.</span>create(<span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>http://localhost:8984/solr/collection1<span class="pl-pds">"</span></span>));
<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>builder(lb)<span class="pl-k">.</span>build();</pre>
  </div> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>

<span class="pl-k">val</span> <span class="pl-en">lb</span> <span class="pl-k">=</span> <span class="pl-en">RoundRobinLB</span>(<span class="pl-en">IndexedSeq</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>http://localhost:8984/solr/collection1<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(lb).build</pre>
  </div> 
  <h4><a id="user-content-fastest-server-load-balancer" class="anchor" href="https://github.com/inoio/solrs#fastest-server-load-balancer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Fastest Server Load Balancer</h4> 
  <p>The <code>FastestServerLB</code> is a statistics based load balancer that classifies servers as "fast" and "slow" servers (based on their latest average response time) and selects one of the "fast" servers (round robin) when asked for one. This is useful e.g. when some solr server is currently performing major GC, or when for some nodes network latency is increased (temporary or permanent).</p> 
  <p>The latest average response time is determined in the following order (the first found measure is used):</p> 
  <ol> 
   <li>currently still running requests (if they're lasting longer than previous, already completed requests)</li> 
   <li>average response time of the current or the previous second</li> 
   <li>average response time of the last ten seconds</li> 
   <li>total average resonse time</li> 
  </ol> 
  <p>The response time is measured using a configured test query (per collection). A dedicated test query is used, because user queries can have very different performance characteristics, so that most often it would even be hard for an application to classify them. With the dedicated test query you can control what is used to measure response time.</p> 
  <p>Servers are considered "fast" when the response time is &lt;= the average response time of all servers. This is the default, you can also override this (by specifying a <code>filterFastServers</code> function).</p> 
  <p>Because nobody likes log spamming and burning CPU time while everybody else is sleeping, the test query is not executed with a fixed rate.<br> For "fast" servers test queries are run whenever a request comes in, with a lower bound of <code>minDelay</code> (default: 100 millis). With high traffic this leads to high resolution statistics so that e.g. sub-second GC pauses should be detected.<br> For "slow" servers (response time &gt; average) tests are run with a fixed <code>maxDelay</code> (default: 10 seconds), this is also the case for "fast" servers when there are no users queries in the meantime.</p> 
  <p>To have initial stats, after the <code>FastestServerLB</code> was created it runs the test queries several times (default: 10). This can be overridden with <code>initialTestRuns</code>.</p> 
  <p><code>FastestServerLB</code> also exports stats via JMX (under object name <code>io.ino.solrs:type=FastestServerLB</code>), in case you're interested in this.</p> 
  <p>Here's a code sample of the <code>FastestServerLB</code>:</p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.*</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Arrays</span>;
<span class="pl-k">import</span> <span class="pl-smi">scala.Tuple2</span>;
<span class="pl-k">import static</span> <span class="pl-smi">java.util.concurrent.TimeUnit.*</span>;

<span class="pl-smi">StaticSolrServers</span> servers <span class="pl-k">=</span> <span class="pl-smi">StaticSolrServers</span><span class="pl-k">.</span>create(<span class="pl-smi">Arrays</span><span class="pl-k">.</span>asList(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>http://localhost:8984/solr/collection1<span class="pl-pds">"</span></span>));
<span class="pl-k">Tuple2&lt;<span class="pl-smi">String</span>, <span class="pl-smi">SolrQuery</span>&gt;</span> col1TestQuery <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">Tuple2&lt;&gt;</span>(<span class="pl-s"><span class="pl-pds">"</span>collection1<span class="pl-pds">"</span></span>, <span class="pl-k">new</span> <span class="pl-smi">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>*:*<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>setRows(<span class="pl-c1">0</span>));
<span class="pl-k">Function&lt;<span class="pl-smi">SolrServer</span>, <span class="pl-k">Tuple2&lt;<span class="pl-smi">String</span>, <span class="pl-smi">SolrQuery</span>&gt;</span>&gt;</span> collectionAndTestQuery <span class="pl-k">=</span> server <span class="pl-k">-</span><span class="pl-k">&gt;</span> col1TestQuery;
<span class="pl-k">FastestServerLB&lt;?&gt;</span> lb <span class="pl-k">=</span> <span class="pl-smi">FastestServerLB</span><span class="pl-k">.</span>builder(servers, collectionAndTestQuery)
    .withMinDelay(<span class="pl-c1">50</span>, <span class="pl-c1">MILLISECONDS</span>)
    .withMaxDelay(<span class="pl-c1">5</span>, <span class="pl-c1">SECONDS</span>)
    .withInitialTestRuns(<span class="pl-c1">50</span>)
    .build();
<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>builder(lb)<span class="pl-k">.</span>build();</pre>
  </div> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">lb</span> <span class="pl-k">=</span> {
  <span class="pl-k">val</span> <span class="pl-en">servers</span> <span class="pl-k">=</span> <span class="pl-en">StaticSolrServers</span>(<span class="pl-en">IndexedSeq</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>http://localhost:8984/solr/collection1<span class="pl-pds">"</span></span>))
  <span class="pl-k">val</span> <span class="pl-en">col1TestQuery</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>collection1<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-k">new</span> <span class="pl-en">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>*:*<span class="pl-pds">"</span></span>).setRows(<span class="pl-c1">0</span>)
  <span class="pl-k">def</span> <span class="pl-en">collectionAndTestQuery</span>(<span class="pl-v">server</span>: <span class="pl-en">SolrServer</span>) <span class="pl-k">=</span> col1TestQuery
  <span class="pl-k">new</span> <span class="pl-en">FastestServerLB</span>(servers, collectionAndTestQuery, minDelay <span class="pl-k">=</span> <span class="pl-c1">50</span> millis, maxDelay <span class="pl-k">=</span> <span class="pl-c1">5</span> seconds, initialTestRuns <span class="pl-k">=</span> <span class="pl-c1">50</span>)
}
<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(lb).build</pre>
  </div> 
  <h3><a id="user-content-solr-cloud--zookeeper-support" class="anchor" href="https://github.com/inoio/solrs#solr-cloud--zookeeper-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Solr Cloud / ZooKeeper Support</h3> 
  <p>Solr Cloud is supported by <code>io.ino.solrs.CloudSolrServers</code>, which is a <code>SolrServers</code> implementation (can be passed to <code>RoundRobinLB</code>/<code>FastestServerLB</code>).</p> 
  <p>Solr Cloud is supported with the following properties / restrictions:</p> 
  <ul> 
   <li>No Shard Support (yet, please raise an issue or submit a pull request)</li> 
   <li>No Collection Aliases supported (a PR's welcome)</li> 
   <li>Can use a default collection, if this is not provided, per request the <code>SolrQuery</code> must specify the collection via the "collection" parameter.</li> 
   <li>New solr servers or solr servers that changed their state from inactive (e.g. down) to active can be tested with warmup queries before they're used for load balancing queries, for this a <code>WarmupQueries</code> instance can be set.</li> 
   <li>Querying solr is possible when ZooKeeper is temporarily not available</li> 
   <li>Construction of <code>CloudSolrServers</code> is possible while ZooKeeper is not available. When ZK becomes available <code>CloudSolrServers</code> will be connected to ZK. As interval for trying to connect the <code>CloudSolrServers.zkConnectTimeout</code> property is (re)used (10 seconds by default). Connection is tried "forever", but of course this does not prevent <code>CloudSolrServers</code> or <code>AsyncSolrClient</code> to be shutdown.</li> 
   <li>Construction of <code>CloudSolrServers</code> is possible when no solr instances are known by ZK. When solr servers have registered at ZK, <code>CloudSolrServers</code> will notice this. As retry interval the <code>CloudSolrServers.clusterStateUpdateInterval</code> property is (re)used (1 second by default).</li> 
   <li>ZK cluster state updates are read using the <code>CloudSolrServers.clusterStateUpdateInterval</code>.</li> 
  </ul> 
  <p>To run solrs connected to SolrCloud / ZooKeeper, you pass an instance of <code>CloudSolrServers</code> to <code>RoundRobinLB</code>/<code>FastestServerLB</code>. The simplest case looks like this:</p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.*</span>;

<span class="pl-k">CloudSolrServers&lt;?&gt;</span> servers <span class="pl-k">=</span> <span class="pl-smi">CloudSolrServers</span><span class="pl-k">.</span>builder(<span class="pl-s"><span class="pl-pds">"</span>localhost:2181<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>build();
<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>builder(<span class="pl-k">new</span> <span class="pl-smi">RoundRobinLB</span>(servers))<span class="pl-k">.</span>build();</pre>
  </div> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>

<span class="pl-k">val</span> <span class="pl-en">servers</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CloudSolrServers</span>(<span class="pl-s"><span class="pl-pds">"</span>localhost:2181<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(<span class="pl-en">RoundRobinLB</span>(servers)).build</pre>
  </div> 
  <p>Here's an example that shows all configuration properties in use:</p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.*</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Collections</span>;
<span class="pl-k">import static</span> <span class="pl-smi">java.util.concurrent.TimeUnit.*</span>;

<span class="pl-k">CloudSolrServers&lt;?&gt;</span> servers <span class="pl-k">=</span> <span class="pl-smi">CloudSolrServers</span><span class="pl-k">.</span>builder(<span class="pl-s"><span class="pl-pds">"</span>host1:2181,host2:2181<span class="pl-pds">"</span></span>)
    .withZkClientTimeout(<span class="pl-c1">15</span>, <span class="pl-c1">SECONDS</span>)
    .withZkConnectTimeout(<span class="pl-c1">10</span>, <span class="pl-c1">SECONDS</span>)
    .withClusterStateUpdateInterval(<span class="pl-c1">1</span>, <span class="pl-c1">SECONDS</span>)
    .withDefaultCollection(<span class="pl-s"><span class="pl-pds">"</span>collection1<span class="pl-pds">"</span></span>)
    .withWarmupQueries((collection) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-smi">Collections</span><span class="pl-k">.</span>singletonList(<span class="pl-k">new</span> <span class="pl-smi">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>*:*<span class="pl-pds">"</span></span>)), <span class="pl-c1">10</span>)
    .build();
<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>builder(<span class="pl-k">new</span> <span class="pl-smi">RoundRobinLB</span>(servers))<span class="pl-k">.</span>build();</pre>
  </div> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">servers</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CloudSolrServers</span>(
    zkHost <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>host1:2181,host2:2181<span class="pl-pds">"</span></span>,
    zkClientTimeout <span class="pl-k">=</span> <span class="pl-c1">15</span> seconds,
    zkConnectTimeout <span class="pl-k">=</span> <span class="pl-c1">10</span> seconds,
    clusterStateUpdateInterval <span class="pl-k">=</span> <span class="pl-c1">1</span> second,
    defaultCollection <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>collection1<span class="pl-pds">"</span></span>),
    warmupQueries <span class="pl-k">=</span> <span class="pl-en">WarmupQueries</span>(<span class="pl-s"><span class="pl-pds">"</span>collection1<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span> <span class="pl-en">Seq</span>(<span class="pl-k">new</span> <span class="pl-en">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>*:*<span class="pl-pds">"</span></span>)), count <span class="pl-k">=</span> <span class="pl-c1">10</span>))
<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(<span class="pl-en">RoundRobinLB</span>(servers)).build</pre>
  </div> 
  <p>Remember to either specify a default collection (as shown above) or set the collection to use per query:</p> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.apache.solr.client.solrj.</span><span class="pl-v">SolrQuery</span>

<span class="pl-k">val</span> <span class="pl-en">query</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SolrQuery</span>(<span class="pl-s"><span class="pl-pds">"</span>scala<span class="pl-pds">"</span></span>).setParam(<span class="pl-s"><span class="pl-pds">"</span>collection<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>collection1<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">response</span> <span class="pl-k">=</span> solr.query(query)
</pre>
  </div> 
  <p>When running SolrCloud you should also configure a retry policy (<code>RetryPolicy.TryAvailableServers</code> to be concrete), because restarts of solr nodes are not that fast registered by ZooKeeper (and therefore also not by our <code>CloudSolrServers</code>), so that for a short period of time queries might be failing because a solr node just became not available.</p> 
  <h3><a id="user-content-retry-policy" class="anchor" href="https://github.com/inoio/solrs#retry-policy" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Retry Policy</h3> 
  <p>For the case that a request fails <code>AsyncColrClient</code> allows to configure a <code>RetryPolicy</code>. The following are currently provided (you can implement your own of course):</p> 
  <ul> 
   <li><code>RetryPolicy.TryOnce</code>: Don't retry at all</li> 
   <li><code>RetryPolicy.TryAvailableServers</code>: Try all servers by fetching the next server from the <code>LoadBalancer</code>. When requests for all servers failed, the last failure is propagated to the client.</li> 
   <li><code>RetryPolicy.AtMost(times: Int)</code>: Retries the given number of times.</li> 
  </ul> 
  <p>The retry policy can be configured via the <code>Builder</code>, like this:</p> 
  <p>[java]</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">import</span> <span class="pl-smi">io.ino.solrs.*</span>;

<span class="pl-smi">JavaAsyncSolrClient</span> solr <span class="pl-k">=</span> <span class="pl-smi">JavaAsyncSolrClient</span><span class="pl-k">.</span>builder(<span class="pl-k">new</span> <span class="pl-smi">RoundRobinLB</span>(<span class="pl-smi">CloudSolrServers</span><span class="pl-k">.</span>builder(<span class="pl-s"><span class="pl-pds">"</span>host1:2181,host2:2181<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>build()))
    .withRetryPolicy(<span class="pl-smi">RetryPolicy</span><span class="pl-k">.</span>TryAvailableServers())
    .build();</pre>
  </div> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>

<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(<span class="pl-en">RoundRobinLB</span>(<span class="pl-k">new</span> <span class="pl-en">CloudSolrServers</span>(<span class="pl-s"><span class="pl-pds">"</span>host1:2181,host2:2181<span class="pl-pds">"</span></span>)))
    .withRetryPolicy(<span class="pl-en">RetryPolicy</span>.<span class="pl-en">TryAvailableServers</span>)
    .build</pre>
  </div> 
  <p>There's not yet support for delaying retries, raise an issue or submit a pull request for this if you need it.</p> 
  <h3><a id="user-content-request-interception--filtering" class="anchor" href="https://github.com/inoio/solrs#request-interception--filtering" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Request Interception / Filtering</h3> 
  <p>Solrs allows to intercept queries sent to Solr, here's an example that shows how to log details about each request:</p> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>

<span class="pl-k">val</span> <span class="pl-en">loggingInterceptor</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RequestInterceptor</span> {
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">interceptQuery</span>(<span class="pl-v">f</span>: (<span class="pl-en">SolrServer</span>, <span class="pl-en">SolrQuery</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-en">QueryResponse</span>])
                             (<span class="pl-v">solrServer</span>: <span class="pl-en">SolrServer</span>, <span class="pl-v">q</span>: <span class="pl-en">SolrQuery</span>)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">QueryResponse</span>] <span class="pl-k">=</span> {
    <span class="pl-k">val</span> <span class="pl-en">start</span> <span class="pl-k">=</span> <span class="pl-en">System</span>.currentTimeMillis()
    f(solrServer, q).map { qr <span class="pl-k">=&gt;</span>
      <span class="pl-k">val</span> <span class="pl-en">requestTime</span> <span class="pl-k">=</span> <span class="pl-en">System</span>.currentTimeMillis() <span class="pl-k">-</span> start
      logger.info(s<span class="pl-s"><span class="pl-pds">"</span>Query $q to $solrServer took $requestTime ms (query time in solr: ${qr.getQTime} ms).<span class="pl-pds">"</span></span>)
      qr
    }
  }
}

<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>)
             .withRequestInterceptor(loggingInterceptor).build</pre>
  </div> 
  <h3><a id="user-content-metrics" class="anchor" href="https://github.com/inoio/solrs#metrics" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Metrics</h3> 
  <p>There's basic metrics support for request timings and number of exceptions. You can provide your own implementation of <code>io.ino.solrs.Metrics</code> or use the <code>CodaHaleMetrics</code> class shipped with solrs if you're happy with this great <a href="http://metrics.codahale.com/" target="_blank">metrics library</a> :-)</p> 
  <p>To configure solrs with the <code>Metrics</code> implementation just pass an initialized instance like this:</p> 
  <p>[scala]</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.ino.solrs.future.ScalaFutureFactory.</span><span class="pl-v">Implicit</span>

<span class="pl-k">val</span> <span class="pl-en">solr</span> <span class="pl-k">=</span> <span class="pl-en">AsyncSolrClient</span>.<span class="pl-en">Builder</span>(<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8983/solr/collection1<span class="pl-pds">"</span></span>)
             .withMetrics(<span class="pl-k">new</span> <span class="pl-en">CodaHaleMetrics</span>()).build</pre>
  </div> 
  <p>If you're using Coda Hale's Metrics library and you want to reuse an existing <code>MetricsRegistry</code>, just pass it to the <code>CodaHaleMetrics</code> class: <code>new CodaHaleMetrics(registry)</code>.</p> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/inoio/solrs#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>The license is Apache 2.0, see LICENSE.txt.</p> 
 </article>
</div>