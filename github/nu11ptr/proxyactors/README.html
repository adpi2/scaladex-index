<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/nu11ptr/proxyactors#proxyactors" aria-hidden="true" class="anchor" id="user-content-proxyactors" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>ProxyActors</h1> 
  <p>A simple, lightweight typed actor framework for Scala. It includes an optional load balancer for transparently load balancing typed actor workloads. The current implementation is only ~160 SLOC in a single file. The goal of the project is to meet some specific use cases of our company (see 'Why?' section), but we are hoping you will find it useful as well.</p> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#installation" aria-hidden="true" class="anchor" id="user-content-installation" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h1> 
  <ul> 
   <li>Requires Scala 2.10 (which requires Java 1.6) and CGLib (tested on v2.2.2)</li> 
  </ul> 
  <p><strong>Option 1: SBT</strong></p> 
  <pre><code>libraryDependencies += "com.api-tech" % "proxyactors_2.10" % "0.2.1"
</code></pre> 
  <p><strong>Option 2: Copy the file into your project (you'll still need CGLib)</strong></p> 
  <p>Copy the 'package.scala' file into the folder for package api.actor in your project. Optionally, change the package to match your organization.</p> 
  <p><strong>Option 3: <a href="https://bitbucket.org/apitech/proxyactors/downloads/proxyactors_2.10-0.2.1.jar" target="_blank">Download</a> the jar (you'll still need CGLib)</strong></p> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#examples" aria-hidden="true" class="anchor" id="user-content-examples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples</h1> 
  <h2><a href="https://github.com/nu11ptr/proxyactors#hello-world" aria-hidden="true" class="anchor" id="user-content-hello-world" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Hello World</h2> 
  <p>First, the obligatory 'hello world'. The async. hello is called first, but printed after the synchronous hello due to being delayed and executed in a different thread.</p> 
  <pre><code>import api.actor._  // Single import line

class HelloWorld {
    def async() { Thread.sleep(100); println("Hello World! (async)") }
}

val hello = singleThreadContext.proxyActor[HelloWorld]()

hello.async()
println("Hello World! (sync)")

actorsFinished(hello)   // Blocks until asyncHello is complete
</code></pre> 
  <p>The output is:</p> 
  <pre><code>Hello World! (sync)
Hello World! (async)
</code></pre> 
  <h2><a href="https://github.com/nu11ptr/proxyactors#load-balancing" aria-hidden="true" class="anchor" id="user-content-load-balancing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Load Balancing</h2> 
  <p>Next, a quick example demonstrating typed actor load balancing. This example doubles all numbers 1 to 1000 in parallel and then adds them up and prints the result.</p> 
  <pre><code>import scala.concurrent.{Await, Future, Promise}
import scala.concurrent.duration.Duration
import api.actor._

trait Doubler { def double(n: Int): Future[Int] }

class MyDoubler extends Doubler {
    def double(n: Int): Future[Int] = { Promise.successful(n + n).future }
}

// Create one thread and actor per logical CPU thread
val actors = allCoresContext.proxyActors[MyDoubler](qty = totalCores)
val doubler = proxyRouter[Doubler](actors)

val futures = for (i &lt;- 1 to 1000) yield doubler.double(i)
val total = futures.foldLeft(0) {
    (sum, fut) =&gt; Await.result(fut, Duration.Inf) + sum
}

println(s"1 to 1000 doubled and then summed equals $total")

actorsFinished(actors)
</code></pre> 
  <p>The output is:</p> 
  <pre><code>1 to 1000 doubled and then summed equals 1001000
</code></pre> 
  <h2><a href="https://github.com/nu11ptr/proxyactors#simple-mutual-exclusion" aria-hidden="true" class="anchor" id="user-content-simple-mutual-exclusion" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Simple Mutual Exclusion</h2> 
  <p>Lastly, we show how we can wrap a callback class in a simple mutual exclusion proxy actor. This still runs in the same thread as called, but removes the need for us to lock our mutable class data.</p> 
  <p>NOTE: This example doesn't work/compile - it is just to show what is possible.</p> 
  <pre><code>import api.actor.{proxyActor, actorsFinished}

// Not thread-safe 'as-is'
class MyCallbackClass extends FictionalCallbackInterface {
    var mutableData: Int = 0

    def callbackMethod(newData: Int) { mutableData += newData }
}

// By default, actors are created in the 'sameThread' context, so callback
// is executed synchronously within whatever thread(s) 'library' provides
val callback = proxyActor[MyCallbackClass]()
library.addCallbackListener(callback)

// library is used here and invokes your callback via one or more threads
// The library has now signalled us that the work is complete

// Remember that accessing a 'var' in scala is a method call. Therefore
// even directly accessing the var is subject to actor mutual exclusion
println(s"Our final value was: ${callback.mutabledata}")

// We aren't using a thread pool - so no need to call 'actorsFinished'
// (but you still can and it is probably a good idea)
actorsFinished(callback)
</code></pre> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#features" aria-hidden="true" class="anchor" id="user-content-features" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h1> 
  <ul> 
   <li>Extremely small and lightweight</li> 
   <li>Learn the API in minutes</li> 
   <li>Typed actor router/load balancer with the distribution algorithm as a simple function</li> 
   <li>Actors extend your classes - no way to leak non-actor reference</li> 
   <li>Utilizes Scala 2.10 Futures/ExecutorContexts</li> 
   <li>Thread pools auto shutdown after last actor signals it is finished</li> 
   <li>CGLib is the only dependency (other than Scala library)</li> 
   <li>Ability to wrap callback objects in a mutual exclusion proxy (when used with threaded libraries). By default, this happens without additional threading overhead.</li> 
  </ul> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#typed-actors" aria-hidden="true" class="anchor" id="user-content-typed-actors" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Typed Actors?</h1> 
  <p>There are better sites for understanding all the theory. Definitely google them to get the 'big picture'. We'll just cover how our library works in few bullet points, and hopefully you can see why something like this makes sense.</p> 
  <ul> 
   <li>The base of a typed actor is your regular Scala class with no special features</li> 
   <li>We create a proxy of that class and instantiate it with the args of your choosing</li> 
   <li>This proxy can now be used just like the regular object with these differences: 
    <ul> 
     <li>We lock them for mutual exclusion - they are guaranteed to only execute in one thread at a time. You don't need to lock your class's mutable data anymore.</li> 
     <li>They are executed in a thread pool of your choosing (one pool for all actors, single thread per actor, or any other combination)</li> 
     <li>Methods that return Unit or a Scala future execute asynchronously in the pool</li> 
     <li>Methods that return values will still operate synchronously, however (with exception of Scala futures).</li> 
    </ul> </li> 
   <li>When you are done with an actor, you call 'actorsFinished'. When all actors finish that were using a thread pool, that thread pool is automatically freed. 'actorsFinished' will block as needed if not all actor methods have finished execution.</li> 
  </ul> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#why" aria-hidden="true" class="anchor" id="user-content-why" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why?</h1> 
  <p>The first thing that probably comes to mind for Scala typed actors is Akka. Akka is great. We like Akka. If you need its many features, you should use it too. Our library has probably not even 2% the features of Akka (and never will!). Clear enough? :-)</p> 
  <p>That said, Akka is a large, diverse collection of parallel compute, synchronization paradigms, and much more. Sometimes this is what we need, and sometimes we just need something very small, simple, and focused.</p> 
  <p>Here are the specific things we needed for our projects:</p> 
  <h3><a href="https://github.com/nu11ptr/proxyactors#typed-actors-that-extend-our-classes-not-wrap-them" aria-hidden="true" class="anchor" id="user-content-typed-actors-that-extend-our-classes-not-wrap-them" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Typed actors that 'extend' our classes, not 'wrap' them</h3> 
  <p>Yes, we know this seems backwards with all the hype of composition over inheritance, but we have a good reason for wanting this. Due to the Scala/Java implicit 'this' reference, it is very easy to leak 'this' outside the object when registering for callbacks, etc. Additionally, we don't like giving our classes knowledge that they are a typed actor even if just for identity purposes. Yes, we can abstract that, but it is more convoluted. Extending isn't always great either - you can't extend final classes/methods, etc (it is possible we'll add wrapping as an alternative in a future release).</p> 
  <h3><a href="https://github.com/nu11ptr/proxyactors#typed-actor-routingload-balancing" aria-hidden="true" class="anchor" id="user-content-typed-actor-routingload-balancing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Typed actor routing/load balancing</h3> 
  <p>We wanted to be able to take a list of typed actors and load balance to them as a group. We wanted to do it without a lot of work or boilerplate. Lastly, we wanted a solid default load balancing algorithm that would make it easy to load balance parallel workloads.</p> 
  <h3><a href="https://github.com/nu11ptr/proxyactors#easy-mutual-exclusion-without-boilerplate" aria-hidden="true" class="anchor" id="user-content-easy-mutual-exclusion-without-boilerplate" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Easy mutual exclusion without boilerplate</h3> 
  <p>Not every program needs to be parallel. Due to Java having first-class threads since it's inception, several libraries have shipped with embedded threading for concurrency purposes. Even if you are writing a simple script that takes callbacks, it is very likely you'll need to think about mutual exclusion. Using a simple 'proxyActor' function call, you can wrap these callback objects in an actor that is designed for mutual exclusion, and by default, operates in the same thread it was called by. Since it is very coarse locking via proxy, you'll lose some performance/parallelism, but for many programs that just isn't a concern.</p> 
  <h3><a href="https://github.com/nu11ptr/proxyactors#very-easy-fast-and-small" aria-hidden="true" class="anchor" id="user-content-very-easy-fast-and-small" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Very easy, fast, and small</h3> 
  <p>The goal is to make every feature easy to use without needing to reach for the ScalaDoc. We wanted an API that fit in our heads. We only want things in the library that we will use.</p> 
  <p>Our jar is currently ~40K and includes examples. The code itself is ~160 SLOC in a single file, so no worries about tracking a bug through thousands of lines of code. You can even just copy the single file right into your programs. (unfortunately, you'd still need to have the CGLib jar)</p> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#performance" aria-hidden="true" class="anchor" id="user-content-performance" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Performance</h1> 
  <p>We haven't done any benchmarks yet. No doubt we will eventually, but it isn't high priority for us as our workloads either a) do a ton of work per actor call or b) aren't performance sensitive. Regardless, since we use a proxy that uses reflection, you will want to do as much work as possible per call to call offset the overhead in performance sensitive workloads.</p> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#links" aria-hidden="true" class="anchor" id="user-content-links" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Links</h1> 
  <p>Primary: <a href="https://bitbucket.org/apitech/proxyactors" target="_blank">https://bitbucket.org/apitech/proxyactors</a></p> 
  <p>Mirror: <a href="https://github.com/nu11ptr/ProxyActors" target="_blank">https://github.com/nu11ptr/ProxyActors</a></p> 
  <p>ScalaDoc: <a href="http://apitech.bitbucket.org/proxyactors/scaladoc/#api.actor.package" target="_blank">http://apitech.bitbucket.org/proxyactors/scaladoc/#api.actor.package</a></p> 
  <p>Downloads: <a href="https://bitbucket.org/apitech/proxyactors/downloads" target="_blank">https://bitbucket.org/apitech/proxyactors/downloads</a></p> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#license" aria-hidden="true" class="anchor" id="user-content-license" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h1> 
  <p>ProxyActors is release under a modified BSD license. This means you can use it in open source or commerical programs without the need to release your code. All we ask is that you maintain our copyright notice.</p> 
  <h1><a href="https://github.com/nu11ptr/proxyactors#contributions" aria-hidden="true" class="anchor" id="user-content-contributions" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributions</h1> 
  <p>Regretfully, we are unable to accept code contributions at this time. The library currently does what we need it to do, and we wish to retain the sole copyright on the the code. Please do submit bug reports, fork, and change the code as you need, but please understand that pull requests will be refused.</p> 
 </article>
</div>