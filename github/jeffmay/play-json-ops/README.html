<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/jeffmay/play-json-ops" target="_blank"> <img src="https://camo.githubusercontent.com/9889c76ef96afb52060794e7aa25b3e2d153508a/68747470733a2f2f7472617669732d63692e6f72672f6a6566666d61792f706c61792d6a736f6e2d6f70732e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/jeffmay/play-json-ops.svg" style="max-width:100%;"> </a> <a href="https://coveralls.io/github/jeffmay/play-json-ops?branch=master" target="_blank"> <img src="https://camo.githubusercontent.com/561ccce733a69759d8729d3f3995c0188c3ec46b/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6a6566666d61792f706c61792d6a736f6e2d6f70732f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/jeffmay/play-json-ops/badge.svg?branch=master&amp;service=github" style="max-width:100%;"> </a></p> 
  <table> 
   <tbody>
    <tr> 
     <th>play-json-ops</th> 
     <th>play-json-tests</th> 
    </tr> 
    <tr> 
     <td> <a href="https://bintray.com/jeffmay/maven/play-json-ops/_latestVersion" target="_blank"> <img src="https://camo.githubusercontent.com/654e4adbd190aa544f52e6f3c812a77687f54783/68747470733a2f2f6170692e62696e747261792e636f6d2f7061636b616765732f6a6566666d61792f6d6176656e2f706c61792d6a736f6e2d6f70732f696d616765732f646f776e6c6f61642e737667" data-canonical-src="https://api.bintray.com/packages/jeffmay/maven/play-json-ops/images/download.svg" style="max-width:100%;"> </a> </td> 
     <td> <a href="https://bintray.com/jeffmay/maven/play-json-tests/_latestVersion" target="_blank"> <img src="https://camo.githubusercontent.com/6e65d6d99fb0c8d4704276568e28775bb61b0e21/68747470733a2f2f6170692e62696e747261792e636f6d2f7061636b616765732f6a6566666d61792f6d6176656e2f706c61792d6a736f6e2d74657374732f696d616765732f646f776e6c6f61642e737667" data-canonical-src="https://api.bintray.com/packages/jeffmay/maven/play-json-tests/images/download.svg" style="max-width:100%;"> </a> </td> 
    </tr> 
   </tbody>
  </table> 
  <h1><a id="user-content-play-json-ops" class="anchor" href="https://github.com/jeffmay/play-json-ops#play-json-ops" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Play Json Ops</h1> 
  <p>Augments the <a href="https://www.playframework.com/documentation/2.3.x/ScalaJson" target="_blank">Play Json library</a> with some helpful implicits and tools for:</p> 
  <ul> 
   <li>Creating formats for traits and abstract classes</li> 
   <li>Safely printing error messages with redacted sensitive data using implicit transformations</li> 
   <li>Formats for all tuples as JsArray</li> 
   <li>ScalaCheck generators for JsValue, JsArray, and JsObject</li> 
   <li>Formats for scala.concurrent.Duration</li> 
   <li>UTCFormats for org.joda.time.DateTime</li> 
   <li>Compile-time Json.oformat and Json.owrites macros</li> 
  </ul> 
  <h1><a id="user-content-getting-started" class="anchor" href="https://github.com/jeffmay/play-json-ops#getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Started</h1> 
  <p>Pretty much all of these tools become available when you extend <a href="https://github.com/jeffmay/play-json-ops/blob/master/src/main/scala/play/api/libs/json/ops/JsonImplicits.scala" target="_blank">JsonImplicits</a></p> 
  <h2><a id="user-content-dependencies" class="anchor" href="https://github.com/jeffmay/play-json-ops#dependencies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependencies</h2> 
  <ul> 
   <li><a href="https://github.com/jeffmay/scalacheck-ops" target="_blank">scalacheck-ops</a>: for the ability to convert ScalaCheck <code>Gen</code> into an <code>Iterator</code></li> 
  </ul> 
  <h2><a id="user-content-jsonimplicits" class="anchor" href="https://github.com/jeffmay/play-json-ops#jsonimplicits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>JsonImplicits</h2> 
  <p>By extending <code>JsonImplicits</code>, you get access to all the implicit <code>TupleFormats</code> as well as the <code>Json.oformat</code> and <code>Json.owrites</code> macros. These are all be pretty self-explanatory:</p> 
  <ul> 
   <li><code>Json.oformat</code> and <code>Json.owrites</code> will use the underlying <code>Json.format</code> and <code>Json.writes</code> macros, but it will cast the results to <code>OFormat</code> since it is impossible for those macro to return anything other than <code>OFormat</code> or <code>OWrites</code>, respectively.</li> 
   <li><code>TupleFormats</code> will provide implicit <code>Reads</code> and <code>Writes</code> for all 22 tuple types by writing the result as a <code>JsArray</code></li> 
  </ul> 
  <h2><a id="user-content-automatic-automated-tests" class="anchor" href="https://github.com/jeffmay/play-json-ops#automatic-automated-tests" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Automatic Automated Tests</h2> 
  <p>To get free test coverage, just extend <code>PlayJsonFormatSpec[T]</code> where <code>T</code> is a serializable type that you would like to create a suite of tests for. All it requires is a ScalaCheck generator of the same type or a sequence of examples.</p> 
  <p>This will use ScalaTest to create the test cases, however it will work just as well with Specs2</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Example</span>(<span class="pl-v">value</span>: <span class="pl-k">String</span>)

<span class="pl-k">object</span> <span class="pl-en">Example</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">format</span> <span class="pl-k">=</span> <span class="pl-en">Json</span>.format[<span class="pl-en">Example</span>]
}

<span class="pl-k">object</span> <span class="pl-en">ExampleGenerators</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">arbExample</span>(<span class="pl-k">implicit</span> <span class="pl-v">arbString</span>: <span class="pl-en">Arbitrary</span>[<span class="pl-k">String</span>])<span class="pl-k">:</span> <span class="pl-en">Arbitrary</span>[<span class="pl-en">Example</span>] <span class="pl-k">=</span>
    <span class="pl-en">Arbitrary</span>(arbString.map(<span class="pl-en">Example</span>(_)))
}

<span class="pl-k">import</span> <span class="pl-v">ExampleGenerators.</span><span class="pl-v">_</span>

<span class="pl-c">// Free unit tests for serializing and deserializing Example values</span>
<span class="pl-c">// Also works with implicit Shrink[Example]</span>
<span class="pl-k">class</span> <span class="pl-en">ExampleFormatSpec</span> <span class="pl-k">extends</span> <span class="pl-e">PlayJsonFormatSpec</span>[<span class="pl-en">Example</span>]
</pre>
  </div> 
  <h2><a id="user-content-creating-formats-for-traits-and-abstract-classes" class="anchor" href="https://github.com/jeffmay/play-json-ops#creating-formats-for-traits-and-abstract-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Creating Formats for Traits and Abstract Classes</h2> 
  <p>The following example shows how you can create a Format for the <code>Generic</code> trait using <code>Json.formatAbstract</code>. This method requires an implicit <code>TypeKeyExtractor[Generic]</code>, which is used to pull a "key" value from some field in the json / model. This key value is then matched on by a provided partial function from key to format: <code>Any =&gt; OFormat[_ &lt;: Generic]</code>. </p> 
  <p>The pattern works as follows:</p> 
  <ol> 
   <li><p>Create the formats of each of the specific formats using <code>AbstractJsonOps.formatWithType</code> and the <code>JsonMacroOps.oformat</code> macro.</p> <p>This will append the key field (even if it isn't in the case class constructor args) to the output json.</p></li> 
   <li><p>Create an implicit <code>TypeKeyExtractor</code> for the generic trait or abstract class on the companion object of that class.</p> <p>This is required for the <code>AbstractJsonOps.formatWithType</code> to work properly and avoids repeating unnecessary boilerplate on each of the specific serializers to write out the key or the generic serializer to read the key.</p></li> 
   <li><p>Finally, define an implicit <code>Format</code> for your generic trait or abstract class using <code>AbstractJsonOps.formatAbstract</code> by providing a partial function from the extracted key (from #2) to the specific serializer (from #1). Any unmatched keys will throw an exception.</p></li> 
  </ol> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Generic</span> {
  <span class="pl-k">def</span> <span class="pl-en">key</span><span class="pl-k">:</span> <span class="pl-k">String</span>
}

<span class="pl-k">object</span> <span class="pl-en">Generic</span> <span class="pl-k">extends</span> <span class="pl-e">JsonImplicits</span> {

  <span class="pl-k">val</span> <span class="pl-en">keyFieldName</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>key<span class="pl-pds">"</span></span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">extractor</span><span class="pl-k">:</span> <span class="pl-en">TypeKeyExtractor</span>[<span class="pl-en">Generic</span>] <span class="pl-k">=</span>
    <span class="pl-en">Json</span>.extractTypeKey[<span class="pl-en">Generic</span>].using(_.key, __ \ keyFieldName)

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">format</span><span class="pl-k">:</span> <span class="pl-en">OFormat</span>[<span class="pl-en">Generic</span>] <span class="pl-k">=</span> <span class="pl-en">Json</span>.formatAbstract[<span class="pl-en">Generic</span>] {
    <span class="pl-k">case</span> <span class="pl-en">SpecificA</span>.key <span class="pl-k">=&gt;</span> <span class="pl-en">OFormat</span>.of[<span class="pl-en">SpecificA</span>]
    <span class="pl-k">case</span> <span class="pl-en">SpecificB</span>.key <span class="pl-k">=&gt;</span> <span class="pl-en">OFormat</span>.of[<span class="pl-en">SpecificB</span>]
  }
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SpecificA</span>(<span class="pl-v">value</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Generic</span> {

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">key</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-en">SpecificA</span>.key
}

<span class="pl-k">object</span> <span class="pl-en">SpecificA</span> <span class="pl-k">extends</span> <span class="pl-e">JsonImplicits</span> {
  <span class="pl-k">val</span> <span class="pl-en">key</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">format</span><span class="pl-k">:</span> <span class="pl-en">OFormat</span>[<span class="pl-en">SpecificA</span>] <span class="pl-k">=</span> <span class="pl-en">Json</span>.formatWithType[<span class="pl-en">SpecificA</span>, <span class="pl-en">Generic</span>](<span class="pl-en">Json</span>.oformat[<span class="pl-en">SpecificA</span>])
}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SpecificB</span>(<span class="pl-v">value</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Generic</span> {

  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">key</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-en">SpecificB</span>.key
}

<span class="pl-k">object</span> <span class="pl-en">SpecificB</span> <span class="pl-k">extends</span> <span class="pl-e">JsonImplicits</span> {
  <span class="pl-k">val</span> <span class="pl-en">key</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>B<span class="pl-pds">"</span></span>

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">format</span><span class="pl-k">:</span> <span class="pl-en">OFormat</span>[<span class="pl-en">SpecificB</span>] <span class="pl-k">=</span> <span class="pl-en">Json</span>.formatWithType[<span class="pl-en">SpecificB</span>, <span class="pl-en">Generic</span>](<span class="pl-en">Json</span>.oformat[<span class="pl-en">SpecificB</span>])
}</pre>
  </div> 
  <h2><a id="user-content-duration-formats" class="anchor" href="https://github.com/jeffmay/play-json-ops#duration-formats" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Duration Formats</h2> 
  <p>You can add implicit Json serializers by importing <code>DurationFormat.string</code> or <code>DurationFormat.array</code> depending on the format you want.</p> 
  <p>You can also extend <code>ArrayDurationFormat</code> or <code>StringDurationFormat</code> for the same effect, but it requires that you also extend an <code>ImplicitDurationReads</code>. A good default is to extend <code>ForgivingDurationReads</code> as this will read either format.</p> 
  <p>Ok, now how the formats look in Json:</p> 
  <ul> 
   <li><p><code>ArrayDurationFormat</code></p> 
    <div class="highlight highlight-source-json">
     <pre>[<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>seconds<span class="pl-pds">"</span></span>]</pre>
    </div></li> 
   <li><p><code>StringDurationFormat</code></p> 
    <div class="highlight highlight-source-json">
     <pre><span class="pl-s"><span class="pl-pds">"</span>1 second<span class="pl-pds">"</span></span></pre>
    </div></li> 
  </ul> 
  <h2><a id="user-content-scalacheck-jsvalue-generators" class="anchor" href="https://github.com/jeffmay/play-json-ops#scalacheck-jsvalue-generators" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>ScalaCheck JsValue Generators</h2> 
  <p><a href="http://scalacheck.org/" target="_blank">ScalaCheck</a> is a very simple and powerful library for property-based testing.</p> 
  <p>Fun fact: It is the only library dependency of the Scala compiler</p> 
  <p>Ok, so assuming you are already familiar with ScalaCheck now... Let's say you want to generate arbitrary <code>JsValue</code>s or <code>JsObject</code>s. All you have to do is extend <code>JsValueGenerators</code> in your test class and voila!</p> 
  <p>By default the maximum depth of the <code>JsValue</code> trees is set to <code>JsValueGenerators.maxDepth</code> and the maximum number of fields for <code>JsObject</code> and values for <code>JsArray</code> is set to <code>JsValueGenerators.maxWidth</code>. You can override this in local scope by providing an implicit <code>Depth</code> or <code>Width</code> type value:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">maxDepth</span><span class="pl-k">:</span> <span class="pl-en">Depth</span> <span class="pl-k">=</span> <span class="pl-c1">4</span>  

forAll() { (<span class="pl-v">json</span>: <span class="pl-en">JsValue</span>) <span class="pl-k">=&gt;</span>
  <span class="pl-c">// ...</span>
}</pre>
  </div> 
  <p>or passing the values explicitly:</p> 
  <div class="highlight highlight-source-scala">
   <pre>forAll(genJsValue(maxDepth <span class="pl-k">=</span> <span class="pl-c1">4</span>, maxWidth <span class="pl-k">=</span> <span class="pl-c1">12</span>)) { (<span class="pl-v">json</span>: <span class="pl-en">JsValue</span>) <span class="pl-k">=&gt;</span>
  <span class="pl-c">// ...</span>
}</pre>
  </div> 
  <p><em>Note:</em> I encountered a compiler bug when overriding implicits in a local scope where the compiler would NOT throw the normal "ambiguous implicit values" exception and instead use the depth defined in the outer scope. Just be sure not to define ambiguous implicit <code>Depth</code> and <code>Width</code> values and everything works great.</p> 
 </article>
</div>