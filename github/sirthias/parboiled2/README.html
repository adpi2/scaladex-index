<div class="announce instapaper_body rst" data-path="README.rst" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><strong>parboiled2</strong> â€“ A Macro-Based PEG Parser Generator for Scala 2.10.3+</p> 
  <div id="user-content-contents-of-this-document"> 
   <p>Contents of this Document</p> 
   <ul> 
    <li><a href="https://github.com/sirthias/parboiled2#introduction" id="user-content-id10" target="_blank">Introduction</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#features" id="user-content-id11" target="_blank">Features</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#installation" id="user-content-id12" target="_blank">Installation</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#example" id="user-content-id13" target="_blank">Example</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#quick-start" id="user-content-id14" target="_blank">Quick Start</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#how-the-parser-matches-input" id="user-content-id15" target="_blank">How the Parser matches Input</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#the-rule-dsl" id="user-content-id16" target="_blank">The Rule DSL</a>
     <ul> 
      <li><a href="https://github.com/sirthias/parboiled2#rule-types-and-the-value-stack" id="user-content-id17" target="_blank">Rule Types and the Value Stack</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#basic-character-matching" id="user-content-id18" target="_blank">Basic Character Matching</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#rule-combinators-and-modifiers" id="user-content-id19" target="_blank">Rule Combinators and Modifiers</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#parser-actions" id="user-content-id20" target="_blank">Parser Actions</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#additional-helpers" id="user-content-id21" target="_blank">Additional Helpers</a></li> 
     </ul> </li> 
    <li><a href="https://github.com/sirthias/parboiled2#error-reporting" id="user-content-id22" target="_blank">Error Reporting</a>
     <ul> 
      <li><a href="https://github.com/sirthias/parboiled2#the-error-collection-process" id="user-content-id23" target="_blank">The Error Collection Process</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#formatting-parse-errors" id="user-content-id24" target="_blank">Formatting Parse Errors</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#tweaking-error-reporting" id="user-content-id25" target="_blank">Tweaking Error Reporting</a>
       <ul> 
        <li><a href="https://github.com/sirthias/parboiled2#the-atomic-marker" id="user-content-id26" target="_blank">The <code>atomic</code> Marker</a></li> 
        <li><a href="https://github.com/sirthias/parboiled2#the-quiet-marker" id="user-content-id27" target="_blank">The <code>quiet</code> Marker</a></li> 
        <li><a href="https://github.com/sirthias/parboiled2#naming-rules" id="user-content-id28" target="_blank">Naming Rules</a></li> 
        <li><a href="https://github.com/sirthias/parboiled2#manual-error-reporting" id="user-content-id29" target="_blank">Manual Error Reporting</a></li> 
       </ul> </li> 
      <li><a href="https://github.com/sirthias/parboiled2#limiting-error-re-runs" id="user-content-id30" target="_blank">Limiting Error Re-Runs</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#recovering-from-parse-errors" id="user-content-id31" target="_blank">Recovering from Parse Errors</a></li> 
     </ul> </li> 
    <li><a href="https://github.com/sirthias/parboiled2#advanced-techniques" id="user-content-id32" target="_blank">Advanced Techniques</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#common-mistakes" id="user-content-id33" target="_blank">Common Mistakes</a>
     <ul> 
      <li><a href="https://github.com/sirthias/parboiled2#disregarding-order-choice" id="user-content-id34" target="_blank">Disregarding Order Choice</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#non-termination-when-using-syntactic-predicates" id="user-content-id35" target="_blank">Non-Termination when using Syntactic Predicates</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#unchecked-mutable-state" id="user-content-id36" target="_blank">Unchecked Mutable State</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#handling-whitespace" id="user-content-id37" target="_blank">Handling Whitespace</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#parsing-the-whole-input" id="user-content-id38" target="_blank">Parsing the whole Input</a></li> 
     </ul> </li> 
    <li><a href="https://github.com/sirthias/parboiled2#grammar-debugging" id="user-content-id39" target="_blank">Grammar Debugging</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#access-to-parser-results" id="user-content-id40" target="_blank">Access to Parser Results</a>
     <ul> 
      <li><a href="https://github.com/sirthias/parboiled2#alternative-deliveryschemes" id="user-content-id41" target="_blank">Alternative DeliverySchemes</a></li> 
     </ul> </li> 
    <li><a href="https://github.com/sirthias/parboiled2#running-the-examples" id="user-content-id42" target="_blank">Running the Examples</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#alternatives" id="user-content-id43" target="_blank">Alternatives</a>
     <ul> 
      <li><a href="https://github.com/sirthias/parboiled2#parboiled2-vs-parboiled-1-x" id="user-content-id44" target="_blank">parboiled2 vs. parboiled 1.x</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#parboiled2-vs-scala-parser-combinators" id="user-content-id45" target="_blank">parboiled2 vs. Scala Parser Combinators</a></li> 
      <li><a href="https://github.com/sirthias/parboiled2#parboiled2-vs-regular-expressions" id="user-content-id46" target="_blank">parboiled2 vs. Regular Expressions</a></li> 
     </ul> </li> 
    <li><a href="https://github.com/sirthias/parboiled2#roadmap" id="user-content-id47" target="_blank">Roadmap</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#contributing" id="user-content-id48" target="_blank">Contributing</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#support" id="user-content-id49" target="_blank">Support</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#references" id="user-content-id50" target="_blank">References</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#credits" id="user-content-id51" target="_blank">Credits</a></li> 
    <li><a href="https://github.com/sirthias/parboiled2#license" id="user-content-id52" target="_blank">License</a></li> 
   </ul> 
  </div> 
  <a name="user-content-introduction" target="_blank" href=""></a> 
  <h2><a id="user-content-introduction" class="anchor" href="https://github.com/sirthias/parboiled2#introduction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id10" target="_blank">Introduction</a></h2> 
  <p><em>parboiled2</em> is a Scala 2.10.3+ library enabling lightweight and easy-to-use, yet powerful, fast and elegant parsing of arbitrary input text. It implements a macro-based parser generator for <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" target="_blank">Parsing Expression Grammars</a> (PEGs), which runs at compile time and translates a grammar rule definition (written in an internal Scala DSL) into corresponding JVM bytecode.</p> 
  <p>PEGs are an alternative to <a href="http://en.wikipedia.org/wiki/Context-free_grammar" target="_blank">Context-Free Grammars</a> (CFGs) for formally specifying syntax, they make a good replacement for regular expressions and have some advantages over the "traditional" way of building parsers via CFGs (like not needing a separate lexer/scanner phase).</p> 
  <p><em>parboiled2</em> is the successor of <a href="http://parboiled.org" target="_blank">parboiled 1.x</a> , which provides a similar capability (for Scala as well as Java) but does not actually <em>generate</em> a parser. Rather <a href="http://parboiled.org" target="_blank">parboiled 1.x</a> interprets a rule tree structure (which is also created via an internal DSL) against the input, which results in a much lower parsing performance. For more info on how <a href="http://parboiled.org" target="_blank">parboiled 1.x</a> and <em>parboiled2</em> compare see <a href="https://github.com/sirthias/parboiled2#parboiled2-vs-parboiled-1-x" target="_blank">parboiled2 vs. parboiled 1.x</a>. You might also be interested in reading about <a href="https://github.com/sirthias/parboiled2#parboiled2-vs-scala-parser-combinators" target="_blank">parboiled2 vs. Scala Parser Combinators</a> and <a href="https://github.com/sirthias/parboiled2#parboiled2-vs-regular-expressions" target="_blank">parboiled2 vs. Regular Expressions</a>.</p> 
  <a name="user-content-features" target="_blank" href=""></a> 
  <h2><a id="user-content-features" class="anchor" href="https://github.com/sirthias/parboiled2#features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id11" target="_blank">Features</a></h2> 
  <ul> 
   <li>Concise, flexible and type-safe DSL for expressing parsing logic</li> 
   <li>Full expressive power of <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" target="_blank">Parsing Expression Grammars</a>, for effectively dealing with most real-world parsing needs</li> 
   <li>Excellent reporting of parse errors</li> 
   <li>Parsing performance comparable to hand-written parsers</li> 
   <li>Easy to learn and use (just one parsing phase (no lexer code required), rather small API)</li> 
   <li>Light-weight enough to serve as a replacement for regular expressions (also strictly more powerful than regexes)</li> 
  </ul> 
  <a name="user-content-installation" target="_blank" href=""></a> 
  <h2><a id="user-content-installation" class="anchor" href="https://github.com/sirthias/parboiled2#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id12" target="_blank">Installation</a></h2> 
  <p>The artifacts for <em>parboiled2</em> live on <a href="http://search.maven.org/" target="_blank">Maven Central</a> and can be tied into your SBT-based Scala project like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.parboiled<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>parboiled<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.3<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>The latest released version is <strong>2.1.3</strong>. It is available for Scala 2.10, Scala 2.11 as well as Scala.js 0.6.</p> 
  <p><em>parboiled2</em> has only one single dependency that it will transitively pull into your classpath: <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a> (currently version 2.3.0).</p> 
  <p><strong>Note:</strong> If your project also uses <code>"io.spray" %% "spray-routing"</code> you'll need to change this to <code>"io.spray" %% "spray-routing-shapeless2"</code> in order for your project to continue to build since the "regular" spray builds use shapeless 1.x.</p> 
  <p>Once on your classpath you can use this single import to bring everything you need into scope:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.parboiled2.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>There might be potentially newer snapshot builds available in the <em>sonatype snapshots</em> repository located at: <a href="https://oss.sonatype.org/content/repositories/snapshots/" target="_blank">https://oss.sonatype.org/content/repositories/snapshots/</a></p> 
  <p>You can find the latest ones here: <a href="https://oss.sonatype.org/content/repositories/snapshots/org/parboiled/parboiled_2.10/" target="_blank">https://oss.sonatype.org/content/repositories/snapshots/org/parboiled/parboiled_2.10/</a> (Scala 2.10) and <a href="https://oss.sonatype.org/content/repositories/snapshots/org/parboiled/parboiled_2.11/" target="_blank">https://oss.sonatype.org/content/repositories/snapshots/org/parboiled/parboiled_2.11/</a> (Scala 2.11)</p> 
  <a name="user-content-example" target="_blank" href=""></a> 
  <h2><a id="user-content-example" class="anchor" href="https://github.com/sirthias/parboiled2#example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id13" target="_blank">Example</a></h2> 
  <p>This is what a simple <em>parboiled2</em> parser looks like:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.parboiled2.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">Calculator</span>(<span class="pl-k">val</span> <span class="pl-en">input</span><span class="pl-k">:</span> <span class="pl-en">ParserInput</span>) <span class="pl-k">extends</span> <span class="pl-e">Parser</span> {
  <span class="pl-k">def</span> <span class="pl-en">InputLine</span> <span class="pl-k">=</span> rule { <span class="pl-en">Expression</span> <span class="pl-k">~</span> <span class="pl-en">EOI</span> }

  <span class="pl-k">def</span> <span class="pl-en">Expression</span><span class="pl-k">:</span> <span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> rule {
    <span class="pl-en">Term</span> <span class="pl-k">~</span> zeroOrMore(
      <span class="pl-c1">'+'</span> <span class="pl-k">~</span> <span class="pl-en">Term</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">_</span>: <span class="pl-k">Int</span>) <span class="pl-k">+</span> _)
    <span class="pl-k">|</span> <span class="pl-c1">'-'</span> <span class="pl-k">~</span> <span class="pl-en">Term</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">_</span>: <span class="pl-k">Int</span>) <span class="pl-k">-</span> _))
  }

  <span class="pl-k">def</span> <span class="pl-en">Term</span> <span class="pl-k">=</span> rule {
    <span class="pl-en">Factor</span> <span class="pl-k">~</span> zeroOrMore(
      <span class="pl-c1">'*'</span> <span class="pl-k">~</span> <span class="pl-en">Factor</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">_</span>: <span class="pl-k">Int</span>) <span class="pl-k">*</span> _)
    <span class="pl-k">|</span> <span class="pl-c1">'/'</span> <span class="pl-k">~</span> <span class="pl-en">Factor</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">_</span>: <span class="pl-k">Int</span>) <span class="pl-k">/</span> _))
  }

  <span class="pl-k">def</span> <span class="pl-en">Factor</span> <span class="pl-k">=</span> rule { <span class="pl-en">Number</span> <span class="pl-k">|</span> <span class="pl-en">Parens</span> }

  <span class="pl-k">def</span> <span class="pl-en">Parens</span> <span class="pl-k">=</span> rule { <span class="pl-c1">'('</span> <span class="pl-k">~</span> <span class="pl-en">Expression</span> <span class="pl-k">~</span> <span class="pl-c1">')'</span> }

  <span class="pl-k">def</span> <span class="pl-en">Number</span> <span class="pl-k">=</span> rule { capture(<span class="pl-en">Digits</span>) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (_.toInt) }

  <span class="pl-k">def</span> <span class="pl-en">Digits</span> <span class="pl-k">=</span> rule { oneOrMore(<span class="pl-en">CharPredicate</span>.<span class="pl-en">Digit</span>) }
}

<span class="pl-k">new</span> <span class="pl-en">Calculator</span>(<span class="pl-s"><span class="pl-pds">"</span>1+1<span class="pl-pds">"</span></span>).<span class="pl-en">InputLine</span>.run() <span class="pl-c">// evaluates to `scala.util.Success(2)`</span></pre>
  </div> 
  <p>This implements a parser for simple integer expressions like <code>1+(2-3*4)/5</code> and runs the actual calculation in-phase with the parser. If you'd like to see it run and try it out yourself check out <a href="https://github.com/sirthias/parboiled2#running-the-examples" target="_blank">Running the Examples</a>.</p> 
  <a name="user-content-quick-start" target="_blank" href=""></a> 
  <h2><a id="user-content-quick-start" class="anchor" href="https://github.com/sirthias/parboiled2#quick-start" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id14" target="_blank">Quick Start</a></h2> 
  <p>A <em>parboiled2</em> parser is a class deriving from <code>org.parboiled2.Parser</code>, which defines one abstract member:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">input</span><span class="pl-k">:</span> <span class="pl-en">ParserInput</span></pre>
  </div> 
  <p>holding the input for the parsing run. Usually it is best implemented as a <code>val</code> parameter in the constructor (as shown in the <a href="https://github.com/sirthias/parboiled2#example" target="_blank">Example</a> above). As you can see from this design you need to (re-)create a new parser instance for every parsing run (parser instances are very lightweight).</p> 
  <p>The "productions" (or "rules") of your grammar are then defined as simple methods, which in most cases consist of a single call to the <code>rule</code> macro whose argument is a <a href="https://github.com/sirthias/parboiled2#the-rule-dsl" target="_blank">DSL expression</a> defining what input the rule is to match and what <a href="https://github.com/sirthias/parboiled2#parser-actions" target="_blank">actions</a> to perform.</p> 
  <p>In order to run your parser against a given input you create a new instance and call <code>run()</code> on the top-level rule, e.g:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">parser</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyParser</span>(input)
parser.topLevelRule.run() <span class="pl-c">// by default returns a ``scala.util.Try``</span></pre>
  </div> 
  <p>For more info on what options you have with regard to accessing the results of a parsing run check out the section on <a href="https://github.com/sirthias/parboiled2#access-to-parser-results" target="_blank">Access to Parser Results</a>.</p> 
  <a name="user-content-how-the-parser-matches-input" target="_blank" href=""></a> 
  <h2><a id="user-content-how-the-parser-matches-input" class="anchor" href="https://github.com/sirthias/parboiled2#how-the-parser-matches-input" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id15" target="_blank">How the Parser matches Input</a></h2> 
  <p><a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" target="_blank">PEG</a> parsers are quite easy to understand as they work just like most people without a lot of background in parsing theory would build a parser "by hand": recursive-descent with backtracking. They have only one parsing phase (not two, like most parsers produced by traditional parser generators like <a href="http://www.antlr.org/" target="_blank">ANTLR</a>), do not require any look-ahead and perform quite well in most real-world scenarios (although they <em>can</em> exhibit exponential runtime for certain pathological languages and inputs).</p> 
  <p>A <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" target="_blank">PEG</a> parser consists of a number of rules that logically form a "tree", with one "root" rule at the top calling zero or more lower-level rules, which can each call other rules and so on. Since rules can also call themselves or any of their parents the rule "tree" is not really a tree but rather a potentially cyclic directed graph, but in most cases the tree structure dominates, which is why its useful to think of it as a tree with potential cycles.</p> 
  <p>When a rule is executed against the current position in an input buffer it applies its specific matching logic to the input, which can either succeed or fail. In the success case the parser advances the input position (the <em>cursor</em>) and potentially executes the next rule. Otherwise, when the rule fails, the cursor is reset and the parser backtracks in search of another parsing alternative that might succeed.</p> 
  <p>For example consider this simple <em>parboiled2</em> rule:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> rule { <span class="pl-c1">'a'</span> <span class="pl-k">~</span> (<span class="pl-c1">'b'</span> <span class="pl-k">~</span> <span class="pl-c1">'c'</span> <span class="pl-k">|</span> <span class="pl-c1">'b'</span> <span class="pl-k">~</span> <span class="pl-c1">'d'</span>) }</pre>
  </div> 
  <p>When this rule is confronted with the input <code>abd</code> the parser matches the input in these steps:</p> 
  <ol class="arabic simple"> 
   <li>Rule <code>foo</code> starts executing, which calls its first sub-rule <code>'a'</code>. The cursor is at position 0.</li> 
   <li>Rule <code>'a'</code> is executed against input position 0, matches (succeeds) and the cursor is advanced to position 1.</li> 
   <li>Rule <code>'b' ~ 'c' | 'b' ~ 'd'</code> starts executing, which calls its first sub-rule <code>'b' ~ 'c'</code>.</li> 
   <li>Rule <code>'b' ~ 'c'</code> starts executing, which calls its first sub-rule <code>'b'</code>.</li> 
   <li>Rule <code>'b'</code> is executed against input position 1, matches (succeeds) and the cursor is advanced to position 2.</li> 
   <li>Rule <code>'c'</code> is executed against input position 2 and mismatches (fails).</li> 
   <li>Rule <code>'b' ~ 'c' | 'b' ~ 'd'</code> notices that its first sub-rule has failed, resets the cursor to position 1 and calls its 2nd sub-rule <code>'b' ~ 'd'</code>.</li> 
   <li>Rule <code>'b' ~ 'd'</code> starts executing, which calls its first sub-rule <code>'b'</code>.</li> 
   <li>Rule <code>'b'</code> is executed against input position 1, matches and the cursor is advanced to position 2.</li> 
   <li>Rule <code>'d'</code> is executed against input position 2, matches and the cursor is advanced to position 3.</li> 
   <li>Rule <code>'b' ~ 'd'</code> completes successfully, as its last sub-rule has succeeded.</li> 
   <li>Rule <code>'b' ~ 'c' | 'b' ~ 'd'</code> completes successfully, as one of its sub-rules has succeeded.</li> 
   <li>Rule <code>foo</code> completes execution successfully, as its last sub-rule has succeeded. The whole input "abd" was matched and the cursor is left at position 3 (after the last-matched character).</li> 
  </ol> 
  <a name="user-content-the-rule-dsl" target="_blank" href=""></a> 
  <h2><a id="user-content-the-rule-dsl" class="anchor" href="https://github.com/sirthias/parboiled2#the-rule-dsl" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id16" target="_blank">The Rule DSL</a></h2> 
  <p>In order to work with <em>parboiled2</em> effectively you should understand the core concepts behind its rule DSL, mainly the "Value Stack" and how <em>parboiled2</em> encodes value stack operations in the Scala type system.</p> 
  <a name="user-content-rule-types-and-the-value-stack" target="_blank" href=""></a> 
  <h3><a id="user-content-rule-types-and-the-value-stack" class="anchor" href="https://github.com/sirthias/parboiled2#rule-types-and-the-value-stack" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id17" target="_blank">Rule Types and the Value Stack</a></h3> 
  <p>Apart from the input buffer and the cursor the parser manages another important structure: the "Value Stack". The value stack is a simple stack construct that serves as temporary storage for your <a href="https://github.com/sirthias/parboiled2#parser-actions" target="_blank">Parser Actions</a>. In many cases it is used for constructing an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">AST</a> during the parsing run but it can also be used for "in-phase" computations (like in the <a href="https://github.com/sirthias/parboiled2#example" target="_blank">Example</a> above) or for any other purpose.</p> 
  <p>When a rule of a <em>parboiled2</em> parser executes it performs any combination of the following three things:</p> 
  <ul> 
   <li>match input, i.e. advance the input cursor</li> 
   <li>operate on the value stack, i.e. pop values off and/or push values to the value stack</li> 
   <li>perform side-effects</li> 
  </ul> 
  <p>Matching input is done by calling <a href="https://github.com/sirthias/parboiled2#basic-character-matching" target="_blank">Basic Character Matching</a> rules, which do nothing but match input and advance the cursor. Value stack operations (and other potential side-effects) are performed by <a href="https://github.com/sirthias/parboiled2#parser-actions" target="_blank">Parser Actions</a>.</p> 
  <p>It is important to understand that rules in <em>parboiled2</em> (i.e. the rule methods in your parser class) do not directly return some custom value as a method result. Instead, all their consuming and producing values happens as side-effects to the value stack. Thereby the way that a rule interacts with value stack is encoded in the rule's type.</p> 
  <p>This is the general definition of a <em>parboiled2</em> rule:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">Rule</span>[<span class="pl-k">-</span><span class="pl-en">I</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">HList</span>, <span class="pl-k">+</span><span class="pl-en">O</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">HList</span>]</pre>
  </div> 
  <p>This can look scary at first but is really quite simple. An <code>HList</code> is defined by <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a> and is essentially a type of list whose element number and element types are statically known at compile time. The <code>I</code> type parameter on <code>Rule</code> encodes what values (the number and types) the rule pops off the value stack and the <code>O</code> type parameter encodes what values (the number and types) the rule then pushes onto the value stack.</p> 
  <p>Luckily, in most cases, you won't have to work with these types directly as they can either be inferred or you can use one of these predefined aliases:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">Rule0</span> <span class="pl-k">=</span> <span class="pl-en">RuleN</span>[<span class="pl-en">HNil</span>]
<span class="pl-k">type</span> <span class="pl-en">Rule1</span>[<span class="pl-k">+</span><span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">RuleN</span>[<span class="pl-en">T</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>]
<span class="pl-k">type</span> <span class="pl-en">Rule2</span>[<span class="pl-k">+</span><span class="pl-en">A</span>, <span class="pl-k">+</span><span class="pl-en">B</span>] <span class="pl-k">=</span> <span class="pl-en">RuleN</span>[<span class="pl-en">A</span> <span class="pl-k">::</span> <span class="pl-en">B</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>]
<span class="pl-k">type</span> <span class="pl-en">RuleN</span>[<span class="pl-k">+</span><span class="pl-en">L</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">HList</span>] <span class="pl-k">=</span> <span class="pl-en">Rule</span>[<span class="pl-en">HNil</span>, <span class="pl-en">L</span>]
<span class="pl-k">type</span> <span class="pl-en">PopRule</span>[<span class="pl-k">-</span><span class="pl-en">L</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">HList</span>] <span class="pl-k">=</span> <span class="pl-en">Rule</span>[<span class="pl-en">L</span>, <span class="pl-en">HNil</span>]</pre>
  </div> 
  <p>Here is what these type aliases denote:</p> 
  <dl> 
   <dt>
    Rule0
   </dt> 
   <dd>
    A rule that neither pops off nor pushes to the value stack, i.e. has no effect on the value stack whatsoever. All 
    <a href="https://github.com/sirthias/parboiled2#basic-character-matching" target="_blank">Basic Character Matching</a> rules are of this type.
   </dd> 
   <dt>
    Rule1[+T]
   </dt> 
   <dd>
    Pushes exactly one value of type 
    <code>T</code> onto the value stack. After 
    <code>Rule0</code> this is the second-most frequently used rule type.
   </dd> 
   <dt>
    Rule2[+A, +B]
   </dt> 
   <dd>
    Pushes exactly two values of types 
    <code>A</code> and 
    <code>B</code> onto the value stack.
   </dd> 
   <dt>
    RuleN[+L &lt;: HList]
   </dt> 
   <dd>
    Pushes a number of values onto the value stack, which correspond to the given 
    <code>L &lt;: HList</code> type parameter.
   </dd> 
   <dt>
    PopRule[-L &lt;: HList]
   </dt> 
   <dd>
    Pops a number of values off the value stack (corresponding to the given 
    <code>L &lt;: HList</code> type parameter) and does not produce any new value itself.
   </dd> 
  </dl> 
  <p>The rule DSL makes sure that the rule types are properly assembled and carried through your rule structure as you combine <a href="https://github.com/sirthias/parboiled2#basic-character-matching" target="_blank">Basic Character Matching</a> with <a href="https://github.com/sirthias/parboiled2#rule-combinators-and-modifiers" target="_blank">Rule Combinators and Modifiers</a> and <a href="https://github.com/sirthias/parboiled2#parser-actions" target="_blank">Parser Actions</a>, so as long as you don't write any logic that circumvents the value stack your parser will be completely type-safe and the compiler will be able to catch you if you make mistakes by combining rules in an unsound way.</p> 
  <a name="user-content-basic-character-matching" target="_blank" href=""></a> 
  <h3><a id="user-content-basic-character-matching" class="anchor" href="https://github.com/sirthias/parboiled2#basic-character-matching" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id18" target="_blank">Basic Character Matching</a></h3> 
  <p>The following basic character matching rules are the only way to cause the parser to match actual input and "make progress". They are the "atomic" elements of the rule DSL which are then used by the <a href="https://github.com/sirthias/parboiled2#rule-combinators-and-modifiers" target="_blank">Rule Combinators and Modifiers</a> to form higher-level rules.</p> 
  <hr> 
  <dl> 
   <dt>
    implicit def ch(c: Char): Rule0
   </dt> 
   <dd>
    <code>Char</code> values can be directly used in the rule DSL and match themselves. There is one notable case where you will have to use the explicit 
    <code>ch</code> wrapper: You cannot use the 
    <code>|</code> operator directly on chars as it denotes the built-in Scala binary "or" operator defined on numeric types (
    <code>Char</code> is an unsigned 16-bit integer). So rather than saying 
    <code>'a' | 'b'</code> you will have to say 
    <code>ch('a') | 'b'</code>.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    implicit def str(s: String): Rule0
   </dt> 
   <dd>
    <code>String</code> values can be directly used in the rule DSL and match themselves.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    implicit def predicate(p: CharPredicate): Rule0
   </dt> 
   <dd>
    You can use 
    <code>org.parboiled2.CharPredicate</code> values directly in the rule DSL. 
    <code>CharPredicate</code> is an efficient implementation of character sets and already comes with a number pre-defined character classes like 
    <code>CharPredicate.Digit</code> or 
    <code>CharPredicate.LowerHexLetter</code>.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    implicit def valueMap[T](m: Map[String, T]): R
   </dt> 
   <dd>
    <p>Values of type <code>Map[String, T]</code> can be directly used in the rule DSL and match any of the given map's keys and push the respective value upon a successful match. The resulting rule type depends on <code>T</code>:</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th><code>T</code></th> 
       <th><code>R</code></th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Unit</code></td> 
       <td><code>Rule0</code></td> 
      </tr> 
      <tr>
       <td><code>L &lt;: HList</code></td> 
       <td><code>RuleN[L]</code> (pushes all values of <code>L</code>)</td> 
      </tr> 
      <tr>
       <td><code>T</code> (otherwise)</td> 
       <td><code>Rule1[T]</code> (pushes only one value)</td> 
      </tr> 
     </tbody> 
    </table> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def anyOf(chars: String): Rule0
   </dt> 
   <dd>
    This constructs a 
    <code>Rule0</code> which matches any of the given strings characters.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def noneOf(chars: String): Rule0
   </dt> 
   <dd>
    This constructs a 
    <code>Rule0</code> which matches any single character except the ones in the given string and except EOI.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def ignoreCase(c: Char): Rule0
   </dt> 
   <dd>
    Matches the given single character case insensitively. Note: 
    <strong>The given character must be specified in lower-case!</strong> This requirement is currently NOT enforced!
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def ignoreCase(s: String): Rule0
   </dt> 
   <dd>
    Matches the given string of characters case insensitively. Note: 
    <strong>The given string must be specified in all lower-case!</strong> This requirement is currently NOT enforced!
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def ANY: Rule0
   </dt> 
   <dd>
    Matches any character except 
    <em>EOI</em> (end-of-input).
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def EOI: Char
   </dt> 
   <dd>
    The 
    <em>EOI</em> (end-of-input) character, which is a virtual character that the parser "appends" after the last character of the actual input.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def MATCH: Rule0
   </dt> 
   <dd>
    Matches no character (i.e. doesn't cause the parser to make any progress) but succeeds always. It's the "empty" rule that is mostly used as a neutral element in rule composition.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def MISMATCH[I &lt;: HList, O &lt;: HList]: Rule[I, O]
   </dt> 
   <dd>
    A rule that always fails. Fits any rule signature.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    def MISMATCH0: Rule0
   </dt> 
   <dd>
    Same as 
    <code>MISMATCH</code> but with a clearly defined type. Use it (rather then 
    <code>MISMATCH</code>) if the call site doesn't clearly "dictate" a certain rule type and using 
    <code>MISMATCH</code> therefore gives you a compiler error.
   </dd> 
  </dl> 
  <a name="user-content-rule-combinators-and-modifiers" target="_blank" href=""></a> 
  <h3><a id="user-content-rule-combinators-and-modifiers" class="anchor" href="https://github.com/sirthias/parboiled2#rule-combinators-and-modifiers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id19" target="_blank">Rule Combinators and Modifiers</a></h3> 
  <p>Rules can be freely combined/modified with these operations:</p> 
  <hr> 
  <dl> 
   <dt>
    a ~ b
   </dt> 
   <dd>
    <p>Two rules <code>a</code> and <code>b</code> can be combined with the <code>~</code> operator resulting in a rule that only matches if first <code>a</code> matches and then <code>b</code> matches. The computation of the resulting rule type is somewhat involved. Here is an illustration (using an abbreviated HList notation):</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th>a</th> 
       <th>b</th> 
       <th>a ~ b</th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Rule[, A]</code></td> 
       <td><code>Rule[, B]</code></td> 
       <td><code>Rule[, A:B]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[A:B:C, D:E:F]</code></td> 
       <td><code>Rule[F, G:H]</code></td> 
       <td><code>Rule[A:B:C, D:E:G:H]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[A, B:C]</code></td> 
       <td><code>Rule[D:B:C, E:F]</code></td> 
       <td><code>Rule[D:A, E:F]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[A, B:C]</code></td> 
       <td><code>Rule[D:C, E:F]</code></td> 
       <td>Illegal if <code>D</code> != <code>B</code></td> 
      </tr> 
     </tbody> 
    </table> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    a | b
   </dt> 
   <dd>
    Two rules 
    <code>a</code> and 
    <code>b</code> can be combined with the 
    <code>|</code> operator to form an "ordered choice" in 
    <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" target="_blank">PEG</a> speak. The resulting rule tries to match 
    <code>a</code> and succeeds if this succeeds. Otherwise the parser is reset and 
    <code>b</code> is tried. This operator can only be used on compatible rules.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    &amp;(a)
   </dt> 
   <dd>
    <p>Creates a "positive syntactic predicate", i.e. a rule that tests if the underlying rule matches but doesn't cause the parser to make any progress (i.e. match any input) itself. Also, all effects that the underlying rule might have had on the value stack are cleared out, the resulting rule type is therefore always <code>Rule0</code>, independently of the type of the underlying rule.</p> 
    <p>Note that <code>&amp;</code> not itself consuming any input can have surprising implications in repeating constructs, see <a href="https://github.com/sirthias/parboiled2#non-termination-when-using-syntactic-predicates" target="_blank">Non-Termination when using Syntactic Predicates</a> for more details.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    !a
   </dt> 
   <dd>
    <p>Creates a "negative syntactic predicate", i.e. a rule that matches only if the underlying one mismatches and vice versa. A syntactic predicate doesn't cause the parser to make any progress (i.e. match any input) and also clears out all effects that the underlying rule might have had on the value stack. The resulting rule type is therefore always <code>Rule0</code>, independently of the type of the underlying rule.</p> 
    <p>Note that <code>!</code> not itself consuming any input can have surprising implications in repeating constructs, see <a href="https://github.com/sirthias/parboiled2#non-termination-when-using-syntactic-predicates" target="_blank">Non-Termination when using Syntactic Predicates</a> for more details.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    optional(a)
   </dt> 
   <dd>
    <p>Runs its inner rule and succeeds even if the inner rule doesn't. The resulting rule type depends on the type of the inner rule:</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th>Type of <code>a</code></th> 
       <th>Type of <code>optional(a)</code></th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Rule0</code></td> 
       <td><code>Rule0</code></td> 
      </tr> 
      <tr>
       <td><code>Rule1[T]</code></td> 
       <td><code>Rule1[Option[T]]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[I, O &lt;: I]</code></td> 
       <td><code>Rule[I, O]</code></td> 
      </tr> 
     </tbody> 
    </table> 
    <p>The last case is a so-called "reduction rule", which leaves the value stack unchanged on a type level. This is an example of a reduction rule wrapped with <code>optional</code>:</p> 
    <div class="highlight highlight-source-scala">
     <pre>capture(<span class="pl-en">CharPredicate</span>.<span class="pl-en">Digit</span>) <span class="pl-k">~</span> optional(ch(<span class="pl-c1">'h'</span>) <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> s <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>hex<span class="pl-pds">"</span></span>))</pre>
    </div> 
    <p>The inner rule of <code>optional</code> here has type <code>Rule[String :: HNil, String :: HNil]</code>, i.e. it pops one <code>String</code> off the stack and pushes another one onto it, which means that the number of elements on the value stack as well as their types remain the same, even though the actual values might have changed.</p> 
    <p>As a shortcut you can also use <code>a.?</code> instead of <code>optional(a)</code>.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    zeroOrMore(a)
   </dt> 
   <dd>
    <p>Runs its inner rule until it fails, always succeeds. The resulting rule type depends on the type of the inner rule:</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th>Type of <code>a</code></th> 
       <th>Type of <code>zeroOrMore(a)</code></th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Rule0</code></td> 
       <td><code>Rule0</code></td> 
      </tr> 
      <tr>
       <td><code>Rule1[T]</code></td> 
       <td><code>Rule1[Seq[T]]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[I, O &lt;: I]</code></td> 
       <td><code>Rule[I, O]</code></td> 
      </tr> 
     </tbody> 
    </table> 
    <p>The last case is a so-called "reduction rule", which leaves the value stack unchanged on a type level. This is an example of a reduction rule wrapped with <code>zeroOrMore</code>:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(factor <span class="pl-k">:</span><span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>]) <span class="pl-k">~</span> zeroOrMore(<span class="pl-c1">'*'</span> <span class="pl-k">~</span> factor <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">a</span>: <span class="pl-k">Int</span>, b) <span class="pl-k">=&gt;</span> a <span class="pl-k">*</span> b))</pre>
    </div> 
    <p>The inner rule of <code>zeroOrMore</code> here has type <code>Rule[Int :: HNil, Int :: HNil]</code>, i.e. it pops one <code>Int</code> off the stack and pushes another one onto it, which means that the number of elements on the value stack as well as their types remain the same, even though the actual values might have changed.</p> 
    <p>As a shortcut you can also use <code>a.*</code> instead of <code>zeroOrMore(a)</code>.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    oneOrMore(a)
   </dt> 
   <dd>
    <p>Runs its inner rule until it fails, succeeds if its inner rule succeeded at least once. The resulting rule type depends on the type of the inner rule:</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th>Type of <code>a</code></th> 
       <th>Type of <code>oneOrMore(a)</code></th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Rule0</code></td> 
       <td><code>Rule0</code></td> 
      </tr> 
      <tr>
       <td><code>Rule1[T]</code></td> 
       <td><code>Rule1[Seq[T]]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[I, O &lt;: I]</code></td> 
       <td><code>Rule[I, I]</code></td> 
      </tr> 
     </tbody> 
    </table> 
    <p>The last case is a so-called "reduction rule", which leaves the value stack unchanged on a type level. This is an example of a reduction rule wrapped with <code>oneOrMore</code>:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(factor <span class="pl-k">:</span><span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>]) <span class="pl-k">~</span> oneOrMore(<span class="pl-c1">'*'</span> <span class="pl-k">~</span> factor <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">a</span>: <span class="pl-k">Int</span>, b) <span class="pl-k">=&gt;</span> a <span class="pl-k">*</span> b))</pre>
    </div> 
    <p>The inner rule of <code>oneOrMore</code> here has type <code>Rule[Int :: HNil, Int :: HNil]</code>, i.e. it pops one <code>Int</code> off the stack and pushes another one onto it, which means that the number of elements on the value stack as well as their types remain the same, even though the actual values might have changed.</p> 
    <p>As a shortcut you can also use <code>a.+</code> instead of <code>oneOrMore(a)</code>.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    xxx.times(a)
   </dt> 
   <dd>
    <p>Repeats a rule a given number of times. <code>xxx</code> can be either a positive <code>Int</code> value or a range <code>(&lt;x&gt; to &lt;y&gt;)</code> whereby both <code>&lt;x&gt;</code> and <code>&lt;y&gt;</code> are positive <code>Int</code> values. The resulting rule type depends on the type of the inner rule:</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th>Type of <code>a</code></th> 
       <th>Type of <code>xxx.times(a)</code></th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Rule0</code></td> 
       <td><code>Rule0</code></td> 
      </tr> 
      <tr>
       <td><code>Rule1[T]</code></td> 
       <td><code>Rule1[Seq[T]]</code></td> 
      </tr> 
      <tr>
       <td><code>Rule[I, O &lt;: I]</code></td> 
       <td><code>Rule[I, O]</code></td> 
      </tr> 
     </tbody> 
    </table> 
    <p>The last case is a so-called "reduction rule", which leaves the value stack unchanged on a type level. This is an example of a reduction rule wrapped with <code>oneOrMore</code>:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(factor <span class="pl-k">:</span><span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>]) <span class="pl-k">~</span> (<span class="pl-c1">1</span> to <span class="pl-c1">5</span>).times(<span class="pl-c1">'*'</span> <span class="pl-k">~</span> factor <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((<span class="pl-v">a</span>: <span class="pl-k">Int</span>, b) <span class="pl-k">=&gt;</span> a <span class="pl-k">*</span> b))</pre>
    </div> 
    <p>The inner rule here has type <code>Rule[Int :: HNil, Int :: HNil]</code>, i.e. it pops one <code>Int</code> off the stack and pushes another one onto it, which means that the number of elements on the value stack as well as their types remain the same, even though the actual values might have changed.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    a.separatedBy(separator: Rule0)
   </dt> 
   <dd>
    <p>You can use <code>a.separatedBy(b)</code> to create a rule with efficient and automatic support for element separators if <code>a</code> is a rule produced by the <code>zeroOrMore</code>, <code>oneOrMore</code> or <code>xxx.times</code> modifier and <code>b</code> is a <code>Rule0</code>. The resulting rule has the same type as <code>a</code> but expects the individual repetition elements to be separated by a successful match of the <code>separator</code> rule.</p> 
    <p>As a shortcut you can also use <code>a.*(b)</code> or <code>(a * b)</code> instead of <code>zeroOrMore(a).separatedBy(b)</code>. The same shortcut also works for <code>+</code> (<code>oneOrMore</code>).</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    a ~!~ b
   </dt> 
   <dd>
    Same as ~ but with "cut" semantics, meaning that the parser will never backtrack across this boundary. If the rule being concatenated doesn't match a parse error will be triggered immediately. Usually you don't need to use this "cut" operator but in certain cases it can help in simplifying grammar construction.
   </dd> 
  </dl> 
  <a name="user-content-parser-actions" target="_blank" href=""></a> 
  <h3><a id="user-content-parser-actions" class="anchor" href="https://github.com/sirthias/parboiled2#parser-actions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id20" target="_blank">Parser Actions</a></h3> 
  <p>The <a href="https://github.com/sirthias/parboiled2#basic-character-matching" target="_blank">Basic Character Matching</a> rules and the <a href="https://github.com/sirthias/parboiled2#rule-combinators-and-modifiers" target="_blank">Rule Combinators and Modifiers</a> allow you to build <em>recognizers</em> for potentially complex languages, but usually your parser is supposed to do more than simply determine whether a given input conforms to the defined grammar. In order to run custom logic during parser execution, e.g. for creating custom objects (like an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">AST</a>), you will have to add some "actions" to your rules.</p> 
  <hr> 
  <dl> 
   <dt>
    push(value)
   </dt> 
   <dd>
    <p><code>push(value)</code> creates a rule that matches no input (but always succeeds, as a rule) and pushes the given value onto the value stack. Its rule type depends on the given value:</p> 
    <table> 
     <thead valign="bottom"> 
      <tr>
       <th>Type of <code>value</code></th> 
       <th>Type of <code>push(value)</code></th> 
      </tr> 
     </thead> 
     <tbody valign="top"> 
      <tr>
       <td><code>Unit</code></td> 
       <td><code>Rule0</code> (identical to <code>run</code> in this case)</td> 
      </tr> 
      <tr>
       <td><code>L &lt;: HList</code></td> 
       <td><code>RuleN[L]</code> (pushes all values of <code>L</code>)</td> 
      </tr> 
      <tr>
       <td><code>T</code> (otherwise)</td> 
       <td><code>Rule1[T]</code> (pushes only one value)</td> 
      </tr> 
     </tbody> 
    </table> 
    <p>Also note that, due to the macro expansion the <em>parboiled2</em> rule DSL is based on, the given value expression behaves like a call-by-name parameter even though it is not marked as one! This means that the argument expression to <code>push</code> is (re-)evaluated for every rule execution.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    capture(a)
   </dt> 
   <dd>
    <p>Wrapping a rule <code>a</code> with <code>capture</code> turns that rule into one that pushes an additional <code>String</code> instance onto the value stack (in addition to all values that <code>a</code> already pushes itself): the input text matched by <code>a</code>.</p> 
    <p>For example <code>capture(oneOrMore(CharPredicate.Digit))</code> has type <code>Rule1[String]</code> and pushes one value onto the value stack: the string of digit characters matched by <code>oneOrMore(CharPredicate.Digit)</code>.</p> 
    <p>Another example: <code>capture("foo" ~ push(42))</code> has type <code>Rule2[Int, String]</code> and will match input "foo". After successful execution the value stack will have the String <code>"foo"</code> as its top element and <code>42</code> underneath.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    test(condition: Boolean): Rule0
   </dt> 
   <dd>
    <code>test</code> implements "semantic predicates". It creates a rule that matches no input and succeeds only if the given condition expression evaluates to true. Note that, due to the macro expansion the 
    <em>parboiled2</em> rule DSL is based on, the given argument behaves like a call-by-name parameter even though it is not marked as one! This means that the argument expression to 
    <code>test</code> is (re-)evaluated for every rule execution, just as if 
    <code>test</code> would have been defined as 
    <code>def test(condition: =&gt; Boolean): Rule0</code>.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    a ~&gt; (...)
   </dt> 
   <dd>
    <p>The <code>~&gt;</code> operator is the "action operator" and as such the most frequently used way to add custom logic to a rule. It can be applied to any rule and appends action logic to it. The argument to <code>~&gt;</code> is always a function, what functions are allowed and what the resulting rule type is depends on the type of <code>a</code>.</p> 
    <p>The basic idea is that the input of the function is popped of the value stack and the result of the function is pushed back onto it. In its basic form the <code>~&gt;</code> operator therefore transforms the top elements of the value stack into some other object(s).</p> 
    <p>Let's look at some examples:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (i <span class="pl-k">=&gt;</span> i <span class="pl-k">*</span> <span class="pl-c1">2</span>)</pre>
    </div> 
    <p>This results in a <code>Rule1[Int]</code> which multiplies the "output" of rule <code>foo</code> by 2.</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule2</span>[<span class="pl-k">Int</span>, <span class="pl-k">String</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((i, s) <span class="pl-k">=&gt;</span> s <span class="pl-k">+</span> i.toString)</pre>
    </div> 
    <p>This results in a <code>Rule1[String]</code> which combines the two "outputs" of rule <code>foo</code> (an <code>Int</code> and a <code>String</code>) into one single <code>String</code>.</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule2</span>[<span class="pl-k">Int</span>, <span class="pl-k">String</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (_.toDouble)</pre>
    </div> 
    <p>This results in a <code>Rule2[Int, Double]</code>. As you can see the function argument to <code>~&gt;</code> doesn't always have to "take" the complete output of the rule its applied to. It can also take fewer or even more elements. Its parameters are simply matched left to right against the top of the value stack (the right-most parameter matching the top-level element).</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">String</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> ((i <span class="pl-k">:</span><span class="pl-k">Int</span>, s) <span class="pl-k">=&gt;</span> s <span class="pl-k">+</span> i.toString)</pre>
    </div> 
    <p>This results in a <code>Rule[Int :: HNil, String :: HNil]</code>, i.e. a rule that pops one <code>Int</code> value off the stack and replaces it with a <code>String</code>. Note that, while the parameter types to the action function can be inferred if they can be matched against an "output" of the underlying rule, this is not the case for parameters that don't directly correspond to an underlying output. In these cases you need to add an explicit type annotation to the respective action function parameter(s).</p> 
    <p>If an action function returns <code>Unit</code> it doesn't push anything on the stack. So this rule</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">String</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (println(_))</pre>
    </div> 
    <p>has type <code>Rule0</code>.</p> 
    <p>Also, an action function can also be a <code>Function0</code>, i.e. a function without any parameters:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">String</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (() <span class="pl-k">=&gt;</span> <span class="pl-c1">42</span>)</pre>
    </div> 
    <p>This rule has type <code>Rule2[String, Int]</code> and is equivalent to this:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">String</span>]) <span class="pl-k">~</span> push(<span class="pl-c1">42</span>)</pre>
    </div> 
    <p>An action function can also produce more than one output by returning an <code>HList</code> instance:</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">String</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (s <span class="pl-k">=&gt;</span> s.toInt <span class="pl-k">::</span> <span class="pl-c1">3.14</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>)</pre>
    </div> 
    <p>This has type <code>Rule2[Int, Double]</code>.</p> 
    <p>One more very useful feature is special support for case class instance creation:</p> 
    <div class="highlight highlight-source-scala">
     <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>)

(<span class="pl-v">foo</span>: <span class="pl-en">Rule2</span>[<span class="pl-k">String</span>, <span class="pl-k">Int</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">Person</span></pre>
    </div> 
    <p>This has type <code>Rule1[Person]</code>. The top elements of the value stack are popped off and replaced by an instance of the case class if they match in number, order and types to the case class members. This is great for building <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree" target="_blank">AST</a>-like structures! Check out the <a href="https://github.com/sirthias/parboiled2/blob/master/examples/src/main/scala/org/parboiled2/examples/Calculator2.scala" target="_blank">Calculator2</a> example to see this form in action.</p> 
    <p>Note that there is one quirk: For some reason this notation stops working if you explicitly define a companion object for your case class. You'll have to write <code>~&gt; (Person(_, _))</code> instead.</p> 
    <p>And finally, there is one more very powerful action type: the action function can itself return a rule! If an action returns a rule this rule is immediately executed after the action application just as if it had been concatenated to the underlying rule with the <code>~</code> operator. You can therefore do things like</p> 
    <div class="highlight highlight-source-scala">
     <pre>(<span class="pl-v">foo</span>: <span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>]) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (i <span class="pl-k">=&gt;</span> test(i <span class="pl-k">%</span> <span class="pl-c1">2</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-k">~</span> push(i))</pre>
    </div> 
    <p>which is a <code>Rule1[Int]</code> that only produces even integers and fails for all others. Or, somewhat unusual but still perfectly legal:</p> 
    <div class="highlight highlight-source-scala">
     <pre>capture(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span>) <span class="pl-k">~</span><span class="pl-k">&gt;</span> (str(_))</pre>
    </div> 
    <p>which is a <code>Rule0</code> that is identical to <code>'x' ~ 'x'</code>.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    run(expression)
   </dt> 
   <dd>
    <p><code>run</code> is the most versatile parser action. It can have several shapes, depending on the type of its argument expression. If the argument expression evaluates to</p> 
    <ul> 
     <li>a rule (i.e. has type <code>R &lt;: Rule[_, _]</code>) the result type of <code>run</code> is this rule's type (i.e. <code>R</code>) and the produced rule is immediately executed.</li> 
     <li>a function with 1 to 5 parameters these parameters are mapped against the top of the value stack, popped and the function executed. Thereby the function behaves just like an action function for the <code>~&gt;</code> operator, i.e. if it produces a <code>Unit</code> value this result is simply dropped. <code>HList</code> results are pushed onto the value stack (all their elements individually), rule results are immediately executed and other result values are pushed onto the value stack as a single element. The difference between using <code>run</code> and attaching an action function with the <code>~&gt;</code> operator is that in the latter case the compiler can usually infer the types of the function parameters (if they map to "output" values of the base rule) while with <code>run</code> you <em>always</em> have to explicitly attach type annotation to the function parameters.</li> 
     <li>a function with one <code>HList</code> parameter the behavior is similar to the previous case with the difference that the elements of this parameter <code>HList</code> are mapped against the value stack top. This allows for consumption of an arbitrary number of value stack elements (Note: This feature of <code>run</code> is not yet currently implemented.)</li> 
     <li>any other value the result type of <code>run</code> is an always succeeding <code>Rule0</code>. Since in this case it doesn't interact with the value stack and doesn't match any input all it can do is perform "unchecked" side effects. Note that by using <code>run</code> in this way you are leaving the "safety-net" that the value stack and the rule type system gives you! Make sure you understand what you are doing before using these kinds of <code>run</code> actions!</li> 
    </ul> 
    <p>Also note that, due to the macro expansion the <em>parboiled2</em> rule DSL is based on, the given block behaves like a call-by-name parameter even though it is not marked as one! This means that the argument expression to <code>run</code> is (re-)evaluated for every rule execution.</p> 
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    runSubParser(f: ParserInput â‡’ Rule[I, O]): Rule[I, O]
   </dt> 
   <dd>
    This action allows creation of a sub parser and running of one of its rules as part of the current parsing process. The subparser will start parsing at the current input position and the outer parser (the one calling 
    <code>runSubParser</code>) will continue where the sub-parser stopped.
   </dd> 
  </dl> 
  <hr> 
  <p>There are a few more members of the <code>Parser</code> class that are useful for writing efficient action logic:</p> 
  <dl> 
   <dt>
    def cursor: Int
   </dt> 
   <dd>
    The index of the next (yet unmatched) input character. Note: Might be equal to 
    <code>input.length</code> if the cursor is currently behind the last input character!
   </dd> 
   <dt>
    def cursorChar: Char
   </dt> 
   <dd>
    The next (yet unmatched) input character, i.e. the one at the 
    <code>cursor</code> index. Identical to 
    <code>if (cursor &lt; input.length) input.charAt(cursor) else EOI</code> but more efficient.
   </dd> 
   <dt>
    def lastChar: Char
   </dt> 
   <dd>
    Returns the last character that was matched, i.e. the one at index 
    <code>cursor - 1</code> and as such is equivalent to 
    <code>charAt(-1)</code>. Note that for performance optimization this method does 
    <em>not</em> do a range check, i.e. depending on the 
    <code>ParserInput</code> implementation you might get an exception when calling this method before any character was matched by the parser.
   </dd> 
   <dt>
    def charAt(offset: Int): Char
   </dt> 
   <dd>
    Returns the character at the input index with the given delta to the cursor and as such is equivalent to 
    <code>input.charAt(cursor + offset)</code>. Note that for performance optimization this method does 
    <em>not</em> do a range check, i.e. depending on the 
    <code>ParserInput</code> implementation you might get an exception if the computed index is out of bounds.
   </dd> 
   <dt>
    def charAtRC(offset: Int): Char
   </dt> 
   <dd>
    Same as 
    <code>charAt</code> but range-checked. Returns the input character at the index with the given offset from the cursor. If this index is out of range the method returns 
    <code>EOI</code>.
   </dd> 
  </dl> 
  <p>You can use these to write efficient character-level logic like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">hexDigit</span><span class="pl-k">:</span> <span class="pl-en">Rule1</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> rule {
  <span class="pl-en">CharPredicate</span>.<span class="pl-en">HexAlpha</span> <span class="pl-k">~</span> push(<span class="pl-en">CharUtils</span>.hexValue(lastChar))
}</pre>
  </div> 
  <a name="user-content-additional-helpers" target="_blank" href=""></a> 
  <h3><a id="user-content-additional-helpers" class="anchor" href="https://github.com/sirthias/parboiled2#additional-helpers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id21" target="_blank">Additional Helpers</a></h3> 
  <dl> 
   <dt>
    Base64Parsing
   </dt> 
   <dd>
    For parsing 
    <a href="http://tools.ietf.org/html/rfc2045#section-6.8" target="_blank">RFC2045</a> (Base64) encoded strings 
    <em>parboiled</em> provides the 
    <code>Base64Parsing</code> trait which you can mix into your 
    <code>Parser</code> class. See 
    <a href="https://github.com/sirthias/parboiled2/blob/v2.0.0-RC1/parboiled/src/main/scala/org/parboiled2/Base64Parsing.scala" target="_blank">its source</a> for more info on what exactly it provides. 
    <em>parboiled</em> also comes with the 
    <code>org.parboiled2.util.Base64</code> class which provides an efficient Base64 encoder/decoder for the standard as well as custom alphabets.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    DynamicRuleDispatch
   </dt> 
   <dd>
    Sometimes an application cannot fully specify at compile-time which of a given set of rules is to be called at runtime. For example, a parser for parsing HTTP header values might need to select the right parser rule for a header name that is only known once the HTTP request has actually been read from the network. To prevent you from having to write a large (and not really efficient) 
    <code>match</code> against the header name for separating out all the possible cases 
    <em>parboiled</em> provides the 
    <code>DynamicRuleDispatch</code> facility. Check out 
    <a href="https://github.com/sirthias/parboiled2/blob/v2.0.0-RC1/parboiled/src/test/scala/org/parboiled2/DynamicRuleDispatchSpec.scala" target="_blank">its test</a> for more info on how to use it.
   </dd> 
  </dl> 
  <hr> 
  <dl> 
   <dt>
    StringBuilding
   </dt> 
   <dd>
    For certain high-performance use-cases it is sometimes better to construct Strings that the parser is to produce/extract from the input in a char-by-char fashion. To support you in doing this 
    <em>parboiled</em> provides the 
    <code>StringBuilding</code> trait which you can mix into your 
    <code>Parser</code> class. It provides convenient access to a 
    <strong>single</strong> and 
    <strong>mutable</strong> 
    <code>StringBuilder</code> instance. As such it operates outside of the value stack and therefore without the full "safety net" that parboiled's DSL otherwise gives you. If you don't understand what this means you probably shouldn't be using the 
    <code>StringBuilding</code> trait but resort to 
    <code>capture</code> and ordinary parser actions instead.
   </dd> 
  </dl> 
  <a name="user-content-error-reporting" target="_blank" href=""></a> 
  <h2><a id="user-content-error-reporting" class="anchor" href="https://github.com/sirthias/parboiled2#error-reporting" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id22" target="_blank">Error Reporting</a></h2> 
  <p>In many applications, especially with grammars that are not too complex, <em>parboiled</em> provides good error reports right out of the box, without any additional requirements on your part. However, there are cases where you want to have more control over how parse errors are created and/or formatted. This section gives an overview over how parse error reporting works in <em>parboiled</em> and how you can influence it.</p> 
  <a name="user-content-the-error-collection-process" target="_blank" href=""></a> 
  <h3><a id="user-content-the-error-collection-process" class="anchor" href="https://github.com/sirthias/parboiled2#the-error-collection-process" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id23" target="_blank">The Error Collection Process</a></h3> 
  <p>As described in the section about <a href="https://github.com/sirthias/parboiled2#how-the-parser-matches-input" target="_blank">How the Parser matches Input</a> above the parser consumes input by applying grammar rules and backtracking in the case of mismatches. As such rule mismatches are an integral part of the parsers operation and do not generally mean that there is something wrong with the input. Only when the root rule itself mismatches and the parser has no backtracking options remaining does it become clear that a parse error is present. At that point however, when the root rule mismatches, the information about where exactly the problematic input was and which of the many rule mismatches that the parser experienced during the run were the "bad" ones is already lost.</p> 
  <p><em>parboiled</em> overcomes this problem by simply re-running the failed parser, potentially many times, and "watching" it as it tries to consume the erroneous input. With every re-run <em>parboiled</em> learns a bit more about the position and nature of the error and when this analysis is complete a <code>ParseError</code> instance is constructed and handed to the application as the result of the parsing run, which can then use the error information on its level (e.g. for formatting it and displaying it to the user). Note that re-running the parser in the presence of parse errors does result in unsuccessful parsing runs being potentially much slower than successful ones. However, since in the vast majority of use cases failed runs constitute only a small minority of all parsing runs and the normal flow of application logic is disrupted anyway, this slow-down is normally quite acceptable, especially if it results in better error messages. See the section on <a href="https://github.com/sirthias/parboiled2#limiting-error-re-runs" target="_blank">Limiting Error Re-Runs</a> if this is not true for your application.</p> 
  <p>In principle the error reporting process looks like this:</p> 
  <ol class="arabic simple"> 
   <li>The grammar's root rule is run at maximum speed against the parser input. If this succeeds then all is well and the parsing result is immediately dispatched to the user.</li> 
   <li>If the root rule did not match we know that there we have a parsing error. The parser is then run again to establish the "principal error location". The principal error location is the first character in the input that could not be matched by any rule during the parsing run. In order words, it is the maximum value that the parser's <code>cursor</code> member had during the parsing run.</li> 
   <li>Once the error location is known the parser is run again. This time all rule mismatches against the input character at error location are recorded. These rule mismatches are used to determine what input the grammar "expects" at the error location but failed to see. For every such "error rule mismatch" the parser collects the "rule trace", i.e. the stack of rules that led to it. Currently this is done by throwing a special exception that bubbles up through the JVM call stack and records rule stack information on its way up. A consequence of this design is that the parser needs to be re-run once per "error rule mismatch".</li> 
   <li>When all error rule traces have been collected all the relevant information about the parse error has been extracted and a <code>ParseError</code> instance can be constructed and dispatched to the user.</li> 
  </ol> 
  <p>Note: The real process contains a few more steps to properly deal with the <code>atomic</code> and <code>quiet</code> markers described below. However, knowledge of these additional steps is not important for understanding the basic approach for how <code>ParseError</code> instances are constructed.</p> 
  <a name="user-content-formatting-parse-errors" target="_blank" href=""></a> 
  <h3><a id="user-content-formatting-parse-errors" class="anchor" href="https://github.com/sirthias/parboiled2#formatting-parse-errors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id24" target="_blank">Formatting Parse Errors</a></h3> 
  <p>If a parsing runs fails and you receive a <code>ParseError</code> instance you can call the <code>formatError</code> method on your parser instance to get the error rendered into an error message string:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">errorMsg</span> <span class="pl-k">=</span> parser.formatError(error)</pre>
  </div> 
  <p>The <code>formatError</code> message can also take an explicit <code>ErrorFormatter</code> as a second argument, which allows you to influence how exactly the error is to be rendered. For example, in order to also render the rule traces you can do:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">errorMsg</span> <span class="pl-k">=</span> parser.formatError(error, <span class="pl-k">new</span> <span class="pl-en">ErrorFormatter</span>(showTraces <span class="pl-k">=</span> <span class="pl-c1">true</span>))</pre>
  </div> 
  <p>Look at the signature of the <code>ErrorFormatter</code> constructor for more information on what rendering options exist.</p> 
  <p>If you want even more control over the error rendering process you can extend the <code>ErrorFormatter</code> and override its methods where you see fit.</p> 
  <a name="user-content-tweaking-error-reporting" target="_blank" href=""></a> 
  <h3><a id="user-content-tweaking-error-reporting" class="anchor" href="https://github.com/sirthias/parboiled2#tweaking-error-reporting" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id25" target="_blank">Tweaking Error Reporting</a></h3> 
  <p>While the error collection process described above yields all information required for a basic "this character was not matched and these characters were expected instead" information you sometimes want to have more control over what exactly is reported as "found" and as "expected".</p> 
  <a name="user-content-the-atomic-marker" target="_blank" href=""></a> 
  <h4><a id="user-content-the-atomic-marker" class="anchor" href="https://github.com/sirthias/parboiled2#the-atomic-marker" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id26" target="_blank">The <code>atomic</code> Marker</a></h4> 
  <p>Since PEG parsers are scanner-less (i.e. without an intermediate "TOKEN-stream") they operate directly on the input buffer's character level. As such, by default, <em>parboiled</em> reports all errors on this character level.</p> 
  <p>For example, if you run the rule <code>"foo" | "fob" | "bar"</code> against input "foxes" you'll get this error message:</p> 
  <pre>Invalid input 'x', expected 'o' or 'b' (line 1, column 3):
foxes
  ^
</pre> 
  <p>While this error message is certainly correct, it might not be what you want to show your users, e.g. because <code>foo</code>, <code>fob</code> and <code>bar</code> are regarded as "atomic" keywords of your language, that should either be matched completely or not at all. In this case you can use the <code>atomic</code> marker to signal this to the parser. For example, running the rule <code>atomic("foo") | atomic("fob") | atomic("bar")</code> against input "foxes" yields this error message:</p> 
  <pre>Invalid input "fox", expected "foo", "fob" or "bar" (line 1, column 1):
foxes
^
</pre> 
  <p>Of course you can use the <code>atomic</code> marker on any type of rule, not just string rules. It essentially moves the reported error position forward from the principal error position and lifts the level at which errors are reported from the character level to a rule level of your choice.</p> 
  <a name="user-content-the-quiet-marker" target="_blank" href=""></a> 
  <h4><a id="user-content-the-quiet-marker" class="anchor" href="https://github.com/sirthias/parboiled2#the-quiet-marker" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id27" target="_blank">The <code>quiet</code> Marker</a></h4> 
  <p>Another problem that more frequently occurs with <em>parboiled</em>'s default error reporting is that the list of "expected" things becomes too long. Often the reason for this are rules that deal match input which can appear pretty much anywhere, like whitespace or comments.</p> 
  <p>Consider this simple language:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">Expr</span>    <span class="pl-k">=</span> rule { oneOrMore(<span class="pl-en">Id</span> <span class="pl-k">~</span> <span class="pl-en">Keyword</span> <span class="pl-k">~</span> <span class="pl-en">Id</span>).separatedBy(<span class="pl-c1">','</span> <span class="pl-k">~</span> <span class="pl-en">WS</span>) <span class="pl-k">~</span> <span class="pl-en">EOI</span> }
<span class="pl-k">def</span> <span class="pl-en">Id</span>      <span class="pl-k">=</span> rule { oneOrMore(<span class="pl-en">CharPredicate</span>.<span class="pl-en">Alpha</span>) <span class="pl-k">~</span> <span class="pl-en">WS</span> }
<span class="pl-k">def</span> <span class="pl-en">Keyword</span> <span class="pl-k">=</span> rule { atomic((<span class="pl-s"><span class="pl-pds">"</span>has<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-s"><span class="pl-pds">"</span>is<span class="pl-pds">"</span></span>) <span class="pl-k">~</span> <span class="pl-en">WS</span>) }
<span class="pl-k">def</span> <span class="pl-en">WS</span>      <span class="pl-k">=</span> rule { zeroOrMore(anyOf(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-cce">\t</span> <span class="pl-cce">\n</span><span class="pl-pds">"</span></span>)) }</pre>
  </div> 
  <p>When we run the <code>Expr</code> rule against input "Tim has money, Tom Is poor" we get this error:</p> 
  <pre>Invalid input 'I', expected [ \t \n] or Keyword (line 1, column 20):
Tim has money, Tom Is poor
                   ^
</pre> 
  <p>Again the list of "expected" things is technically correct but we don't want to bother the user with the information that whitespace is also allowed at the error location. The <code>quiet</code> marker let's us suppress a certain rule from the expected list if there are also non-quiet alternatives:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">WS</span> <span class="pl-k">=</span> rule { quiet(zeroOrMore(anyOf(<span class="pl-s"><span class="pl-pds">"</span> <span class="pl-cce">\t</span> <span class="pl-cce">\n</span><span class="pl-pds">"</span></span>))) }</pre>
  </div> 
  <p>With that change the error message becomes:</p> 
  <pre>Invalid input 'I', expected Keyword (line 1, column 20):
Tim has money, Tom Is poor
                   ^
</pre> 
  <p>which is what we want.</p> 
  <a name="user-content-naming-rules" target="_blank" href=""></a> 
  <h4><a id="user-content-naming-rules" class="anchor" href="https://github.com/sirthias/parboiled2#naming-rules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id28" target="_blank">Naming Rules</a></h4> 
  <p><em>parboiled</em> uses a somewhat involved logic to determine what exactly to report as "mismatched" and "expected" for a given parse error. Essentially the process looks like this:</p> 
  <ol class="arabic simple"> 
   <li>Compare all rule trace for the error and drop a potentially existing common prefix. This is done because, if all traces share a common prefix, this prefix can be regarded as the "context" of the error which is probably apparent to the user and as such doesn't need to be reported.</li> 
   <li>For each trace (suffix), find the first frame that tried to start its match at the reported error position. The string representation of this frame (which might be an assigned name) is selected for "expected" reporting.</li> 
   <li>Duplicate "expected" strings are removed.</li> 
  </ol> 
  <p>So, apart from placing <code>atomic</code> and <code>quiet</code> markers you can also influence what gets reported as "expected" by explicitly naming rules. One way to do this is to pick good names for the rule methods as they automatically attach their name to their rules. The names of <code>val</code> or <code>def</code> members that you use to reference <code>CharPredicate</code> instances also automatically name the respective rule.</p> 
  <p>If you don't want to split out rules into their own methods you can also use the <code>named</code> modifier. With it you can attach an explicit name to any parser rule. For example, if you run the rule <code>foo</code> from this snippet:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> rule { <span class="pl-s"><span class="pl-pds">"</span>aa<span class="pl-pds">"</span></span> <span class="pl-k">|</span> atomic(<span class="pl-s"><span class="pl-pds">"</span>aaa<span class="pl-pds">"</span></span>).named(<span class="pl-s"><span class="pl-pds">"</span>threeAs<span class="pl-pds">"</span></span>) <span class="pl-k">|</span> <span class="pl-c1">'b'</span> <span class="pl-k">|</span> <span class="pl-c1">'B'</span>.named(<span class="pl-s"><span class="pl-pds">"</span>bigB<span class="pl-pds">"</span></span>) }</pre>
  </div> 
  <p>against input <code>x</code> you'll get this error message:</p> 
  <pre>Invalid input 'x', expected 'a', threeAs, 'b' or bigB (line 1, column 1):
x
^
</pre> 
  <a name="user-content-manual-error-reporting" target="_blank" href=""></a> 
  <h4><a id="user-content-manual-error-reporting" class="anchor" href="https://github.com/sirthias/parboiled2#manual-error-reporting" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id29" target="_blank">Manual Error Reporting</a></h4> 
  <p>If you want to completely bypass <em>parboiled</em>'s built-in error reporting logic you can do so by exclusively relying on the <code>fail</code> helper, which causes the parser to immediately and fatally terminate the parsing run with a single one-frame rule trace with a given "expected" message.</p> 
  <p>For example, the rule <code>"foo" | fail("a true FOO")</code> will produce this error when run against <code>x</code>:</p> 
  <pre>Invalid input 'x', expected a true FOO (line 1, column 1):
x
^
</pre> 
  <a name="user-content-limiting-error-re-runs" target="_blank" href=""></a> 
  <h3><a id="user-content-limiting-error-re-runs" class="anchor" href="https://github.com/sirthias/parboiled2#limiting-error-re-runs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id30" target="_blank">Limiting Error Re-Runs</a></h3> 
  <p>Really large grammars, especially ones with bugs as they commonly appear during development, can exhibit a very large number of rule traces (potentially thousands) and thus cause the parser to take longer than convenient to terminate an error parsing run. In order to mitigate this <em>parboiled</em> has a configurable limit on the maximum number of rule traces the parser will collect during a single error run. The default limit is 24, you can change it by overriding the <code>errorTraceCollectionLimit</code> method of the <code>Parser</code> class.</p> 
  <a name="user-content-recovering-from-parse-errors" target="_blank" href=""></a> 
  <h3><a id="user-content-recovering-from-parse-errors" class="anchor" href="https://github.com/sirthias/parboiled2#recovering-from-parse-errors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id31" target="_blank">Recovering from Parse Errors</a></h3> 
  <p>Currently <em>parboiled</em> only ever parses up to the very first parse error in the input. While this is all that's required for a large number of use cases there are applications that do require the ability to somehow recover from parse errors and continue parsing. Syntax highlighting in an interactive IDE-like environment is one such example.</p> 
  <p>Future versions of <em>parboiled</em> might support parse error recovery. If your application would benefit from this feature please let us know in <a href="https://github.com/sirthias/parboiled2/issues/42" target="_blank">this github ticket</a>.</p> 
  <a name="user-content-advanced-techniques" target="_blank" href=""></a> 
  <h2><a id="user-content-advanced-techniques" class="anchor" href="https://github.com/sirthias/parboiled2#advanced-techniques" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id32" target="_blank">Advanced Techniques</a></h2> 
  <h2 id="user-content-meta-rules"><a id="user-content-meta-rules" class="anchor" href="https://github.com/sirthias/parboiled2#meta-rules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Meta-Rules</h2> 
  <p>Sometimes you might find yourself in a situation where you'd like to DRY up your grammar definition by factoring out common constructs from several rule definitions in a "meta-rule" that modifies/decorates other rules. Essentially you'd like to write something like this (<em>illegal</em> code!):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">expression</span> <span class="pl-k">=</span> rule { bracketed(ab) <span class="pl-k">~</span> bracketed(cd) }
<span class="pl-k">def</span> <span class="pl-en">ab</span> <span class="pl-k">=</span> rule { <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span> }
<span class="pl-k">def</span> <span class="pl-en">cd</span> <span class="pl-k">=</span> rule { <span class="pl-s"><span class="pl-pds">"</span>cd<span class="pl-pds">"</span></span> }
<span class="pl-k">def</span> <span class="pl-en">bracketed</span>(<span class="pl-v">inner</span>: <span class="pl-en">Rule0</span>) <span class="pl-k">=</span> rule { <span class="pl-c1">'['</span> <span class="pl-k">~</span> inner <span class="pl-k">~</span> <span class="pl-c1">']'</span> }</pre>
  </div> 
  <p>In this hypothetical example <code>bracketed</code> is a meta-rule which takes another rule as parameter and calls it from within its own rule definition.</p> 
  <p>Unfortunately enabling a syntax such as the one shown above it not directly possible with <em>parboiled</em>. When looking at how the parser generation in <em>parboiled</em> actually works the reason becomes clear. <em>parboiled</em> "expands" the rule definition that is passed as argument to the <code>rule</code> macro into actual Scala code. The rule methods themselves however remain what they are: instance methods on the parser class. And since you cannot simply pass a method name as argument to another method the calls <code>bracketed(ab)</code> and <code>bracketed(cd)</code> from above don't compile.</p> 
  <p>However, there is a work-around which might be good enough for your meta-rule needs:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">expression</span> <span class="pl-k">=</span> rule { bracketed(ab) <span class="pl-k">~</span> bracketed(cd) }
<span class="pl-k">val</span> <span class="pl-en">ab</span> <span class="pl-k">=</span> () <span class="pl-k">â‡’</span> rule { <span class="pl-s"><span class="pl-pds">"</span>ab<span class="pl-pds">"</span></span> }
<span class="pl-k">val</span> <span class="pl-en">cd</span> <span class="pl-k">=</span> () <span class="pl-k">â‡’</span> rule { <span class="pl-s"><span class="pl-pds">"</span>cd<span class="pl-pds">"</span></span> }
<span class="pl-k">def</span> <span class="pl-en">bracketed</span>(<span class="pl-v">inner</span>: () <span class="pl-k">â‡’</span> <span class="pl-en">Rule0</span>) <span class="pl-k">=</span> rule { <span class="pl-c1">'['</span> <span class="pl-k">~</span> inner() <span class="pl-k">~</span> <span class="pl-c1">']'</span> }</pre>
  </div> 
  <p>If you model the rules that you want to pass as arguments to other rules as <code>Function0</code> instances you <em>can</em> pass them around. Assigning those function instances to <code>val</code> members avoids re-allocation during <em>every</em> execution of the <code>expression</code> rule which would come with a potentially significant performance cost.</p> 
  <a name="user-content-common-mistakes" target="_blank" href=""></a> 
  <h2><a id="user-content-common-mistakes" class="anchor" href="https://github.com/sirthias/parboiled2#common-mistakes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id33" target="_blank">Common Mistakes</a></h2> 
  <a name="user-content-disregarding-order-choice" target="_blank" href=""></a> 
  <h3><a id="user-content-disregarding-order-choice" class="anchor" href="https://github.com/sirthias/parboiled2#disregarding-order-choice" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id34" target="_blank">Disregarding Order Choice</a></h3> 
  <p>There is one mistake that new users frequently make when starting out with writing <a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar" target="_blank">PEG</a> grammars: disregarding the "ordered choice" logic of the <code>|</code> operator. This operator always tries all alternatives <em>in the order that they were defined</em> and picks the first match.</p> 
  <p>As a consequence earlier alternatives that are a prefix of later alternatives will always "shadow" the later ones, the later ones will never be able to match!</p> 
  <p>For example in this simple rule</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> rule { <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-s"><span class="pl-pds">"</span>foobar<span class="pl-pds">"</span></span> }</pre>
  </div> 
  <p>"foobar" will never match. Reordering the alternatives to either "factor out" all common prefixes or putting the more specific alternatives first are the canonical solutions.</p> 
  <p>If your parser is not behaving the way you expect it to watch out for this "wrong ordering" problem, which might be not that easy to spot in more complicated rule structures.</p> 
  <a name="user-content-non-termination-when-using-syntactic-predicates" target="_blank" href=""></a> 
  <h3><a id="user-content-non-termination-when-using-syntactic-predicates" class="anchor" href="https://github.com/sirthias/parboiled2#non-termination-when-using-syntactic-predicates" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id35" target="_blank">Non-Termination when using Syntactic Predicates</a></h3> 
  <p>The syntactic predicate operators, <code>&amp;</code> and <code>!</code>, don't themselves consume any input, so directly wrapping them with a repeating combinator (like <code>zeroOrMore</code> or <code>oneOrMore</code>) will lead to an infinite loop as the parser continuously runs the syntactic predicate against the very same input position without making any progress.</p> 
  <p>If you use syntactic predicates in a loop make sure to actually consume input as well. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> rule { capture(zeroOrMore( <span class="pl-k">!</span><span class="pl-c1">','</span> )) }</pre>
  </div> 
  <p>will never terminate, while</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> rule { capture(zeroOrMore( <span class="pl-k">!</span><span class="pl-c1">','</span> <span class="pl-k">~</span> <span class="pl-en">ANY</span> )) }</pre>
  </div> 
  <p>will capture all input until it reaches a comma.</p> 
  <a name="user-content-unchecked-mutable-state" target="_blank" href=""></a> 
  <h3><a id="user-content-unchecked-mutable-state" class="anchor" href="https://github.com/sirthias/parboiled2#unchecked-mutable-state" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id36" target="_blank">Unchecked Mutable State</a></h3> 
  <p><em>parboiled2</em> parsers work with mutable state as a design choice for achieving good parsing performance. Matching input and operating on the value stack happen as side-effects to rule execution and mutate the parser state. However, as long as you confine yourself to the value stack and do not add parser actions that mutate custom parser members the rule DSL will protect you from making mistakes.</p> 
  <p>It is important to understand that, in case of rule mismatch, the parser state (cursor and value stack) is reset to what it was before the rule execution was started. However, if you write rules that have side-effects beyond matching input and operating on the value stack than these side-effects <em>cannot</em> be automatically rolled-back! This means that you will have to make sure that you action logic "cleans up after itself" in the case of rule mismatches or is only used in locations where you know that rule execution can never fail. These techniques are considered advanced and are not recommended for beginners.</p> 
  <p>The rule DSL is powerful enough to support even very complex parsing logic without the need to resort to custom mutable state, we consider the addition of mutable members as an optimization that should be well justified.</p> 
  <a name="user-content-handling-whitespace" target="_blank" href=""></a> 
  <h3><a id="user-content-handling-whitespace" class="anchor" href="https://github.com/sirthias/parboiled2#handling-whitespace" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id37" target="_blank">Handling Whitespace</a></h3> 
  <p>One disadvantage of PEGs over lexer-based parser can be the handling of white space. In a "traditional" parser with a separate lexer (scanner) phase this lexer can simply skip all white space and only generate tokens for the actual parser to operate on. This can free the higher-level parser grammar from all white space treatment.</p> 
  <p>Since PEGs do not have a lexer but directly operate on the raw input they have to deal with white space in the grammar itself. Language designers with little experience in PEGs can sometime be unsure of how to best handle white space in their grammar.</p> 
  <p>The common and highly recommended pattern is to <strong>match white space always immediately after a terminal (a single character or string) but not in any other place</strong>. This helps with keeping your grammar rules properly structured and white space "taken care of" without it getting in the way.</p> 
  <hr> 
  <p>In order to reduce boilerplate in your grammar definition parboiled allows for cleanly factoring out whitespace matching logic into a dedicated rule. By defining a custom implicit conversion from <code>String</code> to <code>Rule0</code> you can implicitly match whitespace after a string terminal:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">FooParser</span>(<span class="pl-k">val</span> <span class="pl-en">input</span><span class="pl-k">:</span> <span class="pl-en">ParserInput</span>) <span class="pl-k">extends</span> <span class="pl-e">Parser</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">wspStr</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">Rule0</span> <span class="pl-k">=</span> rule {
    str(s) <span class="pl-k">~</span> zeroOrMore(<span class="pl-c1">' '</span>)
  }

  <span class="pl-k">def</span> <span class="pl-en">foo</span> <span class="pl-k">=</span> rule { <span class="pl-s"><span class="pl-pds">"</span>foobar<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> } <span class="pl-c">// implicitly matches trailing blanks</span>
  <span class="pl-k">def</span> <span class="pl-en">fooNoWSP</span> <span class="pl-k">=</span> rule { str(<span class="pl-s"><span class="pl-pds">"</span>foobar<span class="pl-pds">"</span></span>) <span class="pl-k">|</span> str(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>) } <span class="pl-c">// doesn't match trailing blanks</span>
}</pre>
  </div> 
  <p>In this example all usages of a plain string literals in the parser rules will implicitly match trailing space characters. In order to <em>not</em> apply the implicit whitespace matching in this case simply say <code>str("foo")</code> instead of just <code>"foo"</code>.</p> 
  <a name="user-content-parsing-the-whole-input" target="_blank" href=""></a> 
  <h3><a id="user-content-parsing-the-whole-input" class="anchor" href="https://github.com/sirthias/parboiled2#parsing-the-whole-input" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id38" target="_blank">Parsing the whole Input</a></h3> 
  <p>If you don't explicitly match <code>EOI</code> (the special end-of-input pseudo-character) in your grammar's root rule the parser will not produce an error if, at the end of a parsing run, there is still unmatched input left. This means that if the root rule matches only a prefix of the whole input the parser will report a successful parsing run, which might not be what you want.</p> 
  <p>As an example, consider this very basic parser:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyParser</span>(<span class="pl-k">val</span> <span class="pl-en">input</span><span class="pl-k">:</span> <span class="pl-en">ParserInput</span>) <span class="pl-k">extends</span> <span class="pl-e">Parser</span> {
  <span class="pl-k">def</span> <span class="pl-en">InputLine</span> <span class="pl-k">=</span> rule { <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> }
}

<span class="pl-k">new</span> <span class="pl-en">MyParser</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>).<span class="pl-en">InputLine</span>.run()  <span class="pl-c">// Success</span>
<span class="pl-k">new</span> <span class="pl-en">MyParser</span>(<span class="pl-s"><span class="pl-pds">"</span>foot<span class="pl-pds">"</span></span>).<span class="pl-en">InputLine</span>.run()  <span class="pl-c">// also Success!!</span></pre>
  </div> 
  <p>In the second run of the parser, instead of failing with a <code>ParseError</code> as you might expect, it successfully parses the matching input <code>foo</code> and ignores the rest of the input.</p> 
  <p>If this is not what you want you need to explicitly match <code>EOI</code>, for example as follows:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">InputLine</span> <span class="pl-k">=</span> rule { (<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">|</span> <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>) <span class="pl-k">~</span> <span class="pl-en">EOI</span> }</pre>
  </div> 
  <a name="user-content-grammar-debugging" target="_blank" href=""></a> 
  <h2><a id="user-content-grammar-debugging" class="anchor" href="https://github.com/sirthias/parboiled2#grammar-debugging" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id39" target="_blank">Grammar Debugging</a></h2> 
  <p>TODO</p> 
  <p>(e.g., use <code>parse.formatError(error, showTraces = true)</code>)</p> 
  <a name="user-content-access-to-parser-results" target="_blank" href=""></a> 
  <h2><a id="user-content-access-to-parser-results" class="anchor" href="https://github.com/sirthias/parboiled2#access-to-parser-results" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id40" target="_blank">Access to Parser Results</a></h2> 
  <p>In order to run the top-level parser rule against a given input you create a new instance of your parser class and call <code>run()</code> on it, e.g:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">parser</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MyParser</span>(input)
<span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> parser.rootRule.run()</pre>
  </div> 
  <p>By default the type of <code>result</code> in this snippet will be a <code>Try[T]</code> whereby <code>T</code> depends on the type of <code>rootRule</code>:</p> 
  <table> 
   <thead valign="bottom"> 
    <tr>
     <th>Type of <code>rootRule</code></th> 
     <th>Type of <code>rootRule.run()</code></th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr>
     <td><code>Rule0</code></td> 
     <td><code>Try[Unit]</code></td> 
    </tr> 
    <tr>
     <td><code>Rule1[T]</code></td> 
     <td><code>Try[T]</code></td> 
    </tr> 
    <tr>
     <td><code>RuleN[L &lt;: HList]</code> (otherwise)</td> 
     <td><code>Try[L]</code></td> 
    </tr> 
   </tbody> 
  </table> 
  <p>The contents of the value stack at the end of the <code>rootRule</code> execution constitute the result of the parsing run. Note that <code>run()</code> is not available on rules that are not of type <code>RuleN[L &lt;: HList]</code>.</p> 
  <p>If the parser is not able to match the input successfully it creates an instance of class <code>ParseError</code> , which is defined like this</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">ParseError</span>(<span class="pl-v">position</span>: <span class="pl-en">Position</span>, <span class="pl-v">charCount</span>: <span class="pl-k">Int</span>, <span class="pl-v">traces</span>: <span class="pl-en">Seq</span>[<span class="pl-en">RuleTrace</span>]) <span class="pl-k">extends</span> <span class="pl-e">RuntimeException</span></pre>
  </div> 
  <p>In such cases the <code>Try</code> is completed with a <code>scala.util.Failure</code> holding the <code>ParseError</code>. If other exceptions occur during the parsing run (e.g. because some parser action failed) these will also end up as a <code>Try</code> failure.</p> 
  <p><em>parboiled2</em> has quite powerful error reporting facilities, which should help you (and your users) to easily understand why a particular input does not conform to the defined grammar and how this can be fixed. The <code>formatError</code> method available on the <code>Parser</code> class is of great utility here, as it can "pretty print" a parse error instance, to display something like this (excerpt from the <a href="https://github.com/sirthias/parboiled2/blob/master/parboiled/src/test/scala/org/parboiled2/ErrorReportingSpec.scala" target="_blank">ErrorReportingSpec</a>):</p> 
  <pre>Invalid input 'x', expected 'f', Digit, hex or UpperAlpha (line 1, column 4):
abcx
   ^

4 rules mismatched at error location:
  targetRule / | / "fgh" / 'f'
  targetRule / | / Digit
  targetRule / | / hex
  targetRule / | / UpperAlpha
</pre> 
  <a name="user-content-alternative-deliveryschemes" target="_blank" href=""></a> 
  <h3><a id="user-content-alternative-deliveryschemes" class="anchor" href="https://github.com/sirthias/parboiled2#alternative-deliveryschemes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id41" target="_blank">Alternative DeliverySchemes</a></h3> 
  <p>Apart from delivering your parser results as a <code>Try[T]</code> <em>parboiled2</em> allows you to select another one of the pre-defined <code>Parser.DeliveryScheme</code> alternatives, or even define your own. They differ in how they wrap the three possible outcomes of a parsing run:</p> 
  <ul> 
   <li>parsing completed successfully, deliver a result of type <code>T</code></li> 
   <li>parsing failed with a <code>ParseError</code></li> 
   <li>parsing failed due to another exception</li> 
  </ul> 
  <p>This table compares the built-in <code>Parser.DeliveryScheme</code> alternatives (the first one being the default):</p> 
  <table> 
   <thead valign="bottom"> 
    <tr>
     <th>Import</th> 
     <th>Type of <code>rootRule.run()</code></th> 
     <th>Success</th> 
     <th>ParseError</th> 
     <th>Other Exceptions</th> 
    </tr> 
   </thead> 
   <tbody valign="top"> 
    <tr>
     <td>import Parser.DeliveryScheme.Try</td> 
     <td>Try[T]</td> 
     <td>Success</td> 
     <td>Failure</td> 
     <td>Failure</td> 
    </tr> 
    <tr>
     <td>import Parser.DeliveryScheme.Either</td> 
     <td>Either[ParseError, T]</td> 
     <td>Right</td> 
     <td>Left</td> 
     <td>thrown</td> 
    </tr> 
    <tr>
     <td>import Parser.DeliveryScheme.Throw</td> 
     <td>T</td> 
     <td>T</td> 
     <td>thrown</td> 
     <td>thrown</td> 
    </tr> 
   </tbody> 
  </table> 
  <a name="user-content-running-the-examples" target="_blank" href=""></a> 
  <h2><a id="user-content-running-the-examples" class="anchor" href="https://github.com/sirthias/parboiled2#running-the-examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id42" target="_blank">Running the Examples</a></h2> 
  <p>Follow these steps to run the example parsers defined <a href="https://github.com/sirthias/parboiled2/tree/master/examples/src/main/scala/org/parboiled2/examples" target="_blank">here</a> on your own machine:</p> 
  <ol class="arabic"> 
   <li><p>Clone the <em>parboiled2</em> repository:</p> <pre>git clone git://github.com/sirthias/parboiled2.git
</pre> </li> 
   <li><p>Change into the base directory:</p> <pre>cd parboiled2
</pre> </li> 
   <li><p>Run SBT:</p> <pre>sbt "project examples" run
</pre> </li> 
  </ol> 
  <a name="user-content-alternatives" target="_blank" href=""></a> 
  <h2><a id="user-content-alternatives" class="anchor" href="https://github.com/sirthias/parboiled2#alternatives" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id43" target="_blank">Alternatives</a></h2> 
  <a name="user-content-parboiled2-vs-parboiled-1-x" target="_blank" href=""></a> 
  <h3><a id="user-content-parboiled2-vs-parboiled-1x" class="anchor" href="https://github.com/sirthias/parboiled2#parboiled2-vs-parboiled-1x" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id44" target="_blank">parboiled2 vs. parboiled 1.x</a></h3> 
  <p>TODO</p> 
  <p>(about one order of magnitude faster, more powerful DSL, improved error reporting, fewer dependencies (more lightweight), but Scala 2.10.3+ only, no error recovery (yet) and no Java version (ever))</p> 
  <a name="user-content-parboiled2-vs-scala-parser-combinators" target="_blank" href=""></a> 
  <h3><a id="user-content-parboiled2-vs-scala-parser-combinators" class="anchor" href="https://github.com/sirthias/parboiled2#parboiled2-vs-scala-parser-combinators" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id45" target="_blank">parboiled2 vs. Scala Parser Combinators</a></h3> 
  <p>TODO</p> 
  <p>(several hundred times (!) faster, better error reporting, more concise and elegant DSL, similarly powerful in terms of language class capabilities, but Scala 2.10.3+ only, 2 added dependencies (parboiled2 + shapeless))</p> 
  <a name="user-content-parboiled2-vs-regular-expressions" target="_blank" href=""></a> 
  <h3><a id="user-content-parboiled2-vs-regular-expressions" class="anchor" href="https://github.com/sirthias/parboiled2#parboiled2-vs-regular-expressions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id46" target="_blank">parboiled2 vs. Regular Expressions</a></h3> 
  <p>TODO</p> 
  <p>(much easier to read and maintain, more powerful (e.g. regexes do not support recursive structures), faster, but Scala 2.10.3+ only, 2 added dependencies (parboiled2 + shapeless))</p> 
  <a name="user-content-roadmap" target="_blank" href=""></a> 
  <h2><a id="user-content-roadmap" class="anchor" href="https://github.com/sirthias/parboiled2#roadmap" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id47" target="_blank">Roadmap</a></h2> 
  <p>TODO</p> 
  <a name="user-content-contributing" target="_blank" href=""></a> 
  <h2><a id="user-content-contributing" class="anchor" href="https://github.com/sirthias/parboiled2#contributing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id48" target="_blank">Contributing</a></h2> 
  <p>TODO</p> 
  <a name="user-content-support" target="_blank" href=""></a> 
  <h2><a id="user-content-support" class="anchor" href="https://github.com/sirthias/parboiled2#support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id49" target="_blank">Support</a></h2> 
  <p>In most cases the <a href="https://groups.google.com/forum/#!forum/parboiled-user" target="_blank">parboiled2 mailing list</a> is probably the best place for your needs with regard to support, feedback and general discussion.</p> 
  <p><strong>Note:</strong> Your first post after signup is going to be moderated (for spam protection), but we'll immediately give you full posting privileges if your message doesn't unmask you as a spammer.</p> 
  <p>You can also use the gitter.im chat channel for parboiled2:</p> 
  <a href="https://gitter.im/sirthias/parboiled2?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img alt="Join the chat at https://gitter.im/sirthias/parboiled2" src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"> </a> 
  <a name="user-content-references" target="_blank" href=""></a> 
  <h2><a id="user-content-references" class="anchor" href="https://github.com/sirthias/parboiled2#references" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id50" target="_blank">References</a></h2> 
  <p>TODO</p> 
  <a name="user-content-credits" target="_blank" href=""></a> 
  <h2><a id="user-content-credits" class="anchor" href="https://github.com/sirthias/parboiled2#credits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id51" target="_blank">Credits</a></h2> 
  <p>Much of <em>parboiled2</em> was developed by <a href="https://github.com/alexander-myltsev" target="_blank">Alexander Myltsev</a> during <a href="http://www.google-melange.com/gsoc/homepage/google/gsoc2013" target="_blank">GSoc 2013</a>, a big thank you for his great work!</p> 
  <p>Also, without the <a href="http://docs.scala-lang.org/overviews/macros/paradise.html" target="_blank">Macro Paradise</a> made available by <a href="https://github.com/xeno-by" target="_blank">Eugene Burmako</a> <em>parboiled2</em> would probably still not be ready and its codebase would look a lot more messy.</p> 
  <a name="user-content-license" target="_blank" href=""></a> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/sirthias/parboiled2#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/sirthias/parboiled2#id52" target="_blank">License</a></h2> 
  <p><em>parboiled2</em> is released under the <a href="http://en.wikipedia.org/wiki/Apache_license" target="_blank">Apache License 2.0</a></p> 
 </article>
</div>