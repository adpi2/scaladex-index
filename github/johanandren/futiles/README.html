<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-futiles" class="anchor" href="https://github.com/johanandren/futiles#futiles" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Futiles</h1> 
  <p><a href="https://gitter.im/johanandren/futiles?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/johanandren/futiles" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/johanandren/futiles" target="_blank"><img src="https://camo.githubusercontent.com/364751463cd3bd68e9fe5641599e83a96f9f1bb3/68747470733a2f2f7472617669732d63692e6f72672f6a6f68616e616e6472656e2f667574696c65732e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/johanandren/futiles.svg" style="max-width:100%;"></a> <a href="https://coveralls.io/r/johanandren/futiles?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/644b7028e03693dcba33bef13054ecb3fcac0c02/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6a6f68616e616e6472656e2f667574696c65732f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/johanandren/futiles/badge.svg?branch=master" style="max-width:100%;"></a> <a href="http://www.apache.org/licenses/LICENSE-2.0.html" target="_blank"><img src="https://camo.githubusercontent.com/8bf81d4b6a63eaf6f712e3092fe7238f8716e615/687474703a2f2f696d672e736869656c64732e696f2f3a6c6963656e73652d6170616368652d626c75652e737667" alt="License" data-canonical-src="http://img.shields.io/:license-apache-blue.svg" style="max-width:100%;"></a></p> 
  <p>The missing utils for working with Scala Futures</p> 
  <h2><a id="user-content-about" class="anchor" href="https://github.com/johanandren/futiles#about" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>About</h2> 
  <p>Throughout a few different Scala projects I have written these utility functions for working with futures over and over again.</p> 
  <p><a href="https://github.com/johanandren/futiles/blob/master/CHANGELOG.md" target="_blank">Changelog</a></p> 
  <p>License: <a href="https://www.apache.org/licenses/LICENSE-2.0.txt" target="_blank">Apache Licence v2</a>.</p> 
  <h2><a id="user-content-quick-start" class="anchor" href="https://github.com/johanandren/futiles#quick-start" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick start</h2> 
  <p>The artifact is on maven central and can be used by adding it to your project dependencies in sbt:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.markatta<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>futiles<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.0.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Latest stable version:</p> 
  <ul> 
   <li>Scala 2.12 - <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22futiles_2.12%22" target="_blank"><img src="https://camo.githubusercontent.com/c653104807bdfcfb37d5db5a0caac78db6415753/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e6d61726b617474612f667574696c65735f322e31322f62616467652e737667" alt="Maven Central, Scala 2.12" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.markatta/futiles_2.12/badge.svg" style="max-width:100%;"></a></li> 
   <li>Scala 2.11 - <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22futiles_2.11%22" target="_blank"><img src="https://camo.githubusercontent.com/f6ad9e6d0f0f8d143d639e8e5b3b61a19a6c5db0/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e6d61726b617474612f667574696c65735f322e31312f62616467652e737667" alt="Maven Central, Scala 2.11" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.markatta/futiles_2.11/badge.svg" style="max-width:100%;"></a></li> 
   <li>Scala 2.10 - <a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22futiles_2.10%22" target="_blank"><img src="https://camo.githubusercontent.com/0d486c7dea72b0e36d42d4ec918f6dc6ed029caa/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e6d61726b617474612f667574696c65735f322e31302f62616467652e737667" alt="Maven Central, Scala 2.10" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.markatta/futiles_2.10/badge.svg" style="max-width:100%;"></a></li> 
  </ul> 
  <h2><a id="user-content-examples" class="anchor" href="https://github.com/johanandren/futiles#examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples</h2> 
  <h3><a id="user-content-sequencing-futures---markattafutilessequencing" class="anchor" href="https://github.com/johanandren/futiles#sequencing-futures---markattafutilessequencing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sequencing futures - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Sequencing.scala" target="_blank">markatta.futiles.Sequencing</a></h3> 
  <p>The utilities inside of <code>markatta.futiles.Sequencing</code> allows you to sequence other functor types than collections, just like the built in <code>scala.concurrent.Future.sequence</code> function does.</p> 
  <h4><a id="user-content-options" class="anchor" href="https://github.com/johanandren/futiles#options" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Options</h4> 
  <p>Make a future option value out of an option future value:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.Future.</span><span class="pl-v">successful</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Sequencing.</span><span class="pl-v">sequenceOpt</span>
<span class="pl-k">val</span> <span class="pl-en">optionFuture</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Future</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> <span class="pl-en">Some</span>(successful(<span class="pl-s"><span class="pl-pds">"</span>woho!<span class="pl-pds">"</span></span>))
<span class="pl-k">val</span> <span class="pl-en">futureOption</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> sequenceOpt(optionFuture)</pre>
  </div> 
  <h4><a id="user-content-eithers" class="anchor" href="https://github.com/johanandren/futiles#eithers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Eithers</h4> 
  <p>The either sequencing allows you to go from one or two futures inside of an <code>Either</code> to a future with an either inside of it:</p> 
  <ul> 
   <li><code>sequenceEither</code> allows you to go from <code>Either[Future[L], Future[R]]</code> to <code>Future[Either[L, R]]</code></li> 
   <li><code>sequenceL</code> allows you to go from <code>Either[Future[L], R]</code> to <code>Future[Either[L, R]]</code></li> 
   <li><code>sequenceR</code> allows you to go from <code>Either[L, Future[R]]</code> to <code>Future[Either[L, R]]</code></li> 
  </ul> 
  <h4><a id="user-content-tries" class="anchor" href="https://github.com/johanandren/futiles#tries" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Tries</h4> 
  <p><code>sequenceTries</code> takes a collection of <code>Future[A]</code> and turn them into a future collection of each succeeded of failed future. So compared to the build in sequence it will not fail with the first failed future but rather collect all those and let you handle them when all has arrived.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.Future.</span>{<span class="pl-v">successful</span>, <span class="pl-v">failed</span>}
<span class="pl-k">import</span> <span class="pl-v">scala.util.</span><span class="pl-v">Try</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Sequencing.</span><span class="pl-v">sequenceTries</span>

<span class="pl-k">val</span> <span class="pl-en">futures</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Future</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> <span class="pl-en">Seq</span>(successful(<span class="pl-s"><span class="pl-pds">"</span>woho<span class="pl-pds">"</span></span>), failed(<span class="pl-k">new</span> <span class="pl-en">RuntimeException</span>(<span class="pl-s"><span class="pl-pds">"</span>bork<span class="pl-pds">"</span></span>)))

<span class="pl-k">val</span> <span class="pl-en">allOfEm</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Seq</span>[<span class="pl-en">Try</span>[<span class="pl-k">String</span>]]] <span class="pl-k">=</span> sequenceTries(futures)</pre>
  </div> 
  <h3><a id="user-content-traversal---markattafutilestraversal" class="anchor" href="https://github.com/johanandren/futiles#traversal---markattafutilestraversal" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Traversal - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Traversal.scala" target="_blank">markatta.futiles.Traversal</a></h3> 
  <h4><a id="user-content-sequential-traverse" class="anchor" href="https://github.com/johanandren/futiles#sequential-traverse" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sequential traverse</h4> 
  <p><code>scala.concurrent.Future.traverse</code> allows you to have a collection of <code>A</code>s, apply a function <code>A =&gt; Future[B]</code> to each of them and then sequence the resulting collection into a future collection of <code>B</code>.</p> 
  <p>Futiles contains one addition to that concept which basically does the same, but applies the function sequentially, so that at any time only one future is executing and the next one will not be done until it completes. If any future fails, it will stop and return a failed future with that exception.</p> 
  <p><strong>Example:</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.Future.</span>{<span class="pl-v">successful</span>, <span class="pl-v">failed</span>}
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Traversal.</span><span class="pl-v">traverseSequentially</span>
<span class="pl-k">import</span> <span class="pl-v">java.util.concurrent.</span><span class="pl-v">CountDownLatch</span>

<span class="pl-k">val</span> <span class="pl-en">latch</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CountDownLatch</span>(<span class="pl-c1">3</span>)
<span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> traverseSequentially(<span class="pl-en">List</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)) { n <span class="pl-k">=&gt;</span>
  <span class="pl-en">Future</span> {
    latch.countDown()
    (n , latch.getCount)
  }
}

<span class="pl-c"><span class="pl-c">//</span> result will always be Future(List((1, 2L), (2, 1L), (3, 0L)))</span></pre>
  </div> 
  <h4><a id="user-content-sequential-fold-left" class="anchor" href="https://github.com/johanandren/futiles#sequential-fold-left" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sequential fold left</h4> 
  <p>A more general case of traversal, lets you build any kind of object asynchronously but sequentially:</p> 
  <p><strong>Example</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">latch</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">CountDownLatch</span>(<span class="pl-c1">3</span>)
<span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> foldLeftSequentially(<span class="pl-en">List</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>))(<span class="pl-en">Seq</span>.empty[<span class="pl-k">Int</span>]) { (acc, n) <span class="pl-k">=&gt;</span>
  <span class="pl-en">Future</span> {
    latch.countDown()
    <span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> latch.getCount.toInt
    acc <span class="pl-k">:</span><span class="pl-k">+</span> l
  }
}

<span class="pl-c"><span class="pl-c">//</span> result will always be Future(List(2, 1, 0)))</span></pre>
  </div> 
  <h3><a id="user-content-combining-futures---markattafutilescombining" class="anchor" href="https://github.com/johanandren/futiles#combining-futures---markattafutilescombining" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Combining futures - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Combining.scala" target="_blank">markatta.futiles.Combining</a></h3> 
  <h4><a id="user-content-multiple-futures-into-one-future-tuple" class="anchor" href="https://github.com/johanandren/futiles#multiple-futures-into-one-future-tuple" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>multiple futures into one future tuple</h4> 
  <p>Combine up to 6 futures into a tuple with the value of each future using <code>product</code>. If either fails the result will be a failed future. Or apply a function using <code>mapN</code> or <code>flatMapN</code> while you are at it</p> 
  <p>Example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.Future.</span><span class="pl-v">successful</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Combining.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">fTuple</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[(<span class="pl-k">Int</span>, <span class="pl-k">String</span>)] <span class="pl-k">=</span> product(successful(<span class="pl-c1">1</span>), successful(<span class="pl-s"><span class="pl-pds">"</span>woho<span class="pl-pds">"</span></span>))

<span class="pl-k">val</span> <span class="pl-en">mapped</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> 
  map2(successful(<span class="pl-c1">1</span>), successful(<span class="pl-s"><span class="pl-pds">"</span>woho<span class="pl-pds">"</span></span>))((a, b) <span class="pl-k">=&gt;</span> a.toString <span class="pl-k">+</span> b)

<span class="pl-k">val</span> <span class="pl-en">flatMapped</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> 
  flatMap2(successful(<span class="pl-c1">1</span>), successful(<span class="pl-s"><span class="pl-pds">"</span>woho<span class="pl-pds">"</span></span>))((a, b) <span class="pl-k">=&gt;</span> successful(a.toString <span class="pl-k">+</span> b)) </pre>
  </div> 
  <h3><a id="user-content-lifting-and-unlifting-container-types-inside-of-futures----markattafutileslifting" class="anchor" href="https://github.com/johanandren/futiles#lifting-and-unlifting-container-types-inside-of-futures----markattafutileslifting" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Lifting and unlifting container types inside of futures - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Lifting.scala" target="_blank">markatta.futiles.Lifting</a></h3> 
  <h4><a id="user-content-lift-the-implicit-try-into-the-future" class="anchor" href="https://github.com/johanandren/futiles#lift-the-implicit-try-into-the-future" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Lift the implicit try into the future</h4> 
  <p>If you want to lift a failed future into a successful future with a failed try inside, you can do that with <code>markatta.futiles.Lifting.liftTry</code>. This is probably not very interesting except for in the context of <code>sequenceTries</code> which is described above.</p> 
  <h4><a id="user-content-options-1" class="anchor" href="https://github.com/johanandren/futiles#options-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Options</h4> 
  <p>A common problem when working with futures is that you have a nested option, and this makes it impossible to do clean for comprehensions, since you need to handle both <code>Some(value)</code> and <code>None</code> somehow.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    user <span class="pl-k">&lt;</span><span class="pl-k">-</span> userDao.findById(id)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-en">User</span>]]
    cart <span class="pl-k">&lt;</span><span class="pl-k">-</span> shoppingCartDao.findByUserId(...oh noes, user is an option...)
  } <span class="pl-k">yield</span> (...oh noes, so is cart, what to <span class="pl-k">do</span><span class="pl-k">!</span><span class="pl-k">?</span> ...)</pre>
  </div> 
  <p>One easy way out is to "unlift" the value if it is a <code>None</code> into a failed future, but using unapply in the for comprehension gives us a <code>MatchError</code> with little info about what went wrong.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    <span class="pl-en">Some</span>(user) <span class="pl-k">&lt;</span><span class="pl-k">-</span> userDao.findById(id)<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-en">User</span>]]
    <span class="pl-en">Some</span>(cart) <span class="pl-k">&lt;</span><span class="pl-k">-</span> shoppingCartDao.findByUserId(user.id)
  } <span class="pl-k">yield</span> (user, cart)
<span class="pl-c"><span class="pl-c">//</span> hard to know that it wasn't some other MatchError here</span></pre>
  </div> 
  <p>Futiles contains two methods <code>Lifting.unliftOption</code> and <code>Lifting.unliftOptionEx</code> for dealing with this, one where you decide what exception to fail the future with and one where you just provide a text, and an <code>UnliftException</code> is used.</p> 
  <p>To make it really concise an implicit class is provided that will decorate <code>Future[Option[A]]</code> with corresponding methods called <code>unlift</code></p> 
  <p><strong>Example:</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.</span><span class="pl-v">UnliftException</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Lifting.Implicits.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    user <span class="pl-k">&lt;</span><span class="pl-k">-</span> userDao.findById(id).unlift(s<span class="pl-s"><span class="pl-pds">"</span>No user with $id<span class="pl-pds">"</span></span>)
    cart <span class="pl-k">&lt;</span><span class="pl-k">-</span> shoppingCartDao.findByUserId(user.id).unlift(s<span class="pl-s"><span class="pl-pds">"</span>No cart for user $user<span class="pl-pds">"</span></span>)
  } <span class="pl-k">yield</span> (user, cart)

result.recover {
  <span class="pl-k">case</span> <span class="pl-en">UnliftException</span>(msg) <span class="pl-k">if</span> msg.startsWith(<span class="pl-s"><span class="pl-pds">"</span>No user<span class="pl-pds">"</span></span>) <span class="pl-k">=&gt;</span> ...
  <span class="pl-k">case</span> <span class="pl-en">UnliftException</span>(msg) <span class="pl-k">if</span> msg.startsWith(<span class="pl-s"><span class="pl-pds">"</span>No cart<span class="pl-pds">"</span></span>) <span class="pl-k">=&gt;</span> ...
}</pre>
  </div> 
  <h4><a id="user-content-eithers-1" class="anchor" href="https://github.com/johanandren/futiles#eithers-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Eithers</h4> 
  <p>Much like the option unlifting above <code>unliftL</code> and <code>unliftLEx</code> will fail the future if the value is a <code>Right</code> and succeed with the value inside of a <code>Left</code> while <code>unliftR</code> and <code>unliftREx</code> does the exact opposite.</p> 
  <p>There is also implicit decoration for the two:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Lifting.Implicits.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">futureEither</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Either</span>[<span class="pl-k">String</span>, <span class="pl-k">Int</span>]] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">result</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> futureEither.unliftR(<span class="pl-s"><span class="pl-pds">"</span>Danger Danger!<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h3><a id="user-content-booleans---markattafutilesboolean" class="anchor" href="https://github.com/johanandren/futiles#booleans---markattafutilesboolean" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Booleans - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Boolean.scala" target="_blank">markatta.futiles.Boolean</a></h3> 
  <p>Boolean <code>&amp;&amp;</code> and <code>||</code> for <code>Future[Boolean]</code>s. Operations are short circuited just like regular boolean expressions. <strong>Important:</strong> this affects failures, if the operation is short circuited the second <code>Future[Boolean]</code> might not be evaluated at all. If it is created before the boolean op it might be outright ignored even if it fails.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Boolean.Implicits.</span><span class="pl-v">_</span>

<span class="pl-c"><span class="pl-c">//</span> short circuit will only happen if we do not create </span>
<span class="pl-c"><span class="pl-c">//</span> the futures before hand</span>
<span class="pl-k">def</span> <span class="pl-en">a</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">def</span> <span class="pl-en">b</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">both</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> a <span class="pl-k">&amp;&amp;</span> b
<span class="pl-k">val</span> <span class="pl-en">either</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> a <span class="pl-k">||</span> b
<span class="pl-k">val</span> <span class="pl-en">negated</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> <span class="pl-k">!</span>a</pre>
  </div> 
  <p>There is an idea to be able to short circuit for the first arrived future, but this makes failure handling racey (see <a href="https://github.com/johanandren/futiles/issues/5" target="_blank">#5</a>).</p> 
  <h3><a id="user-content-timeouts---markattafutilestimeouts" class="anchor" href="https://github.com/johanandren/futiles#timeouts---markattafutilestimeouts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Timeouts - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Timeouts.scala" target="_blank">markatta.futiles.Timeouts</a></h3> 
  <p>Some times you want to wait a specific amount of time before triggering a future, or you want it to complete at a specific timeout with a value you already have. This is available for example in the play framework future libraries, but maybe you would want to do that without depending on play.</p> 
  <p>If an exception is thrown by the by-name-parameter the future will be failed instead of completed when the timeout is reached.</p> 
  <p><strong>Example:</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Timeouts.</span><span class="pl-v">timeout</span>

<span class="pl-k">val</span> <span class="pl-en">timeoutF</span> <span class="pl-k">=</span> timeout(<span class="pl-c1">1.</span>seconds)(<span class="pl-s"><span class="pl-pds">"</span>It was too slow, you get default instead<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> <span class="pl-en">Future</span>.firstCompletedOf(<span class="pl-en">Seq</span>(doItForReals(), timeoutF))</pre>
  </div> 
  <h4><a id="user-content-implicit-timeout-methods" class="anchor" href="https://github.com/johanandren/futiles#implicit-timeout-methods" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implicit timeout methods</h4> 
  <p>Timeouts is such a common concept that there also is implicit decorations for futures. Note that the original future will always complete at some point, so this does in no way cancel the future if it times out.</p> 
  <p><strong>Example:</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">Timeouts.Implicits.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">future</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>

<span class="pl-k">val</span> <span class="pl-en">willFailIfNotCompletedWithin2s</span> <span class="pl-k">=</span> future.withTimeoutError(<span class="pl-c1">2.</span>seconds)
<span class="pl-k">val</span> <span class="pl-en">willDefaultIfNotCompletedInTime</span> <span class="pl-k">=</span> future.withTimeoutDefault(<span class="pl-c1">2.</span>seconds, <span class="pl-s"><span class="pl-pds">"</span>Sensible default<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h3><a id="user-content-retrying-failed-futures---markattafutilesretry" class="anchor" href="https://github.com/johanandren/futiles#retrying-failed-futures---markattafutilesretry" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Retrying failed futures - <a href="https://github.com/johanandren/futiles/blob/master/src/main/scala/markatta/futiles/Retry.scala" target="_blank">markatta.futiles.Retry</a></h3> 
  <p>A common scenario is that you use Futures to interact with remote systems, but what if the remote system is down exactly when the request is done, or the network cable was disconnected by your little brother.</p> 
  <p>Futiles contains two flavours of retry for futures:</p> 
  <ul> 
   <li>Retry right away with <code>markatta.futiles.Retry.retry</code></li> 
   <li>Retry with an exponential back off, waiting longer and longer before each retry</li> 
  </ul> 
  <p>Both methods allows you to specify the maximum number of retries to perform and a predicate function <code>Throwable =&gt; Boolean</code> that will be given any exception and decides if it should lead to a retry or not.</p> 
  <p>By default all throwables lead to retry.</p> 
  <p><strong>Example of the simple retry</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Retry.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">result</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> retry(<span class="pl-c1">5</span>) {
  callThatService()<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]
}</pre>
  </div> 
  <p>Exponential back off additionally takes a back off time unit, which decides a base for the calculation <code>(2 ^ tries) * jitter * timeUnit</code>, where <code>jitter</code> will be a random value between <code>0.5</code> and <code>1.5</code>. this means that a time unit of 1 second the first retry will back off between <code>1</code> and <code>3</code> seconds, the second try between <code>2</code> and <code>6</code> seconds, the third try between <code>4</code> and <code>12</code> and so on until the maximum number of retries is reached and at that time the future will be failed.</p> 
  <p><strong>Example with exponential back off</strong></p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">Future</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">markatta.futiles.Retry.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">result</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> retryWithBackOff(<span class="pl-c1">5</span>, <span class="pl-c1">5.</span>seconds) {
  callThatService()<span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>]
}</pre>
  </div> 
 </article>
</div>