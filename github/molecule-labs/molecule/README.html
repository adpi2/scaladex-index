<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/molecule-labs/molecule#molecule" aria-hidden="true" class="anchor" id="user-content-molecule" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Molecule</h1> 
  <p>A concurrent programming library combining monadic and streaming I/O in Scala.</p> 
  <p>By releasing Molecule as open source <a href="http://www.alcatel-lucent.com/" target="_blank">Alcatel-Lucent</a>/<a href="http://www.bell-labs.com" target="_blank">Bell Labs</a> is supporting research in easing the industry's transition to network function virtualization on cloud computing platforms.</p> 
  <p>There is a <a href="https://groups.google.com/group/molecule-labs" target="_blank">mailing list</a> for discussions.</p> 
  <ul> 
   <li><a href="https://github.com/molecule-labs/molecule#main-features" target="_blank">Main Features</a></li> 
   <li><a href="https://github.com/molecule-labs/molecule#publication" target="_blank">Publication</a></li> 
   <li><a href="https://github.com/molecule-labs/molecule#example" target="_blank">Example</a></li> 
   <li><a href="https://github.com/molecule-labs/molecule#installing" target="_blank">Installing</a></li> 
   <li><a href="https://github.com/molecule-labs/molecule#building-from-sources" target="_blank">Building From Sources</a></li> 
   <li><a href="https://github.com/molecule-labs/molecule#running-the-examples" target="_blank">Running The Examples</a></li> 
  </ul> 
  <h2><a href="https://github.com/molecule-labs/molecule#main-features" aria-hidden="true" class="anchor" id="user-content-main-features" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Main Features</h2> 
  <ul> 
   <li>User-level threading model with low-overhead context switches on unmodified JVM's.</li> 
   <li>Type-safe communication channels.</li> 
   <li>High-performance and convenient stream processing primitives that batch data transparently.</li> 
   <li>Incremental combinator parsers that work over non-blocking sockets (ala <a href="http://hackage.haskell.org/packages/archive/attoparsec/0.8.0.2/doc/html/Data-Attoparsec.html" target="_blank">AttoParsec</a>).</li> 
   <li>Exceptions and graceful termination handling.</li> 
   <li>Higher maintainability, reliability and flexibility compared to applications written against callback interfaces in plain Java.</li> 
  </ul> 
  <p>Both the <a href="https://github.com/molecule-labs/molecule#publication" target="_blank">paper</a> explaining the rationale and the design principles of Molecule, and the <a href="http://molecule-labs.github.io/molecule" target="_blank">latest API documentation</a> are available online.</p> 
  <h2><a href="https://github.com/molecule-labs/molecule#publication" aria-hidden="true" class="anchor" id="user-content-publication" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Publication</h2> 
  <p><strong><em>Molecule: Using Monadic and Streaming I/O to Compose Process Networks on the JVM</em></strong> by SÃ©bastien Bocq and Koen Daenen. ACM SIGPLAN conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA 2012), Tucson, Arizona, USA, 2012. [<a href="https://github.com/molecule-labs/molecule/raw/docs/publications/OOPSLA_2012/molecule.pdf" target="_blank">pdf</a>]</p> 
  <p>ACM, 2012. This is the authors version of the work. It is posted here by permission of the ACM for your personal use. Not for redistribution. For referencing, please refer to the definitive version, published in SIGPLAN Not. 47, 10 (October 2012), 315-334. <a href="http://doi.acm.org/10.1145/2398857.2384640" target="_blank">http://doi.acm.org/10.1145/2398857.2384640</a> .</p> 
  <p>Note that the API has been evolved since the publication. Check the <a href="http://molecule-labs.github.io/molecule" target="_blank">scaladoc</a> and <a href="https://github.com/molecule-labs/molecule#example" target="_blank">example</a> for the current version.</p> 
  <h2><a href="https://github.com/molecule-labs/molecule#example" aria-hidden="true" class="anchor" id="user-content-example" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example</h2> 
  <p><em>Note: many other examples are available for study in the <code>molecule-*-examples</code> directories.</em></p> 
  <p>This example will walk you through the implementation of a simple process type. First, we show how instances of this process type can interact with the command line. Then, we show how to bind instances to Telnet sessions by implementing the minimal support for the Telnet protocol over binary streams using Molecule's NIO interfaces and incremental parser combinators.</p> 
  <h3><a href="https://github.com/molecule-labs/molecule#interacting-on-the-command-line" aria-hidden="true" class="anchor" id="user-content-interacting-on-the-command-line" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Interacting On The Command Line</h3> 
  <p>Here is how a process that interacts on the command line is defined and then launched.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">molecule.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">molecule.io.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">HelloYou</span> <span class="pl-k">extends</span> <span class="pl-e">ProcessType1x1</span>[<span class="pl-k">String</span>, <span class="pl-k">String</span>, <span class="pl-k">Unit</span>] {

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">in</span>: <span class="pl-en">Input</span>[<span class="pl-k">String</span>], <span class="pl-v">out</span>: <span class="pl-en">Output</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> <span class="pl-k">for</span> {
    _    <span class="pl-k">&lt;</span><span class="pl-k">-</span> out.write(<span class="pl-s"><span class="pl-pds">"</span>What is your name?<span class="pl-pds">"</span></span>)
    name <span class="pl-k">&lt;</span><span class="pl-k">-</span> in.read()
    _    <span class="pl-k">&lt;</span><span class="pl-k">-</span> out.write(<span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>)
  } <span class="pl-k">yield</span> ()

  <span class="pl-k">import</span> <span class="pl-v">molecule.platform.</span><span class="pl-v">Platform</span>
  <span class="pl-k">import</span> <span class="pl-v">molecule.channel.</span><span class="pl-v">Console</span>

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>])<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    <span class="pl-c"><span class="pl-c">//</span> Create an execution platform</span>
    <span class="pl-k">val</span> <span class="pl-en">platform</span> <span class="pl-k">=</span> <span class="pl-en">Platform</span>(<span class="pl-s"><span class="pl-pds">"</span>hello-you<span class="pl-pds">"</span></span>)

    <span class="pl-c"><span class="pl-c">//</span> Launch an instance of HelloYou on the platform</span>
    <span class="pl-c"><span class="pl-c">//</span> and block the main thread with `get_!` until it is terminated.</span>
    platform.launch(<span class="pl-en">HelloYou</span>(<span class="pl-en">Console</span>.stdinLine, <span class="pl-en">Console</span>.stdoutLine)).get_<span class="pl-k">!</span>()
  }
}</pre>
  </div> 
  <p>Before defining a new process type, we must import two packages. The first one imports molecule's main package. The second imports the abstract monadic process type with various useful monadic combinators defined as value members in the <a href="http://molecule-labs.github.io/molecule/#molecule.io.package" target="_blank"><code>io</code></a> package object. Process types are patterned after function types in Scala:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">ProcessTypeixj</span>[<span class="pl-en">I1</span>, ... , <span class="pl-en">Ii</span>, <span class="pl-en">O1</span>, ..., <span class="pl-en">Oj</span>, <span class="pl-en">R</span>] {

  <span class="pl-k">final</span> <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">i1</span>: <span class="pl-en">IChan</span>[<span class="pl-en">I1</span>], ..., <span class="pl-v">oj</span>: <span class="pl-en">IChan</span>[<span class="pl-en">Oj</span>])<span class="pl-k">:</span><span class="pl-en">Process</span>[<span class="pl-en">R</span>] <span class="pl-k">=</span> ...

  <span class="pl-k">protected</span> <span class="pl-k">def</span> <span class="pl-en">main</span>(i1<span class="pl-k">:</span><span class="pl-en">Input</span>[<span class="pl-en">I1</span>], ..., oj<span class="pl-k">:</span><span class="pl-en">Output</span>[<span class="pl-en">Oj</span>])<span class="pl-k">:</span><span class="pl-en">IO</span>[<span class="pl-en">R</span>]

}</pre>
  </div> 
  <p>The abstract class is parameterized by the type <code>Ii</code> and <code>Oj</code> of the input and output channel interfaces of a process followed by its result type <code>R</code>. The <code>apply</code> method is used as a factory method to create lightweight processes. Since <code>HelloYou</code> inherits form <a href="http://molecule-labs.github.io/molecule/#molecule.io.ProcessType1x1" target="_blank"><code>ProcessType1x1[String, String, Unit]</code></a>, the process type <code>HelloYou</code> is a factory of process instances that use one input of type <code>String</code>, one output of type <code>String</code> and terminates with a result of type <code>Unit</code>. All the processes it creates will share the same behavior, which is defined by the implementation of its <code>main</code> method:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">in</span>: <span class="pl-en">Input</span>[<span class="pl-k">String</span>], <span class="pl-v">out</span>: <span class="pl-en">Output</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> <span class="pl-k">for</span> {
    _    <span class="pl-k">&lt;</span><span class="pl-k">-</span> out.write(<span class="pl-s"><span class="pl-pds">"</span>What is your name?<span class="pl-pds">"</span></span>)
    name <span class="pl-k">&lt;</span><span class="pl-k">-</span> in.read()
    _    <span class="pl-k">&lt;</span><span class="pl-k">-</span> out.write(<span class="pl-s"><span class="pl-pds">"</span>Hello <span class="pl-pds">"</span></span> <span class="pl-k">+</span> name <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>!<span class="pl-pds">"</span></span>)
  } <span class="pl-k">yield</span> ()</pre>
  </div> 
  <p>It prompts for a name on its output, reads the name on its input, says hello on its output and then returns <code>()</code>.</p> 
  <p>We can then create a <code>HelloYou</code> process attached to the command line by "applying" its process type to the standard <code>Console.stdinLine</code> and <code>Console.stdoutLine</code> channels, which are defined in the <a href="http://molecule-labs.github.io/molecule/#molecule.channel.Console$" target="_blank">channel</a> package:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">platform</span> <span class="pl-k">=</span> <span class="pl-en">Platform</span>(<span class="pl-s"><span class="pl-pds">"</span>hello-you<span class="pl-pds">"</span></span>)
  platform.launch(<span class="pl-en">HelloYou</span>(<span class="pl-en">Console</span>.stdinLine, <span class="pl-en">Console</span>.stdoutLine)).get_<span class="pl-k">!</span>()</pre>
  </div> 
  <p>The <code>stdinLine</code> input channel, of type <code>IChan[String]</code>, streams each lines typed on the standard input. The <code>stdoutLine</code> output channel, of type <code>OChan[String]</code>, does the reverse and prints each string it receives on consecutive lines on the standard output.</p> 
  <p>A <a href="http://molecule-labs.github.io/molecule/#molecule.platform.Platform" target="_blank"><code>Platform</code></a> creates the user-level threads that execute processes over a handful number of native threads. This number is configurable and matches by default the number of cores available on the underlying hardware (see <code>Platform</code> <a href="http://molecule-labs.github.io/molecule/#molecule.platform.Platform$" target="_blank">factory methods</a>). The launch method is declared like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">Platform</span> {

  <span class="pl-k">final</span> <span class="pl-k">def</span> <span class="pl-en">launch</span>[<span class="pl-en">R</span><span class="pl-k">:</span> <span class="pl-en">Message</span>](<span class="pl-v">process</span>: <span class="pl-en">Process</span>[<span class="pl-en">R</span>])<span class="pl-k">:</span> <span class="pl-en">RIChan</span>[<span class="pl-en">R</span>] <span class="pl-k">=</span> ...

}</pre>
  </div> 
  <p>The type <a href="http://molecule-labs.github.io/molecule/#molecule.channel.RIChan" target="_blank"><code>RIChan</code></a> is the type of channels that deliver a single message, a bit like a <code>Future</code> in <code>java.util.concurrent</code>. Since the process instance is executed asynchronously, the native thread must block until the process has terminated, otherwise the application would exit immediately before someone has the time to type its name. This is done using the <code>get_!</code> method of the result channel, which blocks the main thread until the process returns its result <code>()</code>.</p> 
  <h3><a href="https://github.com/molecule-labs/molecule#exposing-processes-over-telnet" aria-hidden="true" class="anchor" id="user-content-exposing-processes-over-telnet" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Exposing Processes Over Telnet</h3> 
  <p>We will now create a "Telnet servlet container" that instantiates a new process each time a Telnet client connects to it. For simplicity, we will just filter out <a href="http://tools.ietf.org/html/rfc854" target="_blank">initial Telnet negotiation commands</a> - those that start with the <code>IAC</code> byte followed by 1 byte identifying the operation and a second byte indicating the option. To do so, we create an incremental binary parser that we will use to parse Telnet messages from <code>ByteBuffer</code> streams read on non-blocking TCP sockets:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">molecule.parsers.bytebuffer.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">TelnetLineAdapter</span> {

  <span class="pl-k">val</span> <span class="pl-en">IAC</span> <span class="pl-k">=</span> <span class="pl-c1">255.</span>toByte

  <span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">TelnetMsg</span>
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Data</span>(<span class="pl-v">cb</span>: <span class="pl-en">ByteBuffer</span>) <span class="pl-k">extends</span> <span class="pl-e">TelnetMsg</span>
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Command</span>(<span class="pl-v">b1</span>: <span class="pl-k">Byte</span>, <span class="pl-v">b2</span>: <span class="pl-k">Byte</span>) <span class="pl-k">extends</span> <span class="pl-e">TelnetMsg</span> {
    <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span>() <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Command(<span class="pl-pds">"</span></span> <span class="pl-k">+</span> unsigned(b1) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span> <span class="pl-k">+</span> unsigned(b2) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span>)<span class="pl-pds">"</span></span>
  }

  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">telnetMsg</span><span class="pl-k">:</span> <span class="pl-en">Parser</span>[<span class="pl-en">ByteBuffer</span>, <span class="pl-en">TelnetMsg</span>] <span class="pl-k">=</span> data <span class="pl-k">|</span> command

  <span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> splitAt(<span class="pl-en">IAC</span>) ^^ { <span class="pl-en">Data</span>(_) }

  <span class="pl-k">val</span> <span class="pl-en">command</span> <span class="pl-k">=</span> (<span class="pl-en">IAC</span> <span class="pl-k">~</span> byteArray(<span class="pl-c1">2</span>)) ^^ {
    <span class="pl-k">case</span> _ <span class="pl-k">~</span> arr <span class="pl-k">=&gt;</span> <span class="pl-en">Command</span>(arr(<span class="pl-c1">0</span>), arr(<span class="pl-c1">1</span>))
  }

}</pre>
  </div> 
  <p><em>Note: readers not familiar with parser combinators are invited to look at <a href="http://www.codecommit.com/blog/scala/the-magic-behind-parser-combinators" target="_blank">this</a> excellent introduction by Daniel Spiewak.</em></p> 
  <p>In case of Telnet, the binary stream carries either some binary Data or a Telnet Command that starts with the <code>IAC</code> byte. The <code>splitAt</code> parser splits each <code>ByteBuffer</code> that it receives at the position where the <code>IAC</code> command occurs or fails if the first byte of the received <code>ByteBuffer</code> matches <code>IAC</code>. Using the <code>telnetMsg</code> parser, we can now create a process type adapter that adapts process types that interact over string channels into process types that interact over raw byte buffer channels:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">abstract</span> <span class="pl-k">class</span> <span class="pl-en">TelnetLineAdapter</span>[<span class="pl-en">R</span><span class="pl-k">:</span> <span class="pl-en">Message</span>](<span class="pl-v">ptype</span>: <span class="pl-en">ProcessType1x1</span>[<span class="pl-k">String</span>, <span class="pl-k">String</span>, <span class="pl-en">R</span>]) 
<span class="pl-k">extends</span> <span class="pl-e">ProcessType1x1</span>[<span class="pl-en">ByteBuffer</span>, <span class="pl-en">ByteBuffer</span>, <span class="pl-en">R</span>] {
  <span class="pl-k">import</span> <span class="pl-v">molecule.parsers.</span><span class="pl-v">charbuffer</span>
  <span class="pl-k">import</span> <span class="pl-v">java.nio.</span><span class="pl-v">CharBuffer</span>

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">in</span>: <span class="pl-en">Input</span>[<span class="pl-en">ByteBuffer</span>], <span class="pl-v">out</span>: <span class="pl-en">Output</span>[<span class="pl-en">ByteBuffer</span>]) <span class="pl-k">=</span>
    handover {
      ptype(
        in.parse(telnetMsg).collect {
          <span class="pl-k">case</span> <span class="pl-en">Data</span>(bb) <span class="pl-k">=&gt;</span> bb
        }.map(decode(<span class="pl-s"><span class="pl-pds">"</span>US-ASCII<span class="pl-pds">"</span></span>)).parse(charbuffer.line(<span class="pl-c1">2048</span>)),
        out.map(encode(<span class="pl-s"><span class="pl-pds">"</span>US-ASCII<span class="pl-pds">"</span></span>)).map { <span class="pl-v">s</span>: <span class="pl-k">String</span> <span class="pl-k">=&gt;</span> <span class="pl-en">CharBuffer</span>.wrap(s.replaceAll(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>) }
      )
    }
}</pre>
  </div> 
  <p>Telnet commands are filtered out from the byte buffer input stream using the <code>collect</code> streaming primitive. The resulting stream is then converted into a stream of strings through ASCII decoded <code>CharBuffer</code>s, which are then parsed into lines of maximum 2048 characters. Lines sent on the output are wrapped into character buffers and then encoded into ASCII byte buffers (output channels being contravariant, transformations must be read from right to left).</p> 
  <p>Now, we are ready to expose <code>HelloYou</code> processes over individual Telnet connections using Molecule's NIO layer, like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">molecule.nio.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">HelloYouTelnet</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">TelnetLineAdapter</span>(<span class="pl-en">HelloYou</span>)
<span class="pl-k">val</span> <span class="pl-en">ns</span> <span class="pl-k">=</span> <span class="pl-en">NetSystem</span>(<span class="pl-en">Platform</span>(<span class="pl-s"><span class="pl-pds">"</span>hello-you<span class="pl-pds">"</span></span>))
ns.launchTcpServer(<span class="pl-s"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">8888</span>, <span class="pl-en">HelloYouTelnet</span>)</pre>
  </div> 
  <p>The <code>launchTcpServer</code> method of a <a href="http://molecule-labs.github.io/molecule/#molecule.net.NetSystem" target="_blank"><code>NetSystem</code></a>, launches a new instance of the adapted <code>HelloYou</code> process type each time it accepts a new TCP connection on the specified socket address. Each process will be connected to the byte buffer input and output streams of the socket connected to the client. This socket, configured in non-blocking mode, will be automatically closed once both channels are closed. This occurs as soon as the process terminates thanks to the automatic resource management implemented by monadic processes. The nice thing about this server is that it can handle efficiently more than one thousands Telnet sessions in one megabyte of memory without blocking any native thread. Also, now that we created this adapter, we can reuse it to expose any interactive process over Telnet as long as this process interacts line by line over string channels.</p> 
  <p><strong>Note:</strong> <em>Similar examples can be found in <a href="https://github.com/molecule-labs/molecule/blob/master/molecule-io-examples/src/main/scala/molecule/examples/io/EchoYou.scala" target="_blank"><code>molecule-io-example</code></a> and <a href="https://github.com/molecule-labs/molecule/blob/master/molecule-net-examples/src/main/scala/molecule/examples/net/echoyou/EchoYouTelnet.scala" target="_blank"><code>molecule-net-examples</code></a>. See section <a href="https://github.com/molecule-labs/molecule#running-the-examples" target="_blank">"Running The Examples"</a> for instructions on how to run these examples.</em></p> 
  <h2><a href="https://github.com/molecule-labs/molecule#installing" aria-hidden="true" class="anchor" id="user-content-installing" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installing</h2> 
  <p>Molecule is available on the Sonatype OSS Maven repository (which is mirrored on the central Maven repository as well):</p> 
  <pre><code>group id: com.github.molecule-labs
artifact ids (scala 2.9): molecule-core_2.9.3, molecule-io_2.9.3, molecule-parsers_2.9.3, molecule-net_2.9.3
artifact ids (scala 2.10): molecule-core_2.10, molecule-io_2.10, molecule-parsers_2.10, molecule-net_2.10
artifact ids (scala 2.11): molecule-core_2.11, molecule-io_2.11, molecule-parsers_2.11, molecule-net_2.11
latest versions:
  0.5.3 (for molecule-core)
  0.5.4 (for molecule-parsers)
  0.5.2 (for other packages)
</code></pre> 
  <p>Alternatively you can download the Jar files directly from Sonatype:</p> 
  <p>for scala 2.11</p> 
  <ul> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-core_2.11/0.5.3/molecule-core_2.11-0.5.3.jar" target="_blank">molecule-core.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-io_2.11/0.5.2/molecule-io_2.11-0.5.2.jar" target="_blank">molecule-io.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-parsers_2.11/0.5.4/molecule-parsers_2.11-0.5.4.jar" target="_blank">molecule-parsers.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-net_2.11/0.5.2/molecule-net_2.11-0.5.2.jar" target="_blank">molecule-net.jar</a></li> 
  </ul> 
  <p>for scala 2.10</p> 
  <ul> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-core_2.10/0.5.3/molecule-core_2.10-0.5.3.jar" target="_blank">molecule-core.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-io_2.10/0.5.2/molecule-io_2.10-0.5.2.jar" target="_blank">molecule-io.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-parsers_2.10/0.5.4/molecule-parsers_2.10-0.5.4.jar" target="_blank">molecule-parsers.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-net_2.10/0.5.2/molecule-net_2.10-0.5.2.jar" target="_blank">molecule-net.jar</a></li> 
  </ul> 
  <p>for scala 2.9.3</p> 
  <ul> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-core_2.9.3/0.5.3/molecule-core_2.9.3-0.5.3.jar" target="_blank">molecule-core.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-io_2.9.3/0.5.2/molecule-io_2.9.3-0.5.2.jar" target="_blank">molecule-io.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-parsers_2.9.3/0.5.4/molecule-parsers_2.9.3-0.5.4.jar" target="_blank">molecule-parsers.jar</a></li> 
   <li><a href="https://oss.sonatype.org/content/groups/public/com/github/molecule-labs/molecule-net_2.9.3/0.5.2/molecule-net_2.9.3-0.5.2.jar" target="_blank">molecule-net.jar</a></li> 
  </ul> 
  <h2><a href="https://github.com/molecule-labs/molecule#building-from-sources" aria-hidden="true" class="anchor" id="user-content-building-from-sources" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Building From Sources</h2> 
  <p>Using <a href="http://www.scala-sbt.org/release/docs/Getting-Started/Setup" target="_blank">sbt</a>:</p> 
  <pre><code>&gt; git clone git://github.com/molecule-labs/molecule.git/
&gt; cd molecule
&gt; sbt collect-jar
</code></pre> 
  <h2><a href="https://github.com/molecule-labs/molecule#running-the-examples" aria-hidden="true" class="anchor" id="user-content-running-the-examples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the Examples</h2> 
  <p>From command line. First make a build as described above and stay in the molecule folder.</p> 
  <pre><code>java -cp ~/.ivy2/cache/org.scala-lang/scala-library/jars/scala-library-2.9.3.jar:\
./target/2.9.3/molecule-core.jar:./target/2.9.3/molecule-io.jar:\
./target/2.9.3/molecule-net.jar:\
./target/2.9.3/molecule-core-examples.jar:\
./target/2.9.3/molecule-io-examples.jar:\
./target/2.9.3/molecule-net-examples.jar:\
./target/2.9.3/molecule-parsers.jar \
molecule.examples.io.HelloYou
</code></pre> 
  <p><strong>Note:</strong> On Windows, use your full home directory iso '~' and use ';' iso ':' as file separator (and make it one long line, escaping CR with backslash will probably not work).</p> 
  <p>main example classes:</p> 
  <pre><code>- molecule.examples.io.HelloYou (interactive in command line)
- molecule.examples.io.EchoYou (interactive in command line)
- molecule.examples.io.stopwatch.StopWatch (interactive, opens 3 graphical windows)
- molecule.examples.io.primesieve.PrimeSieve (logs primes)
- molecule.examples.io.chameneos.ChameneosRedux (logs a single number)
- molecule.examples.core.Clock (logs time)
- molecule.examples.net.echoyou.EchoYouTelnet 
    (This starts a telnet server that acts like the second example.
     It will log the IP-address and port to connect to.
     To connect, open another terminal window type
        $ telnet &lt;IP-address&gt; &lt;port&gt;
     You can connect multiple clients to the same server.
     It should also work from another machine if your 
    Firewall does not block the connection over the given port.)
</code></pre> 
  <p>Alternatively, you checkout the sources and run them from your favorite IDE with the Scala plugin installed.</p> 
  <h2><a href="https://github.com/molecule-labs/molecule#license" aria-hidden="true" class="anchor" id="user-content-license" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>Copyright 2015 Alcatel-Lucent</p> 
  <p>Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License, Version 2.0</a></p> 
 </article>
</div>