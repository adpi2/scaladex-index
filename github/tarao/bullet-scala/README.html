<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-bullet----" class="anchor" href="https://github.com/tarao/bullet-scala#bullet----" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>bullet <a href="https://travis-ci.org/tarao/bullet-scala" target="_blank"><img src="https://camo.githubusercontent.com/61dc9edbb81a196fb306bb693d11aa7e5dd219ea/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f746172616f2f62756c6c65742d7363616c612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://img.shields.io/travis/tarao/bullet-scala.svg?branch=master" style="max-width:100%;"></a> <a href="https://coveralls.io/github/tarao/bullet-scala?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/a8c7d24fdff546fd0eb45c873fdf3fbd4bef7540/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f746172616f2f62756c6c65742d7363616c612f62616467652e7376673f6272616e63683d6d617374657226736572766963653d676974687562" alt="Coverage status" data-canonical-src="https://coveralls.io/repos/tarao/bullet-scala/badge.svg?branch=master&amp;service=github" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/com.github.tarao/bullet_2.11" target="_blank"><img src="https://camo.githubusercontent.com/086f33d24836679106101971f21cd4f78a4d2a83/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e6769746875622e746172616f2f62756c6c65745f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.github.tarao/bullet_2.11/badge.svg" style="max-width:100%;"></a> <a href="http://javadoc-badge.appspot.com/com.github.tarao/bullet_2.11" target="_blank"><img src="https://camo.githubusercontent.com/176958a213ca397c7846c6f12915ea3ff13e1464/687474703a2f2f6a617661646f632d62616467652e61707073706f742e636f6d2f636f6d2e6769746875622e746172616f2f62756c6c65745f322e31312e7376673f6c6162656c3d7363616c61646f63" alt="Scaladoc" data-canonical-src="http://javadoc-badge.appspot.com/com.github.tarao/bullet_2.11.svg?label=scaladoc" style="max-width:100%;"></a></h1> 
  <p>A monadic library to resolve object relations with the aim of avoiding the N+1 query problem. The solution requires only pure computations in Scala depending on neither database implementations nor any other frameworks.</p> 
  <h2><a id="user-content-getting-started-" class="anchor" href="https://github.com/tarao/bullet-scala#getting-started-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting started <a name="user-content-install" target="_blank" href=""></a></h2> 
  <p>Add dependency in your <code>build.sbt</code> as the following.</p> 
  <div class="highlight highlight-source-scala">
   <pre>    libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
      <span class="pl-s"><span class="pl-pds">"</span>com.github.tarao<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>bullet<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.0.2<span class="pl-pds">"</span></span>
    )</pre>
  </div> 
  <p>The library is available on <a href="https://maven-badges.herokuapp.com/maven-central/com.github.tarao/bullet_2.11" target="_blank">Maven Central</a>. Currently, supported Scala version is 2.11.</p> 
  <h2><a id="user-content-overview-" class="anchor" href="https://github.com/tarao/bullet-scala#overview-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview <a name="user-content-overview" target="_blank" href=""></a></h2> 
  <h3><a id="user-content-the-problem" class="anchor" href="https://github.com/tarao/bullet-scala#the-problem" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>The problem</h3> 
  <p>Assume that you have <code>Car</code> and <code>Engine</code> classes and, if <code>Car</code> has an <code>Engine</code>, it is resolved by a type class method <code>toEngine</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">CarId</span> <span class="pl-k">=</span> <span class="pl-k">Long</span>
<span class="pl-k">type</span> <span class="pl-en">EngineId</span> <span class="pl-k">=</span> <span class="pl-k">Long</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Car</span>(<span class="pl-v">id</span>: <span class="pl-en">CarId</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Engine</span>(<span class="pl-v">id</span>: <span class="pl-en">EngineId</span>, <span class="pl-v">carId</span>: <span class="pl-en">CarId</span>)

<span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">CarRelation</span>(<span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span> {
  <span class="pl-k">def</span> <span class="pl-en">toEngine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> ...
}</pre>
  </div> 
  <p>It is quite usual to implement <code>toEngine</code> method by using a repository which issues a DB query.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">CarRelation</span>(<span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span> {
  <span class="pl-k">def</span> <span class="pl-en">toEngine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> <span class="pl-en">EngineRepository</span>.findByCarId(car.id)
}

<span class="pl-k">val</span> <span class="pl-en">db</span> <span class="pl-k">=</span> ...
<span class="pl-k">object</span> <span class="pl-en">EngineRepository</span> {
  <span class="pl-k">def</span> <span class="pl-en">findByCarId</span>(<span class="pl-v">carId</span>: <span class="pl-en">CarId</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> db.run {
    sql<span class="pl-s"><span class="pl-pds">"</span>SELECT * FROM engine WHERE car_id = $carId LIMIT 1<span class="pl-pds">"</span></span>.as[<span class="pl-en">Engine</span>]
  }.headOption
}</pre>
  </div> 
  <p>There is no problem when you resolve an <code>Engine</code> from a <code>Car</code>. In this case, a <code>SELECT</code> query is executed internally.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> <span class="pl-en">Car</span>(<span class="pl-c1">1234L</span>)
<span class="pl-k">val</span> <span class="pl-en">engine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> car.toEngine
<span class="pl-c">// SELECT * FROM engine WHERE car_id = 1234 LIMIT 1</span></pre>
  </div> 
  <p>If you have multiple <code>Car</code>s and want to get their <code>Engine</code>s, you may want to write like this.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">cars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>] <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Car</span>(<span class="pl-c1">1L</span>), <span class="pl-en">Car</span>(<span class="pl-c1">2L</span>), <span class="pl-en">Car</span>(<span class="pl-c1">3L</span>), ...)
<span class="pl-k">val</span> <span class="pl-en">engines</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> cars.map(_.toEngine).flatten
<span class="pl-c">// SELECT * FROM engine WHERE car_id = 1 LIMIT 1</span>
<span class="pl-c">// SELECT * FROM engine WHERE car_id = 2 LIMIT 1</span>
<span class="pl-c">// SELECT * FROM engine WHERE car_id = 3 LIMIT 1</span>
<span class="pl-c">// ...</span></pre>
  </div> 
  <p>Yes, it works. But there is a problem that the <code>SELECT</code> query is executed for each <code>id</code> of the element of <code>cars</code>. When you have hundreds or thousands of <code>cars</code>, it is likely to be a perfomance issue.</p> 
  <p>One way to solve this problem is to <code>JOIN</code> tables. When you instantiate <code>Car</code>s from <code>car</code> table in your DB, <code>engine</code> table might also be <code>INNER JOIN</code>ed. This is a quite common solution but not the best one. If you have for example <code>Wheel</code>s, a <code>Bumper</code>, and <code>Door</code>s for a <code>Car</code>, you will soon need to <code>JOIN</code> them all but not all of them are needed every time. You will have to write instantiation methods with ugly <code>JOIN</code> queries for each combination of parts that you need.</p> 
  <p>Ideally, it would be nice if the last expression executes a single <code>SELECT</code> query.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">engines</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> cars.map(_.toEngine).flatten
<span class="pl-c">// SELECT * FROM engine WHERE car_id IN (1, 2, 3, ...)</span></pre>
  </div> 
  <p>Is this possible? In Scala, yes, it is.</p> 
  <h3><a id="user-content-our-solution" class="anchor" href="https://github.com/tarao/bullet-scala#our-solution" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Our solution</h3> 
  <p>All you have to do is to replace <code>toEngine</code> method to return an instance of a monad created by <code>HasA.Monadic</code> with an instance of <code>HasA[Car, Engine]</code>, which describes how to resolve <code>Engine</code>s from <code>Car</code>s.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.github.tarao.bullet.</span><span class="pl-v">HasA</span>

<span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">CarRelation</span>(<span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span> {
  <span class="pl-k">def</span> <span class="pl-en">toEngine</span> <span class="pl-k">=</span> <span class="pl-en">HasA</span>.<span class="pl-en">Monadic</span>(car, hasEngine)
}
<span class="pl-k">val</span> <span class="pl-en">hasEngine</span><span class="pl-k">:</span> <span class="pl-en">HasA</span>[<span class="pl-en">Car</span>, <span class="pl-en">Engine</span>] <span class="pl-k">=</span> ...</pre>
  </div> 
  <p>The usage of <code>toEngine</code> is quite the same except that (1) you have to write a type of return value (<code>Option[Engine]</code> or <code>Seq[Engine]</code> in this case), (2) you don't need to <code>flatten</code> anymore.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.github.tarao.bullet.Implicits.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">engine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> car.toEngine

<span class="pl-k">val</span> <span class="pl-en">cars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>] <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">engines</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> cars.map(_.toEngine)</pre>
  </div> 
  <p>The implementation of <code>hasEngine</code> should resolve <code>Engine</code>s from <code>Car</code>s in a single query. <code>HasA[Car, Engine]</code> has an interface for that named <code>map()</code>, whose type is <code>Seq[Car] =&gt; Seq[Engine]</code>. Then the implementation whould be the following.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">hasEngine</span><span class="pl-k">:</span> <span class="pl-en">HasA</span>[<span class="pl-en">Car</span>, <span class="pl-en">Engine</span>] <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">HasA</span>[<span class="pl-en">Car</span>, <span class="pl-en">Engine</span>] {
  <span class="pl-k">def</span> <span class="pl-en">map</span>(<span class="pl-v">cars</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>])<span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> db.run {
    sql<span class="pl-s"><span class="pl-pds">"</span>SELECT * FROM engine WHERE car_id IN (${cars.map(_.id)})<span class="pl-pds">"</span></span>.as[<span class="pl-en">Engine</span>]
  }
}</pre>
  </div> 
  <p>Note that <code>map()</code> method is used for resolving both <code>Option[Engine]</code> and <code>Seq[Engine]</code>. In our example, <code>toEngine</code> results in executing a <code>SELECT</code>-<code>WHERE</code>-<code>IN</code> query in the both cases.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> <span class="pl-en">Car</span>(<span class="pl-c1">1234L</span>)
<span class="pl-k">val</span> <span class="pl-en">engine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> car.toEngine
<span class="pl-c">// SELECT * FROM engine WHERE car_id IN (1234L)</span>

<span class="pl-k">val</span> <span class="pl-en">cars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>] <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Car</span>(<span class="pl-c1">1L</span>), <span class="pl-en">Car</span>(<span class="pl-c1">2L</span>), <span class="pl-en">Car</span>(<span class="pl-c1">3L</span>), ...)
<span class="pl-k">val</span> <span class="pl-en">engines</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> cars.map(_.toEngine)
<span class="pl-c">// SELECT * FROM engine WHERE car_id IN (1, 2, 3, ...)</span></pre>
  </div> 
  <h3><a id="user-content-how-does-it-work" class="anchor" href="https://github.com/tarao/bullet-scala#how-does-it-work" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How does it work?</h3> 
  <p>The key mechanism is a monad, which is a return value of <code>toEngine</code>. In the last example, we receive a monad as a variable of type <code>Option[Engine]</code> or <code>Seq[Engine]</code>. This is actually an implicit conversion. If we make it explicit, the example looks like this.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">engine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> car.toEngine.run

<span class="pl-k">val</span> <span class="pl-en">cars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>] <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">engines</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> cars.map(_.toEngine).run</pre>
  </div> 
  <p>It is <code>run()</code> which actually calls <code>HasA[].map()</code>. Until then, the invocation of <code>HasA[].map()</code> is postponed inside the monad. If the receiver of <code>run()</code> is a list of monads, it will organize them into an argument of a single invocation of <code>HasA[].map()</code>. (You may wonder how it is possible since each monad value has its own instance of <code>HasA[]</code>. It is actually only the first one in the list to be used.)</p> 
  <h3><a id="user-content-why-is-it-a-monad" class="anchor" href="https://github.com/tarao/bullet-scala#why-is-it-a-monad" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why is it a monad?</h3> 
  <p>The above story does not describe the way using our monad as a monad. Actually, it is not necessarily a monad as long as it is some kind of a deferred object. It is a monad just for convenience.</p> 
  <p>Let's see an example. Suppose that an <code>Engine</code> has its <code>Crankshaft</code> and there is a type class method <code>toCrankshaft</code> defined in the same way as <code>toEngine</code>. If we don't have the monadic feature, we need to look up a <code>Crankshaft</code> of a <code>Car</code> via an <code>Engine</code> in the way like this.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">engine</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> car.toEngine
<span class="pl-k">val</span> <span class="pl-en">crankshaft</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Crankshaft</span>] <span class="pl-k">=</span>
  engine.map(_.toCrankshaft<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Crankshaft</span>]).flatten</pre>
  </div> 
  <p>If we use the monadic feature, it can be written like this.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">crankshaft</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">Crankshaft</span>] <span class="pl-k">=</span> <span class="pl-k">for</span> {
  e <span class="pl-k">&lt;</span><span class="pl-k">-</span> car.toEngine
  c <span class="pl-k">&lt;</span><span class="pl-k">-</span> e.toCrankshaft
} <span class="pl-k">yield</span>(c)</pre>
  </div> 
  <p>This is much easier to read especially when you need a complex operation on <code>e</code> and/or <code>c</code>.</p> 
  <h2><a id="user-content-has-a-relation-" class="anchor" href="https://github.com/tarao/bullet-scala#has-a-relation-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Has-a relation <a name="user-content-has-a" target="_blank" href=""></a></h2> 
  <p>As you have seen in the <a href="https://github.com/tarao/bullet-scala#overview" target="_blank">overview</a>, only things you have to do are to implement <code>HasA[].map()</code> and to provide a monad factory using it.</p> 
  <h3><a id="user-content-summary" class="anchor" href="https://github.com/tarao/bullet-scala#summary" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Summary</h3> 
  <ul> 
   <li>Extend <code>HasA[From, To]</code> and implement <code>map: Seq[From] =&gt; Seq[To]</code>.</li> 
   <li>Provide a monad factory which returns <code>HasA.Monadic(from, hasA)</code> where: 
    <ul> 
     <li><code>from</code> is an instance of <code>From</code></li> 
     <li><code>hasA</code> is an instance of <code>HasA[From, To]</code></li> 
    </ul></li> 
  </ul> 
  <h2><a id="user-content-has-many-relation-" class="anchor" href="https://github.com/tarao/bullet-scala#has-many-relation-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Has-many relation <a name="user-content-has-many" target="_blank" href=""></a></h2> 
  <p>You can specify a list type as <code>To</code> type argument of <code>HasA[From, To]</code>. In this case, you can resolve a single value as a <code>Seq[_]</code> instead of <code>Option[Seq[_]]</code>, or multiple values as a <code>Seq[_]</code> instead of <code>Seq[Seq[_]]</code>. For example, if you have <code>HasA[Car, Seq[Wheel]]</code> and <code>toWheels</code> returns a monad, then these can be used as the following.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">wheels</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Wheel</span>] <span class="pl-k">=</span> car.toWheels
<span class="pl-k">val</span> <span class="pl-en">cars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>] <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">totalWheels</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Wheel</span>] <span class="pl-k">=</span> cars.map(_.toWheels)</pre>
  </div> 
  <h3><a id="user-content-summary-1" class="anchor" href="https://github.com/tarao/bullet-scala#summary-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Summary</h3> 
  <ul> 
   <li>The same as <code>HasA[From, To]</code> but <code>To</code> is a list type</li> 
   <li>The result can be flattened automatically</li> 
  </ul> 
  <h2><a id="user-content-joining-related-objects-" class="anchor" href="https://github.com/tarao/bullet-scala#joining-related-objects-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Joining related objects <a name="user-content-join" target="_blank" href=""></a></h2> 
  <p>Sometimes you may want to merge related two objects into one. For example, if you have <code>Car</code>s and their <code>Engine</code>s, you may want to have values of <code>CarWithEngine</code>s where those are merged. To do this, you can use another interface <code>Join.Monadic</code> to define a type class method <code>withEngine</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.github.tarao.bullet.</span><span class="pl-v">Join</span>

<span class="pl-k">type</span> <span class="pl-en">CarWithEngine</span> <span class="pl-k">=</span> (<span class="pl-en">Car</span>, <span class="pl-en">Engine</span>)

<span class="pl-k">implicit</span> <span class="pl-k">class</span> <span class="pl-en">CarRelation</span>(<span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span> {
  <span class="pl-k">def</span> <span class="pl-en">withEngine</span> <span class="pl-k">=</span> <span class="pl-en">Join</span>.<span class="pl-en">Monadic</span>(car, joinEngine)
}

<span class="pl-k">type</span> <span class="pl-en">JoinEngineToCar</span> <span class="pl-k">=</span> <span class="pl-en">Join</span>[<span class="pl-en">CarWithEngine</span>, <span class="pl-en">CarId</span>, <span class="pl-en">Car</span>, <span class="pl-en">Engine</span>]
<span class="pl-k">val</span> <span class="pl-en">joinEngine</span><span class="pl-k">:</span> <span class="pl-en">JoinEngineToCar</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">JoinEngineToCar</span> {
  <span class="pl-k">def</span> <span class="pl-en">map</span>(<span class="pl-v">cars</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>])<span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span> ... <span class="pl-c">// the same as HasA[Car, Engine]</span>
  <span class="pl-k">def</span> <span class="pl-en">leftKey</span>(<span class="pl-v">car</span>: <span class="pl-en">Car</span>)<span class="pl-k">:</span> <span class="pl-en">CarId</span> <span class="pl-k">=</span> car.id
  <span class="pl-k">def</span> <span class="pl-en">rightKey</span>(<span class="pl-v">engine</span>: <span class="pl-en">Engine</span>)<span class="pl-k">:</span> <span class="pl-en">CarId</span> <span class="pl-k">=</span> engine.carId
  <span class="pl-k">def</span> <span class="pl-en">merge</span>(<span class="pl-v">car</span>: <span class="pl-en">Car</span>, <span class="pl-v">engine</span>: <span class="pl-en">Engine</span>)<span class="pl-k">:</span> <span class="pl-en">CarWithEngine</span> <span class="pl-k">=</span> (car, engine)
}</pre>
  </div> 
  <p>This time you have four methods to implement. <code>map()</code>, <code>leftKey()</code>, <code>rightKey()</code> and <code>merge()</code>. <code>map()</code> is the same as in <code>HasA[Car, Engine]</code>. <code>leftKey()</code> and <code>rightKey()</code> provides how you associate one object to another. In this case, a <code>Car</code> and its <code>Engine</code> should share their <code>CarId</code>. associated objects are passed to <code>merge()</code>.</p> 
  <p>The usage is quite similar to <code>toEngine</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">enginedCar</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">CarWithEngine</span>] <span class="pl-k">=</span> car.withEngine

<span class="pl-k">val</span> <span class="pl-en">cars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Car</span>] <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">enginedCars</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">CarWithEngine</span>] <span class="pl-k">=</span> cars.map(_.withEngine)</pre>
  </div> 
  <h3><a id="user-content-summary-2" class="anchor" href="https://github.com/tarao/bullet-scala#summary-2" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Summary</h3> 
  <ul> 
   <li>Extend <code>Join[Result, Key, Left, Right]</code> and implement four methods: 
    <ul> 
     <li><code>map: Seq[Left] =&gt; Seq[Right]</code></li> 
     <li><code>leftKey: Left =&gt; Key</code></li> 
     <li><code>rightKey: Right =&gt; Key</code></li> 
     <li><code>merge: (Left, Right) =&gt; Result</code></li> 
    </ul></li> 
   <li>Provide a monad factory which returns <code>Join.Monadic(left, join)</code> where: 
    <ul> 
     <li><code>left</code> is an instance of <code>Left</code></li> 
     <li><code>join</code> is an instance of <code>Join[Result, Key, Left, Right]</code></li> 
    </ul></li> 
  </ul> 
  <h2><a id="user-content-default-values-" class="anchor" href="https://github.com/tarao/bullet-scala#default-values-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Default values <a name="user-content-default" target="_blank" href=""></a></h2> 
  <p>An <code>Option[]</code> return value of <code>run()</code> may be <code>None</code> if <code>HasA[].map()</code> returns an empty list. In this case, you can provide a default value to ensure having some value returned. This is done by providing an implicit value of <code>Monad.Default[]</code>. If you provide a default value, the return value can be received without being wrapped by <code>Option[]</code>. For example, the following code defines a default value for an <code>Engine</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">defaultEngine</span><span class="pl-k">:</span> <span class="pl-en">Monad</span>.<span class="pl-en">Default</span>[<span class="pl-en">Engine</span>] <span class="pl-k">=</span>
  <span class="pl-en">Monad</span>.<span class="pl-en">Default</span>[<span class="pl-en">Engine</span>](<span class="pl-en">Engine</span>(<span class="pl-c1">0L</span>, <span class="pl-c1">0L</span>))

<span class="pl-k">val</span> <span class="pl-en">car</span><span class="pl-k">:</span> <span class="pl-en">Car</span> <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">engine</span><span class="pl-k">:</span> <span class="pl-en">Engine</span> <span class="pl-k">=</span> car.toEngine</pre>
  </div> 
  <p>In this case, note that <strong>the implicit value must be visible in the scope where the invocation of <code>run()</code> or the implicit conversion occurs</strong>.</p> 
  <p>For <code>Join[]</code>, you should be careful that you have two choices of types to provide a default value, either <code>Result</code> or <code>Right</code> of <code>Join[Result, Key, Left, Right]</code>. If you provide a default value for <code>Result</code>, then you will always get a value by <code>run()</code> on a single monad but still get some values lacked by <code>run()</code> on multiple monads. You should provide a default value for <code>Right</code> to avoid this. In this time, <strong>the implicit value must be visible in the scope where the invoction of <code>Join.Monadic()</code> occurs</strong>.</p> 
  <h2><a id="user-content-an-implicit-conversion-vs-an-explicit-run" class="anchor" href="https://github.com/tarao/bullet-scala#an-implicit-conversion-vs-an-explicit-run" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>An implicit conversion vs. an explicit run</h2> 
  <p>You may think that resolving object relations on an implicit conversion is too aggressive. There is a way not to allow implicit conversions and force explicit <code>run()</code>s instead. Only you have to do is not to <code>import com.github.bullet.Implicits._</code>. Other things will work fine without this.</p> 
  <h2><a id="user-content-license-" class="anchor" href="https://github.com/tarao/bullet-scala#license-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License <a name="user-content-license" target="_blank" href=""></a></h2> 
  <ul> 
   <li>Copyright (C) INA Lintaro</li> 
   <li>MIT License</li> 
  </ul> 
 </article>
</div>