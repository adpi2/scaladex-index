<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-mongoquery" class="anchor" href="https://github.com/limansky/mongoquery#mongoquery" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MongoQuery</h1> 
  <p><a href="https://travis-ci.org/limansky/mongoquery" target="_blank"><img src="https://camo.githubusercontent.com/5faa499c99bd2b34b53da469eb55495de07cad36/68747470733a2f2f7472617669732d63692e6f72672f6c696d616e736b792f6d6f6e676f71756572792e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/limansky/mongoquery.svg?branch=master" style="max-width:100%;"></a> <a href="https://coveralls.io/github/limansky/mongoquery?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/a9b6982b81052f198b95f10822dca29050907121/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6c696d616e736b792f6d6f6e676f71756572792f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/limansky/mongoquery/badge.svg?branch=master" style="max-width:100%;"></a></p> 
  <p>MongoQuery is a macro based MongoDB query builder for Scala.</p> 
  <p>Currently the <a href="http://www.mongodb.org/" target="_blank">MongoDB</a> queries API requires to construct DBObjects explicitly. This makes even simple queries bulky. Even though you are using Casbah DSL it often still requires to create <code>MongoDBObject</code>s, and also requires to study new syntax, instead of using MongoDB queries. The purpose of this project is to provide a simple API for creating queries from strings. The goal is to make compile time queries syntax checking (as much as possible).</p> 
  <h2><a id="user-content-how-to-use" class="anchor" href="https://github.com/limansky/mongoquery#how-to-use" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How to use</h2> 
  <h3><a id="user-content-installation" class="anchor" href="https://github.com/limansky/mongoquery#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h3> 
  <p>MongoQuery is published to Sonatype maven repository. Add following dependency to libraryDependencies in your SBT build file:</p> 
  <pre><code>"com.github.limansky" %% "mongoquery-casbah" % "0.5"    // for Casbah users
"com.github.limansky" %% "mongoquery-reactive" % "0.5"  // for ReactiveMongo users
</code></pre> 
  <p>If you want use latest development version:</p> 
  <pre><code>"com.github.limansky" %% "mongoquery-casbah" % "0.6-SNAPSHOT"    // Casbah users
"com.github.limansky" %% "mongoquery-reactive" % "0.6-SNAPSHOT"  // ReactiveMongo users
</code></pre> 
  <h3><a id="user-content-mq-interpolator" class="anchor" href="https://github.com/limansky/mongoquery#mq-interpolator" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>mq interpolator</h3> 
  <p>The <code>mq</code> string interpolator converts string to the BSON objects. If you use <a href="https://github.com/mongodb/casbah" target="_blank">Casbah</a> it creates <code>DBObjects</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.github.limansky.mongoquery.casbah.</span><span class="pl-v">_</span>

<span class="pl-k">def</span> <span class="pl-en">findByName</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> {
  myCollection.find(mq<span class="pl-s"><span class="pl-pds">"</span>{ name : $name}<span class="pl-pds">"</span></span>)
}
</pre>
  </div> 
  <p>For <a href="http://reactivemongo.org/" target="_blank">ReactiveMongo</a> it creates <code>BSONDocument</code>s:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.github.limansky.mongoquery.reactive.</span><span class="pl-v">_</span>

collection.
  find(mq<span class="pl-s"><span class="pl-pds">"""</span>{ firstName : "Jack" }<span class="pl-pds">"""</span></span>, mq<span class="pl-s"><span class="pl-pds">"</span>{ lastName : 1, _id : 1 }<span class="pl-pds">"</span></span>).
  cursor[<span class="pl-en">BSONDocument</span>].
  enumerate().apply(<span class="pl-en">Iteratee</span>.foreach { doc <span class="pl-k">=&gt;</span>
  println(<span class="pl-s"><span class="pl-pds">"</span>found document: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-en">BSONDocument</span>.pretty(doc))
})</pre>
  </div> 
  <p>Since the query is defined inside of the string interpolator, the words started with <code>$</code> are handled as variable references. To type MongoDB operator use <code>$$</code>, e.g:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">makeOlder</span>(<span class="pl-v">age</span>: <span class="pl-k">Int</span>) <span class="pl-k">=</span> {
  people.update(mq<span class="pl-s"><span class="pl-pds">"""</span>{ age : { $$lt : $age } }<span class="pl-pds">"""</span></span>,
                mq<span class="pl-s"><span class="pl-pds">"""</span>{ $$inc : { age : 1 }}<span class="pl-pds">"""</span></span>,
                multi <span class="pl-k">=</span> <span class="pl-c1">1</span>)
}</pre>
  </div> 
  <p>Since the interpolator is implemented using macro it can perform compile time checks of provided queries. The code will not compile if the query is malformed. Also MongoQuery checks if all MongoDB operators are known.</p> 
  <div class="highlight highlight-source-scala">
   <pre>[error] <span class="pl-en">Test</span>.scala<span class="pl-k">:</span><span class="pl-c1">44</span><span class="pl-k">:</span> <span class="pl-en">Unknown</span> operator <span class="pl-c1">'<span class="pl-ii">$kte</span>'</span>. <span class="pl-en">Possible</span> you mean <span class="pl-c1">'<span class="pl-ii">$lte</span>'</span>
[error]     <span class="pl-k">val</span> <span class="pl-en">query</span> <span class="pl-k">=</span> mq<span class="pl-s"><span class="pl-pds">"</span>{start : {$$kte : $start}}<span class="pl-pds">"</span></span>
[error]                              ^

[error] <span class="pl-en">Test</span>.scala<span class="pl-k">:</span><span class="pl-c1">49</span><span class="pl-k">:</span> <span class="pl-c1">'{'</span> expected, but <span class="pl-en">Variable</span> found
[error]     <span class="pl-k">val</span> <span class="pl-en">q</span> <span class="pl-k">=</span> mq<span class="pl-s"><span class="pl-pds">"</span>{ color : {$$in : $colors}<span class="pl-pds">"</span></span>
[error]                                ^</pre>
  </div> 
  <p>Unfortunately, some errors messages does not reflect the error itself. I'm working on it, but it seems like the issue in the Scala Parser Combinators library.</p> 
  <h3><a id="user-content-built-in-types" class="anchor" href="https://github.com/limansky/mongoquery#built-in-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Built-in types</h3> 
  <p>MongoQuery supports several MongoDB specific literal types.</p> 
  <ul> 
   <li>ObjectIds. <code>mq"""{ clientId : ObjectId("01234567890abcdef1234") }"""</code></li> 
   <li>Booleans. <code>mq"{ expired : false }"</code></li> 
   <li>Regular expressions (since 0.5). <code>mq"{ name : /^joe/i }"</code></li> 
  </ul> 
  <h3><a id="user-content-mqt-interpolator" class="anchor" href="https://github.com/limansky/mongoquery#mqt-interpolator" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>mqt interpolator</h3> 
  <p><code>mqt</code> is another one interpolator adding type checking feature. If you have a model classes, you can check if the query contains only fields available in the class. E.g.:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Phone</span>(<span class="pl-v">kind</span>: <span class="pl-k">String</span>, <span class="pl-v">number</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>, <span class="pl-v">phones</span>: <span class="pl-en">List</span>[<span class="pl-en">Phone</span>])

<span class="pl-c">// OK</span>
persons.update(mq<span class="pl-s"><span class="pl-pds">"</span>{}<span class="pl-pds">"</span></span>, mqt<span class="pl-s"><span class="pl-pds">"</span>{$$inc : { age : 1 }}<span class="pl-pds">"</span></span>[<span class="pl-en">Person</span>])

<span class="pl-c">// Failed, person doesn't contain field 'nme'</span>
persons.update(mq<span class="pl-s"><span class="pl-pds">"</span>{}<span class="pl-pds">"</span></span>, mqt<span class="pl-s"><span class="pl-pds">"""</span>{$$set : { nme : "Joe" }}<span class="pl-pds">"""</span></span>[<span class="pl-en">Person</span>])

<span class="pl-c">//Failed, name is not indexed field</span>
persons.find(mqt<span class="pl-s"><span class="pl-pds">"</span>{ name.1 : 'Joe' }<span class="pl-pds">"</span></span>[<span class="pl-en">Person</span>])

<span class="pl-c">// OK</span>
persons.find(mqt<span class="pl-s"><span class="pl-pds">"</span>{ phone.number : '223322' }<span class="pl-pds">"</span></span>[<span class="pl-en">Person</span>])

<span class="pl-c">// Failed, Phone doesn't contain field num</span>
persons.find(mqt<span class="pl-s"><span class="pl-pds">"</span>{ phone.num : '223322' }<span class="pl-pds">"</span></span>[<span class="pl-en">Person</span>])</pre>
  </div> 
  <h3><a id="user-content-runtime-parsing" class="anchor" href="https://github.com/limansky/mongoquery#runtime-parsing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Runtime parsing</h3> 
  <p>MongoQuery also provides runtime parsers for both backends. It might be useful for testing purposes, or if you generate queries on runtime, or for converting JSON to BSON. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.github.limansky.mongoquery.casbah.</span><span class="pl-v">BSONParser</span>

persons.find(<span class="pl-en">BSONParser</span>.parse(<span class="pl-s"><span class="pl-pds">"""</span>{ age : { $lt : 42 }}<span class="pl-pds">"""</span></span>))</pre>
  </div> 
  <h2><a id="user-content-feedback" class="anchor" href="https://github.com/limansky/mongoquery#feedback" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Feedback</h2> 
  <p>Any feedback is very welcome! You can ask any questions in <a href="https://groups.google.com/forum/#!forum/mongoquery-users" target="_blank">MongoQuery mailing list</a>.</p> 
 </article>
</div>