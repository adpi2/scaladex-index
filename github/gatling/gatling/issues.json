{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":2602,
            "title":"Core: Provide a \"streaming\" CSV reader",
            "bodyText":"There are cases where users are loading massive CSV files as feeders for their simulations.\nCurrently, as CSV feeders are loaded eagerly to avoid file IO during the simulation, users may require huge heaps so that the data can fit in memory.\nAn alternative could be to read CSV files in small batches, which would trade memory usage for some file IO when a new batch is read.",
            "url":"https://github.com/gatling/gatling/issues/2602"
          },
          {
            "number":2830,
            "title":"Doc: How to debug scripts page in the documentation",
            "bodyText":"I suggest creating a debugging page in the documentation. Extract the stuff about printing session  values and add logback stuff.",
            "url":"https://github.com/gatling/gatling/issues/2830"
          },
          {
            "number":2909,
            "title":"Recorder: Support user provided keystore required for talking with the server",
            "bodyText":"Not that complicated to implement:\n\nintroduce in SslClientContext the same kind of changes as in SslServerContext so it's no longer an object, but an instance that gets passed a configuration. The change is to pass KeyManagers instead of null. Such KeyManagers can be created this way.\nchange GUI and RecorderConfiguration",
            "url":"https://github.com/gatling/gatling/issues/2909"
          },
          {
            "number":2971,
            "title":"Recorder: SslServerContext assumes the keyStore and KeyManager have the same password",
            "bodyText":"In SslServerContext the keyStrore is initialized like so:\nlazy val keyStore = {\n      val ks = KeyStore.getInstance(keyStoreType.toString)\n      withCloseable(keyStoreInitStream) { ks.load(_, password) }\n      ks\n    }\nand the KeyManager is initialized like so\n // Set up key manager factory to use our key store\n      val kmf = KeyManagerFactory.getInstance(Algorithm)\n      kmf.init(keyStore, password)\nThe code assumes they both use the same password. In reality, if there are two different passwords needed the you will get the an exception:\njava.security.UnrecoverableKeyException: Cannot recover key",
            "url":"https://github.com/gatling/gatling/issues/2971"
          },
          {
            "number":3345,
            "title":"Have an inject built-in for ramped acceleration",
            "bodyText":"A bit similar to splitUsers.\nscn.inject(\n    constantUsersPerSec(50) during(3 minutes),\n    constantUsersPerSec(100) during(3 minutes),\n    constantUsersPerSec(150) during(3 minutes),\n    constantUsersPerSec(200) during(3 minutes),\n    constantUsersPerSec(250) during(3 minutes),\n    constantUsersPerSec(300) during(3 minutes),\n    constantUsersPerSec(350) during(3 minutes),\n    constantUsersPerSec(400) during(3 minutes),\n    constantUsersPerSec(450) during(3 minutes),\n    constantUsersPerSec(500) during(3 minutes),\n    constantUsersPerSec(550) during(3 minutes),\n    constantUsersPerSec(600) during(3 minutes),\n    constantUsersPerSec(650) during(3 minutes),\n    constantUsersPerSec(700) during(3 minutes),\n    constantUsersPerSec(750) during(3 minutes),\n    constantUsersPerSec(800) during(3 minutes),\n    constantUsersPerSec(850) during(3 minutes),\n    constantUsersPerSec(900) during(3 minutes),\n    constantUsersPerSec(950) during(3 minutes),\n    constantUsersPerSec(1000) during(3 minutes)\n  )\ncan be shorten as\nscn.inject((1 to 20).map(i => constantUsersPerSec(i * 50) during(3 minutes)))\nbut it would be nice to have a built-in for non-Scala developers.",
            "url":"https://github.com/gatling/gatling/issues/3345"
          }
        ]
      }
    }
  }
}