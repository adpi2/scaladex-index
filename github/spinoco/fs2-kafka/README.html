<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/spinoco/fs2-kafka#fs2-kafka" aria-hidden="true" class="anchor" id="user-content-fs2-kafka" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>fs2-kafka</h1> 
  <p>Kafka client implemented with <a href="https://github.com/scalaz/scalaz-stream" target="_blank">fs2</a> library</p> 
  <p><a href="https://travis-ci.org/Spinoco/fs2-kafka" target="_blank"><img src="https://camo.githubusercontent.com/219bc0c5746828810961e8c876d3b3ec92136b60/68747470733a2f2f7472617669732d63692e6f72672f5370696e6f636f2f6673322d6b61666b612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/Spinoco/fs2-kafka.svg?branch=master" style="max-width:100%;"></a> <a href="https://gitter.im/fs2-http/Lobby" target="_blank"><img src="https://camo.githubusercontent.com/37ae58da0714da32b437cf7d777596f1c4c0fd82/68747470733a2f2f6261646765732e6769747465722e696d2f66756e6374696f6e616c2d73747265616d732d666f722d7363616c612f6673322e737667" alt="Gitter Chat" data-canonical-src="https://badges.gitter.im/functional-streams-for-scala/fs2.svg" style="max-width:100%;"></a></p> 
  <h2><a href="https://github.com/spinoco/fs2-kafka#overview" aria-hidden="true" class="anchor" id="user-content-overview" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h2> 
  <p>fs2-kafka is a simple client for consuming and publishing messages from / to Apache Kafka. It has minimalistic functionality and is fully implemented without any dependency on kafka native driver. It is fully asynchronous and non-blocking.</p> 
  <p>Thanks to fs2, it comes with full backpressure and streaming support out of the box, and plays well with other fs2 libraries such as <a href="https://github.com/Spinoco/fs2-http" target="_blank">fs2-http</a>.</p> 
  <p>fs2-kafka was built with minimal dependencies (apart from fs2, only scodec and shapeless is used).</p> 
  <p>fs2-kafka only supports a subset of features compared to the native kafka client. There is for example no support for creating/administering topics and partitions, or for Kafka Connect / Kafka Streams. The reason for that is that we wanted the client to be as simple as possible, thus leaving all non-essential functionality to other solutions. Please note there is also no support for SASL Kafka protocol now.</p> 
  <h2><a href="https://github.com/spinoco/fs2-kafka#features" aria-hidden="true" class="anchor" id="user-content-features" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <ul> 
   <li>Subscribe to topic / parition, with configurable pre-fetch behaviour.</li> 
   <li>Publish to topic / partition</li> 
   <li>Query metadata from kafka cluster</li> 
   <li>Query offset range for topic / partition</li> 
  </ul> 
  <p>For the compression of messages fs2-kafka supports GZIP and Snappy compression.</p> 
  <p>fs2-kafka supports versions between 0.8.2 and 0.10.2 of kafka cluster with respective protocols. The protocols are cross-tested against the different versions of Kafka (i.e. 0.10.2 is tested to wrok ok with 0.8.2, 0.9.1, 0.10, 0.10.1 and 0.10.2 protocols).</p> 
  <h2><a href="https://github.com/spinoco/fs2-kafka#sbt" aria-hidden="true" class="anchor" id="user-content-sbt" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SBT</h2> 
  <p>Add this to your build file</p> 
  <pre><code>libraryDependencies += "com.spinoco" %% "fs2-kafka" % "0.1.2" 
</code></pre> 
  <h2><a href="https://github.com/spinoco/fs2-kafka#dependencies" aria-hidden="true" class="anchor" id="user-content-dependencies" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependencies</h2> 
  <table> 
   <thead> 
    <tr> 
     <th>version</th> 
     <th>scala</th> 
     <th>fs2</th> 
     <th>scodec</th> 
     <th>shapeless</th> 
    </tr> 
   </thead> 
   <tbody> 
    <tr> 
     <td>0.1.2</td> 
     <td>2.11, 2.12</td> 
     <td>0.9.7</td> 
     <td>1.10.3</td> 
     <td>2.3.2</td> 
    </tr>
   </tbody>
  </table> 
  <h2><a href="https://github.com/spinoco/fs2-kafka#usage" aria-hidden="true" class="anchor" id="user-content-usage" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>Throughout this simple usage guide, please consider having the following imports on your classpath:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">fs2.util.syntax.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">spinoco.fs2.</span><span class="pl-v">kafka</span>
<span class="pl-k">import</span> <span class="pl-v">spinoco.fs2.kafka.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">spinoco.protocol.kafka.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>If you type console from fs2-kafka's project sbt, these imports are added for you automatically.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#basics" aria-hidden="true" class="anchor" id="user-content-basics" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Basics</h3> 
  <p>The client can be used with any <code>F</code> (effectfull type) that conforms to <code>Async[F]</code>. As a reference throughout the guide we will use fs2.Task.</p> 
  <p>To obtain a Kafka client the following code can be used :</p> 
  <div class="highlight highlight-source-scala">
   <pre>kafka.client(
  ensemble <span class="pl-k">=</span> <span class="pl-en">Set</span>(broker(<span class="pl-s"><span class="pl-pds">"</span>kafka-broker1-dns-name<span class="pl-pds">"</span></span>, port <span class="pl-k">=</span> <span class="pl-c1">9092</span>))
  , protocol <span class="pl-k">=</span> <span class="pl-en">ProtocolVersion</span>.<span class="pl-en">Kafka_0_10_2</span>
  , clientName <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-client-name<span class="pl-pds">"</span></span>
) flatMap { kafkaClient <span class="pl-k">=&gt;</span>
  <span class="pl-c"><span class="pl-c">/*</span> your code using Kafka Client *<span class="pl-c">*/</span></span>
  <span class="pl-k">???</span>.<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">Stream</span>[<span class="pl-en">F</span>, <span class="pl-en">A</span>]]
}
</pre>
  </div> 
  <p>Note that the resulting type of this program is <code>Stream[F, A]</code>, which means that stream needs to be run, and once it finishes the kafka client will terminate.</p> 
  <p>The <code>protocol</code> parameter allows to explicitly specify the protocol to be used with Kafka ensemble, to make production migrations and upgrades easy.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#publishing-to-topics" aria-hidden="true" class="anchor" id="user-content-publishing-to-topics" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Publishing to topics</h3> 
  <p>fs2-kafka has 4 possible ways to publish to a topic.</p> 
  <ul> 
   <li> <p><code>publish1</code> - publishes one message to topic and partition and awaits confirmation from the leader</p> </li> 
   <li> <p><code>publishN</code> - publishes a chunk of messages to topic / partition and awaits confirmation from the leader</p> </li> 
   <li> <p><code>publish1Unsafe</code> - like publish1, except this won't confirm that publish was successful</p> </li> 
   <li> <p><code>publishNUnsafe</code> - like publishN, except this won't confirm that publish was successful</p> </li> 
  </ul> 
  <p>The first two methods (<code>publish1</code> and <code>publishN</code>) allow to publish messages safely, meaning that once the message is published, the result contains the offset of the first successfully published message. Each of these two methods has two important parameters that have to be specified:</p> 
  <ul> 
   <li><code>requireQuorum</code> : When set to true, this indicates that quorum (majority) of ISR (In sync replicas) must aknowledge the publish operation in order for it to be successful. When set to <code>false</code>, only the leader must acknowledge the publish.</li> 
   <li><code>serverAckTimeout</code> : A timeout at server (broker) to confirm the message publish operation. Note that this timeout is only relevant when publish is sent to kafka broker. There is no timeout locally within the client, so for example if there are no brokers available, the message will be queued up until the leader will become avaialble. That local timeout is subject to be implemented with <code>F</code> (see examples below).</li> 
  </ul> 
  <p>The second two methods to publish to topic (<code>publish1Unsafe</code> and <code>publishNUnsafe</code>) allow to publish without confirmation from the server. Locally, there is only minimal verification that publish was successful, essentially once the leader is avaiailble and connection with the leader has been established, the publish is considered to be successful.</p> 
  <p>Please note there is a difference from how the kafka native client behaves when publishing. Kafka client retries (3x) when there was an unsuccesful publish. fs2-kafka instead fails as soon as possible and leaves it up to the user to choose from any retry mechanics.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#examples-of-publishing-to-topic" aria-hidden="true" class="anchor" id="user-content-examples-of-publishing-to-topic" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples of publishing to topic:</h3> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span>/ assuming val kafkaClient: KafkaClient = ... </span>

<span class="pl-c"><span class="pl-c">//</span> publishes safely 1 message to topic-A partition 0, with Key 1, and value [1, 2, 3]  </span>
<span class="pl-c"><span class="pl-c">//</span> returns when the publish was accepted by a majority (quorum) of the servers. Fails, when server doesn't get acknowledgements from ISRs in 10s or less. </span>
kafkaClient.publish1(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), partition(<span class="pl-c1">0</span>), <span class="pl-en">ByteVector</span>(<span class="pl-c1">1</span>), <span class="pl-en">ByteVector</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>), requireQuorum <span class="pl-k">=</span> <span class="pl-c1">true</span>, serverAckTimeout <span class="pl-k">=</span> <span class="pl-c1">10</span> seconds)

<span class="pl-c"><span class="pl-c">//</span> consumes a stream of key value pairs and publishes them in chunks to a broker. Note that this publishes the stream of messages in chunks utilitizing the kafka batch processing.   </span>
<span class="pl-c"><span class="pl-c">//</span> returns when the publish was accepted by a majority (quorum) of the servers. Fails, when server doesn't get acknowledgements from ISRs in 10s or less. </span>
<span class="pl-c"><span class="pl-c">//</span> Additionally the chunks are not compressed, but GZIP or Snappy can be plugged in by specifying the compress attribute. </span>
<span class="pl-c"><span class="pl-c">//</span> The resulting stream will contain the starting offset of the very first message in chunk. </span>
<span class="pl-k">val</span> <span class="pl-en">streamOfValues</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, (<span class="pl-en">ByteVector</span>, <span class="pl-en">ByteVector</span>)] <span class="pl-k">=</span> <span class="pl-k">???</span>
streamOfValues.chunk.evalMap {
  kafkaClient.publishN(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), partition(<span class="pl-c1">0</span>), requireQuorum <span class="pl-k">=</span> <span class="pl-c1">true</span>, serverAckTimeout <span class="pl-k">=</span> <span class="pl-c1">10</span> seconds, compress <span class="pl-k">=</span> <span class="pl-c1">None</span>)
}

<span class="pl-c"><span class="pl-c">//</span> publishes an s1 message to topic-A partition 0, with Key 1, and value [1, 2, 3]  </span>
<span class="pl-c"><span class="pl-c">//</span> returns immediately, when there is a leader known for topic/ partition </span>
kafkaClient.publish1Unsafe(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), partition(<span class="pl-c1">0</span>), <span class="pl-en">ByteVector</span>(<span class="pl-c1">1</span>), <span class="pl-en">ByteVector</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>))

<span class="pl-c"><span class="pl-c">//</span> consumes a stream of key value pairs and publishes them in chunks to a broker. Note that this publishes the stream of messages in chunks utilitizing the kafka batch processing.   </span>
<span class="pl-c"><span class="pl-c">//</span> returns immediately. </span>
<span class="pl-c"><span class="pl-c">//</span> Additionally the chunks are not compressed, but GZIP or Snappy can be plugged in by specifying the compress attribute. </span>
<span class="pl-k">val</span> <span class="pl-en">streamOfValues</span><span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">Task</span>, (<span class="pl-en">ByteVector</span>, <span class="pl-en">ByteVector</span>)] <span class="pl-k">=</span> <span class="pl-k">???</span>
streamOfValues.chunk.evalMap {
  kafkaClient.publishNUnsafe(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), partition(<span class="pl-c1">0</span>),compress <span class="pl-k">=</span> <span class="pl-c1">None</span>)
}
</pre>
  </div> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#querying-kafka-for-available-offsets" aria-hidden="true" class="anchor" id="user-content-querying-kafka-for-available-offsets" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Querying kafka for available offsets</h3> 
  <p>In some scenarios, it is useful to know kafka first and last offset at any given time. As you will see below, the fs2-kafka makes the "tail" of the topic with every message (tail - last message in topic) available. However, you may need to know the available range before you start consuming the topic.</p> 
  <p>fs2-kafka has <code>offsetRangeFor</code> API for that purpose. When evaluated, this will return the offset of the first and the next message to be published in every topic/partition. When the offsets are equal, the topic/partition is empty.</p> 
  <p>exmaple:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Queries the first and the next-to-be-published offset of messages in topic `topic-A` partition 0</span>
kafkaClient.offsetRangeFor(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), partition(<span class="pl-c1">0</span>)) flatMap { <span class="pl-k">case</span> (first, next) <span class="pl-k">=&gt;</span>
   <span class="pl-k">???</span>
}
</pre>
  </div> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#subscription" aria-hidden="true" class="anchor" id="user-content-subscription" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Subscription</h3> 
  <p>fs2-kafka client only has one method of subscriptions for the topic. Subscription to topic is utilizing the <code>subscribe</code> method with several parameters that can finetune its exact behaviour.</p> 
  <p>Subscription to kafka topic always subscribes with the first message specified in the <code>offset</code> parameter and always awaits the next messages to be published to the topic (won't terminate when there are no more messages in topic available). That behaviour, in combination with <code>offsetRangeFor</code>, shall give the user the posibility to express any subscription pattern necessary.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#subscribe-at-invalid-offset-range" aria-hidden="true" class="anchor" id="user-content-subscribe-at-invalid-offset-range" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Subscribe at invalid offset range</h3> 
  <p>fs2-kafka client is able to recover itself when there is an invalid offset specified for the <code>offset</code> parameter. The rules to recover from an invalid offset are:</p> 
  <ul> 
   <li>When the offset is lower than the offset of the first message available in the topic, the subscription will start at the very first message available</li> 
   <li>When the offset is greater than the offset of the last message availble in the topic, the subscription will start at the very next message arriving to topic since the stream was evaluated.</li> 
  </ul> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#error-recovery" aria-hidden="true" class="anchor" id="user-content-error-recovery" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Error Recovery</h3> 
  <p>fs2-kafka client may recover from broker failures. It also allows the recovery to be handled externally by user logic. However, simple machanics have been built in.</p> 
  <p>Client's recovery of the <code>subscribe</code> method is controlled by <code>leaderFailureTimeout</code> and <code>leaderFailureMaxAttempts</code> parameters. Default behaviour is to allow for three consecutive leader failures and sleep for 5s between these failures before giving up and failing the subscription. When the user wants to control failure recovery manually, <code>0 millis</code> should be used for <code>leaderFailureTimeout</code> and <code>0</code> for <code>leaderFailureMaxAttempts</code> parameters, causing the subscription to fail at any error (except for invalid offsets, which are always handled).</p> 
  <p>fs2-kafka client <code>subscribe</code> will recover from any failures, and will start the next subscription from the next offset to the last received message.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#further-subscription-fine-tuning" aria-hidden="true" class="anchor" id="user-content-further-subscription-fine-tuning" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Further subscription fine-tuning</h3> 
  <p>fs2-kafka subscription allows to further finetune the behaviour of the subscriptions. When subscribing, the fs2-kafka client may receive more messages in a single chunk, and in that case fs2-kafka fully utiliizes the "chunk" optimization of the fs2 library. Furthermore, the following parameters may control the behaviour of the subscription :</p> 
  <ul> 
   <li><code>minChunkByteSize</code> - Controls the minimum number of bytes that must be ready at kafka leader in order to complete a single fetch chunk. If there is less than that amout of bytes, the susbcriber will wait up to that amount of bytes before emitting any messages.</li> 
   <li><code>maxChunkByteSize</code> - Controls the maximum number of bytes that is allowed in a single chunk. If there is more bytes than this number available at leader, the client will split the results to more chunks // requests.</li> 
   <li><code>maxWaitTime</code> - Controls how much time we wait before the next <code>fetch</code> attempt is performed at the leader.</li> 
  </ul> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#configurable-pre-fetching" aria-hidden="true" class="anchor" id="user-content-configurable-pre-fetching" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configurable pre-fetching</h3> 
  <p>To improve performance, fs2-kafka allows to pre-fetch data from the kafka topic by setting the <code>prefetch</code> parameter to <code>true</code> (default). This allows to pre-fetch the next chunk of messages from the topic while the current chunk of messages is processed at client. This may significantly increase performance, specifically when dealing with large chunks of messages.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#subscribe-from-head" aria-hidden="true" class="anchor" id="user-content-subscribe-from-head" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Subscribe from head</h3> 
  <p>In fs2-kafka <code>Head</code> is considered to be the first message ever published to a topic. Typically, the user may want to either consume all messages in the topic and process any new messages arriving to the topic, or finish subscription on the very last message available in topic.</p> 
  <p>To subscribe for all messages and await the next messages to be published in a topic use:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  kafkaClient.subscribe(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), parition(<span class="pl-c1">0</span>), <span class="pl-en">HeadOffset</span>) <span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">F</span>, <span class="pl-en">TopicMessage</span>] 
</pre>
  </div> 
  <p>A more complex example occurs when you want to subscribe for messages and stop the subscription at the very last message published to a topic:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  kafkaClient.offsetRangeFor(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), partition(<span class="pl-c1">0</span>)) flatMap { <span class="pl-k">case</span> (first, next) <span class="pl-k">=&gt;</span>
    kafkaClient.subscribe(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), parition(<span class="pl-c1">0</span>), first) takeWhile { _.offset <span class="pl-k">&lt;=</span> next }
  }<span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">F</span>, <span class="pl-en">TopicMessage</span>] 
</pre>
  </div> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#subscribe-from-an-exact-offset" aria-hidden="true" class="anchor" id="user-content-subscribe-from-an-exact-offset" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Subscribe from an exact offset</h3> 
  <p>Very similar to <code>Head</code>, the subscription offset can be specified when subscribing from an exact position:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">desiredOffsetToSubscribeFrom</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> <span class="pl-k">???</span>
  kafkaClient.subscribe(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), parition(<span class="pl-c1">0</span>), offset(desiredOffsetToSubscribeFrom)) <span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">F</span>, <span class="pl-en">TopicMessage</span>] 
</pre>
  </div> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#subscribe-at-tail" aria-hidden="true" class="anchor" id="user-content-subscribe-at-tail" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Subscribe at tail</h3> 
  <p>When subscribing at <code>Tail</code>, the subscriber will receive any messages that have not been published to the topic yet:&nbsp;</p> 
  <div class="highlight highlight-source-scala">
   <pre>  kafkaClient.subscribe(topic(<span class="pl-s"><span class="pl-pds">"</span>topic-A<span class="pl-pds">"</span></span>), parition(<span class="pl-c1">0</span>), <span class="pl-en">TailOffset</span>) <span class="pl-k">:</span> <span class="pl-en">Stream</span>[<span class="pl-en">F</span>, <span class="pl-en">TopicMessage</span>] 
</pre>
  </div> 
  <h2><a href="https://github.com/spinoco/fs2-kafka#design" aria-hidden="true" class="anchor" id="user-content-design" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Design</h2> 
  <p>fs2-kafka is very simple when it comes to internal architecture. Even though kafka supports a variety of patterns, we chose a simple, minimalistic architecture that in our opinion will fit most real-world use-cases.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#subscribers" aria-hidden="true" class="anchor" id="user-content-subscribers" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Subscribers</h3> 
  <p>Every subscriber in fs2-kafka has their own dedicated TCP connection with the leader. We don't do any connection pooling. The reason for this is that we want to have a predictable performance for every topic / partition combination. Kafka inherently blocks fetch requests serving them in FIFO order. That effectively disallows for reusing TCP connections for topics with mixed message types (i.e. short and long messages). Reusing TCP connections will lead to unpredictable performance.</p> 
  <h3><a href="https://github.com/spinoco/fs2-kafka#publishers" aria-hidden="true" class="anchor" id="user-content-publishers" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Publishers</h3> 
  <p>Unlike subscribers, publishers do share TCP connections. Each topic/partition combination has only one dedicated TCP connection that is opened with the very first publish attempt to topic/partition and is kept open to be reused for successive publish attempts. fs2-kafka does not reuse connections between topic/partition for the same reasons as the subscribers: FIFO ordering and predictable performance.</p> 
 </article>
</div>