<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-presentation" class="anchor" href="https://github.com/mcamou/scuby#presentation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>PRESENTATION</h2> 
  <p>Scuby is a thin integration layer between Scala and JRuby. It aims to provide DSLs for Scala and JRuby to ease interoperability. The original inspiration came from a couple of blog entries published by Daniel Spiewak:</p> 
  <p><a href="http://www.codecommit.com/blog/ruby/jruby-interop-dsl-in-scala" target="_blank">JRuby Interop DSL in Scala</a></p> 
  <p><a href="http://www.codecommit.com/blog/ruby/integrating-scala-into-jruby" target="_blank">Integrating Scala into JRuby</a></p> 
  <p>The idea behind this polyglot architecture came about based on the <a href="http://olabini.com/blog/2008/06/fractal-programming/" target="_blank">Fractal Programming</a> post by Ola Bini, in which he talks about dividing a program in 3 layers: the static layer for performance-critical functionality and those functions in which type safety is paramount, a dynamic layer where you create a DSL, and a DSL layer where the bulk of the business logic resides.</p> 
  <p>Scuby was first publicly presented at RubyConf 2009, in the talk <em>Ruby is from Mars, Functional Languages are from Venus: Integrating Ruby with Erlang, Scala or F#</em> by Angela O.K. Wright.</p> 
  <p>The project has been sponsored in part by <a href="http://www.abstra.cc" target="_blank">Abstra.cc</a> where we use it for our internal development.</p> 
  <h2><a id="user-content-adding-scuby-to-your-project" class="anchor" href="https://github.com/mcamou/scuby#adding-scuby-to-your-project" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>ADDING SCUBY TO YOUR PROJECT</h2> 
  <p>Scuby is available in Maven Central. As of version 0.2.5 it has been cross-compiled with Scala 2.10 and 2.11. To add Scuby to an SBT project, just add the following dependency to your build.sbt:</p> 
  <pre><code>libraryDependencies += "com.tecnoguru" %% "scuby" % "0.2.6"
</code></pre> 
  <p>or if you use Maven, add this to your pom.xml:</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependency</span>&gt;
  &lt;<span class="pl-ent">groupId</span>&gt;com.tecnoguru&lt;/<span class="pl-ent">groupId</span>&gt;
  &lt;<span class="pl-ent">artifactId</span>&gt;scuby_2.10&lt;/<span class="pl-ent">artifactId</span>&gt; <span class="pl-c">&lt;!-- Or scuby_2.11 --&gt;</span>
  &lt;<span class="pl-ent">version</span>&gt;0.2.6&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre>
  </div> 
  <p>If you use Gradle or some other build tool, please convert this to your preferred syntax.</p> 
  <p><strong>NOTE</strong> Starting with Scuby 0.2.2, the artifact name has changed from <code>scuby</code> to <code>scuby_2.10</code> / <code>scuby_2.11</code> as per Scala packaging conventions.</p> 
  <p><strong>NOTE</strong> Don't use Scuby 0.2.2, it has a nasty bug where it won't resolve class names that are within modules. Update to Scuby 0.2.3+.</p> 
  <h2><a id="user-content-using-a-different-jruby-version" class="anchor" href="https://github.com/mcamou/scuby#using-a-different-jruby-version" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>USING A DIFFERENT JRUBY VERSION</h2> 
  <p>At the moment Scuby is based on JRuby 1.7.13 and Scala 2.10.4/2.11.1, even though it makes almost no use (yet) of the new Java interoperability features introduced with JRuby 1.4. These should slowly find their way into Scuby as time permits. As of 0.2.2+ it does make some use of calls to the JRuby classes themselves, so YMMV as far as using different versions of JRuby.</p> 
  <p>JRuby 1.7.12 seems to have multithreading problems when using the default LocalContextScope (LocalContextScope.SINGLETON). This is reflected in the Specs2 tests, which now run sequentially. Please make a note of this and be careful when using Scuby from within different threads.</p> 
  <p>However, if for some reason you wish to use an older version of JRuby, you can add the following line to your project's <code>build.sbt</code>:</p> 
  <pre><code>libraryDependencies += "org.jruby" % "jruby" % "1.7.6" force()
</code></pre> 
  <p>This would bring in JRuby 1.7.6. Note the <code>force()</code> at the end of the line, this tells SBT to use that version regardless of if some other dependency has a transitive dependency on a later one.</p> 
  <h2><a id="user-content-compiling-scuby" class="anchor" href="https://github.com/mcamou/scuby#compiling-scuby" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>COMPILING SCUBY</h2> 
  <p>The Scuby build.sbt file includes dependencies on <code>org.scala-lang:scala-library:2.11.2</code> and <code>org.jruby:jruby-complete:1.7.12</code>. If you don't use SBT you will have to download those dependencies (and any transitive ones) and place them on your CLASSPATH.</p> 
  <p>If you want to compile for both Scala 2.10.x and 2.11.x, use <code>+ package</code> instead of just <code>package</code>.</p> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/mcamou/scuby#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>USAGE</h2> 
  <p>At this point the Scala -&gt; Ruby part is partly done, while the Ruby -&gt; Scala part is still in the planning stages, although it's become less necessary with the JRuby changes in 1.6.x and the other projects mentioned in the <em>RELATED PROJECTS</em> section. Here are some examples of the things you can do today. Assume you have the following Ruby code in a file called <code>test.rb</code> somewhere in your CLASSPATH (this file is part of the Scuby unit tests and can be found in <code>src/test/resources/test.rb</code>). As features are added this example might become outdated (as in, there are more things you can do than shown here). Look at the tests to check out the latest capabilities:</p> 
  <div class="highlight highlight-source-ruby">
   <pre><span class="pl-k">module</span> <span class="pl-en">Core</span>
  <span class="pl-k">class</span> <span class="pl-en">Person</span>
    <span class="pl-k">attr_accessor</span> <span class="pl-c1">:firstname</span>, <span class="pl-c1">:lastname</span>
    <span class="pl-k">def</span> <span class="pl-en">initialize</span> (<span class="pl-smi">firstname</span>, <span class="pl-smi">lastname</span>)
      <span class="pl-smi">@firstname</span> <span class="pl-k">=</span> firstname
      <span class="pl-smi">@lastname</span> <span class="pl-k">=</span> lastname
   <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">fullname</span>
      <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pse">#{</span><span class="pl-s1">firstname</span><span class="pl-pse"><span class="pl-s1">}</span></span> <span class="pl-pse">#{</span><span class="pl-s1">lastname</span><span class="pl-pse"><span class="pl-s1">}</span></span><span class="pl-pds">"</span></span>
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">get_label</span>
      javax.swing.<span class="pl-c1">JLabel</span>.<span class="pl-k">new</span>(fullname)
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">length</span>
      fullname.length
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>

  <span class="pl-k">module</span> <span class="pl-en">BackEnd</span>
   <span class="pl-k">def</span> <span class="pl-en">self.get_people</span>
      <span class="pl-c"># Get data from the backend and return an Array of Person</span>
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">self.get_data</span>
      { <span class="pl-c1">:people</span> =&gt; get_people, <span class="pl-c1">:other_data</span> =&gt; get_other_data }
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">self.get_person</span>(<span class="pl-smi">name</span>)
      <span class="pl-c"># Get a person's data from the backend and return a Person object</span>
    <span class="pl-k">end</span>

    <span class="pl-k">def</span> <span class="pl-en">self.get_other_data</span>
      <span class="pl-c"># Get some other data that is needed for the app</span>
    <span class="pl-k">end</span>
  <span class="pl-k">end</span>
<span class="pl-k">end</span></pre>
  </div> 
  <p>Here are some examples using Scuby:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.tecnoguru.scuby.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">JRuby.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> {
  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> { 
    <span class="pl-c">// Require a Ruby file from the classpath</span>
    require(<span class="pl-s"><span class="pl-pds">"</span>example<span class="pl-pds">"</span></span>) 

    <span class="pl-c">// Eval a Ruby statement discarding the return value</span>
    evalIgnore(<span class="pl-s"><span class="pl-pds">"</span>import Core<span class="pl-pds">"</span></span>)

    <span class="pl-c">// Eval a Ruby statement that returns a Ruby object</span>
    <span class="pl-k">val</span> <span class="pl-en">array</span> <span class="pl-k">=</span> evalRuby(<span class="pl-s"><span class="pl-pds">"</span>[]<span class="pl-pds">"</span></span>)

    <span class="pl-c">// or that returns a Scala/Java object or primitive</span>
    <span class="pl-k">val</span> <span class="pl-en">array2</span> <span class="pl-k">=</span> eval[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"</span>[1, 2, 3].length<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">array2</span><span class="pl-k">:</span> <span class="pl-k">Int</span> <span class="pl-k">=</span> eval(<span class="pl-s"><span class="pl-pds">"</span>[1, 2, 3].length<span class="pl-pds">"</span></span>)

    <span class="pl-c">// Create a Ruby object</span>
    <span class="pl-k">val</span> <span class="pl-en">array3</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RubyObject</span>(<span class="pl-en">'Array</span>)

    <span class="pl-c">// Easily call is_a? and respond_to?</span>
    array3 isA_<span class="pl-k">?</span> <span class="pl-en">'Array</span> <span class="pl-c">// true</span>
    array3 isA_<span class="pl-k">?</span> <span class="pl-en">'Hash</span>  <span class="pl-c">// false</span>

    array3 respondTo_<span class="pl-k">?</span> <span class="pl-en">'length</span> <span class="pl-c">// true</span>
    array3 respondTo_<span class="pl-k">?</span> <span class="pl-en">'foo</span>    <span class="pl-c">//false</span>

    <span class="pl-c">// Create a proxy object for the Ruby BackEnd module</span>
    <span class="pl-k">val</span> <span class="pl-en">backEnd</span> <span class="pl-k">=</span> <span class="pl-en">RubyModule</span>(<span class="pl-en">'BackEnd</span>)

    <span class="pl-c">// Create an instance of the Person class</span>
    <span class="pl-k">val</span> <span class="pl-en">person</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RubyObject</span>(<span class="pl-en">'Person</span>, <span class="pl-s"><span class="pl-pds">"</span>Zaphod<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Beeblebrox<span class="pl-pds">"</span></span>)
    <span class="pl-k">val</span> <span class="pl-en">person2</span> <span class="pl-k">=</span> <span class="pl-en">RubyClass</span>(<span class="pl-en">'Person</span>) <span class="pl-k">!</span> (<span class="pl-en">'new</span>, <span class="pl-s"><span class="pl-pds">"</span>Ford<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Prefect<span class="pl-pds">"</span></span>)

    <span class="pl-c">// Call a method on a Ruby object (in this case, the Ruby module),</span>
    <span class="pl-c">// passing in parameters, and get back another Ruby object</span>
    <span class="pl-k">val</span> <span class="pl-en">zaphod</span> <span class="pl-k">=</span> backEnd <span class="pl-k">!</span> (<span class="pl-en">'get_person</span>, <span class="pl-s"><span class="pl-pds">"</span>Zaphod<span class="pl-pds">"</span></span>)

    <span class="pl-c">// JRuby automatically converts between Java primitives/Strings and some Ruby classes. This can sometimes be a</span>
    <span class="pl-c">// problem. For those cases you have to use the send[T] method with the expected type. See</span>
    <span class="pl-c">// https://github.com/jruby/jruby/wiki/CallingJavaFromJRuby for more info.</span>
    <span class="pl-k">val</span> <span class="pl-en">name</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> zaphod.send[<span class="pl-k">String</span>](<span class="pl-en">'fullname</span>)
    <span class="pl-k">val</span> <span class="pl-en">length</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> zaphod.send[<span class="pl-k">Long</span>](<span class="pl-en">'length</span>)

    <span class="pl-c">// Call a Ruby method with no parameters</span>
    <span class="pl-k">val</span> <span class="pl-en">data</span> <span class="pl-k">=</span> backEnd <span class="pl-k">!</span> <span class="pl-en">'get_data</span>

    <span class="pl-c">// Ruby method chaining</span>
    <span class="pl-k">val</span> <span class="pl-en">length</span> <span class="pl-k">=</span> backEnd <span class="pl-k">!</span> <span class="pl-en">'get_people</span> <span class="pl-k">!</span> <span class="pl-en">'length</span>

    <span class="pl-c">// Access to a Ruby hash or array (i.e., something that implements the</span>
    <span class="pl-c">// [] method]). Returns an AnyRef (i.e. a java.lang.Object). Also, creating</span>
    <span class="pl-c">// a Ruby Symbol using %</span>
    <span class="pl-k">val</span> <span class="pl-en">people</span> <span class="pl-k">=</span> data(<span class="pl-k">%</span>(<span class="pl-en">'people</span>))
    <span class="pl-k">val</span> <span class="pl-en">zaphod2</span> <span class="pl-k">=</span> people(<span class="pl-c1">0</span>)

    <span class="pl-c">// Multidimensional hashes or arrays (i.e., data["parm1"]["parm2"])</span>
    <span class="pl-k">val</span> <span class="pl-en">ford</span> <span class="pl-k">=</span> data(<span class="pl-k">%</span>(<span class="pl-en">'people</span>), <span class="pl-c1">1</span>)

    <span class="pl-c">// Modify/add an element to a Collection (or anything that implements []=)</span>
    people(<span class="pl-c1">2</span>) <span class="pl-k">=</span> <span class="pl-en">RubyClass</span>(<span class="pl-en">'Person</span>) <span class="pl-k">!</span> (<span class="pl-en">'new</span>, <span class="pl-s"><span class="pl-pds">"</span>Arthur<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Dent<span class="pl-pds">"</span></span>)

    <span class="pl-c">// Call a Ruby method which returns a Java object, in a type-safe way</span>
    <span class="pl-k">val</span> <span class="pl-en">label</span> <span class="pl-k">=</span> person.send[<span class="pl-en">JLabel</span>](<span class="pl-en">'get_label</span>)

    <span class="pl-c">// This is one way of chaining method calls that include array access. This</span>
    <span class="pl-c">// is kind of ugly but necessary because of the strong typing, since</span>
    <span class="pl-c">// Array/Hash access returns an AnyRef.</span>
    <span class="pl-c">// Ruby equivalent:</span>
    <span class="pl-c">// label = backEnd.get_data.get_people[:people][0].get_label</span>
    <span class="pl-c">// contents = form.components[:startables].widget.peer  # Returns a JComponent</span>
    <span class="pl-k">val</span> <span class="pl-en">label</span> <span class="pl-k">=</span> (backEnd <span class="pl-k">!</span> <span class="pl-en">'get_data</span> <span class="pl-k">!</span> (<span class="pl-c1">'<span class="pl-ii">[], %(</span>'</span>people)) <span class="pl-k">!</span> (<span class="pl-c1">'<span class="pl-ii">[], 0)).send[JLabel](</span>'</span>get_label)
    <span class="pl-c">// OR</span>
    <span class="pl-k">val</span> <span class="pl-en">zaphod3</span> <span class="pl-k">=</span> (backEnd <span class="pl-k">!</span> <span class="pl-en">'get_data</span>(<span class="pl-k">%</span><span class="pl-en">'people</span>, <span class="pl-c1">0</span>)).<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">RubyObj</span>]
    <span class="pl-k">val</span> <span class="pl-en">label</span> <span class="pl-k">=</span> zaphod3.get_label

    <span class="pl-c">// You can also use the as[T] method to wrap a RubyObj with a</span>
    <span class="pl-c">// dynamically-generated proxy for a trait, to get all the statically-typed</span>
    <span class="pl-c">// goodness on the Scala side. The proxy also takes care of the CamelCase to</span>
    <span class="pl-c">// snake_case conversion. I have tested the basic calls and case conversion,</span>
    <span class="pl-c">// plus the attribute assignments. More testing is needed to make sure</span>
    <span class="pl-c">// there are no more edge cases</span>
    <span class="pl-k">trait</span> <span class="pl-en">Person</span> {
      <span class="pl-k">def</span> <span class="pl-en">firstname</span><span class="pl-k">:</span> <span class="pl-k">String</span>
      <span class="pl-k">def</span> <span class="pl-en">firstname_=</span>(<span class="pl-v">f</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>
      <span class="pl-k">def</span> <span class="pl-en">lastname</span><span class="pl-k">:</span> <span class="pl-k">String</span>
      <span class="pl-k">def</span> <span class="pl-en">lastname_=</span>(<span class="pl-v">l</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>
      <span class="pl-k">def</span> <span class="pl-en">fullname</span><span class="pl-k">:</span> <span class="pl-k">String</span>
      <span class="pl-k">def</span> <span class="pl-en">getLabel</span><span class="pl-k">:</span> <span class="pl-en">JLabel</span>
    }

    <span class="pl-k">val</span> <span class="pl-en">zaphod</span><span class="pl-k">:</span><span class="pl-en">Person</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RubyObject</span>(<span class="pl-en">'Person</span>, <span class="pl-s"><span class="pl-pds">"</span>Zaphod<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Beeblebrox<span class="pl-pds">"</span></span>).as[<span class="pl-en">Person</span>]
    zaphod.firstname <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>The Zeeb<span class="pl-pds">"</span></span>
    println(zaphod.fullname)
    <span class="pl-k">val</span> <span class="pl-en">label</span> <span class="pl-k">=</span> zaphod.getLabel
 }
}</pre>
  </div> 
  <p>This is the gist of it. Basically we can create Ruby objects, call methods on them and evaluate Ruby code. Scuby has its own <code>RubyObj</code> class that wraps a JRuby <code>RubyObject</code> and does its magic. It also has its own <code>RubyClass</code> and <code>RubyModule</code> classes that represent respectively a Ruby class and a Ruby module.</p> 
  <h2><a id="user-content-related-projects" class="anchor" href="https://github.com/mcamou/scuby#related-projects" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>RELATED PROJECTS</h2> 
  <p><a href="http://rubygems.org/gems/jruby-scala" target="_blank">jruby-scala</a>: Allows you to use Ruby Procs as Scala functions, including Scala traits into Ruby modules, and more.</p> 
  <p><a href="https://github.com/RubyAndScala/jruby-scala-collections" target="_blank">jruby-scala-collections</a>: Eases the pain of passing JRuby and Scala collections back and forth</p> 
  <h2><a id="user-content-next-steps-and-ideas" class="anchor" href="https://github.com/mcamou/scuby#next-steps-and-ideas" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>NEXT STEPS AND IDEAS</h2> 
  <p>On the Scala side</p> 
  <ul> 
   <li><p>Use typeclasses to remove all the explicit wrapping of org.jruby.RubyObject's into com.tecnoguru.scuby.RubyObj's</p></li> 
   <li><p>Transparently wrap Ruby collections in Scala collections, so you can use them with <code>foreach</code>, <code>for</code>, <code>map</code>, <code>foldLeft</code>, <code>foldRight</code>, etc... (see <a href="https://github.com/arturaz/jruby-scala-collections" target="_blank">jruby-scala-collections</a>)</p></li> 
   <li><p>Create traits that mimic the standard Ruby object hierarchy, at least for Object, Class and Module, and either allow the traits passed in to as[T] to wrap them, or automatically extend the traits depending on the Ruby object's type</p></li> 
   <li><p>Create a Java-friendly API so Scuby can be more-easily used from Java or other JVM languages</p></li> 
   <li><p>Optimization. There are probably a lot of things that can be optimized by calling the internal JRuby APIs</p></li> 
   <li><p>More test cases for <code>as[T]</code> and perhaps simplify the implementation</p></li> 
   <li><p>More testing in general</p></li> 
  </ul> 
  <p>On the JRuby side (although lots of it is handled automatically by JRuby).</p> 
  <ul> 
   <li><p>Create a gem for loading into JRuby (See <a href="http://rubygems.org/gems/jruby-scala" target="_blank">jruby-scala</a> and <a href="https://github.com/RubyAndScala/jruby-scala-collections" target="_blank">jruby-scala-collections</a>)</p></li> 
   <li><p>FunctionN -&gt; block conversion, so you could pass in a Scala function to any Ruby method that expects a block. (See <a href="http://rubygems.org/gems/jruby-scala" target="_blank">jruby-scala</a>)</p></li> 
   <li><p>Wrapping the Scala collections with their Ruby/JRuby/Java equivalents. (See <a href="https://github.com/RubyAndScala/jruby-scala-collections" target="_blank">jruby-scala-collections</a>)</p></li> 
   <li><p>Add an <code>Object#to_scala</code> method which wraps the Ruby Object in a Scuby <code>RubyObj</code>. Ideally the wrapping should be done automatically but I'm not totally sure if that's possible. This will probably not be necessary once I correctly use typeclasses.</p></li> 
   <li><p>Create a scala top-level function, so you can do, i.e., <code>scala.mutable.List</code> instead of <code>Java::ScalaMutable::List</code></p></li> 
  </ul> 
  <h2><a id="user-content-collaborating" class="anchor" href="https://github.com/mcamou/scuby#collaborating" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>COLLABORATING</h2> 
  <p>As usual on GitHub: fork, pull, modify, <em>create tests</em>, commit, push, pull request. You can also find me on Twitter as <a href="https://twitter.com/thedoc" target="_blank">@thedoc</a></p> 
  <h2><a id="user-content-thanks" class="anchor" href="https://github.com/mcamou/scuby#thanks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>THANKS</h2> 
  <p>Thanks to eirslett for the cross-compilation instructions and pull request!</p> 
 </article>
</div>