<div class="announce instapaper_body rst" data-path="README.rst" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p>This Scala library is convenient for creating network server and client, useful for quickly writing server and client tests. This library doesn't try to be robust. If you want long running robust server or client, you should try other things.</p> 
  <p>This library is small, the only dependency is <a href="http://netty.io/" target="_blank">Netty</a>.</p> 
  <a name="user-content-features" target="_blank" href=""></a> 
  <h2><a id="user-content-features" class="anchor" href="https://github.com/ngocdaothanh/netcaty#features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <p>HTTP:</p> 
  <ul> 
   <li>Server. Server can start at random open port, very useful for tests. It also automatically handles "Expect 100 Continue" requests.</li> 
   <li>Client.</li> 
   <li>Can handle chunks up to 16 MB.</li> 
   <li>HTTPS.</li> 
  </ul> 
  <p>TCP:</p> 
  <ul> 
   <li>Server.</li> 
   <li>Client.</li> 
  </ul> 
  <a name="user-content-be-familiar-with-netty" target="_blank" href=""></a> 
  <h2><a id="user-content-be-familiar-with-netty" class="anchor" href="https://github.com/ngocdaothanh/netcaty#be-familiar-with-netty" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Be familiar with Netty</h2> 
  <p><a href="http://ngocdaothanh.github.io/netcaty/#netcaty.http.package" target="_blank">Netcaty Scaladoc</a></p> 
  <p>To create and inspect requests/responses, you should be familiar with things in package <a href="http://netty.io/4.0/api/io/netty/handler/codec/http/package-frame.html" target="_blank">io.netty.handler.codec.http</a> and <a href="http://netty.io/4.0/api/io/netty/buffer/package-frame.html" target="_blank">io.netty.buffer</a> in <a href="http://netty.io/4.0/api/index.html" target="_blank">Netty Javadoc</a>.</p> 
  <p><code>req</code> and <code>res</code> in the examples below are:</p> 
  <ul> 
   <li><code>req</code>: <a href="http://netty.io/4.0/api/io/netty/handler/codec/http/FullHttpRequest.html" target="_blank">FullHttpRequest</a></li> 
   <li><code>res</code>: <a href="http://netty.io/4.0/api/io/netty/handler/codec/http/FullHttpResponse.html" target="_blank">FullHttpResponse</a></li> 
  </ul> 
  <a name="user-content-http-server" target="_blank" href=""></a> 
  <h2><a id="user-content-http-server" class="anchor" href="https://github.com/ngocdaothanh/netcaty#http-server" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>HTTP server</h2> 
  <p>Start server at port 9000:</p> 
  <pre>netcaty.Http.respondOne(9000, { case (req, res) =&gt;
  // res is an empty 200 OK response.
  // Modify it to respond what you want.
})
</pre> 
  <p><code>respondOnce</code> returns after the port has been bounded so you don't need to manually call <code>Thread.sleep(someTime)</code> to wait for the server to be started. The server runs on a separate thread. It sends only one response and after that stops immediately.</p> 
  <p>If you don't want to stop the server after one response:</p> 
  <pre>val server = netcaty.Http.respond(9000, { case (req, res) =&gt;
  // res is an empty 200 OK response.
  // Modify it to respond what you want.
})

// Later:
server.stop()
</pre> 
  <p>Port 0 means Netcaty will start server at a random open port. This is very useful for writing tests. To get the real port, call <code>server.getPort</code>.</p> 
  <a name="user-content-http-client" target="_blank" href=""></a> 
  <h2><a id="user-content-http-client" class="anchor" href="https://github.com/ngocdaothanh/netcaty#http-client" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>HTTP client</h2> 
  <p>Sync mode:</p> 
  <pre>// Create a FullHttpRequest
import io.netty.handler.codec.http.{DefaultFullHttpRequest, HttpMethod, HttpVersion}
val req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/path")

// req will be automatically released
val res = netcaty.Http.request("localhost", 9000, req)

// Use res
...

// Must manually release after using
res.release()
</pre> 
  <p>Async mode:</p> 
  <pre>// Create a FullHttpRequest
import io.netty.handler.codec.http.{DefaultFullHttpRequest, HttpMethod, HttpVersion}
val req = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, "/path")

// req and res will be automatically released
netcaty.Http.request("localhost", 9000, req, { res =&gt;
  ...
})
</pre> 
  <a name="user-content-tcp-server" target="_blank" href=""></a> 
  <h2><a id="user-content-tcp-server" class="anchor" href="https://github.com/ngocdaothanh/netcaty#tcp-server" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>TCP server</h2> 
  <p>You must know beforehand the length of the request. In a controlled environment like tests, that's not a big drawback.</p> 
  <p>To listen on port 9000, receive exactly 123 bytes, then respond:</p> 
  <pre>netcaty.Tcp.respondOne(9000, 123, { requestBytes =&gt;
  // Return bytes to respond
  "Hello World".getBytes
})
</pre> 
  <pre>val server = netcaty.Http.respond(9000, 123, { requestBytes =&gt;
  // Return bytes to respond
  "Hello World".getBytes
})

// Later:
server.stop()
</pre> 
  <a name="user-content-tcp-client" target="_blank" href=""></a> 
  <h2><a id="user-content-tcp-client" class="anchor" href="https://github.com/ngocdaothanh/netcaty#tcp-client" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>TCP client</h2> 
  <p>You must know beforehand the length of the response. In a controlled environment like tests, that's not a big drawback.</p> 
  <p>Sync mode:</p> 
  <pre>val responseBytes = netcaty.Tcp.request("localhost", 9000, requestBytes)
</pre> 
  <p>Async mode:</p> 
  <pre>netcaty.Tcp.request("localhost", 9000, requestBytes, { responseBytes =&gt;
  ...
})
</pre> 
  <a name="user-content-https-and-tcp-over-ssl" target="_blank" href=""></a> 
  <h2><a id="user-content-https-and-tcp-over-ssl" class="anchor" href="https://github.com/ngocdaothanh/netcaty#https-and-tcp-over-ssl" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>HTTPS and TCP over SSL</h2> 
  <p>In the above examples, just replace <code>netcaty.Http</code> and <code>netcaty.Tcp</code> with <code>netcaty.Https</code> and <code>netcaty.Tcps</code>.</p> 
  <ul> 
   <li>Server: uses dummy certificate.</li> 
   <li>Client: acepts all certificates.</li> 
  </ul> 
  <a name="user-content-use-with-sbt" target="_blank" href=""></a> 
  <h2><a id="user-content-use-with-sbt" class="anchor" href="https://github.com/ngocdaothanh/netcaty#use-with-sbt" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Use with SBT</h2> 
  <p>Supported Scala versions: 2.10.x, 2.11.x</p> 
  <pre>libraryDependencies += "tv.cntt" % "netcaty" %% "1.4"
</pre> 
  <p>Netcaty uses Netty 4. Javassist can boost Netty 4 speed. Optionally, you can add:</p> 
  <pre>libraryDependencies += "org.javassist" % "javassist" % "3.18.2-GA"
</pre> 
  <a name="user-content-netcat" target="_blank" href=""></a> 
  <h2><a id="user-content-netcat" class="anchor" href="https://github.com/ngocdaothanh/netcaty#netcat" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Netcat</h2> 
  <p>For more simple problems, maybe you don't need to use additionaly library. You can use <a href="http://en.wikipedia.org/wiki/Netcat" target="_blank">Netcat</a>, like this:</p> 
  <pre>import scala.sys.process._

object Http {
  def async(fun: =&gt; Unit) {
    val t = new Thread(new Runnable { def run { fun } })
    t.start()
  }

  //----------------------------------------------------------------------------

  def serveRaw(port: Int, lines: Seq[String]) {
    val raw = lines.mkString("\r\n")
    (Seq("echo", "-n", raw) #| Seq("sh", "-c", "nc -l " + port)).!
  }

  def serveContent(port: Int, contentType: String, content: String) {
    val contentLength = content.getBytes.length
    serveRaw(port, Seq(
      "HTTP/1.1 200 OK",
      s"Content-Type: $contentType",
      s"Content-Length: $contentLength",
      "",
      content
    ))
  }

  def asyncServeRaw(port: Int, lines: Seq[String]) {
    async { serveRaw(port, lines) }
  }

  def asyncServeContent(port: Int, contentType: String, content: String) {
    async { serveContent(port, contentType, content) }
  }

  //----------------------------------------------------------------------------

  def requestRaw(host: String, port: Int, lines: Seq[String]): String = {
    val raw = lines.mkString("", "\r\n", "\r\n\r\n")
    // "-i 1" delays 1s, slowering the tests.
    // But without it the result will be empty.
    (Seq("echo", "-n", raw) #| s"nc -i 1 $host $port").!!
  }

  def get(host: String, port: Int, path: String): String = {
    requestRaw(host, port, Seq(
      s"GET $path HTTP/1.1",
      s"Host: $host:$port"
    ))
  }
}
</pre> 
 </article>
</div>