<div class="announce instapaper_body markdown" data-path="README.markdown" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-rojoma-json" class="anchor" href="https://github.com/rjmac/rojoma-json#rojoma-json" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>rojoma-json</h1> 
  <h2><a id="user-content-getting-it" class="anchor" href="https://github.com/rjmac/rojoma-json#getting-it" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting it</h2> 
  <p>Starting with version 2.0.0, rojoma-json is published on Maven central, so setting up SBT is as simple as</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.rojoma<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>rojoma-json-v3<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>3.7.2<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>While for Maven, the pom snippet is:</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependencies</span>&gt;
  &lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;com.rojoma&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;rojoma-json-v3_${scala.version}&lt;/<span class="pl-ent">artifactId</span>&gt;
    &lt;<span class="pl-ent">version</span>&gt;3.7.2&lt;/<span class="pl-ent">version</span>&gt;
  &lt;/<span class="pl-ent">dependency</span>&gt;
&lt;/<span class="pl-ent">dependencies</span>&gt;</pre>
  </div> 
  <p>rojoma-json-v3 is published for Scala version 2.10, 2.11, and 2.12.</p> 
  <h2><a id="user-content-documentation" class="anchor" href="https://github.com/rjmac/rojoma-json#documentation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Documentation</h2> 
  <h3><a id="user-content-package-comrojomajsonv3ast" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3ast" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.ast</h3> 
  <ul> 
   <li><code>JValue</code>: An AST for JSON 
    <ul> 
     <li><code>JAtom</code> 
      <ul> 
       <li><code>JNull</code></li> 
       <li><code>JBoolean(boolean: Boolean)</code></li> 
       <li><code>JString(string: String)</code></li> 
       <li><code>JNumber</code></li> 
      </ul> </li> 
     <li><code>JCompound</code> 
      <ul> 
       <li><code>JArray(toSeq: scala.collection.Seq[JValue])</code></li> 
       <li><code>JObject(fields: scala.collection.Map[String, JValue])</code></li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
  <p>The <code>JCompound</code> classes extend <code>Iterable</code> and have convenience methods that make them act like <code>Seq</code> and <code>Map</code> respectively, but are not themselves actually <code>Seq</code>s or <code>Map</code>s. Use the <code>toSeq</code>, or <code>fields</code> or <code>toMap</code>, method to get a real one.</p> 
  <p><code>JNumber</code> is not a case class; it is an abstract class whose implementation varies depending on how it was constructed. Use the various <code>toX</code> methods to access its value.</p> 
  <p>All <code>JValue</code>s have a <code>cast[T]</code> method that can be used to safely downcast to a more specific type.</p> 
  <p>There is also support for "dynamically typed" access to JValues:</p> 
  <div class="highlight highlight-source-scala">
   <pre>someJValue <span class="pl-k">=</span> j<span class="pl-s"><span class="pl-pds">"</span>{outer : {inner : [0,1,2,3]}}<span class="pl-pds">"</span></span>
someJValue.dyn.outer.inner(<span class="pl-c1">2</span>).<span class="pl-k">?</span>             <span class="pl-c"><span class="pl-c">//</span> returns Right(JNumber(2))</span>
someJValue.dyn.outer(<span class="pl-s"><span class="pl-pds">"</span>inner<span class="pl-pds">"</span></span>)(<span class="pl-c1">2</span>).<span class="pl-k">?</span>          <span class="pl-c"><span class="pl-c">//</span> returns Right(JNumber(2))</span>
someJValue.dyn.outer.inner(<span class="pl-c1">2</span>).<span class="pl-k">!</span>             <span class="pl-c"><span class="pl-c">//</span> returns JNumber(2)</span>
someJValue.dyn.outer.nonexistant.inner(<span class="pl-c1">2</span>).<span class="pl-k">?</span> <span class="pl-c"><span class="pl-c">//</span> returns Left(DecodeError.MissingField("nonexistant", .outer))</span>
someJValue.dyn.outer.nonexistant.inner(<span class="pl-c1">2</span>).<span class="pl-k">!</span> <span class="pl-c"><span class="pl-c">//</span> throws a NoSuchElementException</span></pre>
  </div> 
  <p>This is implemented via scala's <code>Dynamic</code> trait; as a result, <code>applyDynamic</code>, <code>selectDynamic</code>, and <code>apply</code>, plus the methods on <code>Object</code>, will resolve to real methods instead of path elements.</p> 
  <h3><a id="user-content-package-comrojomajsonv3codec" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3codec" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.codec</h3> 
  <ul> 
   <li><code>JsonEncode[T]</code>: a typeclass for converting objects to <code>JValue</code>s</li> 
   <li><code>JsonDecode[T]</code>: a typeclass for converting objects from <code>JValue</code>s</li> 
   <li><code>FieldEncode[T]</code>: a typeclass for converting objects to object keys</li> 
   <li><code>FieldDecode[T]</code>: a typeclass for converting objects from object keys</li> 
  </ul> 
  <p>Encoding is assumed to always succeed; decoding can fail, returning a <code>DecodeError</code> containing the cause of the failure and the path at which the failure happened.</p> 
  <p>The following types have implicit codecs in <code>JsonEncode</code>'s and <code>JsonDecode</code>'s companions:</p> 
  <ul> 
   <li><code>String</code></li> 
   <li><code>Boolean</code></li> 
   <li>Numeric types, including <code>BigInt</code>, <code>BigDecimal</code>, and their <code>java.math</code> counterparts</li> 
   <li><code>JValue</code> and all its subclasses</li> 
   <li>Any <code>S[T] &lt;: Seq[T]</code> if <code>T</code> has a <code>JsonCodec</code> and <code>S</code> has an implicit <code>CanBuild</code></li> 
   <li>Any <code>S[T] &lt;: Set[T]</code> if <code>T</code> has a <code>JsonCodec</code> and <code>S</code> has an implicit <code>CanBuild</code></li> 
   <li>Any <code>M[T, U] &lt;: Map[T,U]</code> if <code>T</code> has a <code>FieldCodec</code>, <code>U</code> has a <code>JsonCodec</code> and <code>M</code> has an implicit <code>CanBuild</code></li> 
   <li><code>Either</code> (biased on decoding to <code>Right</code>)</li> 
   <li><code>Unit</code></li> 
   <li>Tuples up to <code>Tuple22</code></li> 
   <li><code>java.util.List[T]</code> if <code>T</code> has a <code>JsonCodec</code></li> 
   <li><code>java.util.Set[T]</code> if <code>T</code> has a <code>JsonCodec</code></li> 
   <li><code>java.util.Map[T, U]</code> if <code>T</code> has a <code>FieldCodec</code> and <code>U</code> has a <code>JsonCodec</code></li> 
   <li>Java enumerations</li> 
   <li><code>java.util.UUID</code></li> 
   <li><code>java.net.URL</code></li> 
  </ul> 
  <p>The "atomic" ones (<code>String</code>, <code>Boolean</code>, numbers, enums, <code>UUID</code>, and <code>URL</code>) also have field codecs in <code>FieldEncode</code> and <code>FieldDecode</code>.</p> 
  <p>Numeric codecs are "lenient" -- that is, if a number is out of range of the requested type, it undergoes the normal truncation <code>BigDecimal.toXXX</code> does. If this is not desired, request a <code>BigDecimal</code> and use the <code>.toXXXExact</code> alternatives.</p> 
  <p>In addition to the implicit codecs, Scala <code>Enumeration</code>s can have codecs automatically generated for them via the non-implicit methods <code>JsonEncode.scalaEnumEncode</code> and <code>JsonDecode.scalaEnumDecode</code> (or the convenience <code>JsonCodec.scalaEnumCodec</code> which defines both). These methods all take the enumeration's container object as a parameter.</p> 
  <p>The codecs' companion objects themselves can be used as values that represent the result of an implicit search. That is:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">JsonEncode</span>[<span class="pl-en">T</span>] <span class="pl-k">===</span> implicitly[<span class="pl-en">JsonEncode</span>[<span class="pl-en">T</span>]]
<span class="pl-en">JsonDecode</span>[<span class="pl-en">T</span>] <span class="pl-k">===</span> implicitly[<span class="pl-en">JsonDecode</span>[<span class="pl-en">T</span>]]
<span class="pl-en">FieldEncode</span>[<span class="pl-en">T</span>] <span class="pl-k">===</span> implicitly[<span class="pl-en">FieldEncode</span>[<span class="pl-en">T</span>]]
<span class="pl-en">FieldDecode</span>[<span class="pl-en">T</span>] <span class="pl-k">===</span> implicitly[<span class="pl-en">FieldDecode</span>[<span class="pl-en">T</span>]]</pre>
  </div> 
  <p>Default <code>JsonEncode</code>s will be as lazy as possible. Modifying the object that was encoded before serializing the resulting <code>JValue</code> or calling <code>forced</code> on it has undefined behavior.</p> 
  <h3><a id="user-content-package-comrojomajsonv3io" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3io" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.io</h3> 
  <ul> 
   <li><code>JsonReader</code>: Convert character data to <code>JValues</code></li> 
   <li><code>JsonWriter</code>: Convert <code>JValues</code> to character data 
    <ul> 
     <li><code>CompactJsonWriter</code></li> 
     <li><code>PrettyJsonWriter</code></li> 
    </ul> </li> 
  </ul> 
  <p>The two concrete <code>JsonWriter</code> classes have <code>toWriter</code> and <code>toString</code> convenience methods on their companion objects. <code>JsonReader</code>, similarly, has <code>fromString</code> and <code>fromWriter</code>. Neither <code>JsonReader</code> nor the <code>JsonWriter</code>s make any effort to minimize the number of calls to <code>read()</code> or <code>write()</code> on the IO handle they're given, so it is probably a good idea to ensure that it is buffered.</p> 
  <p>As extensions to the JSON specification, <code>JsonReader</code> accepts the following:</p> 
  <ul> 
   <li>single-quote delimited strings</li> 
   <li>unquoted object keys</li> 
   <li>Javascript-style comments</li> 
  </ul> 
  <p>The only limits on the sizes of strings and depth of nesting are those of the JVM. Parsing is done recursively, and so stack space is the limiting factor in nesting. Numbers are restricted to those which can fit in a Java <code>BigDecimal</code>. The reader does validate surrogate pairs and will replace stray halves with the Unicode <code>REPLACEMENT_CHARACTER</code> character. <code>JsonReader</code> also guarantees to read exactly as much as necessary as to read a single <code>JValue</code> -- i.e., only to the closing delimiter for objects, arrays, and strings, and one character past for all other types of JSON datum.</p> 
  <p>Below the <code>JsonReader</code> level lives the <code>JsonEvent</code> level, which can be used to implement streamed processing. A <code>JsonReader</code> consumes an <code>Iterator[JsonEvent]</code>; that iterator can itself be either a <code>JsonEventIterator</code> (which consumes an <code>Iterator[JsonToken]</code>) or a <code>FusedBlockJsonEventIterator</code> (which reads character data directly). In the former case, <code>Iterator[JsonToken]</code> is provided by <code>JsonTokenIterator</code> and <code>BlockJsonTokenIterator</code>. Building on top of the non-<code>Block</code> versions will ensure, at a performance penalty, that no more is read from the underlying source of character data than is necessary to read a complete JSON datum; the <code>Block</code> variants are faster at the cost of reading more than that. If you do not specify, rojoma-json will always pick the non-<code>Block</code> versions when reading from <code>Reader</code>s.</p> 
  <h3><a id="user-content-package-comrojomajsonv3matcher" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3matcher" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.matcher</h3> 
  <ul> 
   <li><code>OptPattern</code>: The base class of all <code>Pattern</code>s, plus <code>POption</code> 
    <ul> 
     <li><code>Pattern</code>: A specification for extracting data from <code>JValue</code>s 
      <ul> 
       <li><code>Literal(x: JValue)</code>: match a literal value</li> 
       <li><code>FLiteral(f: JValue =&gt; Boolean)</code>: conditionally match a value</li> 
       <li><code>PArray(subpatterns: Pattern*)</code>: match an array containing values that match a series of patterns</li> 
       <li><code>PObject(subpatterns: (String, OptPattern)*)</code>: match an object containing fields that match patterns</li> 
       <li><code>FirstOf(subpatterns: Pattern*)</code>: try to match a series of patterns in turn</li> 
       <li><code>AllOf(subpatterns: OptPattern*)</code>: match a series of patterns in turn</li> 
       <li><code>Variable[T : JsonCodec]</code>: match a value of type <code>T</code></li> 
      </ul> </li> 
     <li><code>POption(subpattern: Pattern)</code>: Optionally match a pattern. Only valid in a <code>PObject</code> and <code>AllOf</code>.</li> 
    </ul> </li> 
  </ul> 
  <p>These are probably best understood with a simple example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">channel</span> <span class="pl-k">=</span> <span class="pl-en">Variable</span>[<span class="pl-k">String</span>]() <span class="pl-c"><span class="pl-c">//</span> Could be anything with a JsonCodec instance</span>
<span class="pl-k">val</span> <span class="pl-en">text</span> <span class="pl-k">=</span> <span class="pl-en">Variable</span>[<span class="pl-k">String</span>]()
<span class="pl-k">val</span> <span class="pl-en">ChatPattern</span> <span class="pl-k">=</span>
  <span class="pl-en">PObject</span>(<span class="pl-s"><span class="pl-pds">"</span>command<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>chat<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>to<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> channel,
          <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> text)
<span class="pl-k">val</span> <span class="pl-en">JoinPattern</span> <span class="pl-k">=</span>
  <span class="pl-en">PObject</span>(<span class="pl-s"><span class="pl-pds">"</span>command<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>join<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>channel<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> channel)
<span class="pl-k">val</span> <span class="pl-en">LeavePattern</span> <span class="pl-k">=</span>
  <span class="pl-en">PObject</span>(<span class="pl-s"><span class="pl-pds">"</span>command<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>leave<span class="pl-pds">"</span></span>,
          <span class="pl-s"><span class="pl-pds">"</span>channel<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> channel,
          <span class="pl-s"><span class="pl-pds">"</span>message<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">POption</span>(text))

<span class="pl-k">def</span> <span class="pl-en">process</span>(<span class="pl-v">message</span>: <span class="pl-en">JValue</span>) <span class="pl-k">=</span> message <span class="pl-k">match</span> {
  <span class="pl-k">case</span> <span class="pl-en">ChatPattern</span>(results) <span class="pl-k">=&gt;</span>
    sendText(channel(results), text(results))
  <span class="pl-k">case</span> <span class="pl-en">JoinPattern</span>(results) <span class="pl-k">=&gt;</span>
    joinChannel(channel(results))
  <span class="pl-k">case</span> <span class="pl-en">LeavePattern</span>(results) <span class="pl-k">=&gt;</span>
    departChannel(channel(results), text.get(results))
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span>
    error(<span class="pl-s"><span class="pl-pds">"</span>unknown command<span class="pl-pds">"</span></span>, message)
}

<span class="pl-k">def</span> <span class="pl-en">leaveChannel</span>(<span class="pl-v">channelName</span>: <span class="pl-k">String</span>, <span class="pl-v">message</span>: <span class="pl-en">Option</span>[<span class="pl-k">String</span>])<span class="pl-k">:</span> <span class="pl-en">JValue</span> <span class="pl-k">=</span>
  <span class="pl-en">LeavePattern</span>.generate(channel <span class="pl-k">:</span><span class="pl-k">=</span> channelName, text <span class="pl-k">:</span><span class="pl-k">=</span><span class="pl-k">?</span> message)</pre>
  </div> 
  <p><code>OptPattern</code>'s companion contains implicit conversions from various literal forms into <code>Pattern</code>s.</p> 
  <p>Information is extracted by means of <code>Variable</code> patterns. <code>Variable</code>s can be created with the <code>apply</code> method on the companion object. They are typed and will only succeed in matching if the value at their position is of the correct type. If a single <code>Variable</code> appears more than once in a <code>Pattern</code>, it is not an error, but all appearances must match the same value.</p> 
  <p>Any object with an implicit <code>JsonDecode</code> instance in scope can be automatically coerced to a literal <code>Pattern</code>. If there is also a <code>JsonEncode</code> instance, that pattern can be used as a generator.</p> 
  <p>The result of a match is an opaque object which can be given to a <code>Variable</code> to extract the data, either by applying the <code>Variable</code> like a function or calling its <code>get</code> method. <code>Variables</code> and <code>Pattern</code>s themselves are immutable.</p> 
  <p><code>PObject</code> will accepts multiple patterns for a single field; all must accept for the containing <code>PObject</code> to accept. If the target of a field is marked optional by wrapping it in a <code>POption</code>, it either must match the subpattern or not appear at all. To tolerate random unparsable data in a field, use FirstOf with a final branch that accepts anything.</p> 
  <p>In <code>AllOf</code>, if a field is marked with POption, the value under consideration is allowed to <em>not</em> match that particular subpattern. In this context, <code>POption(p)</code> is a shorthand for <code>FirstOf(p, Variable[JValue]())</code>.</p> 
  <p>Custom matchers can be defined by subclassing <code>Pattern</code> and implementing the method <code>evaluate(x: JValue, environment: Pattern.Results): Either[DecodeError, Pattern.Results]</code>.</p> 
  <p>Most <code>Pattern</code>s can also be used to generate JSON using the <code>generate</code> method, passing in a list of variable bindings in the form <code>variable := value</code> or, if the variable occurs in an "optional" position (i.e., inside a <code>POption</code> or <code>FirstOf</code>) <code>variable :=? optValue</code>, where <code>optValue</code> is an <code>Option</code>.</p> 
  <h3><a id="user-content-package-comrojomajsonv3zipper" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3zipper" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.zipper</h3> 
  <p>A zipper for navigating JSON. There are five interfaces:</p> 
  <ul> 
   <li><code>JsonZipper</code> 
    <ul> 
     <li><code>JAtomZipper</code></li> 
     <li><code>JArrayZipper</code></li> 
     <li><code>JObjectZipper</code></li> 
    </ul> </li> 
   <li><code>NothingZipper</code></li> 
  </ul> 
  <p>An array or object zipper may be acquired by calling <code>asArray</code> or <code>asObject</code> on a generic zipper.</p> 
  <p>Each of the first five allows you to move <code>up</code>, to the <code>top</code> of the object, or find the zipper's current <code>value</code>, <code>replace</code>, or <code>remove</code> it. In addition, the array and object zippers allow <code>replace</code>ing or <code>remove</code>ing child elements. All of the motion operators (except <code>top</code>) return <code>Option</code>s; suffix the operator with <code>_!</code> to make it return the value directly or throw a <code>NoSuchElementException</code> if the motion is impossible.</p> 
  <p>The <code>NothingZipper</code> is special -- it is what is returned from removing the current object. With a <code>NothingZipper</code> you can either put a new object in the hole it represents (via the <code>replace</code> method) or move <code>up</code> or to the <code>top</code>. Unlike the <code>JsonZipper</code> classes, when you have nothing <code>top</code> might not return anything, since it is possible that the root object is what was removed.</p> 
  <h3><a id="user-content-package-comrojomajsonv3jpath" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3jpath" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.jpath</h3> 
  <p>The <code>JPath</code> class is a simple wrapper over <code>JsonZipper</code>s for doing "xpath-style" queries on a <code>JValue</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Find the first name of all users that live in Tucson</span>
<span class="pl-k">new</span> <span class="pl-en">JPath</span>(myObject).down(<span class="pl-s"><span class="pl-pds">"</span>users<span class="pl-pds">"</span></span>).<span class="pl-k">*</span>.having(_.down(<span class="pl-s"><span class="pl-pds">"</span>city<span class="pl-pds">"</span></span>).where(_.here <span class="pl-k">==</span> <span class="pl-en">JString</span>(<span class="pl-s"><span class="pl-pds">"</span>Tucson<span class="pl-pds">"</span></span>))).down(<span class="pl-s"><span class="pl-pds">"</span>firstName<span class="pl-pds">"</span></span>).finish</pre>
  </div> 
  <p>The result is a <code>Stream[JValue]</code>. Currently <code>JPath</code> is a read-only interface.</p> 
  <h3><a id="user-content-package-comrojomajsonv3util" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3util" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.util</h3> 
  <p>Utility operations that combine parts from other packages. The main member of this package is the object <code>JsonUtil</code> which contains convenience methods for moving data all the way between character data and usable objects.</p> 
  <p>The package includes helpers for building <code>JsonEncode</code> and <code>JsonDecode</code> instances. For single classes, there is the macro-based <code>AutomaticJsonCodecBuilder</code> (also <code>AutomaticJsonEncodeBuilder</code> and <code>AutomaticJsonDecodeBuilder</code> for unidirectional conversion) which can produce instances for case-like classes automatically. There is also the older <code>SimpleJsonCodecBuilder</code> (with encode and decode variants) that requires the programmer to say how to (de)construct objects. They are very straightforward to use:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">a</span>: <span class="pl-k">Int</span>, <span class="pl-v">b</span>: <span class="pl-en">Option</span>[<span class="pl-k">String</span>])
<span class="pl-k">object</span> <span class="pl-en">Foo</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">jCodec</span> <span class="pl-k">=</span> <span class="pl-en">AutomaticJsonCodecBuilder</span>[<span class="pl-en">Foo</span>]
  <span class="pl-c"><span class="pl-c">//</span> alternately: SimpleJsonCodecBuilder[Foo].build("a", _.a, "b", _.b)</span>
}</pre>
  </div> 
  <p>These can be used to build codecs for any classes which have accessors that match up to their constructor parameters. For the <code>Simple</code> case, the names and accessors must be provided in the same order the constructor takes them, or you will either get an exception when <code>build</code> is called (because it can't find the right constructor) or you'll get a <code>JsonCodec</code> that doesn't roundtrip properly (if the types of the accessors just happen to line up with the types of the constructor parameters). The types of the values to be serialized must either have <code>JsonCodec</code>s themselves, or be <code>Option</code>s wrapping around such types. <code>build</code> comes in variants that will handle up to 22 fields.</p> 
  <p>The generation for the <code>Automatic</code> builders can be affected by placing annotations (also defined in the <code>util</code> package) on the subject class's constructor's parameters. The annotations are:</p> 
  <ul> 
   <li><code>@JsonKey("string literal")</code> which overrides automatic selection of the field's name in the generated JSON.</li> 
   <li><code>@NullForNone</code> which causes the field to generate a <code>null</code> if it is an empty <code>Option</code>. Ordinarily empty <code>Option</code>s are simply omitted from generation altogether.</li> 
   <li><code>@LazyCodec</code> which causes the codec for the field to be resolved lazily. It is ordinarily not necessary, but can be used to stop stack overflows or <code>NullPointerException</code>s building codecs for recursive data structures.</li> 
   <li><code>@JsonKeyStrategy(strategy)</code> to override the subject class's default key generation strategy.</li> 
  </ul> 
  <p>The two defined strategies are <code>Strategy.Identity</code> (the default) and <code>Strategy.Underscore</code> (which converts camel-case names to lower-case, underscore-separated names). The <code>@JsonKeyStrategy</code> and <code>@NullForNone</code> annotations can also be used on the class level to set the default strategy for all fields. If two names map to the same JSON identifier (whether automatically or through use of <code>@JsonKey</code>) a compiler error occurs.</p> 
  <p>For hierarchies of classes, there are analagous <code>Simple</code> and <code>Automatic</code> hierarchy codec builders. The simple builders expect a chain of branches; the automatic ones derives the chain automatically. The means by which the different cases are differentiated is configurable. The options are <code>TagToValue</code> which produces a wrapper object shaped as <code>{"typeTag" : "value"}</code>, <code>TagAndValue</code> which produces a wrapper shaped as <code>{"tagName" : "typeTag", "valueName" : "value"}</code>, <code>InternalTag</code> which only works with values that encode as objects and which adds an additional field to them to serve as the type tag, and <code>NoTag</code> which on decoding simply tries all branches in the order specified until one succeeds.</p> 
  <p>Note that the <code>AutomaticHierarchy</code> builders can be affected by <a href="https://issues.scala-lang.org/browse/SI-7046" target="_blank">SI-7046</a> and <a href="https://issues.scala-lang.org/browse/SI-7588" target="_blank">SI-7588</a>.</p> 
  <h3><a id="user-content-package-comrojomajsonv3interpolation" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3interpolation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.interpolation</h3> 
  <p>A string interpolator for building <code>JValue</code>s in a syntactically lightweight way. The package contains interpolators <code>json</code> and <code>j</code>; they are exact synonyms.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.interpolation.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span>

<span class="pl-c"><span class="pl-c">//</span> generates { "hello" : "world", "world" : "wide web" }</span>
j<span class="pl-s"><span class="pl-pds">"""</span>{ "hello" : $x, $x : "wide web" }<span class="pl-pds">"""</span></span>

<span class="pl-c"><span class="pl-c">//</span> Any encodable can be used in a non-field position</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>)
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">aCodec</span> <span class="pl-k">=</span> <span class="pl-en">AutomaticJsonCodecBuilder</span>[<span class="pl-en">A</span>]
j<span class="pl-s"><span class="pl-pds">"""</span>{ "a" : ${A(5)} }<span class="pl-pds">"""</span></span> <span class="pl-c"><span class="pl-c">//</span> { "a" : { "x" : 5 } }</span></pre>
  </div> 
  <p>The interpolators are implemented as macros. The well-formedness of the template is checked at compile time.</p> 
  <h3><a id="user-content-package-comrojomajsonv3conversionsv2" class="anchor" href="https://github.com/rjmac/rojoma-json#package-comrojomajsonv3conversionsv2" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>package com.rojoma.json.v3.conversions.v2</h3> 
  <p>While version 3 of rojoma-json is not binary or source compatible with v2, it can exist alongside it. This package contains helpers to convert between the two versions, to assist in transitions.</p> 
  <p>The package is meant to have all its contents imported. It contains implicit conversions which add <code>toV3</code> methods onto rojoma-json-2's <code>JsonToken</code>s, <code>JsonEvent</code>s, and <code>JValue</code>s and <code>toV2</code> methods onto rojoma-json-3's. In addition, it can create rojoma-json-2 <code>JsonCodec</code>s from instances of 3's <code>JsonEncode</code> and <code>JsonDecode</code>.</p> 
  <h2><a id="user-content-cookbook" class="anchor" href="https://github.com/rjmac/rojoma-json#cookbook" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cookbook</h2> 
  <h3><a id="user-content-producing-json-from-values" class="anchor" href="https://github.com/rjmac/rojoma-json#producing-json-from-values" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Producing JSON from values</h3> 
  <p>To a <code>Writer</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.util.</span>{<span class="pl-v">JsonUtil</span>, <span class="pl-v">ArrayIteratorEncode</span>}
<span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.codec.</span><span class="pl-v">JsonEncode</span>

<span class="pl-k">def</span> <span class="pl-en">writeIndented</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonEncode</span>](<span class="pl-v">x</span>: <span class="pl-en">T</span>) <span class="pl-k">=</span>
  <span class="pl-en">JsonUtil</span>.writeJson(x, pretty <span class="pl-k">=</span> <span class="pl-c1">true</span>)

<span class="pl-k">def</span> <span class="pl-en">writeCompact</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonEncode</span>](<span class="pl-v">x</span>: <span class="pl-en">T</span>) <span class="pl-k">=</span>
  <span class="pl-en">JsonUtil</span>.writeJson(x, pretty <span class="pl-k">=</span> <span class="pl-c1">false</span>)

<span class="pl-k">def</span> <span class="pl-en">writeArrayStreaming</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonEncode</span>](<span class="pl-v">x</span>: <span class="pl-en">Iterator</span>[<span class="pl-en">T</span>]) <span class="pl-k">=</span>
  <span class="pl-en">ArrayIteratorEncode</span>.toText(x)</pre>
  </div> 
  <p>To a <code>String</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.util.</span><span class="pl-v">JsonUtil</span>
<span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.codec.</span><span class="pl-v">JsonEncode</span>

<span class="pl-k">def</span> <span class="pl-en">formatIndented</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonEncode</span>](<span class="pl-v">x</span>: <span class="pl-en">T</span>) <span class="pl-k">=</span>
  <span class="pl-en">JsonUtil</span>.renderJson(x, pretty <span class="pl-k">=</span> <span class="pl-c1">true</span>)

<span class="pl-k">def</span> <span class="pl-en">writeCompact</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonEncode</span>](<span class="pl-v">x</span>: <span class="pl-en">T</span>) <span class="pl-k">=</span>
  <span class="pl-en">JsonUtil</span>.renderJson(x, pretty <span class="pl-k">=</span> <span class="pl-c1">false</span>)</pre>
  </div> 
  <h3><a id="user-content-producing-values-from-json" class="anchor" href="https://github.com/rjmac/rojoma-json#producing-values-from-json" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Producing values from JSON</h3> 
  <p>From a <code>Reader</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.util.</span>{<span class="pl-v">JsonUtil</span>, <span class="pl-v">JsonArrayIterator</span>}
<span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.codec.</span>{<span class="pl-v">JsonDecode</span>, <span class="pl-v">DecodeError</span>}

<span class="pl-k">def</span> <span class="pl-en">read</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonDecode</span>](<span class="pl-v">r</span>: <span class="pl-en">Reader</span>)<span class="pl-k">:</span> <span class="pl-en">Either</span>[<span class="pl-en">DecodeError</span>, <span class="pl-en">T</span>] <span class="pl-k">=</span>
  <span class="pl-en">JsonUtil</span>.readJson[<span class="pl-en">T</span>](r)

<span class="pl-c"><span class="pl-c">//</span> This will throw an `ElementDecodeException` if the JSON is a well-formed</span>
<span class="pl-c"><span class="pl-c">//</span> array but the data cannot be interpreted as a `T`</span>
<span class="pl-k">def</span> <span class="pl-en">readStreaming</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonDecode</span>](<span class="pl-v">r</span>: <span class="pl-en">Reader</span>)<span class="pl-k">:</span> <span class="pl-en">Iterator</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span>
  <span class="pl-en">JsonArrayIterator</span>.fromReader[<span class="pl-en">T</span>](r)</pre>
  </div> 
  <p>From a <code>String</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.util.</span><span class="pl-v">JsonUtil</span>
<span class="pl-k">import</span> <span class="pl-v">com.rojoma.json.v3.codec.</span>{<span class="pl-v">JsonDecode</span>, <span class="pl-v">DecodeError</span>}

<span class="pl-k">def</span> <span class="pl-en">parse</span>[<span class="pl-en">T</span> <span class="pl-k">:</span> <span class="pl-en">JsonDecode</span>](<span class="pl-v">s</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">Either</span>[<span class="pl-en">DecodeError</span>, <span class="pl-en">T</span>] <span class="pl-k">=</span>
  <span class="pl-en">JsonUtil</span>.parseJson[<span class="pl-en">T</span>](s)</pre>
  </div> 
  <h2><a id="user-content-incompatible-changes-from-rojoma-json-2" class="anchor" href="https://github.com/rjmac/rojoma-json#incompatible-changes-from-rojoma-json-2" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Incompatible changes from rojoma-json 2</h2> 
  <ul> 
   <li><code>JNumber</code> is no longer a case class.</li> 
   <li><code>JsonDecode</code> returns <code>Either[DecodeError, T]</code> instead of <code>Option[T]</code>.</li> 
   <li><code>Pattern#matches</code> and <code>Pattern#evaluate</code> return <code>Either[DecodeError, Pattern.Results]</code> instead of <code>Option[Pattern.Results]</code>.</li> 
   <li><code>JsonDiff</code> is gone. It was cute but useless.</li> 
   <li><code>PArray</code> now requires an exact length match.</li> 
   <li>The position on <code>JsonToken</code>s and <code>JsonEvent</code>s is now provided in a secondary constructor parameter, rather than being a mutable field.</li> 
   <li>The various high-level readers prefer to use block IO instead of character-by-character IO.</li> 
  </ul> 
 </article>
</div>