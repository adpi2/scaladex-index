<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-units" class="anchor" href="https://github.com/karols/units#units" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>units</h1> 
  <p><strong>Flexible, statically-checked experimental library for units of measurement.</strong></p> 
  <p>Published under MIT License.</p> 
  <h2><a id="user-content-current-version-022" class="anchor" href="https://github.com/karols/units#current-version-022" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Current version: 0.2.2</h2> 
  <p><a href="https://github.com/karols/units/blob/master/CHANGELOG.md" target="_blank">Changelog.</a></p> 
  <p><a href="https://github.com/karols/units/blob/master/doc/TODO.md" target="_blank">Plans for the nearest future.</a></p> 
  <p><a href="https://github.com/karols/units/blob/master/doc/BUILD.md" target="_blank">Build instructions.</a></p> 
  <p>Available at Maven Central:</p> 
  <pre><code>libraryDependencies += "io.github.karols" %% "units" % "0.2.2"
</code></pre> 
  <h2><a id="user-content-features" class="anchor" href="https://github.com/karols/units#features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <p><a href="https://github.com/karols/units/blob/master/doc/RATIONALE.md" target="_blank">Reasons for creation and design goals.</a></p> 
  <p>Main features:</p> 
  <ul> 
   <li><p>static, compile-time checking of units of measure</p></li> 
   <li><p>ability to define custom units of measure</p></li> 
   <li><p>unit arithmetic</p></li> 
   <li><p>automatic unit conversions</p></li> 
   <li><p>many out-of-the-box supported units and their conversions</p></li> 
   <li><p>support for affine spaces</p></li> 
  </ul> 
  <p>A quick comparison with the units of measure support in F# is <a href="https://github.com/karols/units/blob/master/doc/FSHARP.md" target="_blank">here</a>.</p> 
  <h1><a id="user-content-quick-showcase" class="anchor" href="https://github.com/karols/units#quick-showcase" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick showcase</h1> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.defining.</span><span class="pl-v">_</span>

<span class="pl-k">type</span> <span class="pl-en">USD</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_U<span class="pl-k">~</span><span class="pl-k">:</span>_S<span class="pl-k">~</span><span class="pl-k">:</span>_D] 
<span class="pl-k">type</span> <span class="pl-en">EUR</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_E<span class="pl-k">~</span><span class="pl-k">:</span>_U<span class="pl-k">~</span><span class="pl-k">:</span>_R] 

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">EUR_to_USD</span> <span class="pl-k">=</span> one[<span class="pl-en">EUR</span>].contains(<span class="pl-c1">1.25</span>)[<span class="pl-en">USD</span>]

<span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.SI.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.USCustomary.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">priceInUSA</span>     <span class="pl-k">=</span>  <span class="pl-c1">200.</span>of[<span class="pl-en">USD</span><span class="pl-k">/</span>square[foot]]
<span class="pl-k">val</span> <span class="pl-en">priceInGermany</span> <span class="pl-k">=</span> <span class="pl-c1">1500.</span>of[<span class="pl-en">EUR</span><span class="pl-k">/</span>square[metre]]

<span class="pl-k">val</span> <span class="pl-en">area</span> <span class="pl-k">=</span> <span class="pl-c1">200.</span>of[centimetre] <span class="pl-k">*</span> <span class="pl-c1">550.</span>of[centimetre]

<span class="pl-k">val</span> <span class="pl-en">costInUSA</span>     <span class="pl-k">=</span> priceInUSA     <span class="pl-k">*</span> area.convert[foot × foot]
<span class="pl-k">val</span> <span class="pl-en">costInGermany</span> <span class="pl-k">=</span> priceInGermany <span class="pl-k">*</span> area.convert[metre × metre]

println(s<span class="pl-s"><span class="pl-pds">"</span>You can buy tiles in Germany for ${costInGermany.mkString}.<span class="pl-pds">"</span></span>)
println(s<span class="pl-s"><span class="pl-pds">"</span>You can buy tiles in USA for ${costInUSA.mkString}.<span class="pl-pds">"</span></span>)

<span class="pl-k">if</span>(costInUSA <span class="pl-k">&gt;</span><span class="pl-k">~</span> costInGermany) {
    println(<span class="pl-s"><span class="pl-pds">"</span>Buy in Germany.<span class="pl-pds">"</span></span>)
} <span class="pl-k">else</span> {
    println(<span class="pl-s"><span class="pl-pds">"</span>Buy in USA.<span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <p>prints:</p> 
  <pre><code>You can buy tiles in Germany for 16500.0 EUR.
You can buy tiles in USA for 23680.602916761392 USD.
Buy in Germany.
</code></pre> 
  <h1><a id="user-content-quick-guide" class="anchor" href="https://github.com/karols/units#quick-guide" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick Guide</h1> 
  <h2><a id="user-content-defining-units" class="anchor" href="https://github.com/karols/units#defining-units" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Defining units</h2> 
  <p>You define a unit using <code>DefineUnit</code> type constructor with a type-level string as a parameter.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.defining.</span><span class="pl-v">_</span>

<span class="pl-k">type</span> <span class="pl-en">metre</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_m]
<span class="pl-k">type</span> <span class="pl-en">second</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_s]
<span class="pl-k">type</span> <span class="pl-en">kilogram</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[ _k <span class="pl-k">~</span><span class="pl-k">:</span> _g ]</pre>
  </div> 
  <p>All units are subtypes of trait <code>MUnit</code>. This includes the type <code>_1</code>, which represents the dimensionless unit 1.</p> 
  <p>This also automatically generates implicit names for those units: <code>"m"</code>, <code>"s"</code>, and <code>"kg"</code> respectively.</p> 
  <p>You can define a derived unit with operators <code>×</code> and <code>/</code> (the ASCII alternative for <code>×</code> is <code>&gt;&lt;</code>) and type-level functions <code>square</code> and <code>cube</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">newton</span> <span class="pl-k">=</span> (metre × kilogram) <span class="pl-k">/</span> (second × second)
<span class="pl-k">type</span> <span class="pl-en">hertz</span>  <span class="pl-k">=</span> _1 <span class="pl-k">/</span> second
<span class="pl-k">type</span> <span class="pl-en">m2</span>     <span class="pl-k">=</span> square[metre]
<span class="pl-k">type</span> <span class="pl-en">m3</span>     <span class="pl-k">=</span> cube[metre]</pre>
  </div> 
  <p>with implicit names <code>"kg m s^(-2)"</code>, <code>"s^(-1)"</code>, <code>"m^2"</code>, and <code>"m^3"</code> respectively.</p> 
  <p>You can define a related unit with conversion ratio:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">centimetre</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_c<span class="pl-k">~</span><span class="pl-k">:</span>_m]
<span class="pl-k">type</span> <span class="pl-en">kilometre</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_k<span class="pl-k">~</span><span class="pl-k">:</span>_m]

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">km_to_m</span> <span class="pl-k">=</span> one[kilometre].contains(<span class="pl-c1">1000</span>)[metre]
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">m_to_cm</span> <span class="pl-k">=</span> one[metre].contains(<span class="pl-c1">100</span>)[centimetre]</pre>
  </div> 
  <p>This way, you have defined conversions m→km, km→m, m→cm, cm→m, m²→km², m³→km³, km²→m² etc.</p> 
  <p>Note that this does not define a conversion from kilometres to centimetres. You can do it this way:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">km_to_cm</span> <span class="pl-k">=</span> km_to_m <span class="pl-k">&gt;&gt;</span> m_to_cm</pre>
  </div> 
  <p>You can also quickly generate conversions for kg×m→kg×cm, m/s→cm/s, J/m→J/cm, N/m²→N/cm²:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">kgm_to_kgcm</span> <span class="pl-k">=</span> m_to_cm.times[kilogram]
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">mps_to_cmps</span> <span class="pl-k">=</span> m_to_cm.dividedBy[second]
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">Jpm_to_Jpcm</span> <span class="pl-k">=</span> m_to_cm.dividing[joule]
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">Npm2_to_Npcm2</span> <span class="pl-k">=</span> m_to_cm.pow2.dividing[newton]</pre>
  </div> 
  <p>See sources for <code>io.github.karols.units.SI</code> and <code>io.github.karols.units.USCustomary</code> objects for more examples.</p> 
  <h2><a id="user-content-using-values-with-units" class="anchor" href="https://github.com/karols/units#using-values-with-units" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using values with units</h2> 
  <p>All code below assumes the following is imported:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>You can create a value with a unit:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">length</span> <span class="pl-k">=</span> <span class="pl-c1">2.</span>of[metre]</pre>
  </div> 
  <p>This value is of type <code>IntU[metre]</code>. If you used a double literal, you would receive a <code>DoubleU</code> instance:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">length2</span> <span class="pl-k">=</span> <span class="pl-c1">2.0</span>.of[metre]</pre>
  </div> 
  <p><code>IntU</code> and <code>DoubleU</code> are represented at runtime as an unboxed <code>Long</code> and <code>Double</code> respectively.</p> 
  <p>You can add and subtract values with the same units:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length <span class="pl-k">+</span> length2 <span class="pl-c"><span class="pl-c">//</span> equals 4 m</span></pre>
  </div> 
  <p>You can multiply or divide two values:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length <span class="pl-k">*</span> length2 <span class="pl-c"><span class="pl-c">//</span> equals 4 m^2</span></pre>
  </div> 
  <p>You can also compare values with the same units:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">area</span> <span class="pl-k">=</span> <span class="pl-c1">3.</span>of[metre × metre]
area <span class="pl-k">&gt;</span> length <span class="pl-k">*</span> length2        <span class="pl-c"><span class="pl-c">//</span>equals false</span></pre>
  </div> 
  <p>If you want to extract the raw dimensionless numeric value from the value with a unit, you can use value method:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length.value <span class="pl-c"><span class="pl-c">//</span> equals 2: Long</span></pre>
  </div> 
  <p>Other useful methods include raising to powers and getting roots:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length.pow2             <span class="pl-c"><span class="pl-c">//</span> 4 m^2</span>
length.pow3             <span class="pl-c"><span class="pl-c">//</span> 8 m^3</span>
area.sqrt               <span class="pl-c"><span class="pl-c">//</span> 1.7... m</span>
<span class="pl-c1">27.</span>of[cube[metre]].cbrt <span class="pl-c"><span class="pl-c">//</span> 3.0 m</span></pre>
  </div> 
  <p>Note that while using <code>sqrt</code> (respectively: <code>cbrt</code>) method will currently work for types with units to odd (respectively: not divisible by three) powers, but the resulting value will have some ill-defined type.</p> 
  <p>If you want to use an SI prefix without creating a separate unit for it, you can use more extension methods defined on numeric types:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c1">20.</span>kilo[metre]  <span class="pl-c"><span class="pl-c">//</span> equals 20000 m</span>
<span class="pl-c1">3.</span>milli[second] <span class="pl-c"><span class="pl-c">//</span> equals 0.003 s</span></pre>
  </div> 
  <p>Finally, to print a value with a unit, you can use <code>mkString</code> method:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length.mkString               <span class="pl-c"><span class="pl-c">//</span> equals "4 m"</span>
<span class="pl-c1">300.</span>of[metre<span class="pl-k">/</span>second].mkString <span class="pl-c"><span class="pl-c">//</span> equals "300 m s^(-1)"</span></pre>
  </div> 
  <p>It is currently not recommended though, it takes a lot of time to compile and generates awfully large classfiles. The recommended way is to use <code>value</code> method and append a unit symbol manually.</p> 
  <p><a href="https://github.com/karols/units/blob/master/doc/CUSTOM.md" target="_blank">Section about using custom numeric types with units has been moved here.</a></p> 
  <h2><a id="user-content-manual-unit-conversion" class="anchor" href="https://github.com/karols/units#manual-unit-conversion" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Manual unit conversion</h2> 
  <p>You can convert a value to another unit, provided there is an implicit conversion ratio in scope:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">length</span> <span class="pl-k">=</span> <span class="pl-c1">2.</span>of[metre]
length.convert[centimetre]          <span class="pl-c"><span class="pl-c">//</span> equals 200.0 cm</span></pre>
  </div> 
  <p>If you are converting an integer value from a unit to its subunit, you can get the results as an <code>IntU</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length.convertToInt[centimetre]     <span class="pl-c"><span class="pl-c">//</span> equals 200 cm</span></pre>
  </div> 
  <p>You can apply the conversion ratio to a more complicated unit in order to replace one unit with another:</p> 
  <div class="highlight highlight-source-scala">
   <pre>length.represent[metre, centimetre] <span class="pl-c"><span class="pl-c">//</span> equals 200.0 cm</span>
area.represent[metre, centimetre]   <span class="pl-c"><span class="pl-c">//</span> equals 300.0 cm×m</span>
<span class="pl-c1">1.</span>represent[metre, centimetre]      <span class="pl-c"><span class="pl-c">//</span> equals 100.0 cm/m</span></pre>
  </div> 
  <p>Finally, you can apply the conversion to all occurrences of a unit inside another. The only restriction is that the unit you are converting from is a basic unit, defined with <code>DefineUnit</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>area.representAll[metre, centimetre]                              <span class="pl-c"><span class="pl-c">//</span> equals 30000.0 cm^2</span>
<span class="pl-c1">1.</span>representAll[metre, centimetre]                                 <span class="pl-c"><span class="pl-c">//</span> equals 1.0</span>
<span class="pl-c1">2.</span>of[metre<span class="pl-k">/</span>second].representAll[metre, centimetre]                <span class="pl-c"><span class="pl-c">//</span> equals 200.0 cm/s</span>
<span class="pl-c1">2.</span>of[square[metre]<span class="pl-k">/</span>second].representAll[metre, centimetre]        <span class="pl-c"><span class="pl-c">//</span> equals 20000.0 cm^2/s</span>
<span class="pl-c1">30000000.</span>of[kilogram<span class="pl-k">/</span>cube[metre]].representAll[metre, centimetre] <span class="pl-c"><span class="pl-c">//</span> equals 30.0 kg/cm^3</span></pre>
  </div> 
  <h2><a id="user-content-automatic-unit-conversion" class="anchor" href="https://github.com/karols/units#automatic-unit-conversion" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Automatic unit conversion</h2> 
  <p>Units are automatically converted in comparisons when using operators ending with a tilde:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c1">399.</span>of[centimetre] <span class="pl-k">&gt;=</span><span class="pl-k">~</span> <span class="pl-c1">4.</span>of[metre]   <span class="pl-c"><span class="pl-c">//</span> false</span></pre>
  </div> 
  <p>If there is an integer conversion ratio between two units, then adding/subtracting two values with those units converts the sum/difference to the smaller unit:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c1">14.</span>of[centimetre] <span class="pl-k">+</span> <span class="pl-c1">3.</span>of[metre]  <span class="pl-c"><span class="pl-c">//</span> equals 314 cm, not 3.14 m</span></pre>
  </div> 
  <h2><a id="user-content-affine-spaces" class="anchor" href="https://github.com/karols/units#affine-spaces" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Affine spaces</h2> 
  <p>Affine space is a space of quantities which cannot be multiplied or added, only subtracted. The reason for that is that the zero is chosen arbitrarily. Affine spaces are used to represent temperatures, timestamps, Cartesian coordinates, potential energy, electric potential, and more. See <a href="http://math.ucr.edu/home/baez/torsors.html" target="_blank">this article</a> for more info.</p> 
  <p>Example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">freezeC</span> <span class="pl-k">=</span> <span class="pl-c1">0.</span>at[<span class="pl-en">CelsiusScale</span>] <span class="pl-c"><span class="pl-c">//</span> temperature at which water freezes</span>
<span class="pl-c1">0.</span>of[celsius_deg]                <span class="pl-c"><span class="pl-c">//</span> zero difference of temperatures</span></pre>
  </div> 
  <p>Affine values have types <code>DoubleA[A]</code> and <code>IntA[A]</code>, where <code>A</code> is an affine space.</p> 
  <p>The reason that you can't add affine values is that this operation makes no sense.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">freezeF</span> <span class="pl-k">=</span> freezeC.convert[<span class="pl-en">FahrenheitScale</span>] <span class="pl-c"><span class="pl-c">//</span> equals 32°F</span>
freezeC <span class="pl-k">+</span> freezeC                              <span class="pl-c"><span class="pl-c">//</span> 0°C + 0°C == does not compile</span>
freezeF <span class="pl-k">+</span> freezeF                              <span class="pl-c"><span class="pl-c">//</span> 32°F + 32°F == does not compile</span></pre>
  </div> 
  <p>In the above case, if we assumed naïvely that we can add temperatures, the first sum would end up being 0°C, and the second one would be 64°F – clearly two different results.</p> 
  <p>You can add/subtract normal values to/from affine values:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">temperatureIncreaseC</span> <span class="pl-k">=</span> <span class="pl-c1">5.</span>of[celsius_deg]                            <span class="pl-c"><span class="pl-c">//</span> equals +5°C</span>
<span class="pl-k">val</span> <span class="pl-en">temperatureIncreaseF</span> <span class="pl-k">=</span> temperatureIncreaseC.convert[fahrenheit_deg] <span class="pl-c"><span class="pl-c">//</span> equals +9°F</span>

freezeC <span class="pl-k">+</span> temperatureIncreaseC  <span class="pl-c"><span class="pl-c">//</span> equals 5°C</span>
freezeF <span class="pl-k">+</span> temperatureIncreaseF  <span class="pl-c"><span class="pl-c">//</span> equals 41°F == 5°C</span>
freezeC <span class="pl-k">-</span> temperatureIncreaseC  <span class="pl-c"><span class="pl-c">//</span> equals -5°C</span>
freezeF <span class="pl-k">-</span> temperatureIncreaseF  <span class="pl-c"><span class="pl-c">//</span> equals 23°F == -5°C</span></pre>
  </div> 
  <p>You can also calculate a difference between two affine values, which yields a normal value:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">boilC</span> <span class="pl-k">=</span> <span class="pl-c1">100.</span>at[<span class="pl-en">CelsiusScale</span>] <span class="pl-c"><span class="pl-c">//</span> equals 100°C == 212°F</span>
<span class="pl-k">val</span> <span class="pl-en">diffC</span> <span class="pl-k">=</span> boilC <span class="pl-k">--</span> freezeC     <span class="pl-c"><span class="pl-c">//</span> equals +100°C == +180°F</span></pre>
  </div> 
  <p>The operator name is double minus sign, because single minus sign was used for subtracting a normal value and Scala compiler cannot overload that method due to type erasure for value classes.</p> 
  <h2><a id="user-content-defining-affine-spaces" class="anchor" href="https://github.com/karols/units#defining-affine-spaces" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Defining affine spaces</h2> 
  <p>AffineSpace is defined as a pair containing a zero point and a unit.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">io.github.karols.units.defining.</span><span class="pl-v">_</span>

<span class="pl-k">type</span> <span class="pl-en">celsius_deg</span> <span class="pl-k">=</span> <span class="pl-en">DefineUnit</span>[_deg<span class="pl-k">~</span><span class="pl-k">:</span>_C]
<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">CelsiusZero</span>

<span class="pl-k">type</span> <span class="pl-en">CelsiusScale</span> <span class="pl-k">=</span> <span class="pl-en">DefineAffineSpace</span>[<span class="pl-en">CelsiusZero</span>, celsius_deg]</pre>
  </div> 
  <p>Unlike normal values, affine spaces currently require conversion functions in both directions.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">fromCelsiusToFahrenheit</span> <span class="pl-k">=</span> convertAffineSpace[<span class="pl-en">CelsiusScale</span>,<span class="pl-en">FahrenheitScale</span>]{ 
    x <span class="pl-k">=&gt;</span> x <span class="pl-k">*</span> (<span class="pl-c1">9</span><span class="pl-k">/</span><span class="pl-c1">5.0</span>) <span class="pl-k">+</span> <span class="pl-c1">32</span>  <span class="pl-c"><span class="pl-c">//</span> (Double =&gt; Double)</span>
}
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">fromFahrenheitToCelsius</span> <span class="pl-k">=</span> convertAffineSpace[<span class="pl-en">FahrenheitScale</span>,<span class="pl-en">CelsiusScale</span>]{ 
    x <span class="pl-k">=&gt;</span> (x <span class="pl-k">-</span> <span class="pl-c1">32</span>) <span class="pl-k">*</span> (<span class="pl-c1">5</span><span class="pl-k">/</span><span class="pl-c1">9.0</span>)
}</pre>
  </div> 
  <p>If two affine spaces only differ by their unit, you can use <code>changeUnit</code> method to convert between them:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">UnixEpoch</span>
<span class="pl-k">type</span> <span class="pl-en">UnixEpochSeconds</span> <span class="pl-k">=</span> <span class="pl-en">DefineAffineSpace</span>[<span class="pl-en">UnixEpoch</span>, second]
<span class="pl-k">type</span> <span class="pl-en">UnixEpochMillis</span> <span class="pl-k">=</span> <span class="pl-en">DefineAffineSpace</span>[<span class="pl-en">UnixEpoch</span>, millisecond]

<span class="pl-k">val</span> <span class="pl-en">timestamp</span> <span class="pl-k">=</span> <span class="pl-c1">123456789.</span>at[<span class="pl-en">UnixEpochSeconds</span>] <span class="pl-c"><span class="pl-c">//</span> equals 123456789 s from Unix Epoch</span>
timestamp.changeUnit[millisecond]              <span class="pl-c"><span class="pl-c">//</span> equals 123456789000 ms from Unix Epoch</span></pre>
  </div> 
  <p>Affine values can be compared with relational operators, similarly to normal values.</p> 
  <h2><a id="user-content-writing-polymorphic-functions-using-units-of-measure" class="anchor" href="https://github.com/karols/units#writing-polymorphic-functions-using-units-of-measure" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Writing polymorphic functions using units of measure</h2> 
  <p><a href="https://github.com/karols/units/blob/master/doc/POLYMORPHISM.md" target="_blank">This section has been moved to a separate document.</a></p> 
  <h2><a id="user-content-using-arrays" class="anchor" href="https://github.com/karols/units#using-arrays" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using arrays</h2> 
  <p><a href="https://github.com/karols/units/blob/master/doc/ARRAYS.md" target="_blank">This section has been moved to a separate document.</a></p> 
  <h2><a id="user-content-2d-and-3d-vectors" class="anchor" href="https://github.com/karols/units#2d-and-3d-vectors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>2D and 3D vectors</h2> 
  <p><a href="https://github.com/karols/units/blob/master/doc/VECTORS.md" target="_blank">This section has been moved to a separate document.</a></p> 
  <h1><a id="user-content-implementation-details" class="anchor" href="https://github.com/karols/units#implementation-details" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementation details</h1> 
  <p>The implementation started with a pretty common type-level implementation of boolean and integers.</p> 
  <p>Type-level strings are either a cons of a char and a string, a single char, or an empty string. Each char is implemented currently as a triple of members of Z/5Z, so only 125 different characters are allowed.</p> 
  <p>A basic unit is implemented as a thin wrapper around a type-level string. That string is an identifier that is used for type equality comparison, and is also used for implicit name generation.</p> 
  <p>The main type for units (<code>MUnit</code>) is a linked list of pairs of basic units and non-zero integers, used to represent a type-level map.</p> 
 </article>
</div>