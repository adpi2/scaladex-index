<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://gitter.im/joinrun-scala/Lobby?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/91cc7283e398a9cdeb7352e4db3fe3711091ba1b/68747470733a2f2f6261646765732e6769747465722e696d2f6a6f696e72756e2d7363616c612f4c6f6262792e737667" alt="Join the chat at https://gitter.im/joinrun-scala/Lobby" data-canonical-src="https://badges.gitter.im/joinrun-scala/Lobby.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/Chymyst/joinrun-scala" target="_blank"><img src="https://camo.githubusercontent.com/249f53fd5392c9ce889eafdf12a34d9042799ac4/68747470733a2f2f7472617669732d63692e6f72672f4368796d7973742f6a6f696e72756e2d7363616c612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/Chymyst/joinrun-scala.svg?branch=master" style="max-width:100%;"></a> <a href="https://codecov.io/gh/Chymyst/joinrun-scala?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/b850d591a58eef11612f6cbd6041b61dc8db34a2/68747470733a2f2f636f6465636f762e696f2f67682f4368796d7973742f6a6f696e72756e2d7363616c612f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://codecov.io/gh/Chymyst/joinrun-scala/coverage.svg?branch=master" style="max-width:100%;"></a> <a href="https://opensource.org/licenses/Apache-2.0" target="_blank"><img src="https://camo.githubusercontent.com/8051e9938a1ab39cf002818dfceb6b6092f34d68/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4c6963656e73652d417061636865253230322e302d626c75652e737667" alt="License" data-canonical-src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" style="max-width:100%;"></a> <a href="https://github.com/Chymyst/joinrun-scala/tags" target="_blank"><img src="https://camo.githubusercontent.com/27cee1c41ea9d6e30e7175a4170cd65a7c7af0d2/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f7461672f4368796d7973742f6a6f696e72756e2d7363616c612e7376673f6c6162656c3d72656c6561736526636f6c6f72423d626c7565" alt="Github Tag" data-canonical-src="https://img.shields.io/github/tag/Chymyst/joinrun-scala.svg?label=release&amp;colorB=blue" style="max-width:100%;"></a> <a href="http://search.maven.org/#search%7Cga%7C1%7Cio.chymyst" target="_blank"><img src="https://camo.githubusercontent.com/e3ef6cdae8c5c05131b864b67b2da79f72311f54/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f696f2e6368796d7973742f636f72655f322e31312e737667" alt="Maven Central" data-canonical-src="https://img.shields.io/maven-central/v/io.chymyst/core_2.11.svg" style="max-width:100%;"></a></p> 
  <h1><a id="user-content-chymyst----declarative-concurrency-in-scala" class="anchor" href="https://github.com/chymyst/joinrun-scala#chymyst----declarative-concurrency-in-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><code>Chymyst</code> -- declarative concurrency in Scala</h1> 
  <p>This repository hosts <code>Chymyst Core</code> -- a library that provides a Scala domain-specific language for declarative concurrency. <a href="https://github.com/Chymyst/Chymyst" target="_blank"><code>Chymyst</code></a> is a framework-in-planning that will build upon <code>Chymyst Core</code> to enable creating concurrent applications declaratively.</p> 
  <p><code>Chymyst</code> is based on the <strong>chemical machine</strong> paradigm, known in the academic world as <a href="https://en.wikipedia.org/wiki/Join-calculus" target="_blank">Join Calculus (JC)</a>. JC has the same expressive power as CSP (<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes" target="_blank">Communicating Sequential Processes</a>) and <a href="https://en.wikipedia.org/wiki/Actor_model" target="_blank">the Actor model</a>, but is easier to use. (See also <a href="https://chymyst.github.io/joinrun-scala/concurrency.html" target="_blank">Conceptual overview of concurrency</a>.)</p> 
  <p>The initial code of <code>Chymyst Core</code> was based on previous work by Jiansen He (<a href="https://github.com/Jiansen/ScalaJoin" target="_blank">https://github.com/Jiansen/ScalaJoin</a>, 2011) and Philipp Haller (<a href="http://lampwww.epfl.ch/%7Ephaller/joins/index.html" target="_blank">http://lampwww.epfl.ch/~phaller/joins/index.html</a>, 2008), as well as on earlier prototypes in <a href="https://github.com/winitzki/CocoaJoin" target="_blank">Objective-C/iOS</a> and <a href="https://github.com/winitzki/AndroJoin" target="_blank">Java/Android</a>.</p> 
  <p>The current implementation is tested under Oracle JDK 8 with Scala <code>2.11.8</code> and <code>2.12.1</code>.</p> 
  <p><a href="https://chymyst.github.io/joinrun-scala/roadmap.html" target="_blank">Version history and roadmap</a></p> 
  <h1><a id="user-content-overview-of-chymyst-and-the-chemical-machine-paradigm" class="anchor" href="https://github.com/chymyst/joinrun-scala#overview-of-chymyst-and-the-chemical-machine-paradigm" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview of <code>Chymyst</code> and the chemical machine paradigm</h1> 
  <p>To get started, begin with this <a href="https://chymyst.github.io/joinrun-scala/chymyst00.html" target="_blank">tutorial introduction</a>.</p> 
  <p>I presented an early version of <code>Chymyst Core</code>, at that time called <code>JoinRun</code>, at <a href="https://scalaebythebay2016.sched.org/event/7iU2/concurrent-join-calculus-in-scala" target="_blank">Scal√¶ by the Bay 2016</a>. See the <a href="https://www.youtube.com/watch?v=jawyHGjUfBU" target="_blank">talk video</a> and these <a href="https://github.com/winitzki/talks/raw/master/join_calculus/join_calculus_2016_revised.pdf" target="_blank">talk slides revised for the current syntax</a>.</p> 
  <p>There is some <a href="https://github.com/chymyst/joinrun-scala/blob/master/docs/chymyst-core.md" target="_blank">technical documentation for the core library</a>.</p> 
  <p>A complete minimal "Hello, world" project can be found at <a href="https://github.com/Chymyst/helloworld" target="_blank">https://github.com/Chymyst/helloworld</a></p> 
  <h1><a id="user-content-main-features-of-chymyst" class="anchor" href="https://github.com/chymyst/joinrun-scala#main-features-of-chymyst" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Main features of <code>Chymyst</code></h1> 
  <p><code>Chymyst</code> implements Join Calculus similarly to <a href="http://jocaml.inria.fr" target="_blank">JoCaml</a>, with some extensions in both syntax and semantics.</p> 
  <h2><a id="user-content-concise-declarative-syntax" class="anchor" href="https://github.com/chymyst/joinrun-scala#concise-declarative-syntax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Concise declarative syntax</h2> 
  <p><code>Chymyst Core</code> provides an embedded Scala DSL for chemical machine definitions. Example code looks like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.chymyst.jc.</span><span class="pl-v">_</span>

<span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>] <span class="pl-c"><span class="pl-c">//</span> declare a non-blocking molecule s</span>
<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> b[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>] <span class="pl-c"><span class="pl-c">//</span> declare a blocking molecule c</span>
site( <span class="pl-c"><span class="pl-c">//</span> declare a reaction site</span>
  go { <span class="pl-k">case</span> s(x) <span class="pl-k">+</span> c(y, reply) <span class="pl-k">=&gt;</span>
    s(x <span class="pl-k">+</span> y) <span class="pl-k">+</span> reply(x)
  }
)
s(<span class="pl-c1">1</span>) <span class="pl-c"><span class="pl-c">//</span> emit non-blocking molecule s with value 1</span>
</pre>
  </div> 
  <p>As a baseline reference, the most concise syntax for JC is available in <a href="http://jocaml.inria.fr" target="_blank">JoCaml</a>, which uses a modified OCaml compiler. The equivalent reaction definition in JoCaml looks like this:</p> 
  <div class="highlight highlight-source-ocaml">
   <pre>def s(x) <span class="pl-k">&amp;</span> c(y) <span class="pl-k">=</span>  <span class="pl-k">//</span> declare a reaction site <span class="pl-k">as</span> well <span class="pl-k">as</span> molecules s <span class="pl-k">and</span> <span class="pl-en">c</span>
   <span class="pl-v">s</span>(<span class="pl-v">x</span> + <span class="pl-v">y</span>) &amp; <span class="pl-v">reply</span> <span class="pl-v">x</span> <span class="pl-v">to</span> <span class="pl-v">c</span>
<span class="pl-v">spawn</span> <span class="pl-v">s</span>(<span class="pl-c1">1</span>)  // <span class="pl-v">emit</span> <span class="pl-v">non</span>-<span class="pl-v">blocking</span> <span class="pl-v">molecule</span> <span class="pl-v">s</span> <span class="pl-v">with</span> <span class="pl-v">value</span> <span class="pl-c1">1</span>
</pre>
  </div> 
  <p>In the JoCaml syntax, <code>s</code> and <code>c</code> are declared implicitly, together with the reaction, and type inference fixes the types of their values. Implicit declaration of molecule emitters (‚Äúchannels‚Äù) is not possible in <code>Chymyst</code> because Scala macros cannot insert new top-level name declarations into the code. For this reason, <code>Chymyst</code> requires explicit declarations of molecule types (for example, <code>val c = b[Int, Int]</code>).</p> 
  <h2><a id="user-content-arbitrary-input-patterns" class="anchor" href="https://github.com/chymyst/joinrun-scala#arbitrary-input-patterns" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Arbitrary input patterns</h2> 
  <p>In <code>Chymyst</code>'s Scala DSL, a reaction's input patterns is a <code>case</code> clause in a partial function. Within the limits of the Scala syntax, reactions can define arbitrary input patterns.</p> 
  <ul> 
   <li>Reactions can use pattern matching expressions as well as guard conditions for selecting molecule values:</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> m[<span class="pl-en">Option</span>[<span class="pl-k">Int</span>]]
<span class="pl-k">val</span> <span class="pl-en">d</span> <span class="pl-k">=</span> m[(<span class="pl-k">String</span>, <span class="pl-en">List</span>[<span class="pl-k">String</span>])]

go { <span class="pl-k">case</span> c(<span class="pl-en">Some</span>(x)) <span class="pl-k">+</span> d( s<span class="pl-k">@</span>(<span class="pl-s"><span class="pl-pds">"</span>xyz<span class="pl-pds">"</span></span>, <span class="pl-en">List</span>(p, q, r)) ) 
      <span class="pl-k">if</span> x <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> <span class="pl-k">&amp;&amp;</span> p.length <span class="pl-k">&gt;</span> q.length <span class="pl-k">=&gt;</span>
      <span class="pl-c"><span class="pl-c">//</span> Reaction will start only if the condition holds.</span>
      <span class="pl-c"><span class="pl-c">//</span> Reaction body can use pattern variables x, s, p, q, r.</span>
}
</pre>
  </div> 
  <ul> 
   <li>Reactions can use repeated input molecules ("nonlinear patterns"):</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]

go { <span class="pl-k">case</span> c(x) <span class="pl-k">+</span> c(y) <span class="pl-k">if</span> x <span class="pl-k">&gt;</span> y <span class="pl-k">=&gt;</span> c(x <span class="pl-k">-</span> y) }
</pre>
  </div> 
  <p>Some concurrent algorithms are more easily expressed using repeated input molecules.</p> 
  <ul> 
   <li>A reaction can consume any number of blocking molecules at once, and each blocking molecule will receive its own reply.</li> 
  </ul> 
  <p>For example, here is a reaction that consumes 3 blocking molecules <code>f</code>, <code>f</code>, <code>g</code> and exchanges the values caried by the two <code>f</code> molecules:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> b[<span class="pl-k">Int</span>, <span class="pl-k">Int</span>]
<span class="pl-k">val</span> <span class="pl-en">g</span> <span class="pl-k">=</span> b[<span class="pl-k">Unit</span>, <span class="pl-k">Unit</span>]

go { <span class="pl-k">case</span> f(x1, replyF1) <span class="pl-k">+</span> f(x2, replyF2) <span class="pl-k">+</span> g(_, replyG) <span class="pl-k">=&gt;</span>
   replyF1(x2) <span class="pl-k">+</span> replyF2(x1) <span class="pl-k">+</span> replyG()
}
</pre>
  </div> 
  <p>This reaction is impossible to write using JoCaml-style syntax <code>reply x to f</code>: in that syntax, we cannot identify which of the copies of <code>f</code> should receive which reply value. We can do this in JoCaml:</p> 
  <div class="highlight highlight-source-ocaml">
   <pre>def f(x1) <span class="pl-k">+</span> f(x2) <span class="pl-k">+</span> g<span class="pl-c1">()</span> <span class="pl-k">=&gt;</span>
  reply x2 <span class="pl-k">to</span> f; reply x1 <span class="pl-k">to</span> f; reply <span class="pl-c1">()</span> <span class="pl-k">to</span> g
</pre>
  </div> 
  <p>However, this does not specify that the reply value <code>x2</code> should be sent to the process that emitted <code>f(x1)</code> rather than to the process that emitted <code>f(x2)</code>.</p> 
  <h2><a id="user-content-reactions-are-values" class="anchor" href="https://github.com/chymyst/joinrun-scala#reactions-are-values" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Reactions are values</h2> 
  <p>Reactions are not merely <code>case</code> clauses but locally scoped values of type <code>Reaction</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
<span class="pl-k">val</span> <span class="pl-en">reaction</span><span class="pl-k">:</span> <span class="pl-en">Reaction</span> <span class="pl-k">=</span> go { <span class="pl-k">case</span> c(x) <span class="pl-k">=&gt;</span> println(x) }
<span class="pl-c"><span class="pl-c">//</span> Declare a reaction, but do not run anything yet.</span>
</pre>
  </div> 
  <p>Users can build reaction sites incrementally, constructing, say, an array of <code>n</code> reaction values, where <code>n</code> is a run-time parameter. Then a reaction site can be declared, using the array of reaction values:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">reactions</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Reaction</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
site(<span class="pl-v">reactions</span>: _<span class="pl-k">*</span>)
</pre>
  </div> 
  <p>Since molecule emitters are local values, one can also define <code>n</code> different molecules, where <code>n</code> is a run-time parameter. There is no limit on the number of reactions in one reaction site, and no limit on the number of different molecules. </p> 
  <p>Nevertheless, reactions and reaction sites are immutable once declared.</p> 
  <h2><a id="user-content-timeouts-for-blocking-molecules" class="anchor" href="https://github.com/chymyst/joinrun-scala#timeouts-for-blocking-molecules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Timeouts for blocking molecules</h2> 
  <p>Emitting a blocking molecule will block forever if no reactions can consume that molecule. Users can decide to time out on that blocking call:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> b[<span class="pl-k">Unit</span>, <span class="pl-k">Int</span>]

site(...) <span class="pl-c"><span class="pl-c">//</span> define some reactions that consume f</span>

<span class="pl-k">val</span> <span class="pl-en">result</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> f.timeout()(<span class="pl-c1">200</span> millis)
<span class="pl-c"><span class="pl-c">//</span> will return None on timeout</span>
</pre>
  </div> 
  <h2><a id="user-content-static-analysis-for-correctness-and-optimization" class="anchor" href="https://github.com/chymyst/joinrun-scala#static-analysis-for-correctness-and-optimization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Static analysis for correctness and optimization</h2> 
  <p><code>Chymyst</code> uses macros to perform extensive static analysis of reactions at compile time. This allows <code>Chymyst</code> to detect some errors such as deadlock or livelock, and to give warnings for possible deadlock or livelock, before any reactions are started.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> m[<span class="pl-k">Unit</span>]

site( go { <span class="pl-k">case</span> a(x) <span class="pl-k">=&gt;</span> c() <span class="pl-k">+</span> a(x<span class="pl-k">+</span><span class="pl-c1">1</span>) } )
<span class="pl-c"><span class="pl-c">//</span> Does not compile: "Unconditional livelock due to a(x)"</span>
</pre>
  </div> 
  <p>The static analysis also enforces constraints such as the uniqueness of the reply to blocking molecules.</p> 
  <p>Common cases of invalid chemical definitions are flagged either at compile time, or as run-time errors that occur after defining a reaction site and before starting any processes. Other errors are flagged when reactions are run (e.g. if a blocking molecule gets no reply but static analysis was unable to determine that).</p> 
  <p>The results of static analysis are used to optimize the scheduling of reactions at runtime. For instance, reactions that impose no cross-molecule conditions are scheduled significantly faster.</p> 
  <h2><a id="user-content-thread-pools" class="anchor" href="https://github.com/chymyst/joinrun-scala#thread-pools" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Thread pools</h2> 
  <p><code>Chymyst</code> implements fine-grained threading control. Each reaction site and each reaction can be run on a different, separate thread pool if required. The user can control the number of threads in thread pools.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">tp1</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FixedPool</span>(<span class="pl-c1">1</span>)
<span class="pl-k">val</span> <span class="pl-en">tp8</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SmartPool</span>(<span class="pl-c1">8</span>)

site(tp8)( <span class="pl-c"><span class="pl-c">//</span> reaction site runs on tp8</span>
  go { <span class="pl-k">case</span> a(x) <span class="pl-k">=&gt;</span> ... } onThreads tp1, <span class="pl-c"><span class="pl-c">//</span> this reaction runs on tp1</span>
  go { ... } <span class="pl-c"><span class="pl-c">//</span> all other reactions run on tp8</span>
 )
</pre>
  </div> 
  <p>Thread pools are "smart" because they will automatically adjust the number of active threads if blocking operations occur. So, blocking operations do not decrease the degree of parallelism.</p> 
  <h2><a id="user-content-graceful-shutdown" class="anchor" href="https://github.com/chymyst/joinrun-scala#graceful-shutdown" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Graceful shutdown</h2> 
  <p>When a <code>Chymyst</code>-based program needs to exit, it can shut down the thread pools that run reactions.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">tp</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SmartPool</span>(<span class="pl-c1">8</span>)

<span class="pl-c"><span class="pl-c">//</span> define reactions and run them</span>

tp.shutdownNow() <span class="pl-c"><span class="pl-c">//</span> all reactions running on `tp` will stop</span>
</pre>
  </div> 
  <h2><a id="user-content-fair-nondeterminism" class="anchor" href="https://github.com/chymyst/joinrun-scala#fair-nondeterminism" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Fair nondeterminism</h2> 
  <p>Whenever a molecule can start several reactions, the reaction is chosen at random.</p> 
  <h2><a id="user-content-fault-tolerance" class="anchor" href="https://github.com/chymyst/joinrun-scala#fault-tolerance" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Fault tolerance</h2> 
  <p>Reactions marked as fault-tolerant will be automatically restarted if exceptions are thrown.</p> 
  <h2><a id="user-content-debugging" class="anchor" href="https://github.com/chymyst/joinrun-scala#debugging" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Debugging</h2> 
  <p>The execution of reactions can be traced via logging levels per reaction site. Due to automatic naming of molecules and static analysis, debugging can print information about reaction flow in a visual way.</p> 
  <h2><a id="user-content-comparison-chemical-machine-vs-academic-join-calculus" class="anchor" href="https://github.com/chymyst/joinrun-scala#comparison-chemical-machine-vs-academic-join-calculus" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Comparison: chemical machine vs. academic Join Calculus</h2> 
  <p>In talking about <code>Chymyst</code>, I follow the chemical machine metaphor and terminology, which differs from the terminology usually found in academic papers on JC. Here is a dictionary:</p> 
  <table>
   <thead> 
    <tr> 
     <th>Chemical machine</th> 
     <th>Academic Join Calculus</th> 
     <th><code>Chymyst</code> code</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>input molecule</td> 
     <td>message on channel</td> 
     <td><code>case a(123) =&gt; ...</code> <em>// pattern-matching</em></td> 
    </tr> 
    <tr> 
     <td>molecule emitter</td> 
     <td>channel name</td> 
     <td><code>val a : M[Int]</code></td> 
    </tr> 
    <tr> 
     <td>blocking emitter</td> 
     <td>synchronous channel</td> 
     <td><code>val q : B[Unit, Int]</code></td> 
    </tr> 
    <tr> 
     <td>reaction</td> 
     <td>process</td> 
     <td><code>val r1 = go { case a(x) + ... =&gt; ... }</code></td> 
    </tr> 
    <tr> 
     <td>emitting an output molecule</td> 
     <td>sending a message</td> 
     <td><code>a(123)</code> <em>// side effect</em></td> 
    </tr> 
    <tr> 
     <td>emitting a blocking molecule</td> 
     <td>sending a synchronous message</td> 
     <td><code>q()</code> <em>// returns Int</em></td> 
    </tr> 
    <tr> 
     <td>reaction site</td> 
     <td>join definition</td> 
     <td><code>site(r1, r2, ...)</code></td> 
    </tr> 
   </tbody>
  </table> 
  <p>As another comparison, here is some code in academic Join Calculus, taken from <a href="http://research.microsoft.com/en-us/um/people/fournet/papers/join-tutorial.pdf" target="_blank">this tutorial</a>:</p> 
  <p><a href="https://github.com/chymyst/joinrun-scala/blob/master/docs/academic_join_calculus_2.png" target="_blank"><img alt="def newVar(v0) def put(w) etc." src="https://github.com/chymyst/joinrun-scala/raw/master/docs/academic_join_calculus_2.png" width="400" style="max-width:100%;"></a></p> 
  <p>This code creates a shared value container <code>val</code> with synchronized single access.</p> 
  <p>The equivalent <code>Chymyst</code> code looks like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">newVar</span>[<span class="pl-en">T</span>](<span class="pl-v">v0</span>: <span class="pl-en">T</span>)<span class="pl-k">:</span> (<span class="pl-en">B</span>[<span class="pl-en">T</span>, <span class="pl-k">Unit</span>], <span class="pl-en">B</span>[<span class="pl-k">Unit</span>, <span class="pl-en">T</span>]) <span class="pl-k">=</span> {
  <span class="pl-k">val</span> <span class="pl-en">put</span> <span class="pl-k">=</span> b[<span class="pl-en">T</span>, <span class="pl-k">Unit</span>] 
  <span class="pl-k">val</span> <span class="pl-en">get</span> <span class="pl-k">=</span> b[<span class="pl-k">Unit</span>, <span class="pl-en">T</span>]
  <span class="pl-k">val</span> <span class="pl-en">_val</span> <span class="pl-k">=</span> m[<span class="pl-en">T</span>] <span class="pl-c"><span class="pl-c">//</span> Will use the name `_val` since `val` is a Scala keyword.</span>

  site(
    go { <span class="pl-k">case</span> put(w, ret) <span class="pl-k">+</span> _val(v) <span class="pl-k">=&gt;</span> _val(w); ret() },
    go { <span class="pl-k">case</span> get(_, ret) <span class="pl-k">+</span> _val(v) <span class="pl-k">=&gt;</span> _val(v); ret(v) }
  )
  _val(v0)

  (put, get)
}
</pre>
  </div> 
  <h1><a id="user-content-example-dining-philosophers" class="anchor" href="https://github.com/chymyst/joinrun-scala#example-dining-philosophers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example: "dining philosophers"</h1> 
  <p>This is a complete runnable example.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.chymyst.jc.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">Main</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {
<span class="pl-c">   <span class="pl-c">/**</span></span>
<span class="pl-c">   * Print message and wait for a random time interval.</span>
<span class="pl-c">   <span class="pl-c">*/</span></span>
  <span class="pl-k">def</span> <span class="pl-en">wait</span>(<span class="pl-v">message</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    println(message)
    <span class="pl-en">Thread</span>.sleep(scala.util.<span class="pl-en">Random</span>.nextInt(<span class="pl-c1">20</span>))
  }

  <span class="pl-k">val</span> <span class="pl-en">hungry1</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">hungry2</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">hungry3</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">hungry4</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">hungry5</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">thinking1</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">thinking2</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">thinking3</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">thinking4</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">thinking5</span> <span class="pl-k">=</span> m[<span class="pl-k">Int</span>]
  <span class="pl-k">val</span> <span class="pl-en">fork12</span> <span class="pl-k">=</span> m[<span class="pl-k">Unit</span>]
  <span class="pl-k">val</span> <span class="pl-en">fork23</span> <span class="pl-k">=</span> m[<span class="pl-k">Unit</span>]
  <span class="pl-k">val</span> <span class="pl-en">fork34</span> <span class="pl-k">=</span> m[<span class="pl-k">Unit</span>]
  <span class="pl-k">val</span> <span class="pl-en">fork45</span> <span class="pl-k">=</span> m[<span class="pl-k">Unit</span>]
  <span class="pl-k">val</span> <span class="pl-en">fork51</span> <span class="pl-k">=</span> m[<span class="pl-k">Unit</span>]

  site (
    go { <span class="pl-k">case</span> thinking1(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Socrates is thinking<span class="pl-pds">"</span></span>);  hungry1() },
    go { <span class="pl-k">case</span> thinking2(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Confucius is thinking<span class="pl-pds">"</span></span>); hungry2() },
    go { <span class="pl-k">case</span> thinking3(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Plato is thinking<span class="pl-pds">"</span></span>);     hungry3() },
    go { <span class="pl-k">case</span> thinking4(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Descartes is thinking<span class="pl-pds">"</span></span>); hungry4() },
    go { <span class="pl-k">case</span> thinking5(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Voltaire is thinking<span class="pl-pds">"</span></span>);  hungry5() },

    go { <span class="pl-k">case</span> hungry1(_) <span class="pl-k">+</span> fork12(_) <span class="pl-k">+</span> fork51(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Socrates is eating<span class="pl-pds">"</span></span>);  thinking1() <span class="pl-k">+</span> fork12() <span class="pl-k">+</span> fork51() },
    go { <span class="pl-k">case</span> hungry2(_) <span class="pl-k">+</span> fork23(_) <span class="pl-k">+</span> fork12(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Confucius is eating<span class="pl-pds">"</span></span>); thinking2() <span class="pl-k">+</span> fork23() <span class="pl-k">+</span> fork12() },
    go { <span class="pl-k">case</span> hungry3(_) <span class="pl-k">+</span> fork34(_) <span class="pl-k">+</span> fork23(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Plato is eating<span class="pl-pds">"</span></span>);     thinking3() <span class="pl-k">+</span> fork34() <span class="pl-k">+</span> fork23() },
    go { <span class="pl-k">case</span> hungry4(_) <span class="pl-k">+</span> fork45(_) <span class="pl-k">+</span> fork34(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Descartes is eating<span class="pl-pds">"</span></span>); thinking4() <span class="pl-k">+</span> fork45() <span class="pl-k">+</span> fork34() },
    go { <span class="pl-k">case</span> hungry5(_) <span class="pl-k">+</span> fork51(_) <span class="pl-k">+</span> fork45(_) <span class="pl-k">=&gt;</span> wait(<span class="pl-s"><span class="pl-pds">"</span>Voltaire is eating<span class="pl-pds">"</span></span>);  thinking5() <span class="pl-k">+</span> fork51() <span class="pl-k">+</span> fork45() }
  )
  <span class="pl-c"><span class="pl-c">//</span> Emit molecules representing the initial state:</span>
  thinking1() <span class="pl-k">+</span> thinking2() <span class="pl-k">+</span> thinking3() <span class="pl-k">+</span> thinking4() <span class="pl-k">+</span> thinking5()
  fork12() <span class="pl-k">+</span> fork23() <span class="pl-k">+</span> fork34() <span class="pl-k">+</span> fork45() <span class="pl-k">+</span> fork51()
  <span class="pl-c"><span class="pl-c">//</span> Now reactions will start and print to the console.</span>
}
</pre>
  </div> 
  <h2><a id="user-content-comparison-chemical-machine-vs-actor-model" class="anchor" href="https://github.com/chymyst/joinrun-scala#comparison-chemical-machine-vs-actor-model" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Comparison: chemical machine vs. Actor model</h2> 
  <p>Chemical machine programming is similar in some aspects to the well-known Actor model (e.g. the <a href="https://github.com/akka/akka" target="_blank">Akka framework</a>).</p> 
  <table>
   <thead> 
    <tr> 
     <th>Chemical machine</th> 
     <th>Actor model</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>molecules carry values</td> 
     <td>messages carry values</td> 
    </tr> 
    <tr> 
     <td>reactions wait to receive certain molecules</td> 
     <td>actors wait to receive certain messages</td> 
    </tr> 
    <tr> 
     <td>synchronization is implicit in molecule emission</td> 
     <td>synchronization is implicit in message-passing</td> 
    </tr> 
    <tr> 
     <td>reactions start when molecules are available</td> 
     <td>actors start running when a message is received</td> 
    </tr> 
   </tbody>
  </table> 
  <p>Main differences between the chemical machine and the Actor model:</p> 
  <table>
   <thead> 
    <tr> 
     <th>Chemical machine</th> 
     <th>Actor model</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>several concurrent reactions start automatically whenever several input molecules are available</td> 
     <td>a desired number of concurrent actors must be created and managed manually</td> 
    </tr> 
    <tr> 
     <td>the user's code only manipulates molecules</td> 
     <td>the user's code must manipulate explicit references to actors as well as messages</td> 
    </tr> 
    <tr> 
     <td>reactions typically wait for (and consume) several input molecules at once</td> 
     <td>actors wait for (and consume) only one input message at a time</td> 
    </tr> 
    <tr> 
     <td>reactions are immutable and stateless, all data is stored on molecules (which are also immutable)</td> 
     <td>actors can mutate (‚Äúbecome another actor‚Äù); actors can hold mutable state</td> 
    </tr> 
    <tr> 
     <td>molecules are held in an unordered bag and processed in random order</td> 
     <td>messages are held in an ordered queue (mailbox) and processed in the order received</td> 
    </tr> 
    <tr> 
     <td>molecule data is statically typed</td> 
     <td>message data is untyped</td> 
    </tr> 
   </tbody>
  </table> 
  <h2><a id="user-content-comparison-chemical-machine-vs-csp" class="anchor" href="https://github.com/chymyst/joinrun-scala#comparison-chemical-machine-vs-csp" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Comparison: chemical machine vs. CSP</h2> 
  <p>CSP (Communicating Sequential Processes) is another approach to declarative concurrency, used today in the Go programming language.</p> 
  <p>Similarities:</p> 
  <p>The channels of CSP are similar to blocking molecules: sending a message will block until a process can be started that consumes the message and replies with a value.</p> 
  <p>Differences:</p> 
  <p>The chemical machine admits only one reply to a blocking channel; CSP can open a channel and send many messages to it.</p> 
  <p>The chemical machine will start processes automatically and concurrently whenever input molecules are available. In CSP, the user needs to create and manage new threads manually.</p> 
  <p>JC has non-blocking channels as a primitive construct. In CSP, non-blocking channels need to be simulated by <a href="https://gobyexample.com/non-blocking-channel-operations" target="_blank">additional user code</a>.</p> 
  <h1><a id="user-content-status" class="anchor" href="https://github.com/chymyst/joinrun-scala#status" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Status</h1> 
  <p>The library JAR is published to Maven Central.</p> 
  <p>The semantics of the chemical machine (restricted to single-host, multicore computations) is fully implemented and tested.</p> 
  <p>Extensive tutorial and usage documentation is available.</p> 
  <p>Unit tests include examples such as concurrent counters, parallel ‚Äúor‚Äù, concurrent merge-sort, and ‚Äúdining philosophers‚Äù. Test coverage is 100% according to <a href="https://codecov.io/gh/Chymyst/joinrun-scala?branch=master" target="_blank">codecov.io</a>.</p> 
  <p>Performance benchmarks indicate that <code>Chymyst Core</code> can schedule about 10,000 reactions per second per CPU core, and the performance bottleneck is in submitting jobs to threads (a distant second bottleneck is pattern-matching in the internals of the library).</p> 
  <p>Known limitations:</p> 
  <ul> 
   <li><code>Chymyst Core</code> is about 2x slower than Jiansen He's <code>ScalaJoin</code> on the blocking molecule benchmark, and about 1.2x slower on some non-blocking molecule benchmarks.</li> 
   <li><code>Chymyst Core</code> has no fairness with respect to the choice of molecules: If a reaction could proceed with many alternative sets of input molecules, the input molecules are not chosen at random.</li> 
   <li><code>Chymyst Core</code> has no distributed execution (Jiansen He's <code>Disjoin.scala</code> is not ported to <code>Chymyst</code>, and probably will not be). Distributed computation should be implemented in a better way than posting channel names on an HTTP server. (However, <code>Chymyst Core</code> will use all cores on a single machine.)</li> 
  </ul> 
  <h1><a id="user-content-run-unit-tests" class="anchor" href="https://github.com/chymyst/joinrun-scala#run-unit-tests" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Run unit tests</h1> 
  <p><code>sbt test</code></p> 
  <p>The tests will print some error messages and exception stack traces - this is normal, as long as all tests pass.</p> 
  <p>Some tests are timed and will fail on a slow machine.</p> 
  <h1><a id="user-content-build-the-benchmark-application" class="anchor" href="https://github.com/chymyst/joinrun-scala#build-the-benchmark-application" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Build the benchmark application</h1> 
  <p><code>sbt benchmark/run</code> will run the benchmarks.</p> 
  <p>To build the benchmark application as a self-contained JAR, run</p> 
  <p><code>sbt benchmark/assembly</code></p> 
  <p>Then run it as</p> 
  <p><code>java -jar benchmark/target/scala-2.11/benchmark-assembly-*.jar</code></p> 
  <h1><a id="user-content-build-the-library-jars" class="anchor" href="https://github.com/chymyst/joinrun-scala#build-the-library-jars" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Build the library JARs</h1> 
  <p>To build the library JARs:</p> 
  <pre><code>sbt core/package core/package-doc

</code></pre> 
  <p>This will prepare JAR assemblies as well as their Scaladoc documentation packages.</p> 
  <p>The main library is in the <code>core</code> JAR assembly (<code>core/target/scala-2.11/core-*.jar</code>). User code should depend on that JAR only.</p> 
  <h1><a id="user-content-use-chymyst-core-in-your-programs" class="anchor" href="https://github.com/chymyst/joinrun-scala#use-chymyst-core-in-your-programs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Use <code>Chymyst Core</code> in your programs</h1> 
  <p><code>Chymyst Core</code> is published to Maven Central. Add this to your <code>build.sbt</code> at the appropriate place:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
  <span class="pl-s"><span class="pl-pds">"</span>io.chymyst<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>latest.integration<span class="pl-pds">"</span></span>
)
</pre>
  </div> 
  <p>To use the chemical machine DSL, do <code>import io.chymyst.jc._</code> in your Scala sources.</p> 
  <p>See the <a href="https://github.com/Chymyst/helloworld" target="_blank">"hello, world" project</a> for a complete minimal example.</p> 
 </article>
</div>