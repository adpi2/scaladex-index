<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/matt-gardner/pra" target="_blank"><img src="https://camo.githubusercontent.com/20e1c5aed8f082b8eb26c39da7accc43d5eb6ed9/68747470733a2f2f7472617669732d63692e6f72672f6d6174742d676172646e65722f7072612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/matt-gardner/pra.svg?branch=master" style="max-width:100%;"></a> <a href="https://coveralls.io/github/matt-gardner/pra?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/cd58004fe0a6a7f315257da0654256e7697622f2/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6769746875622f6d6174742d676172646e65722f7072612f62616467652e7376673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/github/matt-gardner/pra/badge.svg?branch=master" style="max-width:100%;"></a></p> 
  <h1><a id="user-content-pra-path-ranking-algorithm-and-sfe-subgraph-feature-extraction" class="anchor" href="https://github.com/matt-gardner/pra#pra-path-ranking-algorithm-and-sfe-subgraph-feature-extraction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>PRA (Path Ranking Algorithm) and SFE (Subgraph Feature Extraction)</h1> 
  <p>PRA and SFE are algorithms that extract feature matrices from graphs, and use those feature matrices to do link prediction in that graph. This repository contains implementations of PRA and SFE, as used in the following papers (among others):</p> 
  <ul> 
   <li>Efficient and Expressive Knowledge Base Completion Using Subgraph Feature Extraction. Matt Gardner and Tom Mitchell. EMNLP 2015. (<a href="http://rtw.ml.cmu.edu/emnlp2015_sfe" target="_blank">website</a>)</li> 
   <li>Incorporating Vector Space Similarity in Random Walk Inference over Knowledge Bases. Matt Gardner, Partha Talukdar, Jayant Krishnamurthy, and Tom Mitchell. EMNLP 2014. (<a href="http://rtw.ml.cmu.edu/emnlp2014_vector_space_pra" target="_blank">website</a>)</li> 
   <li>Improving Learning and Inference in a Large Knowledge-base using Latent Syntactic Cues. Matt Gardner, Partha Talukdar, Bryan Kisiel, and Tom Mitchell. EMNLP 2013. (<a href="http://rtw.ml.cmu.edu/emnlp2013_pra" target="_blank">website</a>)</li> 
  </ul> 
  <p>To reproduce the experiments in those papers, see the corresponding website. Note that the EMNLP 2015 paper has the most detailed instructions, and the older papers use versions of the code that aren't compatible with the current repository; if you really want to reproduce the older experiments, talk to me.</p> 
  <p>See <a href="http://matt-gardner.github.io/pra/" target="_blank">the github.io page</a> for code documentation. Please feel free to file bugs, feature requests, or send pull requests.</p> 
  <p>If the Travis CI badge above says that the build is failing, just click on the badge, go to <code>Build History</code>, and find the most recent commit with a passing build, and check that one out to use the code. Or, if you're using this as a library, just specify the most recent released version in your library dependencies with <code>sbt</code> or <code>mvn</code>, and it should be based on a passing build (see the changelog below for the most recent version).</p> 
  <h1><a id="user-content-note" class="anchor" href="https://github.com/matt-gardner/pra#note" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>NOTE</h1> 
  <p>This code generally takes quite a bit of memory. That's probably a byproduct of how it was developed; I typically use a machine that has 400GB of RAM, so I don't need to worry too much about how much memory the code is using. That means I probably do some things that are memory inefficient; on NELL graphs, the code can easily use upwards of 40GB. On larger graphs, and with various parameter settings, it can easily use much more than that. With small graphs, though, I can successfully run the code on a machine that only has 8GB of RAM. This needs some work to be made more memory efficient on larger graphs. It should be straightforward to implement a stochastic gradient training regime, for instance, that would allow for much more memory-efficient computation.</p> 
  <h1><a id="user-content-license" class="anchor" href="https://github.com/matt-gardner/pra#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h1> 
  <p>This code makes use of a number of other libraries that are distributed under various open source licenses (notably the Apache License and the Common Public License). You can see those dependencies listed in the build.sbt file. The code under the src/ directory is distributed under the terms of the GNU General Public License, version 3 (or, at your choosing, any later version of that license). You can find the text of that license <a href="http://www.gnu.org/licenses/gpl-3.0.txt" target="_blank">here</a>.</p> 
  <h1><a id="user-content-changelog" class="anchor" href="https://github.com/matt-gardner/pra#changelog" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changelog</h1> 
  <p>Version 3.4 (released on 8/26/2016):</p> 
  <ul> 
   <li> <p>Migrated the graph creation code to using the pipeline architecture from my util library.</p> </li> 
   <li> <p>Added a node pair feature extractor inspired by one of the node feature extractors.</p> </li> 
  </ul> 
  <p>Version 3.3 (released on 3/22/2016):</p> 
  <ul> 
   <li> <p>Integrated this github repo with Travis CI and coveralls (as seen in the badges at the top of this README).</p> </li> 
   <li> <p>Implemented a kind of PathFollower for SFE - that is, given a node in the graph, and a set of features, find all other nodes that are reachable by those features. This is both easier and more complicated than the PathFollower in PRA; we don't have to compute probabilities, but we do potentially have more complicated features that make this computation difficult (I'm planning on punting on the complicated ones for now...). Currently implemented and tested for a few simple feature extractors.</p> </li> 
  </ul> 
  <p>Version 3.2 (released on 1/21/2016):</p> 
  <ul> 
   <li> <p>Allow for feature extraction and classification over <em>nodes</em> in the graph, instead of only <em>node pairs</em>. This means that in addition to classifying <em>relations</em> between two entities, you can now also classify entity <em>types</em> based on the features of your graph.</p> </li> 
   <li> <p>Made a change in how feature matrices are computed with SubgraphFeatureGenerator, which saves a whole lot of memory, especially on large datasets. Previously, all of the intermediate graph structures for all training / test instances would be kept in memory when computing a feature matrix, and this could get very unwieldy. Now we compute them one at a time, only keeping the final feature vector.</p> </li> 
   <li> <p>Implemented remote graphs. This means that if you have a really large graph that takes a long time to load, or is too big to fit in memory along with all of your feature computation, you can start a graph server once somewhere and let it run, while just passing the code a reference to where the server is running. The trouble is that it's <em>way</em> too slow. To make this really feasible, I need to push more of the computation to the graph, so you don't have to do so much socket communication (i.e., make a remote BfsPathFinder, or SubgraphFeatureGenerator). I did significantly increase the efficiency of loading the graph and storing it in memory as part of this, so runtimes improve quite a bit, at least.</p> </li> 
  </ul> 
  <p>Version 3.1 (released on 11/9/2015):</p> 
  <ul> 
   <li> <p>Started work on getting SGD training for PRA/SFE. There is a lot there in the code to make this work, and some aspects already do. In fact, you can run with an SGD model right now, if you want, it just doesn't work that well. I haven't figured out parameters / learning rates / momentum / whatever to make the SGD training actually perform as well as MALLET's batch training. Hopefully, though, figuring this out will allow for much improved memory requirements in the code.</p> </li> 
   <li> <p>Some improvements on the Graph object API, with the end goal of allowing the graph to live on a remote server, among other graph variations.</p> </li> 
   <li> <p>Removed the utility code into its own repository, which is now a dependency. This was so I could use those utilities in other projects I'm working on.</p> </li> 
   <li> <p>Some general efficiency improvements, that so far seem to lead to a ~20% reduction in both running time and memory usage.</p> </li> 
  </ul> 
  <p>Version 3.0 (released on 5/30/2015):</p> 
  <ul> 
   <li> <p>More refinement on the parameter specification (hence the larger version bump, as the parameter files are not compatible with previous versions). This nests parameters in the specification file according to how they are used in the code, and makes some things in the code <em>way</em> simpler. I think the specification is also conceptually cleaner, but maybe someone else would just think it's more verbose...</p> </li> 
   <li> <p>A lot of code moved to scala, and in the process some of it became more configurable.</p> </li> 
   <li> <p>It could still use some more versatility, but there are some improvements to how the graph works - there's a setting where you can keep the graph in memory, for instance, instead of using GraphChi to do random walks over the graph on disk. You can also make instance-specific graphs, so that each training and testing instance has its own graph to use. These need to be pretty small for this to make sense, though.</p> </li> 
   <li> <p>There is a new mechanism for selecting negative examples, using personalized page rank to select them instead of PRA's random walks. It turns out that it doesn't affect PRA's performance at all, really, but it allows for a better test scenario, and it allows for comparing methods on the same training data, where some other method isn't capable of selecting its own negative examples.</p> </li> 
   <li> <p>Allowed for other learning algorithms to use PRA's feature matrix. We tried using SVMs with various kernels, and it turns out that logistic regression is better, at least on the metrics we used. And the code is set up to allow you to (relatively) easily experiment with other algorithms, if you want to.</p> </li> 
   <li> <p>Implemented a new way of creating a feature matrix over node pairs in the graph, which is simpler and easier than PRA; it's similar to just doing the first step of PRA and extracting a feature matrix from the resulting subgraphs. It's faster and works quite a bit better.</p> </li> 
  </ul> 
  <p>Version 2.0 (released on 3/4/2015):</p> 
  <ul> 
   <li> <p>Much better parameter specification. See <a href="http://matt-gardner.github.io/pra" target="_blank">the github.io page</a> for information on the new way to specify and run experiments. This totally breaks backwards compatibility with older formats, so you'll need to go read the documentation if you want to upgrade to this version.</p> </li> 
   <li> <p>Working synthetic data generation. There are a lot of parameters to play with here; see the documentation linked above for some more info.</p> </li> 
   <li> <p>A matrix multiplication implementation of the vector space random walks from the EMNLP 2014 paper. This is at least done in theory. I haven't gotten the performance to be quite as good yet, but the mechanism for doing it is in the code.</p> </li> 
   <li> <p>Better handling of JVM exit (version 1.1 and earlier tend to spit out InterruptedExceptions at you when it terminates, and most of the time won't give you back the sbt console).</p> </li> 
  </ul> 
  <p>Version 1.1 (released on 12/20/2014):</p> 
  <ul> 
   <li> <p>ExperimentScorer now shows more information. It used to only show each experiment ranked by an overall score (like MAP); now it does a significance test on those metrics, and shows a table of each experiment's performance on each individual relation in the test. ExperimentScorer is not currently very configurable, though - you have to change the code if you want to show something else. This is relatively easy, though, as the parameters are all at the top of the file. You could also write another class that calls ExperimentScorer with your own parameters, if you want.</p> </li> 
   <li> <p>Added matrix multiplication as an alternative to random walks in the path following step. This is still somewhat experimental, and more details will be forthcoming in a few months. There's a new parameter that can be specified in the param file called <code>path follower</code>. Set it to <code>matrix multiplication</code> to use the new technique. The value of this is mostly theoretical at this point, as performance is pretty much identical to using random walks, except it's slower and less scalable. I plan on getting the vector space random walk idea into the matrix multiplication code soon.</p> </li> 
   <li> <p>Removed the onlyExplicitNegatives option, because it turns out it's redundant with a setting of the matrix accept policy.</p> </li> 
   <li> <p>Started work on synthetic data generation, but it's not done yet (well, you can generate some data, but learning from it doesn't turn out as I expect. Something is up...). A final release of working synthetic data generation will have to wait until version 1.2.</p> </li> 
  </ul> 
 </article>
</div>