<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-jooq-scala-mappingss" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#jooq-scala-mappingss" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>JOOQ-scala-mappingss</h1> 
  <p>All the <a href="http://www.jooq.org" target="_blank">JOOQ</a> power, in the <a href="http://www.scala-lang.org/" target="_blank">scala</a> world.</p> 
  <h3><a id="user-content-why" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#why" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why?</h3> 
  <hr> 
  <p>JOOQ is a great tool for accessing SQL stores. It's expressive and powerful. But sometimes you will find yourself building some stuff that could be facilitated for simple use cases. That's the motivation to start this project, using scala macros.</p> 
  <h3><a id="user-content-installation" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h3> 
  <hr> 
  <p>Add this definition to the <strong>build.sbt</strong></p> 
  <pre><code>libraryDependencies ++= Seq(
    "org.jooq"                     %  "jooq"               % "3.6.2",
    "org.jooq"                     %  "jooq-meta"          % "3.6.2",
    "com.github.gabadi.scalajooq" %% "jooq-scala-mappings" % "0.0.3"
)
</code></pre> 
  <p><strong>Important</strong>: Depends on scala 2.11 (there is no scala 2.10 version, at least today), and jooq 3.6.1 or greater with the scala codegen.</p> 
  <h3><a id="user-content-functionalities" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#functionalities" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Functionalities</h3> 
  <hr> 
  <ol> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#record-to-entity-mapping" target="_blank">Record to entities mappings</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#entity-to-record-mapping" target="_blank">Entity to record mappings</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#scala-option-support" target="_blank">Scala option support</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#implicit-type-conversion" target="_blank">Implicit type conversion</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#embedded-entities" target="_blank">Embedded entities</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#base-dao-functionality" target="_blank">Base DAO functionality</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#base-query-generator" target="_blank">Base query generator</a></li> 
   <li><a href="https://github.com/gabadi/jooq-scala-mappings#one-to-one-many-to-one-support" target="_blank">One to one / many to one support</a></li> 
  </ol> 
  <p>More to come...</p> 
  <h3><a id="user-content-record-to-entity-mapping" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#record-to-entity-mapping" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Record to entity mapping</h3> 
  <p>Given this mysql table:</p> 
  <pre><code>CREATE TABLE `user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `first_name` varchar(50) NOT NULL,
  `last_name` varchar(50) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre> 
  <p>A mapping to this case class</p> 
  <pre><code>case class User(id: java.lang.Long,
                firstName: String, 
                lastName: String) {
}
</code></pre> 
  <p>Is as simple as:</p> 
  <pre><code>    val r = dsl.newRecord(Tables.USER)
    r setId 1l
    r setFirstName "Any name"
    r setLastName "Any lastname"

    val meta = com.github.gabadi.scalajooq.JooqMeta.metaOf[tables.User, UserRecord, User]

    val user = meta toEntity r

</code></pre> 
  <p>Note: <strong>tables.User</strong> and <strong>UserRecord</strong> were autogenerated by the jooq scala codegen.</p> 
  <p>Note: To generate the dsl instance, see the JOOQ documentation</p> 
  <p>This is not magic, this is not reflection, this is a macro. But what do I win? The answer is that now, all the runtime exceptions will be compilation exceptions. So, if for example, you have a typo in the user class like this:</p> 
  <pre><code>case class User(id: java.lang.Long,
                firsName: String, 
                lastName: String) {
}
</code></pre> 
  <p>During compilation you'll see a message like this:</p> 
  <pre><code>Mappings error:
 com.github.gabadi.scalajooq.User.firsName expects a db.test.public.tables.records.UserRecord.FIRS_NAME column, but doesn't exists
</code></pre> 
  <h3><a id="user-content-entity-to-record-mapping" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#entity-to-record-mapping" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Entity to record mapping</h3> 
  <p>The other way is valid too</p> 
  <pre><code>    val entity = User(0, "name", "last")

    val meta = com.github.gabadi.scalajooq.JooqMeta.metaOf[tables.User, UserRecord, User]

    val record = meta toRecord entity
    record.store()

</code></pre> 
  <p>Note: This the method toRecord depends in an implicit DSLContext instance</p> 
  <h3><a id="user-content-scala-option-support" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#scala-option-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scala option support</h3> 
  <p>Option values, one important feature in scala, is not supported for JOOQ until version 4.0. But with JOOQ-scala-mapping, giving this class:</p> 
  <pre><code>case class UserOption(id: java.lang.Long,
                      firstName: Option[String], 
                      lastName: Option[String]) {
}
</code></pre> 
  <p>Anyone can make a mapping like this:</p> 
  <pre><code>    val r = dsl.newRecord(Tables.USER)
    r setId 1l

    val meta = com.github.gabadi.scalajooq.JooqMeta.metaOf[tables.User, UserRecord, User]

    val user = meta toEntity r
    println(user)
</code></pre> 
  <p>With this result:</p> 
  <pre><code>    User(1, None, None)
</code></pre> 
  <p>And in the other hand, JOOQ-scala-mappings will never let you have an Entity with a null field. Instead of that, an exception will be thrown when you try to generate that entity.</p> 
  <h3><a id="user-content-implicit-type-conversion" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#implicit-type-conversion" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implicit type conversion</h3> 
  <p>The current user as defined, has a small issue. If you see the id field, you'll see that it's not a scala Long, it's a java Long. So, what if you want a standard scala <strong>Long</strong>?, or <strong>Int</strong>? or <strong>Boolean</strong>? For that, you have implicit conversions. That means that for <strong>JOOQ-scala-mappings</strong> this two entities are valid representations for the <strong>user</strong> table</p> 
  <pre><code>case class User1(id: java.lang.Long,
                 firsName: String, 
                 lastName: String) {
}
case class User2(id: Long,
                 firsName: String, 
                 lastName: String) {
}

</code></pre> 
  <h3><a id="user-content-embedded-entities" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#embedded-entities" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Embedded entities</h3> 
  <p>Ok, you need to represent a complex entity, with some other embedded entity inside... Something like this:</p> 
  <pre><code>case class Name(first: String, last: String)

case class Profile(name: Name)

case class FullUser(id: Long, profile: Profile)
</code></pre> 
  <p>This can be automatically mapped to a table like this:</p> 
  <pre><code>CREATE TABLE `full_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `profile_name_first` varchar(50),
  `profile_name_last` varchar(50),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre> 
  <p>See that the <strong>FullUser</strong> has an <strong>Id</strong> and we can call the <strong>Profile</strong> an embedded entity inside the <strong>FullUser</strong>, and the <strong>Name</strong> inside the <strong>Profile</strong> may be another embedded entity. <br> And that hierarchy can be mapped with something like this:</p> 
  <pre><code> val nameMeta = JooqMeta.namespacedMetaOf[tables.FullUser, FullUserRecord, Name]("profileName")
 val profileMeta = JooqMeta.namespacedMetaOf[tables.FullUser, FullUserRecord, Profile]("profile")
 val userMeta = JooqMeta.metaOf[tables.FullUser, FullUserRecord, FullUser]
</code></pre> 
  <p>Where the <strong>namespacedMetaOf</strong> does the magic If this seams to be too much work, we can simple do:</p> 
  <pre><code> val userMeta = JooqMeta.metaOf[tables.FullUser, FullUserRecord, FullUser]
</code></pre> 
  <p>And with only that, all the other macros will be auto generated.</p> 
  <h3><a id="user-content-base-dao-functionality" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#base-dao-functionality" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Base DAO functionality</h3> 
  <p>Now, it could be nice to have the most basic functionalities already implemented. For that there is a DAO with the most necessary methods. The usage is as simple as:</p> 
  <pre><code>  implicit lazy val userMeta = JooqMeta.metaOf[tables.User, UserRecord, User]

  lazy val userDAO = new DefaultJooqDAO[UserRecord, User]() {}
</code></pre> 
  <p>By doing so, you will have this operations already implemented:</p> 
  <pre><code>findAll(): List[User]
insert(user: User): Long
insert(user: User, more: User*): Unit
insertAll(users: Seq[User]): Unit
update(user: User): Int
update(user: User, more: User*): Int
updateAll(users: Seq[User]): Int
delete(user: User): Int
delete(user: User, more: User*): Int
deleteAll(users: Seq[User]): Int
deleteAll(): Int
deleteById(id: Long): Int
deleteById(id: Long, more: Long*): Int
deleteByIds(ids: Seq[Long]): Int
findById(id: Long): Option[User]
findByIds(id: Long, more: Long*): List[User]
findByIds(ids: Seq[Long]): List[User]
</code></pre> 
  <p>This dao implementation, works for entities with a single <strong>primaryKey</strong>, with type <strong>Long</strong> or <strong>Int</strong> and <strong>autoincremental</strong>. In case of, for example, a <strong>String</strong> <strong>primaryKey</strong>, can be resolved with:</p> 
  <pre><code>  implicit lazy val userMeta = JooqMeta.metaOf[tables.UserByCode, UserByCodeRecord, UserByCode]

  lazy val userDAO = new JooqDAO[UserByCodeRecord, String, UserByCode]() {}
</code></pre> 
  <p>Where the second type parameter in the <strong>JooqDAO</strong> indicates that this table has a <strong>String</strong> as a <strong>primaryKey</strong>. <br> Another use case, is that the <strong>User.id</strong> is not autogenerated, for example an <strong>UUID</strong>. In that case, this can resolved simply doing</p> 
  <pre><code>  implicit lazy val userMeta = JooqMeta.metaOf[tables.User, UserRecord, User]

  lazy val userDAO = new DefaultJooqDAO[UserRecord, User]() {
    override lazy val createFields = userMeta.fields
  }
</code></pre> 
  <p>This means: During creation, use all the fields of the user. Does not ignore the <strong>primaryKey</strong> like the default implementation. <br> Another use case, may be enhanced functionality, like a <strong>saveOrUpdate</strong> that depends on the SQL implementation. <br> This is an extension for <strong>saveOrUpdate</strong> in a <strong>MySQL</strong> store</p> 
  <pre><code>  class MySQLDefaultDAO [Rec &lt;: UpdatableRecord[Rec], Entity] extends DefaultJooqDAO[Rec, Entity] {
    def saveOrUpdate(e: Entity)(implicit dsl: DSLContext): Unit = {
      val createRecord = attached(e)
      val updateRecord = attached(e).into(updateFields :_*)
      dsl.insertInto(table).set(createRecord).onDuplicateKeyUpdate().set(updateRecord).execute()
    }

    def saveOrUpdate(e: Seq[Entity])(implicit dsl: DSLContext): Unit = e.foreach(saveOrUpdate)

    def saveOrUpdate(e: Entity, en: Entity*)(implicit dsl: DSLContext): Unit = saveOrUpdate(en :+ e)
  }
</code></pre> 
  <p>Now all the DAOs that extends <strong>MySQLDefaultDAO</strong> instead of <strong>DefaultJooqDAO</strong> will have the <strong>saveOrUpdate</strong> functionality. <br> <strong>Important Note:</strong> <br> All the methods definitions in the default dao, actually receives one more implicit parameter. That parameter is the <strong>Jooq DSLContext</strong> used for the dao operations. So the whole usage example should be:</p> 
  <pre><code>    val configuration = new DefaultConfiguration()
      ...
    implicit val dsl = DSL using configuration
      ...
    userDAO insert User(0l, "name", "last")
</code></pre> 
  <h3><a id="user-content-base-query-generator" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#base-query-generator" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Base query generator</h3> 
  <p>This feature is trivial in the beginning, but combined with the one-to-one, many-to-one, etc support, may be very powerful. <br> With this, a query maybe autogenerated. So, for example:</p> 
  <pre><code>  val userMeta = JooqMeta.metaOf[tables.User, UserRecord, User]
  println(userMeta.query)
</code></pre> 
  <p>Generates this code:</p> 
  <pre><code>select 
  "PUBLIC"."USER"."ID", 
  "PUBLIC"."USER"."FIRST_NAME", 
  "PUBLIC"."USER"."LAST_NAME"
from "PUBLIC"."USER"
</code></pre> 
  <p><strong>NOTE:</strong> This will autogenerate the joins for the x-to-x support</p> 
  <h3><a id="user-content-one-to-one--many-to-one-support" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#one-to-one--many-to-one-support" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>One to one / many to one support</h3> 
  <p>With this feature, it's possible to fetch eagerly a joined entity. <br> For example, giving this schema:</p> 
  <pre><code>CREATE TABLE `city` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50),
  `state_id` bigint(20),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `state` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50),
  `country_id` bigint(20),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

CREATE TABLE `country` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `name` varchar(50),
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre> 
  <p>This can be mapped with this entities and mappers</p> 
  <pre><code>case class City(id: Long, name: String, state: State)

case class State(id: Long, name: String, country: Country)

case class Country(id: Long, name: String)

...

implicit lazy val countryMeta = JooqMeta.metaOf[tables.Country, CountryRecord, Country]
implicit lazy val stateMeta = JooqMeta.metaOf[tables.State, StateRecord, State]
implicit lazy val cityMeta = JooqMeta.metaOf[tables.City, CityRecord, City]
</code></pre> 
  <p>This <strong>JooqMetas</strong> may be used with the <strong>JooqDAOs</strong>, or simply doing:</p> 
  <pre><code>   println(cityMeta.query)
</code></pre> 
  <p>will be autogenerated the following query</p> 
  <pre><code>select 
  "PUBLIC"."CITY"."ID", 
  "PUBLIC"."CITY"."NAME", 
  "PUBLIC"."STATE"."ID", 
  "PUBLIC"."STATE"."NAME", 
  "PUBLIC"."COUNTRY"."ID", 
  "PUBLIC"."COUNTRY"."NAME", 
  "PUBLIC"."STATE"."COUNTRY_ID", 
  "PUBLIC"."CITY"."STATE_ID"
from "PUBLIC"."CITY"
  join "PUBLIC"."STATE"
  on "PUBLIC"."CITY"."STATE_ID" = "PUBLIC"."STATE"."ID"
  join "PUBLIC"."COUNTRY"
  on "PUBLIC"."STATE"."COUNTRY_ID" = "PUBLIC"."COUNTRY"."ID"
</code></pre> 
  <p><strong>IMPORTANT:</strong> Only the fetching is done eagerly, but there is no cascade functionality.</p> 
  <h3><a id="user-content-next-functionalities" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#next-functionalities" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Next functionalities</h3> 
  <hr> 
  <ol> 
   <li>Custom join field</li> 
   <li>Many to many functionality</li> 
   <li>Basic query generator</li> 
  </ol> 
  <h3><a id="user-content-limitations" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#limitations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Limitations</h3> 
  <hr> 
  <ol> 
   <li>Does not support a two way relation. Something like this:</li> 
  </ol> 
  <pre><code>case class Profile(firstName: String, lastName: String)

case class User(id: Long, profile: Profile)
</code></pre> 
  <p>In this case, the <strong>User</strong> knowns the <strong>Profile</strong>. And the <strong>Profile</strong> knowns the <strong>User</strong>. So the macro can never be resolved.</p> 
  <ol> 
   <li>The current version, does not support an the same entity to be referenced twice in the same entity, like in this example.</li> 
  </ol> 
  <pre><code>case class City(id: Long, name: String)

case class Route(from: City, to: City)
</code></pre> 
  <h3><a id="user-content-contributing" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#contributing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributing</h3> 
  <hr> 
  <p>Please see <a href="https://github.com/gabadi/jooq-scala-mappings/blob/master/CONTRIBUTING.md" target="_blank">CONTRIBUTING</a></p> 
  <h3><a id="user-content-contributors" class="anchor" href="https://github.com/gabadi/jooq-scala-mappings#contributors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributors</h3> 
  <hr> 
  <ul> 
   <li><strong><a href="https://www.linkedin.com/in/ricardotellechea" target="_blank">Ricardo Tellechea</a></strong></li> 
  </ul> 
 </article>
</div>