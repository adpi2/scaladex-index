<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://travis-ci.org/davidmweber/scopus" target="_blank"><img src="https://camo.githubusercontent.com/c997991c747b29872cfff284894db820c877009e/68747470733a2f2f7472617669732d63692e6f72672f64617669646d77656265722f73636f7075732e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/davidmweber/scopus.png?branch=master" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-scopus" class="anchor" href="https://github.com/davidmweber/scopus#scopus" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scopus</h2> 
  <p>Scopus is a Scala interface to the <a href="http://www.opus-codec.org" target="_blank">Opus</a> and <a href="http://www.speex.org/" target="_blank">Speex</a> codecs. There is also a PCM "codec" which is effectively a NULL codec and is useful in testing.</p> 
  <p>It is light and thin by design and gives programmers access to the bulk of the functionality to the codecs. It uses JNI to handle the native code and works for Linux (amd64 and i386) and OSX. Benchmarks performed on the encoder show that it is 10% slower than a native C implementation. For example, on a 3.5Ghz i5, the Opus coder runs at 360 times real time (complexity factor set to 2). The Opus decoder runs at around 1600 times real time. A native benchmark shows the encoder to run at 400 times real time. The LLVM C compiler (clang v3.4) pips GCC by about 5%.</p> 
  <p>There is support for the Speex <a href="http://www.speex.org/docs/manual/speex-manual/node7.html#SECTION00740000000000000000" target="_blank">echo cancellation API</a>. Like the rest of the library, this is a thin layer over the underlying C libraries. See the tests for an example of how to use this.</p> 
  <p>The sources for Opus can be downloaded <a href="http://www.opus-codec.org/downloads/" target="_blank">here</a> and those for Speex are <a href="http://www.speex.org/downloads/" target="_blank">here</a>.</p> 
  <p>Note that the Opus codec is better in most aspects than the Speex codec. The latter demonstrates that the framework can manage multiple codecs without running into patent issues.</p> 
  <h2><a id="user-content-licensing" class="anchor" href="https://github.com/davidmweber/scopus#licensing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Licensing</h2> 
  <p>Scopus by David Weber is released under the <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</p> 
  <h2><a id="user-content-building" class="anchor" href="https://github.com/davidmweber/scopus#building" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Building</h2> 
  <p>Clone the sources and do a <code>sbt test</code>. Package and deploy as you see fit.</p> 
  <p>The native libraries can be built using the makefiles in the <code>src/native/opus directory</code>. You do need to have the Opus libraries and headers installed and copied to the appropriate native directories in the <code>resource</code> directory. You may have to customise the paths to the include file (jni.h) a little. The libraries libjni-opus.{so,dylib}, libopus.{so.0,0.dylib} and libspeex{.so.1,1.dylib} should be placed in the appropriate <code>resources/native/</code> directory. Some resources to understanding this process are:</p> 
  <ul> 
   <li><a href="https://github.com/bimargulies/jni-origin-testbed" target="_blank">Benson Margulies' JNI test bed</a> shows how to avoid <code>LD_LIBRARY_PATH</code> hell.</li> 
   <li>Read the <code>ld</code> man page, especially the bit about -rpath=$ORIGIN (Linux) and @loader_path (OSX). It makes the magic work.</li> 
   <li>For OSX, <code>otool</code> and <code>install_name_tool</code> are your friends. See <a href="http://www.tribler.org/trac/wiki/MacBinaries" target="_blank">here</a> for more details.</li> 
  </ul> 
  <p>This library explicitly copies the dynamic libraries out of the resources directory in the jar file to a unique location (something like <code>/tmp/scopus_418af7c0b63</code> on Linux systems) from where it loads them. The temporary files are deleted when the JVM exits. Note that if you have existing installations of Opus, the linker will likely find that library rather than the bundled one (demonstrated for Linux). This may cause the test cases to fail.</p> 
  <p>The Opus codec performance improves if compiled with <code>clang</code>. Configure, build and test it as follows:</p> 
  <div class="highlight highlight-source-shell">
   <pre>CC=clang CFLAGS=-O3 ./configure
make
make check</pre>
  </div> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/davidmweber/scopus#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>Scopus is available from the Sonatype Maven repo with builds for Scala 2.11 and 2.12. Add the following dependency to your sbt build:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>sonatype-public<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>https://oss.sonatype.org/content/groups/public<span class="pl-pds">"</span></span>

  libaryDependencies <span class="pl-k">+</span><span class="pl-k">=</span>  <span class="pl-s"><span class="pl-pds">"</span>za.co.monadic<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scopus<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.3.9<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Encoding a stream is pretty simple. Return types are Scala are wrapped in a <code>Try[_]</code> so it is up to you to manage errors reported by the decoder or the encoder.</p> 
  <div class="highlight highlight-source-scala">
   <pre>   <span class="pl-c"><span class="pl-c">//</span> Variable bit rate Opus encoder with discontinuous transmission</span>
   <span class="pl-k">val</span> <span class="pl-en">enc</span> <span class="pl-k">=</span> <span class="pl-en">OpusEncoder</span>(<span class="pl-en">Sf8000</span>, <span class="pl-c1">1</span>, <span class="pl-en">Audio</span>).setUseDtx(<span class="pl-c1">1</span>).setVbr(<span class="pl-c1">1</span>)  

   <span class="pl-c"><span class="pl-c">//</span> Corresponding decoder</span>
   <span class="pl-k">val</span> <span class="pl-en">dec</span> <span class="pl-k">=</span> <span class="pl-en">OpusDecoder</span>(<span class="pl-en">Sf8000</span>, <span class="pl-c1">1</span>)

   <span class="pl-k">val</span> <span class="pl-en">coded</span><span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]] <span class="pl-k">=</span> enc(<span class="pl-k">new</span> <span class="pl-en">Array</span>[<span class="pl-k">Short</span>](<span class="pl-c1">160</span>))
   <span class="pl-c"><span class="pl-c">//</span> Transmit</span>

   <span class="pl-c"><span class="pl-c">//</span> On receive end</span>
   <span class="pl-k">val</span> <span class="pl-en">decoded</span><span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">Array</span>[<span class="pl-k">Short</span>]] <span class="pl-k">=</span> dec(coded.get)

   <span class="pl-c"><span class="pl-c">//</span> Send decoded packet off</span></pre>
  </div> 
  <p>Using the Speex codec is very similar. </p> 
  <div class="highlight highlight-source-scala">
   <pre>   <span class="pl-k">val</span> <span class="pl-en">enc</span> <span class="pl-k">=</span> <span class="pl-en">SpeexEncoder</span>(<span class="pl-en">Sf8000</span>)

   <span class="pl-k">val</span> <span class="pl-en">dec</span> <span class="pl-k">=</span> <span class="pl-en">SpeexDecoder</span>(<span class="pl-en">Sf8000</span>)

   <span class="pl-k">val</span> <span class="pl-en">coded</span><span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]] <span class="pl-k">=</span> enc(<span class="pl-k">new</span> <span class="pl-en">Array</span>[<span class="pl-k">Short</span>](<span class="pl-c1">160</span>))
   <span class="pl-c"><span class="pl-c">//</span> Transmit</span>

   <span class="pl-c"><span class="pl-c">//</span> On receive end</span>
   <span class="pl-k">val</span> <span class="pl-en">decoded</span><span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">Array</span>[<span class="pl-k">Short</span>]] <span class="pl-k">=</span> dec(coded.get)

   <span class="pl-c"><span class="pl-c">//</span> Send decoded packet off</span></pre>
  </div> 
  <p>There are restrictions on the size of the input buffer. For Speex, all audio frames must be 20ms long. For 8kHz sampling rate, this is 20ms. For Opus, audio frames may be one of the following durations: 2.5, 5, 10, 20, 40 or 60 ms. Smaller values obviously give less delay but at the expense of slightly less efficient compression. Note that Java is big endian while most raw audio data are little endian (at least on Intel Architectures). This means you may have to do some byte swapping when reading audio streams from external sources.</p> 
  <p>Opus can handle two channels while the Speex codec is restricted to 1 channel.</p> 
  <p>Scala does not seem to have a <a href="http://grokbase.com/t/gg/scala-user/1293fwp1je/trying-to-work-with-%0Atry" target="_blank">convention for error handling</a>. I went with <a href="http://www.scala-%0Alang.org/api/2.10.3/index.html#scala.util.Try" target="_blank">Try</a>. If this is not how you think it should be done, read the link and make a case. Try can be flatmapped which is important in my application.</p> 
  <p>Future plans include adding codecs and abstracting the codec layer so they are more pluggable. Pull requests welcome.</p> 
 </article>
</div>