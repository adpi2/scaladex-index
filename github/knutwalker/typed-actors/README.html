<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://github.com/knutwalker/typed-actors/blob/master/banner.jpg" target="_blank"><img src="https://github.com/knutwalker/typed-actors/raw/master/banner.jpg" alt="banner" style="max-width:100%;"></a></p> 
  <p><a href="https://travis-ci.org/knutwalker/typed-actors" target="_blank"><img src="https://camo.githubusercontent.com/8e308e47ad28a7dbe74d795b4f3cbf060f03302e/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f6b6e757477616c6b65722f74797065642d6163746f72732f6d61737465722e737667" alt="Build Status" data-canonical-src="https://img.shields.io/travis/knutwalker/typed-actors/master.svg" style="max-width:100%;"></a> <a href="https://codecov.io/github/knutwalker/typed-actors" target="_blank"><img src="https://camo.githubusercontent.com/73ff0a2aed3f13898159b57b54ac01b40670c510/68747470733a2f2f696d672e736869656c64732e696f2f636f6465636f762f632f6769746875622f6b6e757477616c6b65722f74797065642d6163746f72732f6d61737465722e737667" alt="Coverage" data-canonical-src="https://img.shields.io/codecov/c/github/knutwalker/typed-actors/master.svg" style="max-width:100%;"></a> <a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22de.knutwalker%22%20AND%20a%3Atyped-actors*_2.11" target="_blank"><img src="https://camo.githubusercontent.com/db1f577886270126335bed65c04d3beb3e868d28/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f64652e6b6e757477616c6b65722f74797065642d6163746f72735f322e31312e7376673f6c6162656c3d6c6174657374" alt="Maven" data-canonical-src="https://img.shields.io/maven-central/v/de.knutwalker/typed-actors_2.11.svg?label=latest" style="max-width:100%;"></a> <a href="https://gitter.im/knutwalker/typed-actors" target="_blank"><img src="https://camo.githubusercontent.com/e7d34a5ce59085b65dd1bfae3c963500a3889e2c/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6769747465722d4a6f696e5f436861742d3164636537332e737667" alt="Gitter" data-canonical-src="https://img.shields.io/badge/gitter-Join_Chat-1dce73.svg" style="max-width:100%;"></a> <a href="https://www.apache.org/licenses/LICENSE-2.0" target="_blank"><img src="https://camo.githubusercontent.com/a0adaf19e4ddba6f78e90f324c0a5f56704741b5/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d4150414348455f322d677265656e2e737667" alt="Apache License" data-canonical-src="https://img.shields.io/badge/license-APACHE_2-green.svg" style="max-width:100%;"></a></p> 
  <p><strong>Note</strong>: For Akka 2.4, you have to add <code>-a24</code> to the version number. For example <code>1.1.0</code> becomes <code>1.1.0-a24</code>. The first version available for Akka 2.4 is <code>1.4.0</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">List</span>(
  <span class="pl-s"><span class="pl-pds">"</span>de.knutwalker<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>typed-actors<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.6.0<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>de.knutwalker<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>typed-actors-creator<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.6.0<span class="pl-pds">"</span></span>
)</pre>
  </div> 
  <h2><a id="user-content-documentation" class="anchor" href="https://github.com/knutwalker/typed-actors#documentation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="http://knutwalker.github.io/typed-actors/" target="_blank">Documentation</a></h2> 
  <ul> 
   <li><a href="https://github.com/knutwalker/typed-actors#motivation" target="_blank">Motivation</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#basic-usage" target="_blank">Basic Usage</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#union-typed-actors" target="_blank">Union typed actors</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#unsafe-usage" target="_blank">Unsafe Usage</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#typedactor" target="_blank">TypedActor</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#building-props" target="_blank">Building Props</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#typed-creator" target="_blank">Typed Creator</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#implementation-notes" target="_blank">Implementation Notes</a></li> 
   <li><a href="https://github.com/knutwalker/typed-actors#comparison-with-akka-typed" target="_blank">Comparison with Akka Typed</a></li> 
  </ul> 
  <h2><a id="user-content-motivation" class="anchor" href="https://github.com/knutwalker/typed-actors#motivation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Motivation</h2> 
  <p>One critique of Akka, that <a href="https://groups.google.com/d/msg/akka-user/rLKk7-D_jHQ/M_Anx7vRNhcJ" target="_blank">comes</a> up <a href="http://noelwelsh.com/programming/2013/03/04/why-i-dont-like-akka-actors/#akkas-actors-are-not-usefully-typed" target="_blank">every</a> <a href="http://stew.vireo.org/posts/I-hate-akka/" target="_blank">now</a> and <a href="http://stackoverflow.com/q/5547947/2996265" target="_blank">then</a> is the lack of type safety. Actors essentially represent a <code>PartialFunction[Any, Unit]</code> which is, from a type point of view, something of the worst you can have. It tells you nothing useful; Anything can go in, it might or might not be processed and if so, anything anywhere anytime can happen. It forgoes all the benefits of a statically typed language. There are many reasons for this though, amongst others: location transparency and <code>context.become</code>. While its true that only <code>Any</code> allows us to model <em>everything</em> that <em>can</em> happen, it doesn't mean that everything <em>will always</em> happen. Not every actor gets moved around between different nodes and changes its behavior to something completely unrelated over and over again.</p> 
  <p>So, why not tell the compiler that we know something about certain actors and have it help us? We're in a statically typed language after all. We're used to compiler support when it comes to refactoring, design and composition. Why forgo this for the sake of a feature I don't want to use.</p> 
  <p>Hence, <code>Typed Actors</code>!</p> 
  <p>Akka underwent some experiments itself, for example from <a href="http://doc.akka.io/docs/akka/2.2.0/scala/typed-channels.html" target="_blank">typed-channels</a> and <a href="http://doc.akka.io/docs/akka/2.3.0/scala/typed-actors.html" target="_blank">typed-actors</a> to <a href="http://doc.akka.io/docs/akka/2.4.0/scala/typed.html" target="_blank">akka-typed</a>. Especially the last approach, <code>Akka Typed</code> is really nice and the benefit of having an <code>ActorRef[A]</code> lead to the creation of this library.</p> 
  <p><code>Typed Actors</code> has the following goals:</p> 
  <ul> 
   <li>add a compile-time layer to existing <code>ActorRef</code>s with minimal runtime overhead</li> 
   <li>be compatible with all of the existing Akka modules, traits, and extensions in terms of composition and behavior</li> 
  </ul> 
  <p>and the following non-goals:</p> 
  <ul> 
   <li>enforce an impenetrable mantle of types, don't fight the users knowledge about the actor system, those <em>are</em> dynamic after all</li> 
   <li>support Java</li> 
  </ul> 
  <p>So, let's dive in.</p> 
  <h2><a id="user-content-basic-usage" class="anchor" href="https://github.com/knutwalker/typed-actors#basic-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Basic Usage</h2> 
  <p>To use <strong>Typed Actors</strong>, import the following:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">de.knutwalker.akka.typed.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>The underscore/wildcard import is important to bring some implicit classes into scope. These classes enable the actual syntax to use typed actors. Also, <em>Typed Actors</em> shadows some names from <code>akka.actor</code>, so you need to make sure, that you add this import <strong>after</strong> your akka imports.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">akka.actor.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">de.knutwalker.akka.typed.</span><span class="pl-v">_</span></pre>
  </div> 
  <h4><a id="user-content-actor-definition" class="anchor" href="https://github.com/knutwalker/typed-actors#actor-definition" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Actor Definition</h4> 
  <p>Using Typed Actors is, at first, similar to regular actors. It is always a good idea to define your message protocol.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">MyMessage</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">foo</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">MyMessage</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>(<span class="pl-v">bar</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">MyMessage</span>

<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">SomeOtherMessage</span></pre>
  </div> 
  <p>With that, define a regular actor.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">Actor</span> {
  <span class="pl-k">def</span> <span class="pl-en">receive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
    <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <h4><a id="user-content-actor-creation" class="anchor" href="https://github.com/knutwalker/typed-actors#actor-creation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Actor Creation</h4> 
  <p>Now, use <code>Props</code> and <code>ActorOf</code>. These are now the ones from <code>de.knutwalker.akka.typed</code>, not from <code>akka.actor</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
system<span class="pl-k">:</span> akka.actor.<span class="pl-en">ActorSystem</span> <span class="pl-k">=</span> akka<span class="pl-k">:</span><span class="pl-c">//foo</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span> <span class="pl-k">=</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>]
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(props, name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-actor<span class="pl-pds">"</span></span>)
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[props.<span class="pl-en">Message</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-260681439]</span></pre>
  </div> 
  <p>This will give you an <code>ActorRef[MyMessage]</code>.</p> 
  <p>There are three possible ways to create a <code>Props</code>, mirroring the constructors from <code>akka.actor.Props</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span> <span class="pl-k">=</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>]
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span> <span class="pl-k">=</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>](<span class="pl-k">new</span> <span class="pl-en">MyActor)</span>
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span> <span class="pl-k">=</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>](<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>])
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())</pre>
  </div> 
  <h4><a id="user-content-sending-messages" class="anchor" href="https://github.com/knutwalker/typed-actors#sending-messages" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sending messages</h4> 
  <p>Sending messages to a typed actor is the same as sending messages to an untyped on, you use <code>!</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Foo</span><span class="pl-k">:</span> foo

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Bar</span><span class="pl-k">:</span> bar</pre>
  </div> 
  <p>If you try to send a message from a different protocol, you will get a compile error. Hooray, benefit!</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">31</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-k">type</span> <span class="pl-en">mismatch</span>;
 <span class="pl-v">found</span>   : <span class="pl-en">SomeOtherMessage</span>.type
 <span class="pl-v">required</span>: ref.<span class="pl-en">Message</span>
    (which expands to)  <span class="pl-en">MyMessage</span>
       ref <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
             ^</pre>
  </div> 
  <h4><a id="user-content-ask-pattern" class="anchor" href="https://github.com/knutwalker/typed-actors#ask-pattern" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Ask pattern</h4> 
  <p>Typed actors support the ask pattern, <code>?</code>, without imports and the returned Future is properly typed. In order to achieve this, instead of sending an already instantiated type, you send a function that, given the properly typed sender, will return the message. This is usually achieved with a separate parameter list on a case class (message), typically called <code>replyTo</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyResponse</span>(<span class="pl-v">payload</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyMessage</span>(<span class="pl-v">payload</span>: <span class="pl-k">String</span>)(<span class="pl-k">val</span> <span class="pl-en">replyTo</span><span class="pl-k">:</span> <span class="pl-en">ActorRef</span>[<span class="pl-en">MyResponse</span>])</pre>
  </div> 
  <p>If you define your messages this way, you can left out the last parameter list and will get the required function. To respond, use <code>message.replyTo</code> instead of <code>sender()</code> to get the properly typed sender. Although, to be fair, <code>sender()</code> will be the same actor, it's just the untyped version. Finally, <code>?</code> requires an <code>implicit Timeout</code>, just like the regular, untyped ask.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">akka.util.</span><span class="pl-v">Timeout</span>

<span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">Actor</span> {
  <span class="pl-k">def</span> <span class="pl-en">receive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> m<span class="pl-k">@</span><span class="pl-en">MyMessage</span>(payload) <span class="pl-k">=&gt;</span> m.replyTo <span class="pl-k">!</span> <span class="pl-en">MyResponse</span>(payload)
  }
}
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">timeout</span><span class="pl-k">:</span> <span class="pl-en">Timeout</span> <span class="pl-k">=</span> <span class="pl-c1">1.</span>second</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>])
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/$a#-1898850520]</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">=</span> ref <span class="pl-k">?</span> <span class="pl-en">MyMessage</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
future<span class="pl-k">:</span> scala.concurrent.<span class="pl-en">Future</span>[<span class="pl-en">MyResponse</span>] <span class="pl-k">=</span> scala.concurrent.impl.<span class="pl-en">Promise</span>$<span class="pl-en">DefaultPromise</span><span class="pl-k">@</span>75cf45c8

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">response</span> <span class="pl-k">=</span> scala.concurrent.<span class="pl-en">Await</span>.result(future, <span class="pl-c1">1.</span>second)
response<span class="pl-k">:</span> <span class="pl-en">MyResponse</span> <span class="pl-k">=</span> <span class="pl-en">MyResponse</span>(foo)</pre>
  </div> 
  <p>Next up, learn how to mix multiple unrelated messages into the checked type.</p> 
  <h2><a id="user-content-union-typed-actors" class="anchor" href="https://github.com/knutwalker/typed-actors#union-typed-actors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Union typed actors</h2> 
  <h4><a id="user-content-unrelated-messages" class="anchor" href="https://github.com/knutwalker/typed-actors#unrelated-messages" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Unrelated Messages</h4> 
  <p>The actor messages <a href="https://github.com/knutwalker/typed-actors/blob/master/index.html#actor-definition" target="_blank">before</a> were defined as a sealed trait so that the actor can deal with all subclasses of this trait. That way the actor can deal with multiple types of messages. This works great if you're in control of the messages, unfortunately this is not always the case. Sometimes you have to write an actor that receives multiple messages that are not part of the same sealed trait, possibly because you don't own said messages. To still use <code>Typed Actors</code>, you could use <code>Any</code>, which is just as bad as using untyped actors directly. Alternatively, you could use a <a href="https://en.wikipedia.org/wiki/Sum_type" target="_blank">sum type</a> like <code>Either</code>, define the actor as <code>ActorRef[Either[A, B]]</code> and pattern match on the either in the receive block. This has some drawbacks though. First, listing more than 2 different messages with Either gets very tedious and you'll probably start writing specific custom sum types for each different set of messages and end up with sealed traits that do nothing but wrap other messages and are thus just noisy boilerplate. Second, there is a runtime overhead involved of wrapping and unwrapping the message in the sum type, i.e. you have to <code>apply</code> and <code>unapply</code> the <code>Left</code>/<code>Right</code> instances. Third, and probably the most disruptive one, you cannot send any of the summed types directly but have to wrap them at tellsite, coupling the actor to the chosen sum type. This also means, that you cannot write proxy-like actors that sit in-between other actors because you have to change the messages.</p> 
  <p><code>Typed Actors</code> offer an easy alternative, that solves all the aforementioned problems: <strong>Union Types</strong>. Both, <code>ActorRef[A]</code> and <code>Props[A]</code>, have a <code>or[B]</code> method, that turns those types into an <code>ActorRef[A | B]</code> or a <code>Props[A | B]</code>, respectively. <code>A | B</code> is a so called <a href="http://ktoso.github.io/scala-types-of-types/#union-type-span-style-color-red-span" target="_blank">union type</a> (also sometimes called a disjoint or discriminated union) meaning it is either <code>A</code> or <code>B</code>. In this regard, it serves the same purpose as <code>Either[A, B]</code>, but it is a pure type-level construct. There is no runtime value possible for <code>A | B</code>, it is intended to be used a <a href="http://ktoso.github.io/scala-types-of-types/#phantom-type" target="_blank">phantom type</a> to allow the compiler to apply specific constraints on certain methods. You, as a library user, needn't worry about this; just read <code>A | B</code> as <code>A or B</code>. As a side note, the implementation is different than the one provided by Miles, referenced in the link above and, dare I say, simpler; it's not based on Curry-Howard isomorphism and doesn't require unicode to type.</p> 
  <p>You can call <code>or</code> multiple times, creating an ever-growing union type. For example <code>ActorRef[A].or[B].or[C].or[D]</code> yields <code>ActorRef[A | B | C | D]</code>, which just reads <code>A or B or C or D</code>. There is no restriction on the length (certainly not at 22), although compile times will suffer for very large union types. This solves the first problem, enumerating many types just works naturally. To be fair, this is mainly due to the infix notation. You could write <code>A Either B Either C</code> as well, but that's just weird while <code>A | B | C</code> comes naturally. As mentioned before, <code>|</code> is a pure typelevel construct—there is no runtime value, not event a simple wrapper. This fact solves both, the aforementioned second and third issue. Since there is not even a valid runtime representation, there can be no overhead and there is no wrapping required at tellsite. Okay, enough theory – lets see union types in action.</p> 
  <h4><a id="user-content-union-types" class="anchor" href="https://github.com/knutwalker/typed-actors#union-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Union types</h4> 
  <p>First, let's define some unrelated messages. Note that these are not part of a sealed trait hierarchy.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">foo</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>(<span class="pl-v">bar</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Baz</span>(<span class="pl-v">baz</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">SomeOtherMessage</span></pre>
  </div> 
  <p>Now, let's define an actor that receives all of these messages.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">Actor</span> {
  <span class="pl-k">def</span> <span class="pl-en">receive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
    <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>)
    <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>Define a <code>Props</code> for one of those messages.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">Foo</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>[<span class="pl-en">Foo</span>, <span class="pl-en">MyActor</span>]
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">Foo</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())</pre>
  </div> 
  <p>Now just list the other message types using <code>or</code>, either on the <code>Props</code> or on a created <code>ActorRef</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props2</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span>] <span class="pl-k">=</span> props.or[<span class="pl-en">Bar</span>]
props2<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>]] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref2</span><span class="pl-k">:</span> <span class="pl-en">ActorRef</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span>] <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(props2, name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-actor<span class="pl-pds">"</span></span>)
ref2<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">ActorRef</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>]] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-1800143858]</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span><span class="pl-k">:</span> <span class="pl-en">ActorRef</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] <span class="pl-k">=</span> ref2.or[<span class="pl-en">Baz</span>]
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">ActorRef</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>],<span class="pl-en">Baz</span>]] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-1800143858]</span></pre>
  </div> 
  <p>Now you can send either one of the messages that are listed in the union type.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Foo</span><span class="pl-k">:</span> foo

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Bar</span><span class="pl-k">:</span> bar

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Baz</span>(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Baz</span><span class="pl-k">:</span> baz</pre>
  </div> 
  <p>And if you try to send a message that is not part of the type union, you will get a compile error.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">32</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-en">Cannot</span> prove that message of <span class="pl-k">type</span> <span class="pl-en">SomeOtherMessage</span>.<span class="pl-k">type</span> <span class="pl-en">is</span> a member of ref.<span class="pl-en">Message</span>.
       ref <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
           ^</pre>
  </div> 
  <p>As you can see, there are no wrappers involved. When you send the message, the compiler checks that the message you want to send is part of the union and if this checks succeeds, the compiler will allow the call to <code>!</code> (by not failing to compile). Since there can be no runtime value of the union type, there is a clear distinction for the dispatch to the check if the message itself is the specified type or a subtype thereof and the check if the message is part of the specified union type.</p> 
  <p>You can turn an actor that accepts an union type into of its subcases with <code>only</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref.only[<span class="pl-en">Foo</span>]
res4<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">Foo</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-1800143858]</span>

scala<span class="pl-k">&gt;</span> ref.only[<span class="pl-en">Bar</span>]
res5<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">Bar</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-1800143858]</span>

scala<span class="pl-k">&gt;</span> ref.only[<span class="pl-en">Baz</span>]
res6<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">Baz</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-1800143858]</span></pre>
  </div> 
  <p>Which checks the untion type as well.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref.only[<span class="pl-en">SomeOtherMessage</span>]
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">31</span><span class="pl-k">:</span> <span class="pl-v">error</span>: not <span class="pl-v">found</span>: <span class="pl-k">type</span> <span class="pl-en">SomeOtherMessage</span>
       ref.only[<span class="pl-en">SomeOtherMessage</span>]
                ^</pre>
  </div> 
  <p>Union types will return later; for now, the next part is to learn how to interact with the less safer parts of Akka.</p> 
  <h2><a id="user-content-unsafe-usage" class="anchor" href="https://github.com/knutwalker/typed-actors#unsafe-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Unsafe Usage</h2> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">typedRef</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>[<span class="pl-en">MyMessage</span>](props, name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-actor<span class="pl-pds">"</span></span>)
typedRef<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-760225152]</span></pre>
  </div> 
  <h4><a id="user-content-autoreceived-messages" class="anchor" href="https://github.com/knutwalker/typed-actors#autoreceived-messages" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Autoreceived Messages</h4> 
  <p>Some messages are automatically handled by some actors and need or cannot be provided in the actors type. One example is <code>PoisonPill</code>. To sent those kind of messages anyway, use <code>unsafeTell</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> typedRef.unsafeTell(<span class="pl-en">PoisonPill</span>)</pre>
  </div> 
  <h4><a id="user-content-switch-between-typed-and-untyped" class="anchor" href="https://github.com/knutwalker/typed-actors#switch-between-typed-and-untyped" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Switch Between Typed and Untyped</h4> 
  <p>Also, some Akka APIs require you to pass an untyped ActorRef (the regular ActorRef). You can easily turn your typed actor into an untyped one bu using <code>untyped</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">untypedRef</span> <span class="pl-k">=</span> typedRef.untyped
untypedRef<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">UntypedActorRef</span> <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-760225152]</span></pre>
  </div> 
  <p>For convenience, <code>akka.actor.ActorRef</code> is type aliased as <code>de.knutwalker.akka.typed.UntypedActorRef</code>. Similarly, you can turn any untyped ref into a typed one using <code>typed</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">typedAgain</span> <span class="pl-k">=</span> untypedRef.typed[<span class="pl-en">MyMessage</span>]
typedAgain<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-760225152]</span></pre>
  </div> 
  <p>As scala tends to infer <code>Nothing</code> as the most specific bottom type, you want to make sure to always provide a useful type.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> untypedRef.typed
res1<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">Nothing</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-760225152]</span></pre>
  </div> 
  <h4><a id="user-content-compiletime-only" class="anchor" href="https://github.com/knutwalker/typed-actors#compiletime-only" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Compiletime only</h4> 
  <p>There are no compiler checks to make sure, that the given actually is able to receive that kind of message. This signifies the point, that <strong>Typed Actors</strong> are really just a compile-time wrapper and do not carry any kind of runtime information. To further demonstrate this, you can see that both instances are actually the very same (despite the scalac warning).</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> typedRef eq untypedRef
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">29</span><span class="pl-k">:</span> <span class="pl-v">warning</span>: <span class="pl-en">AnyRef</span>{<span class="pl-k">type</span> <span class="pl-en">Message</span> <span class="pl-k">=</span> <span class="pl-en">MyMessage</span>; <span class="pl-k">type</span> <span class="pl-en">Self</span> <span class="pl-k">=</span> de.knutwalker.akka.typed.<span class="pl-en">UntypedActorRef</span>} and akka.actor.<span class="pl-en">ActorRef</span> are <span class="pl-v">unrelated</span>: they will most likely never compare equal
       typedRef eq untypedRef
                ^
res2<span class="pl-k">:</span> <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-c1">true</span></pre>
  </div> 
  <h4><a id="user-content-divergence" class="anchor" href="https://github.com/knutwalker/typed-actors#divergence" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Divergence</h4> 
  <p>This also means, that it is possible to diverge from the specified type with <code>context.become</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span> <span class="pl-k">extends</span> <span class="pl-e">Actor</span> {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">receive</span> <span class="pl-k">=</span> <span class="pl-en">LoggingReceive</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> context become <span class="pl-en">LoggingReceive</span> {
     <span class="pl-k">|</span>       <span class="pl-k">case</span> <span class="pl-en">SomeOtherMessage</span> <span class="pl-k">=&gt;</span> println(<span class="pl-s"><span class="pl-pds">"</span>received some other message<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     }
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">otherRef</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyOtherActor</span>], <span class="pl-s"><span class="pl-pds">"</span>my-other-actor<span class="pl-pds">"</span></span>)
otherRef<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-other-actor#253923972]</span>

scala<span class="pl-k">&gt;</span> otherRef <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Foo</span>(foo)

received a <span class="pl-en">Foo</span><span class="pl-k">:</span> foo
scala<span class="pl-k">&gt;</span> otherRef <span class="pl-k">!</span> <span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Bar</span>(bar)

scala<span class="pl-k">&gt;</span> otherRef <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received unhandled message <span class="pl-en">Foo</span>(baz)

scala<span class="pl-k">&gt;</span> otherRef.untyped <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">SomeOtherMessage</span>
received some other message</pre>
  </div> 
  <p>Making sure, that this cannot happen is outside of the scope of <strong>Typed Actors</strong>. There is, however, a <code>TypedActor</code> trait which tries to provide <em>some</em> help. Learn about it next.</p> 
  <h2><a id="user-content-typedactor" class="anchor" href="https://github.com/knutwalker/typed-actors#typedactor" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>TypedActor</h2> 
  <p>Having a typed reference to an actor is one thing, but how can we improve type-safety within the actor itself? <strong>Typed Actors</strong> offers a <code>trait</code> called <code>TypedActor</code> which you can extend from instead of <code>Actor</code>. <code>TypedActor</code> itself extends <code>Actor</code> but contains an abstract type member and typed receive method instead of just an untyped receive method. In order to use the <code>TypedActor</code>, you have to extend <code>TypedActor.Of[_]</code> and provide your message type via type parameter.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>], name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my-actor<span class="pl-pds">"</span></span>)
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-actor#-685633214]</span>

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Foo</span><span class="pl-k">:</span> foo

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
received a <span class="pl-en">Bar</span><span class="pl-k">:</span> bar</pre>
  </div> 
  <p>If you match on messages from a different type, you will get a compile error.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">SomeOtherMessage</span> <span class="pl-k">=&gt;</span> println(<span class="pl-s"><span class="pl-pds">"</span>received some other message<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">22</span><span class="pl-k">:</span> <span class="pl-v">error</span>: pattern <span class="pl-k">type</span> <span class="pl-en">is</span> incompatible <span class="pl-k">with</span> <span class="pl-e">expected</span> type;
 <span class="pl-v">found</span>   : <span class="pl-en">SomeOtherMessage</span>.type
 <span class="pl-v">required</span>: <span class="pl-en">MyActor</span>.<span class="pl-v">this</span>.<span class="pl-en">Message</span>
    (which expands to)  <span class="pl-en">MyMessage</span>
           <span class="pl-k">case</span> <span class="pl-en">SomeOtherMessage</span> <span class="pl-k">=&gt;</span> println(<span class="pl-s"><span class="pl-pds">"</span>received some other message<span class="pl-pds">"</span></span>)
                ^</pre>
  </div> 
  <h4><a id="user-content-divergence-1" class="anchor" href="https://github.com/knutwalker/typed-actors#divergence-1" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Divergence</h4> 
  <p>Similar to the untyped actor, <code>context.become</code> is not hidden and can still lead to diverging actors.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> context become <span class="pl-en">LoggingReceive</span> {
     <span class="pl-k">|</span>       <span class="pl-k">case</span> <span class="pl-en">SomeOtherMessage</span> <span class="pl-k">=&gt;</span> println(<span class="pl-s"><span class="pl-pds">"</span>received some other message<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     }
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">otherRef</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyOtherActor</span>], <span class="pl-s"><span class="pl-pds">"</span>my-other-actor<span class="pl-pds">"</span></span>)
otherRef<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/my-other-actor#-1609403868]</span>

scala<span class="pl-k">&gt;</span> otherRef <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)

scala<span class="pl-k">&gt;</span> otherRef <span class="pl-k">!</span> <span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Foo</span>(foo)
received a <span class="pl-en">Foo</span><span class="pl-k">:</span> foo
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Bar</span>(bar)

scala<span class="pl-k">&gt;</span> otherRef <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received unhandled message <span class="pl-en">Foo</span>(baz)

scala<span class="pl-k">&gt;</span> otherRef.untyped <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">SomeOtherMessage</span>
received some other message</pre>
  </div> 
  <h4><a id="user-content-more-typing" class="anchor" href="https://github.com/knutwalker/typed-actors#more-typing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>More Typing</h4> 
  <p>The <code>TypedActor</code> offers some more methods that ought to help with keeping within the defined type bound. There is <code>typedSelf</code>, which is the typed version of the regular <code>self</code>. Then there is <code>typedBecome</code>, the typed version of <code>context.become</code>. It takes a partial receive function, much like <code>typedReceive</code>.</p> 
  <p>Using <code>typedBecome</code>, diverging from the type bound is no longer possible</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> typedBecome {
     <span class="pl-k">|</span>       <span class="pl-k">case</span> <span class="pl-en">SomeOtherMessage</span> <span class="pl-k">=&gt;</span> println(<span class="pl-s"><span class="pl-pds">"</span>received some other message<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     }
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">31</span><span class="pl-k">:</span> <span class="pl-v">error</span>: pattern <span class="pl-k">type</span> <span class="pl-en">is</span> incompatible <span class="pl-k">with</span> <span class="pl-e">expected</span> type;
 <span class="pl-v">found</span>   : <span class="pl-en">SomeOtherMessage</span>.type
 <span class="pl-v">required</span>: <span class="pl-en">MyOtherActor</span>.<span class="pl-v">this</span>.<span class="pl-en">Message</span>
    (which expands to)  <span class="pl-en">MyMessage</span>
             <span class="pl-k">case</span> <span class="pl-en">SomeOtherMessage</span> <span class="pl-k">=&gt;</span> println(<span class="pl-s"><span class="pl-pds">"</span>received some other message<span class="pl-pds">"</span></span>)
                  ^</pre>
  </div> 
  <p>You can event get exhaustiveness checks from the compiler by using the <code>Total</code> wrapper.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Total</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">25</span><span class="pl-k">:</span> <span class="pl-v">warning</span>: <span class="pl-k">match</span> may not be exhaustive.
<span class="pl-en">It</span> would fail on the following <span class="pl-v">input</span>: <span class="pl-en">Bar</span>(_)
         <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Total</span> {
                                  ^
defined <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span></pre>
  </div> 
  <p>Please be aware of a <del>bug</del> feature that wouldn't fail on non-exhaustive checks. If you use guards in your matchers, the complete pattern is optimistically treated as exhaustive; See <a href="https://issues.scala-lang.org/browse/SI-5365" target="_blank">SI-5365</a>, <a href="https://issues.scala-lang.org/browse/SI-7631" target="_blank">SI-7631</a>, and <a href="https://issues.scala-lang.org/browse/SI-9232" target="_blank">SI-9232</a>. Note the missing non-exhaustiveness warning in the next example.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">False</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>
<span class="pl-en">False</span><span class="pl-k">:</span> <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Total</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">if</span> <span class="pl-en">False</span> <span class="pl-k">=&gt;</span>
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span></pre>
  </div> 
  <p>Unfortunately, this cannot be worked around by library code. Even worse, this would not result in a unhandled message but in a runtime match error.</p> 
  <h4><a id="user-content-working-with-union-types" class="anchor" href="https://github.com/knutwalker/typed-actors#working-with-union-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Working with Union Types</h4> 
  <p>Union typed <a href="https://github.com/knutwalker/typed-actors#union-typed-actors" target="_blank">before</a> were declared on an already existing <code>Props</code> or <code>ActorRef</code> but how can we use union types together with <code>TypedActor</code>?</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Foo</span>(<span class="pl-v">foo</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Bar</span>(<span class="pl-v">bar</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Baz</span>(<span class="pl-v">baz</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">SomeOtherMessage</span></pre>
  </div> 
  <p>(We're shadowing the previous definition of <code>Foo</code> and <code>Bar</code> here, they are reverted after this chapter).</p> 
  <p>Since union types are implemented at the type-level, there is no runtime value possible that would allow us to discriminate between those subtypes when running the receive block.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">29</span><span class="pl-k">:</span> <span class="pl-v">error</span>: constructor cannot be instantiated to expected type;
 <span class="pl-v">found</span>   : <span class="pl-en">Foo</span>
 <span class="pl-v">required</span>: de.knutwalker.akka.typed.<span class="pl-k">|</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>],<span class="pl-en">Baz</span>]
           <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
                ^
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">30</span><span class="pl-k">:</span> <span class="pl-v">error</span>: constructor cannot be instantiated to expected type;
 <span class="pl-v">found</span>   : <span class="pl-en">Bar</span>
 <span class="pl-v">required</span>: de.knutwalker.akka.typed.<span class="pl-k">|</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>],<span class="pl-en">Baz</span>]
           <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>)
                ^
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">31</span><span class="pl-k">:</span> <span class="pl-v">error</span>: constructor cannot be instantiated to expected type;
 <span class="pl-v">found</span>   : <span class="pl-en">Baz</span>
 <span class="pl-v">required</span>: de.knutwalker.akka.typed.<span class="pl-k">|</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>],<span class="pl-en">Baz</span>]
           <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>)
                ^</pre>
  </div> 
  <p>We have to do this discrimination at type-level as well. Don't worry, it's less complicated as that sound. As a side note, sum types like <code>Either</code> are sometimes referred to as tagged union, the tag being the thing that would help us to discrimite at runtime – our union type is an untagged union instead.</p> 
  <p>The basics stay the same, you still extends <code>TypedActor.Of</code> and implement <code>typedReceive</code> but this time using either <code>Union</code> or <code>TotalUnion</code>. Use <code>Union</code> if you only cover some of the union types cases and <code>TotalUnion</code> if you want to cover <em>all</em> cases. The compiler can perform exhaustiveness checks on the latter. Both methods return a builder-style object that has an <code>on</code> method that must be used to enumerate the individual subcases of the union type and you close with a call to <code>apply</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>]{ <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Bar</span>]{ <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Baz</span>]{ <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span></pre>
  </div> 
  <p>Or if you have a total function for the cases, there is a shortcut:</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .total[<span class="pl-en">Foo</span>]{ foo <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo.foo<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .total[<span class="pl-en">Bar</span>]{ bar <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar.bar<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .total[<span class="pl-en">Baz</span>]{ baz <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz.baz<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span></pre>
  </div> 
  <p>You have to provide at least one case, you cannot define an empty behavior.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">29</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-en">Cannot</span> prove that de.knutwalker.akka.typed.<span class="pl-en">TypedActor</span>.<span class="pl-en">MkPartialUnionReceive</span>.<span class="pl-en">Empty</span> <span class="pl-k">=</span><span class="pl-k">:</span><span class="pl-k">=</span> de.knutwalker.akka.typed.<span class="pl-en">TypedActor</span>.<span class="pl-en">MkPartialUnionReceive</span>.<span class="pl-en">NonEmpty</span>.
           .apply
            ^</pre>
  </div> 
  <p>If you remove one of those cases it still compiles, since <code>Union</code> does not check for exhaustiveness.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>]{ <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Baz</span>]{ <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span></pre>
  </div> 
  <p>If you switch to <code>TotalUnion</code> you can see the compiler message telling that something is missing. Unfortunately it doesn't tell you <em>which</em> case is missing exactly, although that might change in the future.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">TotalUnion</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>]{ <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Baz</span>]{ <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">31</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-en">Cannot</span> prove that de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Baz</span>] contains the same members as de.knutwalker.akka.typed.<span class="pl-k">|</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>],<span class="pl-en">Baz</span>].
           .apply
            ^</pre>
  </div> 
  <p>You can even leave out the call to <code>apply</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>]{ <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Baz</span>]{ <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span></pre>
  </div> 
  <p>Which is true for <code>TotalUnion</code> as well.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">TotalUnion</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>]{ <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Bar</span>]{ <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span>     .on[<span class="pl-en">Baz</span>]{ <span class="pl-k">case</span> <span class="pl-en">Baz</span>(baz) <span class="pl-k">⇒</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Baz: $baz<span class="pl-pds">"</span></span>) }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span></pre>
  </div> 
  <p>As you can see, you basically provide a receive block for all relevant subtypes of the union. One such receive block is typed in its input, though you cannot use the <code>Total</code> helper as this one is fixed on the complete message type, the union type itself in this case.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>](<span class="pl-en">Total</span> { <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) })
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">29</span><span class="pl-k">:</span> <span class="pl-v">error</span>: constructor cannot be instantiated to expected type;
 <span class="pl-v">found</span>   : <span class="pl-en">Foo</span>
 <span class="pl-v">required</span>: de.knutwalker.akka.typed.<span class="pl-k">|</span>[de.knutwalker.akka.typed.<span class="pl-k">|</span>[<span class="pl-en">Foo</span>,<span class="pl-en">Bar</span>],<span class="pl-en">Baz</span>]
           .on[<span class="pl-en">Foo</span>](<span class="pl-en">Total</span> { <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>) })
                                 ^</pre>
  </div> 
  <p>At any rate, the <code>Props</code> and <code>ActorRef</code> from this <code>TypedActor</code> are union typed as well.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span> <span class="pl-k">=</span> <span class="pl-en">PropsFor</span>[<span class="pl-en">MyActor</span>]
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyActor</span>#<span class="pl-en">Message</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(props)
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[props.<span class="pl-en">Message</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/$a#222597801]</span>

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Foo</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Foo</span>(foo)
received a <span class="pl-en">Foo</span><span class="pl-k">:</span> foo

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Bar</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Bar</span>(bar)
received a <span class="pl-en">Bar</span><span class="pl-k">:</span> bar

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">Baz</span>(<span class="pl-s"><span class="pl-pds">"</span>baz<span class="pl-pds">"</span></span>)
[<span class="pl-en">DEBUG</span>] received handled message <span class="pl-en">Baz</span>(baz)
received a <span class="pl-en">Baz</span><span class="pl-k">:</span> baz</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">32</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-en">Cannot</span> prove that message of <span class="pl-k">type</span> <span class="pl-en">SomeOtherMessage</span>.<span class="pl-k">type</span> <span class="pl-en">is</span> a member of ref.<span class="pl-en">Message</span>.
       ref <span class="pl-k">!</span> <span class="pl-en">SomeOtherMessage</span>
           ^</pre>
  </div> 
  <p>If you want to <code>context.become</code> with a union type there are some options.</p> 
  <ol> 
   <li>You can use the <code>Union</code>/<code>TotalUnion</code> helper as described earlier.</li> 
   <li>You can use <code>unionBecome</code> if you only want to cover <em>one</em> particular case. It is a shortcut for <code>typedBecome(Union.on[Msg]{ case ... }.apply)</code></li> 
  </ol> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">Foo</span> <span class="pl-k">|</span> <span class="pl-en">Bar</span> <span class="pl-k">|</span> <span class="pl-en">Baz</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Union</span>
     <span class="pl-k">|</span>     .on[<span class="pl-en">Foo</span>]{
     <span class="pl-k">|</span>        <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span>
     <span class="pl-k">|</span>        unionBecome.on[<span class="pl-en">Bar</span>] {
     <span class="pl-k">|</span>          <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Boo: $bar<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>        }
     <span class="pl-k">|</span>     }
     <span class="pl-k">|</span>     .apply
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyActor</span></pre>
  </div> 
  <h4><a id="user-content-stateless-actor-from-a-total-function" class="anchor" href="https://github.com/knutwalker/typed-actors#stateless-actor-from-a-total-function" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Stateless actor from a total function</h4> 
  <p>The companion object <code>TypedActor</code> has an <code>apply</code> method that wraps a total function in an actor and returns a prop for this actor.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">ActorOf</span>(<span class="pl-en">TypedActor</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Bar: $bar<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span> })
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/$b#509742201]</span></pre>
  </div> 
  <h4><a id="user-content-low-level-typedactor" class="anchor" href="https://github.com/knutwalker/typed-actors#low-level-typedactor" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Low-level TypedActor</h4> 
  <p>You can also directly extend <code>TypedActor</code>, in which case you have to implement the abstract type <code>Message</code>. The <code>Of</code> constructor just does this for you by getting all information from the defined type parameter. You want to use this you need the <code>TypedActor</code> as a trait, for example when mixing it together with other Actor traits, like <code>PersistenActor</code>. For normal use-case, extending <code>TypedActor.Of[_]</code> is encouraged.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">scala.reflect.</span><span class="pl-v">classTag</span>
<span class="pl-k">import</span> <span class="pl-v">scala.reflect.</span><span class="pl-v">classTag</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyTypedActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor</span> {
     <span class="pl-k">|</span>   <span class="pl-k">type</span> <span class="pl-en">Message</span> <span class="pl-k">=</span> <span class="pl-en">MyMessage</span>
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span>
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyTypedActor</span></pre>
  </div> 
  <p>You can even override the <code>receive</code> method, if you have to, using the <code>untypedFromTyped</code> method.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyTypedActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor</span> {
     <span class="pl-k">|</span>   <span class="pl-k">type</span> <span class="pl-en">Message</span> <span class="pl-k">=</span> <span class="pl-en">MyMessage</span>
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">receive</span> <span class="pl-k">=</span>
     <span class="pl-k">|</span>     untypedFromTyped(typedReceive)
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span>
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyTypedActor</span></pre>
  </div> 
  <p>Using this, you can mix a <code>TypedActor</code> and a <code>PersistentActor</code> together.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">import</span> <span class="pl-v">akka.persistence.</span><span class="pl-v">PersistentActor</span>
<span class="pl-k">import</span> <span class="pl-v">akka.persistence.</span><span class="pl-v">PersistentActor</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">TypedPersistentActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor</span> <span class="pl-k">with</span> <span class="pl-e">PersistentActor</span> <span class="pl-k">with</span> <span class="pl-e">ActorLogging</span> {
     <span class="pl-k">|</span>   <span class="pl-k">type</span> <span class="pl-en">Message</span> <span class="pl-k">=</span> <span class="pl-en">MyMessage</span>
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">persistenceId</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>typed-persistent-id<span class="pl-pds">"</span></span>
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">val</span> <span class="pl-en">receiveRecover</span><span class="pl-k">:</span> <span class="pl-en">Receive</span> <span class="pl-k">=</span> akka.actor.<span class="pl-en">Actor</span>.emptyBehavior
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">val</span> <span class="pl-en">typedReceive</span><span class="pl-k">:</span> <span class="pl-en">TypedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-v">foo</span>: <span class="pl-en">Foo</span> <span class="pl-k">=&gt;</span>
     <span class="pl-k">|</span>       persist(foo)(f <span class="pl-k">=&gt;</span> context.system.eventStream.publish(foo))
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">val</span> <span class="pl-en">receiveCommand</span><span class="pl-k">:</span> <span class="pl-en">Receive</span> <span class="pl-k">=</span>
     <span class="pl-k">|</span>     untypedFromTyped(typedReceive)
     <span class="pl-k">|</span> 
     <span class="pl-k">|</span>   <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">receive</span><span class="pl-k">:</span> <span class="pl-en">Receive</span> <span class="pl-k">=</span>
     <span class="pl-k">|</span>     receiveCommand
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">TypedPersistentActor</span></pre>
  </div> 
  <h4><a id="user-content-going-back-to-untyped-land" class="anchor" href="https://github.com/knutwalker/typed-actors#going-back-to-untyped-land" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Going back to untyped land</h4> 
  <p>Sometimes you have to receive messages that are outside of your protocol. A typical case is <code>Terminated</code>, but other modules and patterns have those messages as well. You can use <code>Untyped</code> to specify a regular untyped receive block, just as if <code>receive</code> were actually the way to go. <code>Untyped</code> also works with union types without any special syntax.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> <span class="pl-en">Untyped</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Terminated</span>(ref) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>$ref terminated<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>     <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
defined <span class="pl-k">class</span> <span class="pl-en">MyOtherActor</span></pre>
  </div> 
  <p>With <code>Untyped</code>, you won't get any compiler support, it is meant as an escape hatch; If you find yourself using <code>Untyped</code> all over the place, consider just using a regular <code>Actor</code> instead.</p> 
  <p>Next, learn more ways to create <code>Props</code>.</p> 
  <h2><a id="user-content-building-props" class="anchor" href="https://github.com/knutwalker/typed-actors#building-props" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Building Props</h2> 
  <h4><a id="user-content-message-type-derivation" class="anchor" href="https://github.com/knutwalker/typed-actors#message-type-derivation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Message Type Derivation</h4> 
  <p>When creating a props for a <code>TypeActor</code>, we can derive the message type and thus reduce the amount of type annotation we have to write. This is done with <code>PropsFor</code>.</p> 
  <p>Consider this typed actor.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyActor</span> <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
  <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>received a Foo: $foo<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>Using <code>Props</code> we have to repeat the information, that this actor only accepts messages of type <code>MyMessage</code>, although the compiler knows about this.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>] <span class="pl-c">// MyMessage is repetitive</span>
res0<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-en">Props</span>(<span class="pl-k">new</span> <span class="pl-en">MyActor)</span> <span class="pl-c">// message type derives as Nothing</span>
res1<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">Props</span>[<span class="pl-en">Nothing</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>](<span class="pl-k">new</span> <span class="pl-en">MyActor)</span> <span class="pl-c">// MyMessage and MyActor are repetitive</span>
res2<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-en">Props</span>(<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>]) <span class="pl-c">// message type derives as Nothing</span>
res3<span class="pl-k">:</span> <span class="pl-en">Object</span>{<span class="pl-k">type</span> <span class="pl-en">Message</span> <span class="pl-k">=</span> <span class="pl-en">Nothing</span>; <span class="pl-k">type</span> <span class="pl-en">Self</span> <span class="pl-k">=</span> akka.actor.<span class="pl-en">Props</span>} <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>, <span class="pl-en">MyActor</span>](<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>]) <span class="pl-c">// MyMessage and MyActor are repetitive</span>
res4<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())</pre>
  </div> 
  <p>When you have a <code>TypedActor</code>, you can use <code>PropsFor</code> instead of <code>Props</code> to use the type information embedded in <code>TypedActor#Message</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">PropsFor</span>[<span class="pl-en">MyActor</span>]
res5<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyActor</span>#<span class="pl-en">Message</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-en">PropsFor</span>(<span class="pl-k">new</span> <span class="pl-en">MyActor)</span>
res6<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">Props</span>[<span class="pl-en">MyActor</span>#<span class="pl-en">Message</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-en">PropsFor</span>(<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>])
res7<span class="pl-k">:</span> <span class="pl-en">Object</span>{<span class="pl-k">type</span> <span class="pl-en">Message</span> <span class="pl-k">=</span> <span class="pl-en">MyMessage</span>; <span class="pl-k">type</span> <span class="pl-en">Self</span> <span class="pl-k">=</span> akka.actor.<span class="pl-en">Props</span>} <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())</pre>
  </div> 
  <p>Of course, some of these cases can also be mitigated by using type ascription on the result type.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-k">new</span> <span class="pl-en">MyActor)</span>
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>])
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">PropsFor</span>[<span class="pl-en">MyActor</span>]
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">PropsFor</span>(<span class="pl-k">new</span> <span class="pl-en">MyActor)</span>
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">props</span><span class="pl-k">:</span> <span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">PropsFor</span>(<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>])
props<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())</pre>
  </div> 
  <h4><a id="user-content-type-currying-for-props" class="anchor" href="https://github.com/knutwalker/typed-actors#type-currying-for-props" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type Currying for Props</h4> 
  <p><code>PropsFor</code> only works with a <code>TypedActor</code>. There is yet another way to create a <code>Props</code>, that has the type information curried, <code>PropsOf</code>. With <code>PropsOf</code>, you apply once with the message type and then use one of the three ways to create a <code>Props</code>. This works for all actors</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">PropsOf</span>[<span class="pl-en">MyMessage</span>][<span class="pl-en">MyActor</span>]
res8<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())

scala<span class="pl-k">&gt;</span> <span class="pl-en">PropsOf</span>[<span class="pl-en">MyMessage</span>](<span class="pl-k">new</span> <span class="pl-en">MyActor)</span>
res9<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-en">PropsOf</span>[<span class="pl-en">MyMessage</span>](<span class="pl-c1">classOf</span>[<span class="pl-en">MyActor</span>])
res10<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">MyActor,List</span>())</pre>
  </div> 
  <p>Next, look at how you can improve type safety even further.</p> 
  <h2><a id="user-content-typed-creator" class="anchor" href="https://github.com/knutwalker/typed-actors#typed-creator" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Typed Creator</h2> 
  <p>When creating a <code>Props</code>, the preferred way is to use the <code>(Class[_], Any*)</code> overload, since this one does not create a closure. If you create a props from within an Actor using the <code>(=&gt; Actor)</code> overload, you accidentally close over the <code>ActorContext</code>, that's shared state you don't want. The problem with the constructor using <code>Class</code>, you don't get any help from the compiler. If you change one parameter, there is nothing telling you to change the Props constructor but the eventual runtime error (from your tests, hopefully).</p> 
  <p>Using shapeless, we can try to fix this issue.</p> 
  <h4><a id="user-content-using-the-creator-module" class="anchor" href="https://github.com/knutwalker/typed-actors#using-the-creator-module" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using the creator module</h4> 
  <p>The types creator lives in a <a href="http://search.maven.org/#search%7Cga%7C1%7Cg:%22de.knutwalker%22%20AND%20a:typed-actors-creator*" target="_blank">separate module</a> that you have to include first.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>de.knutwalker<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>typed-actors-creator<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.6.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Next, you <em>have</em> to use the <a href="https://github.com/knutwalker/typed-actors#typedactor" target="_blank"><code>TypedActor</code></a> trait and you <em>have</em> to make your actor a <code>case class</code>. This is necessary, so that shapeless' generic machinery can pick up the required constructor parameters.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span>(<span class="pl-v">param</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
  <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-en">Foo</span>(foo) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>$param - received a Foo: $foo<span class="pl-pds">"</span></span>)
    <span class="pl-k">case</span> <span class="pl-en">Bar</span>(bar) <span class="pl-k">=&gt;</span> println(s<span class="pl-s"><span class="pl-pds">"</span>$param - received a Bar: $bar<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>Next, use the <code>Typed</code> constructor. It takes one type parameter, which is supposed to be your <code>TypedActor</code>. Now you can use two methods, <code>props</code> and <code>create</code>. Both accept the same arguments as the constructor of your <code>TypedActor</code> and will either return a typed <code>Props</code> or typed <code>ActorRef</code>, respectively (thanks to some shapeless magic).</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].props(<span class="pl-s"><span class="pl-pds">"</span>Bernd<span class="pl-pds">"</span></span>)
res0<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">Props</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Props</span>(<span class="pl-en">Deploy</span>(,<span class="pl-en">Config</span>(<span class="pl-en">SimpleConfigObject</span>({})),<span class="pl-en">NoRouter</span>,<span class="pl-en">NoScopeGiven</span>,,),<span class="pl-k">class</span> <span class="pl-en">akka.actor.TypedCreatorFunctionConsumer,List</span>(<span class="pl-k">class</span> <span class="pl-en">MyActor,</span> &lt;<span class="pl-ent">function0</span>&gt;))

scala<span class="pl-k">&gt;</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create(<span class="pl-s"><span class="pl-pds">"</span>Bernd<span class="pl-pds">"</span></span>)
res1<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/$a#-228053190]</span>

scala<span class="pl-k">&gt;</span> <span class="pl-en">ActorOf</span>(<span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].props(<span class="pl-s"><span class="pl-pds">"</span>Bernd<span class="pl-pds">"</span></span>), <span class="pl-s"><span class="pl-pds">"</span>typed-bernd<span class="pl-pds">"</span></span>)
res2<span class="pl-k">:</span> de.knutwalker.akka.typed.package.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/typed-bernd#1603161306]</span></pre>
  </div> 
  <p>Wrong invocations are greeted with a compile error instead of a runtime error!</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create()
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">26</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-k">type</span> <span class="pl-en">mismatch</span>;
 <span class="pl-v">found</span>   : shapeless.<span class="pl-en">HNil</span>
 <span class="pl-v">required</span>: shapeless.<span class="pl-k">::</span>[<span class="pl-k">String</span>,shapeless.<span class="pl-en">HNil</span>]
       <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create()
                            ^

scala<span class="pl-k">&gt;</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create(<span class="pl-s"><span class="pl-pds">"</span>Bernd<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Ralf<span class="pl-pds">"</span></span>)
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">26</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-k">type</span> <span class="pl-en">mismatch</span>;
 <span class="pl-v">found</span>   : shapeless.<span class="pl-k">::</span>[<span class="pl-k">String</span>(<span class="pl-s"><span class="pl-pds">"</span>Bernd<span class="pl-pds">"</span></span>),shapeless.<span class="pl-k">::</span>[<span class="pl-k">String</span>(<span class="pl-s"><span class="pl-pds">"</span>Ralf<span class="pl-pds">"</span></span>),shapeless.<span class="pl-en">HNil</span>]]
 <span class="pl-v">required</span>: shapeless.<span class="pl-k">::</span>[<span class="pl-k">String</span>,shapeless.<span class="pl-en">HNil</span>]
       <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create(<span class="pl-s"><span class="pl-pds">"</span>Bernd<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Ralf<span class="pl-pds">"</span></span>)
                            ^

scala<span class="pl-k">&gt;</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create(<span class="pl-c1">42</span>)
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">26</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-k">type</span> <span class="pl-en">mismatch</span>;
 <span class="pl-v">found</span>   : shapeless.<span class="pl-k">::</span>[<span class="pl-k">Int</span>(<span class="pl-c1">42</span>),shapeless.<span class="pl-en">HNil</span>]
 <span class="pl-v">required</span>: shapeless.<span class="pl-k">::</span>[<span class="pl-k">String</span>,shapeless.<span class="pl-en">HNil</span>]
       <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create(<span class="pl-c1">42</span>)
                            ^</pre>
  </div> 
  <p>Hooray, Benefit!</p> 
  <p>As you can see, shapeless leaks in the error messages, but you can still easily see what parameters are wrong. This technique uses whitebox macros under the hood, which means that support from IDEs such as IntelliJ will be meager, so prepare for red, squiggly lines. If you open autocomplete on a <code>Typed[MyActor]</code>, you won't see the <code>create</code> or <code>props</code> methods but <code>createProduct</code> and <code>propsProduct</code>. This is a leaky implementation as well, better just ignore it and type against those IDE errors.</p> 
  <p>The next bits are about the internals and some good pratices..</p> 
  <h2><a id="user-content-implementation-notes" class="anchor" href="https://github.com/knutwalker/typed-actors#implementation-notes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementation Notes</h2> 
  <p>Typed Actors are implemented as a type tag, a structural type refinement. This is very similar to <a href="https://github.com/scalaz/scalaz/blob/81e68e845e91b54450a4542b19c1378f06aea861/core/src/main/scala/scalaz/package.scala#L90-L101" target="_blank"><code>scalaz.@@</code></a> and a little bit to <a href="https://github.com/milessabin/shapeless/blob/6c659d253ba004baf74e20d5d815729552677303/core/src/main/scala/shapeless/typeoperators.scala#L28-L29" target="_blank"><code>shapeless.tag.@@</code></a> The message type is put together with the surrounding type (<code>ActorRef</code> or <code>Props</code>) into a special type, that exists only at compile time. It carries enough type information for the compiler reject certain calls to tell while not requiring any wrappers at runtime.</p> 
  <p>The actual methods are provided by an implicit ops wrapper that extends AnyVal, so that there is no runtime overhead as well.</p> 
  <p>The union type is inspired by shapeless' <code>HNil</code> or <code>Coproduct</code>. The main differences are: 1) There is no runtime, value-level representation and as such, there is no Inr/Inl/:: constructor, it's just the type <code>|</code> (instead of <code>::</code> or <code>:+:</code> for HList and Coproduct, respectively). 2) It doesn't have an end type, a base case like <code>HNil</code> or <code>CNil</code>. Other than that, the operations around the union type are similar to what you would write if you'd define a function for an HList: There is a typeclass representing the function and some implicit induction steps that recurse on the type. There are some other union type implementations out there, including the one that is offered by shapeless itself but they often just focus on offering membership testing as functionality, while <code>Typed Actors</code> also includes a union set comparison to check whether two union types cover the same elements without them being defined in the same order.</p> 
  <h4><a id="user-content-good-practices" class="anchor" href="https://github.com/knutwalker/typed-actors#good-practices" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Good Practices</h4> 
  <p>Typed Actors does not try to prevent you from doing fancy things and shooting yourself in the foot, it rather wants to give you a way so you can help yourself in keeping your sanity. That is, you can always switch between untyped and typed actors, even if the type information is not actually corresponding to the actors implementation. It is up to you to decide how much safety you want to trade in for flexibility. That being said, you get the most benefit by using the <a href="https://github.com/knutwalker/typed-actors#typedactor" target="_blank">TypedActor</a> with the <a href="https://github.com/knutwalker/typed-actors#typed-creator" target="_blank">Typed Creator</a> and only on the <code>typedReceive</code> and <code>typedBecome</code> methods with the <code>Total</code> wrapper. Depending on the situation, you can fairly fine-tune the amount of untypedness you want to have.</p> 
  <p>One other thing that is frequently causing trouble is <code>sender()</code>. For one, it's not referentially transparent, return the sender of whatever message the Actor is currently processing. This is causing trouble when the <code>sender()</code> call happens for example in a callback attached to a <code>Future</code>. The other thing is, it's always an untyped actor and knowledge about the protocol has to be implicitly kept in the head of the developer. For that reasons, it is a good idea to always provide a <code>replyTo: ActorRef[A]</code> field in the message itself and refrain from using <code>sender()</code>, ideally ever.</p> 
  <p>An example of how this could look like. First, the counter example using <code>sender()</code> as a quasi status quo. To have a sensible <code>sender()</code> available, we're gonna use <code>akka.actor.Inbox</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">akka.actor.ActorDSL.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">box</span> <span class="pl-k">=</span> inbox()</pre>
  </div> 
  <p>This is a typical request reply cycle using <code>sender()</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyMessage</span>(<span class="pl-v">payload</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyResponse</span>(<span class="pl-v">payload</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span>() <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
  <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> <span class="pl-en">MyMessage</span>(payload) <span class="pl-k">=&gt;</span> sender() <span class="pl-k">!</span> payload.toString
  }
}</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create()
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/$a#466697111]</span>

scala<span class="pl-k">&gt;</span> box.send(ref.untyped, <span class="pl-en">MyMessage</span>(<span class="pl-c1">42</span>))</pre>
  </div> 
  <p>Note that there already is a bug, as the return message was not wrapped in <code>MyResponse</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">MyResponse</span>(response) <span class="pl-k">=</span> box.receive()
scala.<span class="pl-en">MatchError</span><span class="pl-k">:</span> <span class="pl-c1">42</span> (of <span class="pl-k">class</span> <span class="pl-en">java.lang.String)</span>
  ... <span class="pl-c1">394</span> elided</pre>
  </div> 
  <p>Here's how that looks using the <code>replyTo</code> pattern.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyResponse</span>(<span class="pl-v">payload</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyMessage</span>(<span class="pl-v">payload</span>: <span class="pl-k">Int</span>)(<span class="pl-k">val</span> <span class="pl-en">replyTo</span><span class="pl-k">:</span> <span class="pl-en">ActorRef</span>[<span class="pl-en">MyResponse</span>])
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span>() <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
  <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
    <span class="pl-k">case</span> m<span class="pl-k">@</span><span class="pl-en">MyMessage</span>(payload) <span class="pl-k">=&gt;</span> m.replyTo <span class="pl-k">!</span> <span class="pl-en">MyResponse</span>(payload.toString)
  }
}</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">ref</span> <span class="pl-k">=</span> <span class="pl-en">Typed</span>[<span class="pl-en">MyActor</span>].create()
ref<span class="pl-k">:</span> de.knutwalker.akka.typed.<span class="pl-en">ActorRef</span>[<span class="pl-en">MyMessage</span>] <span class="pl-k">=</span> <span class="pl-en">Actor</span>[akka<span class="pl-k">:</span><span class="pl-c">//foo/user/$b#1300424475]</span>

scala<span class="pl-k">&gt;</span> ref <span class="pl-k">!</span> <span class="pl-en">MyMessage</span>(<span class="pl-c1">42</span>)(box.receiver.typed)

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">MyResponse</span>(response) <span class="pl-k">=</span> box.receive()
response<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-c1">42</span></pre>
  </div> 
  <p>Let's try to reproduce the bug from earlier.</p> 
  <div class="highlight highlight-source-scala">
   <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">MyActor</span>() <span class="pl-k">extends</span> <span class="pl-e">TypedActor.Of</span>[<span class="pl-en">MyMessage</span>] {
     <span class="pl-k">|</span>   <span class="pl-k">def</span> <span class="pl-en">typedReceive</span> <span class="pl-k">=</span> {
     <span class="pl-k">|</span>     <span class="pl-k">case</span> m<span class="pl-k">@</span><span class="pl-en">MyMessage</span>(payload) <span class="pl-k">=&gt;</span> m.replyTo <span class="pl-k">!</span> payload.toString
     <span class="pl-k">|</span>   }
     <span class="pl-k">|</span> }
&lt;<span class="pl-ent">console</span>&gt;<span class="pl-k">:</span><span class="pl-c1">27</span><span class="pl-k">:</span> <span class="pl-v">error</span>: <span class="pl-k">type</span> <span class="pl-en">mismatch</span>;
 <span class="pl-v">found</span>   : <span class="pl-k">String</span>
 <span class="pl-v">required</span>: m.replyTo.<span class="pl-en">Message</span>
    (which expands to)  <span class="pl-en">MyResponse</span>
           <span class="pl-k">case</span> m<span class="pl-k">@</span><span class="pl-en">MyMessage</span>(payload) <span class="pl-k">=&gt;</span> m.replyTo <span class="pl-k">!</span> payload.toString
                                                            ^</pre>
  </div> 
  <p>Now the compiler has caught the bug, benefit!</p> 
  <p>The <code>replyTo</code> pattern is also important in <a href="http://doc.akka.io/docs/akka/snapshot/scala/typed.html" target="_blank">Akka Typed</a>.</p> 
  <h2><a id="user-content-comparison-with-akka-typed" class="anchor" href="https://github.com/knutwalker/typed-actors#comparison-with-akka-typed" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Comparison with Akka Typed</h2> 
  <p>The <a href="http://doc.akka.io/docs/akka/snapshot/scala/typed.html" target="_blank"><code>Akka Typed</code></a> project is a module of Akka (as of 2.4) which aims to provide typesafe actors as well. Akka typed takes a completely different approach, mirroring most of the untyped API and ultimately offering a completely new API to define your actors behavior. Currently, this implementation sits on top of untyped They are currently actors. Let me add that I really like Akka Typed and having worked with it for some time lead me to think about how to bring type safety to the rest of Akka.</p> 
  <p><code>Akka Typed</code> is not only about a typed <code>ActorRef[A]</code>, there's much more that's changed and is reason to use <code>Akka Typed</code>, both in general and over <code>Typed Actors</code>. It separates the behavior of your actors from its execution model, making them really easy to test; You can just use a synchronous stub execution model and you get to test just the behavior without concerning yourself about the how-to-test-this-async-thingy. The new behavior API is not just a convoluted <code>PartialFunction[A, Unit]</code> but allows you to split your behavior into nice little pieces and have them composed together. <code>Akka Typed</code>'s getting rid of some old (and bad) habits as well; <code>sender()</code> is gone, as are lifecycle methods that have to be overridden, even the <code>Actor</code> trait itself is gone. It's messages and behavior all the way down!</p> 
  <p>Those are all concerns that <code>Typed Actor</code> will never deal with, this is one important difference: <code>Typed Actors</code> is a possibility to add some compile-time checking while <code>Akka Typed</code> is a completely new API. Understandingly, <code>Akka Typed</code> is better at hiding their untyped implementation, nothing in the public API leads to the fact that something like an untyped actor could even exist.</p> 
  <p>On the other hand, having <code>Akka Typed</code> as a separate module means it is difficult to use the typed API with other modules. Most APIs expect an <code>akka.actor.ActorRef</code> and you can't get one from a akka-typed actor (well, you can, but it's dirty). This also applies to things like <code>ActorLogging</code> and <code>Stash</code>. <code>Typed Actors</code> doesn't try to prevent you from going untyped and as there is no different runtime representation, it can be easily used with all existing akka modules. However, if you mix typed/untyped code too much, you run into unhandled messages or maybe even runtime class cast exceptions or match errors (which ought to be bugs then, really).</p> 
  <p><code>Typed Actors</code> makes it easy to deal with multiple types of messages, not just one <code>A</code> thanks to its <a href="https://github.com/knutwalker/typed-actors#union-typed-actors" target="_blank">Union type</a> support. Joining multiple behavior requires them to be of the same type, although you can get far with a little bit of type-fu. Basically, you can take advantage of the covariant nature of <code>ActorRef[-A]</code> (in <code>Typed Actors</code>, ActorRef is actually invariant) and create phantom intersection types (<code>A with B</code>) and upcast at tellsite. It is, however, something different whether you as the library user has to know how to fu or I as the library author know so you don't have to.</p> 
  <p>Also, <code>Akka Typed</code> is concerned with Java interop, which <code>Typed Actors</code> is not. Nevertheless, <code>Akka Typed</code> is a – in my opinion – really nice project and its new API is a major improvement over the default <code>Actor</code>. The resulting patterns, like <code>replyTo</code> are a good idea to use with <code>Typed Actor</code>s as well.</p> 
  <p>That concludes the Usage Guide. I guess the only thing left is to go on hAkking!</p> 
  <h2><a id="user-content-disclaimer" class="anchor" href="https://github.com/knutwalker/typed-actors#disclaimer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Disclaimer</h2> 
  <p>Typed Actor is operating on a best-effort basis to catch unsafe usages of actors at compile time, as such, it may fail to succeed in this effort. It is no replacement for tests and some interoperability issue when combining multiple scala features can lead to code that should not compile, but passes anyway; Therefore the author disclaims all warranty or liability of any kind.</p> 
  <h3><a id="user-content-know-unpleasantries" class="anchor" href="https://github.com/knutwalker/typed-actors#know-unpleasantries" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Know unpleasantries</h3> 
  <p>Due to <code>PartialFunction</code> being contravariant in its input, <code>Receive &lt;: TypedReceive</code> is true. If you have a receive block that is statically known to be a <code>Receive</code> it can be passed without any warning to <code>typedReceive</code> or other methods that actually accept a <code>TypedReceive</code>. This is a failed compiler check, there is no runtime error (if it is, it's a bug).</p> 
  <p>Scala sometime fails to perform exhaustiveness checks for total functions an various grounds. For example, <code>val f: String =&gt; Unit = { case "foo" =&gt; () }</code> compiles just fine. The exhaustiveness guarantees of various <code>total</code> combinators rely soley on scalac for their checks. Therefore, if scalac doesn't warn, Typed Actors also doesn't warn.</p> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/knutwalker/typed-actors#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>This code is open source software licensed under the Apache 2.0 License.</p> 
 </article>
</div>