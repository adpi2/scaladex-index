<div class="announce instapaper_body md" data-path="readme.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-sparse-text-parsing-for-scala" class="anchor" href="https://github.com/mb720/sparse#sparse-text-parsing-for-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Sparse: text parsing for Scala</h1> 
  <p>You can use <code>Sparse</code> to parse text blocks from files and other <a href="http://www.scala-lang.org/api/current/index.html#scala.io.Source" target="_blank">sources</a>.</p> 
  <p><a href="https://travis-ci.org/mb720/sparse" target="_blank"><img src="https://camo.githubusercontent.com/6cf70dd6406c912098da62fa65e2c89064d7b5f6/68747470733a2f2f7472617669732d63692e6f72672f6d623732302f7370617273652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/mb720/sparse.svg?branch=master" style="max-width:100%;"></a></p> 
  <p><a href="https://maven-badges.herokuapp.com/maven-central/eu.matthiasbraun/sparse" target="_blank"><img src="https://camo.githubusercontent.com/6d56bceaa1f16dfa8e83c6f58fe4cbc5e9bc0294/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f65752e6d61747468696173627261756e2f7370617273652f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/eu.matthiasbraun/sparse/badge.svg" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-get-sparse" class="anchor" href="https://github.com/mb720/sparse#get-sparse" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Get Sparse</h2> 
  <p>First, add <code>Sparse</code> as an dependency in your project's <code>build.sbt</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>eu.matthiasbraun<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>sparse<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Then you can import its methods and objects:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">eu.matthiasbraun.sparse.Parser.</span><span class="pl-v">_</span></pre>
  </div> 
  <h2><a id="user-content-usage-examples" class="anchor" href="https://github.com/mb720/sparse#usage-examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage examples</h2> 
  <h3><a id="user-content-basic" class="anchor" href="https://github.com/mb720/sparse#basic" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Basic</h3> 
  <p>Let's say the file you want to parse is this:</p> 
  <pre><code>(unrelated text before first block)
start
  first line in first block
  second line in first block
end

(unrelated text before second block)
start
  first line in second block
  second line in second block
end

(more unrelated text)
</code></pre> 
  <p>Assuming that you're interested in the blocks that start with <code>start</code> and end with <code>end</code>, here's how you parse them: First of all, you load that file using one of the methods in <a href="http://www.scala-lang.org/api/current/index.html#scala.io.Source$" target="_blank">scala.io.Source</a>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">yourFile</span> <span class="pl-k">=</span> fromFile(<span class="pl-k">new</span> <span class="pl-en">File</span>(<span class="pl-s"><span class="pl-pds">"</span>parse/this/file<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>In the case of our example file above, we know exactly how the start and end of a block looks like. So we can do the following to parse the two blocks from the file:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">blocksMaybe</span> <span class="pl-k">=</span> parse(yourFile, from(<span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>), to(<span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>And this is how you print the blocks:</p> 
  <div class="highlight highlight-source-scala">
   <pre>blocksMaybe <span class="pl-k">match</span> {
  <span class="pl-k">case</span> <span class="pl-en">Success</span>(blocks)    <span class="pl-k">=&gt;</span> blocks.foreach { println }
  <span class="pl-k">case</span> <span class="pl-en">Failure</span>(exception) <span class="pl-k">=&gt;</span> println(exception)
}</pre>
  </div> 
  <p>We got a <a href="http://www.scala-lang.org/api/current/index.html#scala.util.Try" target="_blank"><code>Try</code></a> back from <code>parse</code> which contains, if the parsing was successful, the blocks from the parsed file. The first block we got back is this:</p> 
  <pre><code>start
  first line in first block
  second line in first block
end
</code></pre> 
  <p>Probably, the second block won't surprise you, but here it is for completeness' sake:</p> 
  <pre><code>start
  first line in second block
  second line in second block
end
</code></pre> 
  <p>Otherwise, if something went wrong, the <code>Try</code> holds the first exception that occurred during parsing.</p> 
  <p>Should you be interested only in what's <em>inside</em> the blocks, and not in the lines that mark their beginning and their end, you might like to call <code>parse</code> like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>parse(yourFile, after(<span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>), until(<span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>The first block returned by that call is a bit different compared to the one we made using <code>to</code> and <code>from</code>:</p> 
  <pre><code>first line in first block
second line in first block
</code></pre> 
  <p>Up till now you've seen <code>from</code>, <code>to</code>, <code>after</code>, and <code>until</code> to mark the start and end point of your blocks.</p> 
  <p>There is another one, <code>before</code>, that you can use if you're interested in the line that precedes the matching line.</p> 
  <p>The resulting blocks of</p> 
  <div class="highlight highlight-source-scala">
   <pre>parse(yourFile, before(<span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>), until(<span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>are</p> 
  <pre><code>(unrelated text before second block)
start
  first line in first block
  second line in first block
</code></pre> 
  <p>and</p> 
  <pre><code>(unrelated text before second block)
start
  first line in second block
  second line in second block
</code></pre> 
  <h3><a id="user-content-intermediate" class="anchor" href="https://github.com/mb720/sparse#intermediate" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Intermediate</h3> 
  <p>If the starts and the ends of your blocks vary you can define <strong>predicates</strong> to match them.</p> 
  <p>Let's change our example file a bit, to make parsing slightly more challenging:</p> 
  <pre><code>blockStartPrefix: firstBlockHeader
  first line in first block
  second line in first block
end

blockStartPrefix: secondBlockHeader
  first line in second block
  second line in second block
end
</code></pre> 
  <p>Now, because the start of a block is different for each block, we can't match it verbatim as we did in the previous example. But we notice that beginnings of a block all share a common <code>blockStartPrefix</code>. Let's match that:</p> 
  <div class="highlight highlight-source-scala">
   <pre>parse(yourFile, from(_.startsWith(<span class="pl-s"><span class="pl-pds">"</span>blockStartPrefix<span class="pl-pds">"</span></span>), to(<span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>Defining predicates is of course not limited to <code>from</code>. Imagine that block ends vary like so:</p> 
  <pre><code>end of block 1 ###
end of block 2 ###
</code></pre> 
  <p>In this case, we use <code>to(_.endsWith("###"))</code> in order to match the end of a block.</p> 
  <p>If the patterns are more complicated than that, you can always resort to regular expressions:</p> 
  <div class="highlight highlight-source-scala">
   <pre>from(_.matches(yourRegexPattern))</pre>
  </div> 
  <h3><a id="user-content-expert" class="anchor" href="https://github.com/mb720/sparse#expert" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Expert</h3> 
  <p>Maybe you need to consider the <strong>line number</strong> as well to determine if a line should be the beginning or the end of a block. <code>Sparse</code> lets you account for that, too:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">start</span> <span class="pl-k">=</span> from((line, lineNr) <span class="pl-k">=&gt;</span> line.startsWith(<span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;&amp;</span> lineNr <span class="pl-k">&gt;</span> <span class="pl-c1">4</span>)
parse(yourFile, start, to(<span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>This way, the line not only has to begin with the string "start" but also needs to come after the fourth line in the file. If it's clear in your code that the first placeholder stands for the line and the second placeholder for the line number (or if you're feeling especially succinct today), you can shorten the above example to this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">start</span> <span class="pl-k">=</span> from(_.startsWith(<span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>) <span class="pl-k">&amp;&amp;</span> _ <span class="pl-k">&gt;</span> <span class="pl-c1">4</span>)</pre>
  </div> 
  <h3><a id="user-content-master" class="anchor" href="https://github.com/mb720/sparse#master" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Master</h3> 
  <p>If you're not content with the predefined block markers (i.e., <code>from</code>, <code>to</code>, <code>after</code>, <code>until</code>, and <code>before</code>) you can roll your own:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">/** The block begins two lines after the `predicate` matches. */</span>
<span class="pl-k">object</span> <span class="pl-en">twoLinesAfter</span> <span class="pl-k">extends</span> <span class="pl-e">MarkerFactory</span> {
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">predicate</span>: ((<span class="pl-k">String</span>, <span class="pl-k">Int</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">Boolean</span>)) <span class="pl-k">=</span>
    <span class="pl-en">BlockMarker</span>(predicate, offset <span class="pl-k">=</span> <span class="pl-k">+</span><span class="pl-c1">2</span>)
}</pre>
  </div> 
  <p>Your custom marker is used like all the predefined ones shown above:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">blocksMaybe</span> <span class="pl-k">=</span> parse(yourFile, twoLinesAfter(<span class="pl-s"><span class="pl-pds">"</span>start<span class="pl-pds">"</span></span>), to(<span class="pl-s"><span class="pl-pds">"</span>end<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>If you're wondering why you could pass a simple string instead of the <code>((String, Int) =&gt; Boolean)</code> predicate to <code>twoLinesAfter</code>, have a look at the <code>MarkerFactory</code> in <a href="https://github.com/mb720/sparse/blob/master/src/main/scala/eu/matthiasbraun/sparse/Parser.scala" target="_blank"><code>Parser.scala</code></a></p> 
  <h2><a id="user-content-dependencies-of-sparse" class="anchor" href="https://github.com/mb720/sparse#dependencies-of-sparse" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependencies of <code>Sparse</code></h2> 
  <ul> 
   <li>Scala 2.10 for <a href="http://www.scala-lang.org/api/current/index.html#scala.util.Try" target="_blank"><code>Try</code></a></li> 
   <li><a href="http://jsuereth.com/scala-arm/" target="_blank">Scala-ARM 1.4</a> for reading files</li> 
  </ul> 
 </article>
</div>