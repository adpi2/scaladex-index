<div class="announce instapaper_body asciidoc" data-path="README.asciidoc" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-s_machconcurrent-futures-utility-library" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#s_machconcurrent-futures-utility-library" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>s_mach.concurrent: Futures utility library</h1> 
  <div id="user-content-preamble"> 
   <div> 
    <div> 
     <p><a href="https://travis-ci.org/S-Mach/s_mach.concurrent" target="_blank"><img src="https://camo.githubusercontent.com/be99007db32d4c5f7dacc0b9ff97f90769a09603/68747470733a2f2f7472617669732d63692e6f72672f532d4d6163682f735f6d6163682e636f6e63757272656e742e737667" alt="Build Status" data-canonical-src="https://travis-ci.org/S-Mach/s_mach.concurrent.svg" style="max-width:100%;"></a> <a href="https://coveralls.io/r/S-Mach/s_mach.concurrent" target="_blank"><img src="https://camo.githubusercontent.com/f2d095d9729c5c858a4d5b128fd3a5629cb6db00/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f532d4d6163682f735f6d6163682e636f6e63757272656e742f62616467652e706e67" alt="Test Coverage" data-canonical-src="https://coveralls.io/repos/S-Mach/s_mach.concurrent/badge.png" style="max-width:100%;"></a> <a href="https://www.codacy.com/public/lancegatlin/s_mach.concurrent" target="_blank"><img src="https://camo.githubusercontent.com/8f6455f78b8d071826e19f7f3075a85115b9c873/68747470733a2f2f7777772e636f646163792e636f6d2f70726f6a6563742f62616467652f3535353231653664613266303435623839616436663433356163633536636237" alt="Codacy Badge" data-canonical-src="https://www.codacy.com/project/badge/55521e6da2f045b89ad6f435acc56cb7" style="max-width:100%;"></a> Scaladocs: <a href="http://s-mach.github.io/s_mach.concurrent/2.11.x/#s_mach.concurrent.package" target="_blank">2.11</a> <a href="https://s-mach.github.io/s_mach.concurrent/2.12.x/s_mach/concurrent/index.html" target="_blank">2.12</a></p> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-include-in-sbt"><a id="user-content-include-in-sbt" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#include-in-sbt" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Include in SBT</h2> 
   <div> 
    <div> 
     <ol class="arabic"> 
      <li> <p>Add to build.sbt</p> 
       <div> 
        <div> 
         <div class="highlight highlight-source-scala">
          <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>net.s_mach<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>concurrent<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.0.0<span class="pl-pds">"</span></span></pre>
         </div> 
        </div> 
       </div> 
       <div> 
        <table> 
         <tbody>
          <tr> 
           <td> 
            <div>
             Note
            </div> </td> 
           <td> s_mach.concurrent is cross compiled for Scala 2.11/JDK6 and 2.12/JDK8 </td> 
          </tr> 
         </tbody>
        </table> 
       </div> </li> 
     </ol> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-why-do-i-need-this"><a id="user-content-why-do-i-need-this" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#why-do-i-need-this" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Why do I need this?</h2> 
   <div> 
    <div> 
     <p>You love Scala Futures and functional concurrent coding! But you…​</p> 
    </div> 
    <div> 
     <ul> 
      <li> <p>Wish there were methods for controlling how multiple Futures execute (such as retrying failures, throttling or controlling parallelism)</p> </li> 
      <li> <p>Hate all the boilerplate needed to create multiple futures that run in parallel</p> </li> 
      <li> <p>Didn’t realize Future.sequence only returns the first exception (and throws away the rest! you didn’t want those anyways right?)</p> </li> 
      <li> <p>Didn’t realize Future.sequence doesn’t fail immediately (a quick failure on an hour long Future.sequence might not return the failure for an hour!)</p> </li> 
      <li> <p>Wish Future had common idioms such as fold, flatten, etc</p> </li> 
      <li> <p>Are annoyed that you have to use Java’s ScheduledExecutorService for delayed or periodically repeating tasks (or even worse - an ActorSystem)</p> </li> 
      <li> <p>Are a grown up async coder now and tired (so tired) of being punished for waiting on Futures with unnecessary ritual cruft (Await.result …​ very common in testing code!)</p> </li> 
     </ul> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-quick-look"><a id="user-content-quick-look" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#quick-look" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Quick look</h2> 
   <div> 
    <div> 
     <p>Express parallel Future operations in far less lines of code:</p> 
    </div> 
    <div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">read</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>

<span class="pl-c"><span class="pl-c">//</span> Turn this parallel future boilerplate:</span>
<span class="pl-k">val</span> <span class="pl-en">f1</span> <span class="pl-k">=</span> read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">f2</span> <span class="pl-k">=</span> read(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">f3</span> <span class="pl-k">=</span> read(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">:</span> <span class="pl-en">Future</span>[(<span class="pl-k">Int</span>,<span class="pl-k">Int</span>,<span class="pl-k">Int</span>)] <span class="pl-k">=</span>
  <span class="pl-k">for</span> {
    i1 <span class="pl-k">&lt;</span><span class="pl-k">-</span> f1
    i2 <span class="pl-k">&lt;</span><span class="pl-k">-</span> f2
    i3 <span class="pl-k">&lt;</span><span class="pl-k">-</span> f3
  } <span class="pl-k">yield</span> (i1,i2,i3)

<span class="pl-c"><span class="pl-c">//</span> Into this:</span>
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">:</span> <span class="pl-en">Future</span>[(<span class="pl-k">Int</span>,<span class="pl-k">Int</span>,<span class="pl-k">Int</span>)] <span class="pl-k">=</span>
  async.par.run(read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>), read(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>), read(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>))</pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>Create async tasks and configure them to:</p> 
    </div> 
    <div> 
     <ul> 
      <li> <p>Retry errors</p> </li> 
      <li> <p>Control the number of simultaneous operations</p> </li> 
      <li> <p>Limit the number of operations per second</p> </li> 
     </ul> 
    </div> 
    <div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">read</span> <span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">read2</span> <span class="pl-k">:</span> <span class="pl-k">Int</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-k">Double</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">read3</span> <span class="pl-k">:</span> <span class="pl-k">Double</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>

<span class="pl-c"><span class="pl-c">//</span> Tuple-based async task (heterogeneous)</span>
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">:</span> <span class="pl-en">Future</span>[(<span class="pl-k">Int</span>,<span class="pl-k">Double</span>,<span class="pl-k">String</span>)] <span class="pl-k">=</span>
  async <span class="pl-c"><span class="pl-c">//</span> start a new async task</span>
    .par(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> run 2 ops at a time</span>
    .progress(<span class="pl-c1">1.</span>second)(progress <span class="pl-k">=&gt;</span> println(progress)) <span class="pl-c"><span class="pl-c">//</span> print progress once a second</span>
    .retry { <span class="pl-c"><span class="pl-c">//</span> retry some errors with a random delay</span>
      <span class="pl-k">case</span> _<span class="pl-k">:</span><span class="pl-en">TimeoutException</span> <span class="pl-k">=&gt;</span>
        <span class="pl-en">Future</span>.delayed(<span class="pl-en">Random</span>.nextInt(<span class="pl-c1">100</span>).millis)(<span class="pl-c1">true</span>)
      <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>.future
    }
    .run(
      read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>),
      read2(<span class="pl-c1">2</span>),
      read3(<span class="pl-c1">3.0</span>)
    ) <span class="pl-c"><span class="pl-c">//</span> sequence results and fail-immediately on exception (unlike Future.sequence)</span>
    <span class="pl-c"><span class="pl-c">//</span> If the task fails, get the full list of exceptions (unlike Future.sequence)</span>

<span class="pl-c"><span class="pl-c">//</span> Collection-based async task (homogeneous)</span>
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">List</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span>
  <span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)
    .async <span class="pl-c"><span class="pl-c">//</span> start a new async task</span>
    .throttle(<span class="pl-c1">3.</span>second) <span class="pl-c"><span class="pl-c">//</span> perform operations no faster than 1 every 3 seconds</span>
    .retry { <span class="pl-c"><span class="pl-c">//</span> retry some errors with a random delay</span>
      <span class="pl-k">case</span> _<span class="pl-k">:</span><span class="pl-en">TimeoutException</span> <span class="pl-k">=&gt;</span>
        <span class="pl-en">Future</span>.delayed(<span class="pl-en">Random</span>.nextInt(<span class="pl-c1">100</span>).millis)(<span class="pl-c1">true</span>)
      <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>.future
    }
    .map(read) <span class="pl-c"><span class="pl-c">//</span> sequence results and fail-immediately on exception (unlike Future.sequence)</span>
    <span class="pl-c"><span class="pl-c">//</span> If the task fails, get the full list of exceptions (unlike Future.sequence)</span></pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>Save your async task config for later reuse:</p> 
    </div> 
    <div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">myAsyncConfig</span> <span class="pl-k">=</span>
  async
    .par(<span class="pl-c1">2</span>) <span class="pl-c"><span class="pl-c">//</span> run 2 ops at a time</span>
    .progress(<span class="pl-c1">1.</span>second)(progress <span class="pl-k">=&gt;</span> println(progress)) <span class="pl-c"><span class="pl-c">//</span> print progress once a second</span>
    .retry { <span class="pl-c"><span class="pl-c">//</span> retry some errors with a random delay</span>
      <span class="pl-k">case</span> _<span class="pl-k">:</span><span class="pl-en">TimeoutException</span> <span class="pl-k">=&gt;</span>
        <span class="pl-en">Future</span>.delayed(<span class="pl-en">Random</span>.nextInt(<span class="pl-c1">100</span>).millis)(<span class="pl-c1">true</span>)
      <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>.future
    }

<span class="pl-c"><span class="pl-c">//</span> Reuse config on tuple-based async task</span>
myAsyncConfig.run(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> Reuse config on collection-based async task</span>
<span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>).async.using(myAsyncConfig).map(read)</pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>Also, many, many convenience and utility methods:</p> 
    </div> 
    <div> 
     <ul> 
      <li> <p>A.future - stop typing Future.successful(A)</p> </li> 
      <li> <p>Future.get - Await.result without the flagellation</p> </li> 
      <li> <p>Future.flatten - flatten Future[Future[A]] into Future[A]</p> </li> 
      <li> <p>Future.toTry - expand Future[A] to Future[Try[A]] that always succeeds</p> </li> 
      <li> <p>Future.fold - fold Future[A] (which is either Success[A] or Failure[A]) to Future[B] that always succeeds</p> </li> 
      <li> <p>Collection[Future[A]].sequence - idiomatic version of Future.sequence(A) and less typing</p> </li> 
      <li> <p>Future.onTimeout - do something if a Future doesn’t complete within a given amount of time</p> </li> 
      <li> <p>Future.happensBefore - start a Future after another Future completes</p> </li> 
      <li> <p>Future.sideEffect - compose a Future and a side effect (that starts after the Future completes) into a new Future. The new Future completes successfully only after both the original Future and the side effect successfully complete. If either the original Future or the side effect fail, the composed Future fails.</p> </li> 
      <li> <p>Future.delayed or ScheduledExecutionContext.schedule - start a Future after a delay</p> </li> 
      <li> <p>ScheduledExecutionContext.scheduleCancellable - start a Future after a delay and optionally cancel the future if it hasn’t started yet. If cancelled, instead of throwing an exception the future completes successfully with a value you specify!</p> </li> 
      <li> <p>ScheduledExecutionContext.scheduleAtFixedRate - create a repeating task that can be paused or cancelled</p> </li> 
     </ul> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-overview"><a id="user-content-overview" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#overview" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Overview</h2> 
   <div> 
    <div> 
     <p>s_mach.concurrent is an open-source Scala library that provides asynchronous serial and parallel execution flow control primitives for working with asynchronous tasks. An asynchronous task consists of two or more calls to function(s) that return a future result A =&gt; Future[B] instead of the result A =&gt; B. s_mach.concurrent also provides utility &amp; convenience code for working with scala.concurrent.Future.</p> 
    </div> 
    <div> 
     <ul> 
      <li> <p>Adds concurrent flow control primitives async and async.par for performing fixed size heterogeneous (tuple) and variable size homogeneous (collection) asynchronous tasks. These primitives:</p> 
       <div> 
        <ul> 
         <li> <p>Allow enabling optional progress reporting, failure retry and/or throttle control for asynchronous tasks</p> </li> 
         <li> <p>Ensure proper sequencing of returned futures, e.g. given f: Int =&gt; Future[String]:</p> 
          <div> 
           <ul> 
            <li> <p>List(1,2,3).async.map(f) returns Future[List[String]]</p> </li> 
            <li> <p>async.par.run(f(1),f(2),f(3)) returns Future[(String,String,String)]</p> </li> 
           </ul> 
          </div> </li> 
         <li> <p>Ensure fail-immediate sequencing of future results (see the 'Under the hood: Merge' section for details)</p> </li> 
         <li> <p>Ensure all exceptions generated during asynchronous task processing can be retrieved (Future.sequence returns only the first)</p> </li> 
        </ul> 
       </div> </li> 
      <li> <p>collection.async and collection.async.par support collection operations such as map, flatMap and foreach on asynchronous functions, i.e. A =&gt; Future[B]</p> </li> 
      <li> <p>async.par.run(future1, future2, ...) supports running fixed size heterogeneous asynchronous task (of up to 22 futures) in parallel</p> </li> 
      <li> <p>Adds ScheduledExecutionContext, a Scala interface wrapper for java.util.concurrent.ScheduledExecutorService that provides for scheduling delayed and periodic tasks</p> </li> 
      <li> <p>Adds non-blocking concurrent control primitives such as Barrier, Latch, Lock, Semaphore and AtomicFSM</p> </li> 
      <li> <p>Adds future utility methods such as Future.onTimeout, Future.sideEffect and Future.happensBefore</p> </li> 
      <li> <p>Provides convenience methods for writing more readable, concise and DRY code such as Future.get, Future.toTry and Future.fold</p> </li> 
     </ul> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-versioning"><a id="user-content-versioning" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#versioning" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Versioning</h2> 
   <div> 
    <div> 
     <p>s_mach.concurrent uses semantic versioning (<a href="http://semver.org/" target="_blank">http://semver.org/</a>). s_mach.concurrent does not use the package private modifier. Instead, all code files outside of the s_mach.concurrent.impl package form the public interface and are governed by the rules of semantic versioning. Code files inside the s_mach.concurrent.impl package may be used by downstream applications and libraries. However, no guarantees are made as to the stability or interface of code in the s_mach.concurrent.impl package between versions.</p> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-imports-for-examples"><a id="user-content-imports-for-examples" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#imports-for-examples" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Imports for Examples</h2> 
   <div> 
    <div> 
     <p>All code examples assume the following imports:</p> 
    </div> 
    <div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">import</span> <span class="pl-v">scala.util.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.duration.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">s_mach.concurrent.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">s_mach.concurrent.util.</span><span class="pl-v">_</span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">scheduledExecutionContext</span> <span class="pl-k">=</span> <span class="pl-en">ScheduledExecutionContext</span>(<span class="pl-c1">2</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Item</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>, <span class="pl-v">value</span>: <span class="pl-k">Int</span>, <span class="pl-v">relatedItemId</span>: <span class="pl-k">String</span>)
<span class="pl-k">def</span> <span class="pl-en">read</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>) <span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Item</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span> { <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">1000</span>); println(id); <span class="pl-en">Item</span>(id,id.toInt,(id.toInt<span class="pl-k">+</span><span class="pl-c1">1</span>).toString) }
<span class="pl-k">def</span> <span class="pl-en">readFail</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>) <span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Item</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span> { <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">1000</span>); println(id); <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">RuntimeException</span>(id.toString) }
<span class="pl-k">def</span> <span class="pl-en">longRead</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>) <span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Item</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span> { <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">2000</span>); println(id); <span class="pl-en">Item</span>(id,id.toInt,(id.toInt<span class="pl-k">+</span><span class="pl-c1">1</span>).toString) }
<span class="pl-k">def</span> <span class="pl-en">write</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>, <span class="pl-v">item</span>: <span class="pl-en">Item</span>) <span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span> { <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">1000</span>); println(id); <span class="pl-c1">true</span> }
<span class="pl-k">def</span> <span class="pl-en">writeFail</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>, <span class="pl-v">item</span>: <span class="pl-en">Item</span>) <span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-k">Boolean</span>] <span class="pl-k">=</span> <span class="pl-en">Future</span> { <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">1000</span>); println(id); <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">RuntimeException</span>(id.toString) }</pre>
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-asynchronously-transform-or-traverse-collections"><a id="user-content-asynchronously-transform-or-traverse-collections" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#asynchronously-transform-or-traverse-collections" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Asynchronously transform or traverse collections</h2> 
   <div> 
    <div> 
     <p>A common task when working with futures is transforming or traversing a collection in serial or parallel that will call a function that returns a future. With only a few levels of nesting, the standard idioms for accomplishing this lead to difficult to read code. In the following example, a collection of ten identifiers is grouped to batch identifier reads. The flow of execution for each batch is serial while the flow of the identifiers within each batch is parallel.</p> 
    </div> 
    <div> 
     <div>
      Example 1: Transform and traverse collections, standard idiom
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">oomItemIdBatch</span> <span class="pl-k">=</span> (<span class="pl-c1">1</span> to <span class="pl-c1">10</span>).toList.map(_.toString).grouped(<span class="pl-c1">2</span>).toList
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">=</span> { <span class="pl-c"><span class="pl-c">//</span> necessary for pasting into repl</span>
  <span class="pl-k">for</span> {
    oomItem <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Reading...<span class="pl-pds">"</span></span>)
      oomItemIdBatch
        <span class="pl-c"><span class="pl-c">//</span> Serially perform read of each batch</span>
        .foldLeft(<span class="pl-en">Future</span>.successful(<span class="pl-en">List</span>[<span class="pl-en">Item</span>]())) { (facc, idBatch) <span class="pl-k">=&gt;</span>
          <span class="pl-k">for</span> {
            acc <span class="pl-k">&lt;</span><span class="pl-k">-</span> facc
            <span class="pl-c"><span class="pl-c">//</span> Parallel read batch</span>
            oomItem <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-en">Future</span>.sequence(idBatch.map(read))
          } <span class="pl-k">yield</span> acc <span class="pl-k">:::</span> oomItem
        }
    }
    _ <span class="pl-k">=</span> println(<span class="pl-s"><span class="pl-pds">"</span>Computing...<span class="pl-pds">"</span></span>)
    oomNewItemBatch <span class="pl-k">=</span> oomItem.map(item <span class="pl-k">=&gt;</span> item.copy(value <span class="pl-k">=</span> item.value <span class="pl-k">+</span> <span class="pl-c1">1</span>)).grouped(<span class="pl-c1">2</span>).toList
    oomResult <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Writing...<span class="pl-pds">"</span></span>)
      oomNewItemBatch
        <span class="pl-c"><span class="pl-c">//</span> Serially perform write of each batch</span>
        .foldLeft(<span class="pl-en">Future</span>.successful(<span class="pl-en">List</span>[<span class="pl-k">Boolean</span>]())) { (facc, itemBatch) <span class="pl-k">=&gt;</span>
          <span class="pl-k">for</span> {
            acc <span class="pl-k">&lt;</span><span class="pl-k">-</span> facc
            <span class="pl-c"><span class="pl-c">//</span> Parallel write batch</span>
            oomResult <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-en">Future</span>.sequence(itemBatch.map(item <span class="pl-k">=&gt;</span> write(item.id, item)))
          } <span class="pl-k">yield</span> acc <span class="pl-k">:::</span> oomResult
        }
    }
  } <span class="pl-k">yield</span> oomResult.forall(_ <span class="pl-k">==</span> <span class="pl-c1">true</span>)
}</pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>The same code, rewritten using async and async.par:</p> 
    </div> 
    <div> 
     <div>
      Example 2: Using async and async.par to transform and traverse collections:
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">oomItemIdBatch</span> <span class="pl-k">=</span> (<span class="pl-c1">1</span> to <span class="pl-c1">10</span>).toList.map(_.toString).grouped(<span class="pl-c1">2</span>).toList
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">=</span> { <span class="pl-c"><span class="pl-c">//</span> necessary for pasting into repl</span>
  <span class="pl-k">for</span> {
    oomItem <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Reading...<span class="pl-pds">"</span></span>)
      oomItemIdBatch.async.flatMap(_.async.par.map(read))
    }
    _ <span class="pl-k">=</span> println(<span class="pl-s"><span class="pl-pds">"</span>Computing...<span class="pl-pds">"</span></span>)
    oomNewItemBatch <span class="pl-k">=</span> oomItem.map(item <span class="pl-k">=&gt;</span> item.copy(value <span class="pl-k">=</span> item.value <span class="pl-k">+</span> <span class="pl-c1">1</span>)).grouped(<span class="pl-c1">10</span>).toVector
    oomResult <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Writing...<span class="pl-pds">"</span></span>)
      oomNewItemBatch.async.flatMap(_.async.par.map(item <span class="pl-k">=&gt;</span> write(item.id, item)))
    }
  } <span class="pl-k">yield</span> oomResult.forall(_ <span class="pl-k">==</span> <span class="pl-c1">true</span>)
}</pre>
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-limiting-the-maximum-number-of-simultaneous-workers"><a id="user-content-limiting-the-maximum-number-of-simultaneous-workers" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#limiting-the-maximum-number-of-simultaneous-workers" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Limiting the maximum number of simultaneous workers</h2> 
   <div> 
    <div> 
     <p>async.par allows specifying the maximum number of simultaneous workers used during an asynchronous task. In the following example, batches are processed in parallel with at most two workers, while each identifier within a batch is processed with at most four workers.</p> 
    </div> 
    <div> 
     <div>
      Example 3: Using s_mach.concurrent workers to transform and traverse collections:
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">oomItemIdBatch</span> <span class="pl-k">=</span> (<span class="pl-c1">1</span> to <span class="pl-c1">10</span>).toList.map(_.toString).grouped(<span class="pl-c1">2</span>).toList
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">=</span> { <span class="pl-c"><span class="pl-c">//</span> necessary for pasting into repl</span>
  <span class="pl-k">for</span> {
    oomItem <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Reading...<span class="pl-pds">"</span></span>)
      oomItemIdBatch.async.par(<span class="pl-c1">2</span>).flatMap(_.async.par(<span class="pl-c1">4</span>).map(read))
    }
    _ <span class="pl-k">=</span> println(<span class="pl-s"><span class="pl-pds">"</span>Computing...<span class="pl-pds">"</span></span>)
    oomNewItemBatch <span class="pl-k">=</span> oomItem.map(item <span class="pl-k">=&gt;</span> item.copy(value <span class="pl-k">=</span> item.value <span class="pl-k">+</span> <span class="pl-c1">1</span>)).grouped(<span class="pl-c1">10</span>).toVector
    oomResult <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Writing...<span class="pl-pds">"</span></span>)
      oomNewItemBatch.async.par(<span class="pl-c1">2</span>).flatMap(_.async.par(<span class="pl-c1">4</span>).map(item <span class="pl-k">=&gt;</span> write(item.id, item)))
    }
  } <span class="pl-k">yield</span> oomResult.forall(_ <span class="pl-k">==</span> <span class="pl-c1">true</span>)
}</pre>
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-adding-progress-reporting-retry-and-throttle-control-to-asynchronous-tasks"><a id="user-content-adding-progress-reporting-retry-and-throttle-control-to-asynchronous-tasks" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#adding-progress-reporting-retry-and-throttle-control-to-asynchronous-tasks" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Adding progress reporting, retry and throttle control to asynchronous tasks</h2> 
   <div> 
    <div> 
     <p>async and async.par can be optionally modified to report progress, retry failures and/or limit iteration speed to a specific time period for asynchronous tasks. In the following example, completion of each batch reports progress and batches may not complete faster than one every three seconds. For each identifier that is read and fails, the first three TimeoutExceptions or SocketTimeoutExceptions are retried. All other exceptions cause the entire task to fail.</p> 
    </div> 
    <div> 
     <div>
      Example 4: Adding progress reporting, retry and throttle control to collection concurrent operations
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">oomItemIdBatch</span> <span class="pl-k">=</span> (<span class="pl-c1">1</span> to <span class="pl-c1">10</span>).toList.map(_.toString).grouped(<span class="pl-c1">2</span>).toList
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">=</span> { <span class="pl-c"><span class="pl-c">//</span> necessary for pasting into repl</span>
  <span class="pl-k">for</span> {
    oomItem <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Reading...<span class="pl-pds">"</span></span>)
      oomItemIdBatch
        .async
        .progress(<span class="pl-c1">1.</span>second)(progress <span class="pl-k">=&gt;</span> println(progress))
        .throttle(<span class="pl-c1">3.</span>seconds)
        .flatMap { batch <span class="pl-k">=&gt;</span>
          batch
            .async.par
            <span class="pl-c"><span class="pl-c">//</span> Retry at most first 3 timeout and socket exceptions after delaying 100 milliseconds</span>
            .retry {
              <span class="pl-k">case</span> (<span class="pl-v">_</span>: <span class="pl-en">TimeoutException</span>) <span class="pl-k">::</span> tail <span class="pl-k">if</span> tail.size <span class="pl-k">&lt;</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span>
                <span class="pl-en">Future</span>.delayed(<span class="pl-c1">100.</span>millis)(<span class="pl-c1">true</span>)
              <span class="pl-k">case</span> (<span class="pl-v">_</span>: <span class="pl-en">SocketTimeoutException</span>) <span class="pl-k">::</span> tail <span class="pl-k">if</span> tail.size <span class="pl-k">&lt;</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span>
                <span class="pl-en">Future</span>.delayed(<span class="pl-c1">100.</span>millis)(<span class="pl-c1">true</span>)
              <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>.future
            }
            .map(read)
        }
    }
    _ <span class="pl-k">=</span> println(<span class="pl-s"><span class="pl-pds">"</span>Computing...<span class="pl-pds">"</span></span>)
    oomNewItemBatch <span class="pl-k">=</span> oomItem.map(item <span class="pl-k">=&gt;</span> item.copy(value <span class="pl-k">=</span> item.value <span class="pl-k">+</span> <span class="pl-c1">1</span>)).grouped(<span class="pl-c1">10</span>).toVector
    oomResult <span class="pl-k">&lt;</span><span class="pl-k">-</span> {
      println(<span class="pl-s"><span class="pl-pds">"</span>Writing...<span class="pl-pds">"</span></span>)
      oomNewItemBatch.workers(<span class="pl-c1">2</span>).flatMap(_.workers(<span class="pl-c1">4</span>).map(item <span class="pl-k">=&gt;</span> write(item.id, item)))
    }
  } <span class="pl-k">yield</span> oomResult.forall(_ <span class="pl-k">==</span> <span class="pl-c1">true</span>)
}</pre>
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-async-par-workflow-for-fixed-size-heterogeneous-asynchronous-tasks"><a id="user-content-asyncpar-workflow-for-fixed-size-heterogeneous-asynchronous-tasks" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#asyncpar-workflow-for-fixed-size-heterogeneous-asynchronous-tasks" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>async.par workflow for fixed size heterogeneous asynchronous tasks</h2> 
   <div> 
    <div> 
     <p>When first using Future with a for-comprehension, it is natural to assume the following will produce parallel operation:</p> 
    </div> 
    <div> 
     <div>
      Example 5: Does not execute futures in parallel
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">for</span> {
  i1 <span class="pl-k">&lt;</span><span class="pl-k">-</span> read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>)
  i2 <span class="pl-k">&lt;</span><span class="pl-k">-</span> read(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>)
  i3 <span class="pl-k">&lt;</span><span class="pl-k">-</span> read(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)
} <span class="pl-k">yield</span> (i1,i2,i3)</pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>Sadly, this code will compile and run just fine, but it will not execute in parallel. To correctly implement parallel operation, the following standard pattern is used:</p> 
    </div> 
    <div> 
     <div>
      Example 6: Correct Future parallel operation:
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">f1</span> <span class="pl-k">=</span> read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">f2</span> <span class="pl-k">=</span> read(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">f3</span> <span class="pl-k">=</span> read(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">future</span> <span class="pl-k">=</span> { <span class="pl-c"><span class="pl-c">//</span> necessary for pasting into repl</span>
  <span class="pl-k">for</span> {
    i1 <span class="pl-k">&lt;</span><span class="pl-k">-</span> f1
    i2 <span class="pl-k">&lt;</span><span class="pl-k">-</span> f2
    i3 <span class="pl-k">&lt;</span><span class="pl-k">-</span> f3
  } <span class="pl-k">yield</span> (i1,i2,i3)
}</pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>For parallel operation, all of the futures must be started before the for-comprehension. The for-comprehension is a monadic workflow which captures commands that must take place in a specific sequential order. The pattern in Example 6 is necessary because Scala lacks an applicative workflow which captures commands that may be run in any order. s_mach.concurrent adds the async.par.run workflow which is an applicative workflow specifically for fixed size heterogeneous asynchronous tasks. This workflow can more concisely express the pattern above.</p> 
    </div> 
    <div> 
     <p>In the example below, all futures are started at the same time by async.par.run which returns a Future[(Int,Int,Int)] that completes once all supplied futures complete. After this returned future completes, the tuple value results can be extracted using normal Scala idioms.</p> 
    </div> 
    <div> 
     <div>
      Example 7: async.par.run workflow
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">for</span> {
  (i1,i2,i3) <span class="pl-k">&lt;</span><span class="pl-k">-</span> async.par.run(read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>), read(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>), read(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>))
} <span class="pl-k">yield</span> (i1,i2,i3)</pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <p>Additionally, all of the configuration options available for collection.async.par are valid for async.par.run. In the example below, the number of workers is limited to two, progress is reported once a second and certain failures are retried.</p> 
    </div> 
    <div> 
     <div>
      Example 8: async.par.run workflow with two workers, progress reporting and failure retry
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">for</span> {
  (i1,i2,i3) <span class="pl-k">&lt;</span><span class="pl-k">-</span>
    async
      .par(<span class="pl-c1">2</span>)
      .progress(<span class="pl-c1">1.</span>second)(progress <span class="pl-k">=&gt;</span> println(progress))
      .retry {
        <span class="pl-k">case</span> (<span class="pl-v">_</span>: <span class="pl-en">TimeoutException</span>) <span class="pl-k">::</span> tail <span class="pl-k">if</span> tail.size <span class="pl-k">&lt;</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span>
          <span class="pl-en">Future</span>.delayed(<span class="pl-c1">100.</span>millis)(<span class="pl-c1">true</span>)
        <span class="pl-k">case</span> (<span class="pl-v">_</span>: <span class="pl-en">SocketTimeoutException</span>) <span class="pl-k">::</span> tail <span class="pl-k">if</span> tail.size <span class="pl-k">&lt;</span> <span class="pl-c1">3</span> <span class="pl-k">=&gt;</span>
          <span class="pl-en">Future</span>.delayed(<span class="pl-c1">100.</span>millis)(<span class="pl-c1">true</span>)
        <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-c1">false</span>.future
      }
      .run(
        read(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>),
        read(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>),
        read(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>)
      )
} <span class="pl-k">yield</span> (i1,i2,i3)</pre>
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <h2 id="user-content-under-the-hood-merge-function"><a id="user-content-under-the-hood-merge-function" class="anchor" href="https://github.com/s-mach/s_mach.concurrent#under-the-hood-merge-function" aria-hidden="true" target="_blank">
     <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
      <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
     </svg></a>Under the hood: Merge function</h2> 
   <div> 
    <div> 
     <p>The async and async.par primitives utilize the merge and flatMerge sequencing functions to ensure that execution ends immediately once a failure occurs. This is in contrast to Future.sequence which may not always fail immediately when a failure occurs.</p> 
    </div> 
    <div> 
     <p>The merge function performs the same function as Future.sequence (it calls Future.sequence internally) but it ensures that the returned future completes immediately after an exception occurs in any of the futures. Because Future.sequence waits on all futures in left to right order before completing, an exception thrown at the beginning of the computation by a future at the far right will not be detected until after all other futures have completed. For long running computations, this can mean a significant amount of wasted time waiting on futures to complete whose results will be discarded.</p> 
    </div> 
    <div> 
     <p>Additionally, while the scala parallel collections correctly handle multiple parallel exceptions, Future.sequence only returns the first exception encountered. In Future.sequence, all further exceptions past the first are discarded. The merge and flatMerge methods fix these problems by throwing AsyncParThrowable. AsyncParThrowable has a member method to access both the first exception thrown and a future of all exceptions thrown during the computation.</p> 
    </div> 
    <div> 
     <div>
      Example 9: Future.sequence gets stuck waiting on longRead to complete and only returns the first exception:
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">t</span> <span class="pl-k">=</span> <span class="pl-en">Future</span>.sequence(<span class="pl-en">Vector</span>(longRead(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>),readFail(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>),readFail(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>),read(<span class="pl-s"><span class="pl-pds">"</span>4<span class="pl-pds">"</span></span>))).getTry
<span class="pl-c1">3</span>
<span class="pl-c1">4</span>
<span class="pl-c1">2</span>
<span class="pl-c1">1</span>
t<span class="pl-k">:</span> scala.util.<span class="pl-en">Try</span>[scala.collection.immutable.<span class="pl-en">Vector</span>[<span class="pl-en">Item</span>]] <span class="pl-k">=</span> <span class="pl-en">Failure</span>(java.lang.<span class="pl-en">RuntimeException</span><span class="pl-k">:</span> <span class="pl-c1">2</span>)

scala<span class="pl-k">&gt;</span></pre>
      </div> 
     </div> 
    </div> 
    <div> 
     <div>
      Example 10: merge method fails immediately on the first exception and throws AsyncParThrowable which can retrieve all exceptions:
     </div> 
     <div> 
      <div class="highlight highlight-source-scala">
       <pre>scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">t</span> <span class="pl-k">=</span> <span class="pl-en">Vector</span>(longRead(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>),readFail(<span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>),readFail(<span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>),read(<span class="pl-s"><span class="pl-pds">"</span>4<span class="pl-pds">"</span></span>)).merge.getTry
<span class="pl-c1">2</span>
t<span class="pl-k">:</span> scala.util.<span class="pl-en">Try</span>[scala.collection.immutable.<span class="pl-en">Vector</span>[<span class="pl-en">Item</span>]] <span class="pl-k">=</span> <span class="pl-en">Failure</span>(<span class="pl-en">AsyncParThrowable</span>(java.lang.<span class="pl-en">RuntimeException</span><span class="pl-k">:</span> <span class="pl-c1">2</span>))
<span class="pl-c1">3</span>

scala<span class="pl-k">&gt;</span> <span class="pl-c1">4</span>
<span class="pl-c1">1</span>

scala<span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">allFailures</span> <span class="pl-k">=</span> t.failed.get.<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">AsyncParThrowable</span>].allFailure.get
allFailures<span class="pl-k">:</span> <span class="pl-en">Vector</span>[<span class="pl-en">Throwable</span>] <span class="pl-k">=</span> <span class="pl-en">Vector</span>(java.lang.<span class="pl-en">RuntimeException</span><span class="pl-k">:</span> <span class="pl-c1">2</span>, java.lang.<span class="pl-en">RuntimeException</span><span class="pl-k">:</span> <span class="pl-c1">3</span>)</pre>
      </div> 
     </div> 
    </div> 
   </div> 
  </div>
 </article>
</div>