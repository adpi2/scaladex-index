<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-picopickle-030" class="anchor" href="https://github.com/netvl/picopickle#picopickle-030" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>picopickle 0.3.0</h1> 
  <p>picopickle is a serialization library for Scala. Its main features are:</p> 
  <ul> 
   <li>Small and almost dependency-less (the core library depends only on <a href="https://github.com/milessabin/shapeless" target="_blank">shapeless</a>).</li> 
   <li>Extensibility: you can define your own serializators for your types and you can create custom <em>backends</em>, that is, you can use the same library for the different serialization formats (collections, JSON, BSON, etc.); other parts of the serialization behavior like nulls handling can also be customized.</li> 
   <li>Flexibility and convenience: the default serialization format is fine for most uses, but it can be customized almost arbitrarily with support from a convenient converters DSL.</li> 
   <li>Static serialization without reflection: shapeless <a href="https://github.com/milessabin/shapeless/wiki/Feature-overview:-shapeless-2.0.0#generic-representation-of-sealed-families-of-case-classes" target="_blank"><code>Generic</code></a> macros are used to provide serializers for arbitrary types, which means that no reflection is used.</li> 
  </ul> 
  <h2><a id="user-content-contents" class="anchor" href="https://github.com/netvl/picopickle#contents" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contents</h2> 
  <ul> 
   <li><a href="https://github.com/netvl/picopickle#getting-started" target="_blank">Getting started</a> 
    <ul> 
     <li><a href="https://github.com/netvl/picopickle#backend-dependencies" target="_blank">Backend dependencies</a></li> 
    </ul> </li> 
   <li><a href="https://github.com/netvl/picopickle#serialization-mechanism" target="_blank">Serialization mechanism</a></li> 
   <li><a href="https://github.com/netvl/picopickle#usage" target="_blank">Usage</a> 
    <ul> 
     <li><a href="https://github.com/netvl/picopickle#basic-usage" target="_blank">Basic usage</a></li> 
     <li><a href="https://github.com/netvl/picopickle#serializer-objects" target="_blank">Serializer objects</a></li> 
     <li><a href="https://github.com/netvl/picopickle#custom-picklers" target="_blank">Custom picklers</a></li> 
     <li><a href="https://github.com/netvl/picopickle#backends" target="_blank">Backends</a></li> 
     <li><a href="https://github.com/netvl/picopickle#extending-backends" target="_blank">Extending backends</a></li> 
     <li><a href="https://github.com/netvl/picopickle#creating-custom-serializers" target="_blank">Creating custom serializers</a></li> 
     <li><a href="https://github.com/netvl/picopickle#extractors-and-backend-conversion-implicits" target="_blank">Extractors and backend conversion implicits</a></li> 
    </ul> </li> 
   <li><a href="https://github.com/netvl/picopickle#converters" target="_blank">Converters</a></li> 
   <li><a href="https://github.com/netvl/picopickle#supported-types" target="_blank">Supported types</a> 
    <ul> 
     <li><a href="https://github.com/netvl/picopickle#primitives-and-basic-types" target="_blank">Primitives and basic types</a></li> 
     <li><a href="https://github.com/netvl/picopickle#numbers-and-accuracy" target="_blank">Numbers and accuracy</a></li> 
     <li><a href="https://github.com/netvl/picopickle#tuples" target="_blank">Tuples</a></li> 
     <li><a href="https://github.com/netvl/picopickle#collections" target="_blank">Collections</a></li> 
     <li><a href="https://github.com/netvl/picopickle#map-serialization-with-non-string-keys" target="_blank">Map serialization with non-string keys</a></li> 
     <li><a href="https://github.com/netvl/picopickle#sealed-trait-hierarchies" target="_blank">Sealed trait hierarchies</a></li> 
     <li><a href="https://github.com/netvl/picopickle#changing-the-discriminator-key" target="_blank">Changing the discriminator key</a></li> 
     <li><a href="https://github.com/netvl/picopickle#serialization-of-optional-fields" target="_blank">Serialization of optional fields</a></li> 
     <li><a href="https://github.com/netvl/picopickle#renaming-fields-and-sealed-trait-variants" target="_blank">Renaming fields and sealed trait variants</a></li> 
     <li><a href="https://github.com/netvl/picopickle#default-values-of-case-class-fields" target="_blank">Default values of case class fields</a></li> 
     <li><a href="https://github.com/netvl/picopickle#varargs" target="_blank">Varargs</a></li> 
     <li><a href="https://github.com/netvl/picopickle#nulls" target="_blank">Nulls</a></li> 
     <li><a href="https://github.com/netvl/picopickle#accurate-numbers-serialization" target="_blank">Accurate numbers serialization</a></li> 
     <li><a href="https://github.com/netvl/picopickle#value-classes" target="_blank">Value classes</a></li> 
    </ul> </li> 
   <li><a href="https://github.com/netvl/picopickle#official-backends" target="_blank">Official backends</a> 
    <ul> 
     <li><a href="https://github.com/netvl/picopickle#collections-pickler" target="_blank">Collections pickler</a></li> 
     <li><a href="https://github.com/netvl/picopickle#json-pickler" target="_blank">JSON pickler</a></li> 
     <li><a href="https://github.com/netvl/picopickle#bson-pickler" target="_blank">BSON pickler</a></li> 
    </ul> </li> 
   <li><a href="https://github.com/netvl/picopickle#error-handling" target="_blank">Error handling</a></li> 
   <li><a href="https://github.com/netvl/picopickle#limitations" target="_blank">Limitations</a></li> 
   <li><a href="https://github.com/netvl/picopickle#changelog" target="_blank">Changelog</a></li> 
  </ul> 
  <h2><a id="user-content--getting-started" class="anchor" href="https://github.com/netvl/picopickle#-getting-started" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-getting-started" target="_blank" href=""></a> Getting started</h2> 
  <p>The library is published to the Maven central, so you can just add the following line to your <code>build.sbt</code> file in order to use the core library:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.github.netvl.picopickle<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>picopickle-core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.3.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>The library is compiled for both 2.10 and 2.11 Scala versions. If you use 2.10, however, you will need to add <a href="http://docs.scala-lang.org/overviews/macros/paradise.html" target="_blank">Macro Paradise</a> compiler plugin because shapeless macros depend on it:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> compilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.scalamacros<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>paradise<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.0.1<span class="pl-pds">"</span></span> cross <span class="pl-en">CrossVersion</span>.full)
<span class="pl-c"><span class="pl-c">//</span> or</span>
addCompilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.scalamacros<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>paradise<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.0.1<span class="pl-pds">"</span></span> cross <span class="pl-en">CrossVersion</span>.full)</pre>
  </div> 
  <p>Scala 2.11 users do not need this as all relevant macro support is already present in 2.11.</p> 
  <h3><a id="user-content--backend-dependencies" class="anchor" href="https://github.com/netvl/picopickle#-backend-dependencies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-backend-dependencies" target="_blank" href=""></a> Backend dependencies</h3> 
  <p>Picopickle supports different <em>backends</em>. A backend defines the target serialization format, for example, JSON, BSON or just regular collections. The core library provides collections backend, and an additional JSON backend based on <a href="https://github.com/non/jawn" target="_blank">Jawn</a> parser is available as <code>picopickle-backend-jawn</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.github.netvl.picopickle<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>picopickle-backend-jawn<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.3.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Jawn backend uses Jawn parser (naturally!) to read JSON strings but it uses custom renderer to print JSON AST as a string in order to keep dependencies to the minimum. This renderer is very basic and does not support pretty-printing; this is something which is likely to be fixed in one of the future versions.</p> 
  <p>You can create your own backends to support your own data formats; more information on how to do it is available below. It is likely that more officially supported backends will be available later.</p> 
  <h2><a id="user-content--serialization-mechanism" class="anchor" href="https://github.com/netvl/picopickle#-serialization-mechanism" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-serialization-mechanism" target="_blank" href=""></a> Serialization mechanism</h2> 
  <p>picopickle uses the pretty standard typeclass approach where the way the type is serialized or deserialized is defined through implicit objects (called <code>Reader[T]</code> and <code>Writer[T]</code> in picopickle) in scope. The library defines corresponding instances for a lot of standard types:</p> 
  <ul> 
   <li>primitives and other basic types: <code>Byte</code>, <code>Short</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code>, <code>Char</code>, <code>String</code>, <code>Unit</code>, <code>Null</code>, <code>Symbol</code>, <code>Option[T]</code>, <code>Either[A, B]</code>;</li> 
   <li>tuples (currently generated as a part of build process for lengths from 1 to 22);</li> 
   <li>most of standard Scala collections;</li> 
   <li>sealed trait hierarchies: case classes and case objects, possibly implementing some sealed trait, and the sealed trait itself.</li> 
  </ul> 
  <p>Serializers for sealed trait hierarchies are derived automatically with the help of shapeless <code>LabelledGeneric</code> type class. The library defines several generic instances for the core shapeless types (<code>HList</code> and <code>Coproduct</code>), and shapeless does the hard work of inspecting case classes and sealed traits.</p> 
  <p>Since sealed trait hierarchies are equivalent to algebraic data types, their representation with the shapeless type is fairly natural: each case class/case object is represented by a <code>HList</code> of corresponding field types labelled with field names, and the whole hierarchy is represented by a <code>Coproduct</code> of the corresponding types which implement the sealed trait.</p> 
  <p>picopickle also supports recursive types, that is, when a case class eventually depends on itself or on the sealed trait it belongs to, for example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Root</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">A</span> <span class="pl-k">extends</span> <span class="pl-e">Root</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">B</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">b</span>: <span class="pl-en">Option</span>[<span class="pl-en">B</span>]) <span class="pl-k">extends</span> <span class="pl-e">Root</span>  <span class="pl-c"><span class="pl-c">//</span> depends on itself</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">C</span>(<span class="pl-v">next</span>: <span class="pl-en">Root</span>) <span class="pl-k">extends</span> <span class="pl-e">Root</span>  <span class="pl-c"><span class="pl-c">//</span> depends on the sealed trait</span></pre>
  </div> 
  <p>picopickle also supports default values and variable arguments in case classes and renaming of fields or sealed trait descendants with a bit of custom macros.</p> 
  <h2><a id="user-content--usage" class="anchor" href="https://github.com/netvl/picopickle#-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-usage" target="_blank" href=""></a> Usage</h2> 
  <h3><a id="user-content--basic-usage" class="anchor" href="https://github.com/netvl/picopickle#-basic-usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-basic-usage" target="_blank" href=""></a> Basic usage</h3> 
  <p>picopickle is structured using the cake pattern, that is, it consists of several traits providing parts of the functionality which are then combined into a single object called a <em>pickler</em>. It provides everything necessary for the serialization via a glob import:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">some.package.SomePickler.</span><span class="pl-v">_</span>
 
write(<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>) shouldEqual <span class="pl-en">SomePicklerBackend</span>.<span class="pl-en">StringValue</span>(<span class="pl-s"><span class="pl-pds">"</span>Hello<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>The core library and the Jawn backend library provide default picklers, so if you don't need any customization (e.g. you don't need to define custom serializers for your types) you can just import the internals of one of these picklers:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.collections.CollectionsPickler.</span><span class="pl-v">_</span>
 
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">String</span>)
 
write(<span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)
read[<span class="pl-en">A</span>](<span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Jawn-based pickler also provides additional functions, <code>readString()</code>/<code>writeString()</code> and <code>readAst()</code>/<code>writeAst()</code>, which [de]serialize objects to strings and JSON AST to strings, respectively:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.jawn.JsonPickler.</span><span class="pl-v">_</span>
 
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">String</span>)
 
writeString(<span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":10,"y":"hi"}<span class="pl-pds">"""</span></span>
readString[<span class="pl-en">A</span>](<span class="pl-s"><span class="pl-pds">"""</span>{"x":10,"y":"hi"}<span class="pl-pds">"""</span></span>) shouldEqual <span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Currently the string JSON representation is not prettified (but prettification may be implemented in later versions).</p> 
  <h3><a id="user-content--serializer-objects" class="anchor" href="https://github.com/netvl/picopickle#-serializer-objects" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-serializer-objects" target="_blank" href=""></a> Serializer objects</h3> 
  <p>Sometimes you need to work with serialization and deserializaton in the same piece of code (e.g. writing and reading data from database). Then it would be convenient to have <code>read</code> and <code>write</code> methods fixed for some specific type, both for correctness sake and in order to instantiate corresponding readers and writers in one place (which potentially may speed up the compilation).</p> 
  <p>picopickle provides a special serializer class which can be constructed for any type which has <code>Reader</code> and <code>Writer</code> instances. This class provides <code>read</code> and <code>write</code> methods specified for the type which this serializer is created for:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.collections.CollectionsPickler.</span><span class="pl-v">_</span>
 
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">aSerializer</span> <span class="pl-k">=</span> serializer[<span class="pl-en">A</span>]
 
aSerializer.write(<span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">//</span> aSerializer.write("whatever")  // won't compile - write() accepts values of type A only</span>

aSerializer.read(<span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>x<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>y<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>) shouldEqual <span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)
<span class="pl-c"><span class="pl-c">//</span> val x: String = aSerializer.read("whatever")  // won't compile - read() returns values of type A</span></pre>
  </div> 
  <p>Jawn-based pickler extends this class to provide <code>readString</code> and <code>writeString</code> methods:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.jawn.JsonPickler.</span><span class="pl-v">_</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">String</span>)

<span class="pl-k">val</span> <span class="pl-en">aSerializer</span> <span class="pl-k">=</span> serializer[<span class="pl-en">A</span>]

aSerializer.writeString(<span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":10,"y":"hi"}<span class="pl-pds">"""</span></span>
aSerializer.readString(<span class="pl-s"><span class="pl-pds">"""</span>{"x":10,"y":"hi"}<span class="pl-pds">"""</span></span>) shouldEqual <span class="pl-en">A</span>(<span class="pl-c1">10</span>, <span class="pl-s"><span class="pl-pds">"</span>hi<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h3><a id="user-content--custom-picklers" class="anchor" href="https://github.com/netvl/picopickle#-custom-picklers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-custom-picklers" target="_blank" href=""></a> Custom picklers</h3> 
  <p>It is possible that you would want to define custom serializers for some of your types. In that case you can define custom serializer instances in a trait which "depends" on <code>BackendComponent</code> and <code>TypesComponent</code> via a self type annotation:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.</span>{<span class="pl-v">BackendComponent</span>, <span class="pl-v">TypesComponent</span>}
 
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">DefinedByInt</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">String</span>)
 
<span class="pl-k">trait</span> <span class="pl-en">CustomSerializers</span> {
  <span class="pl-c1">this</span><span class="pl-k">:</span> <span class="pl-en">BackendComponent</span> <span class="pl-k">with</span> <span class="pl-e">TypesComponent</span> <span class="pl-k">=&gt;</span>
 
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">definedByIntWriter</span><span class="pl-k">:</span> <span class="pl-en">Writer</span>[<span class="pl-en">DefinedByInt</span>] <span class="pl-k">=</span> <span class="pl-en">Writer</span> {
    <span class="pl-k">case</span> <span class="pl-en">DefinedByInt</span>(x, _) <span class="pl-k">=&gt;</span> backend.makeNumber(x)
  }
 
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">definedByIntReader</span><span class="pl-k">:</span> <span class="pl-en">Reader</span>[<span class="pl-en">DefinedByInt</span>] <span class="pl-k">=</span> <span class="pl-en">Reader</span> {
    <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-en">Number</span>(x) <span class="pl-k">=&gt;</span> <span class="pl-en">DefinedByInt</span>(x.intValue(), x.intValue().toString)
  }
}</pre>
  </div> 
  <p>Then this trait should be mixed into the corresponding pickler trait conveniently defined in the library in order to create the pickler object:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.jawn.</span><span class="pl-v">JsonPickler</span>
 
<span class="pl-k">object</span> <span class="pl-en">CustomPickler</span> <span class="pl-k">extends</span> <span class="pl-e">JsonPickler</span> <span class="pl-k">with</span> <span class="pl-e">CustomSerializers</span></pre>
  </div> 
  <p>You can also define the serializers directly in the pickler object if they are not supposed to be reused or if you only have one pickler object in your program:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.jawn.</span><span class="pl-v">JsonPickler</span>
 
<span class="pl-k">object</span> <span class="pl-en">CustomPickler</span> <span class="pl-k">extends</span> <span class="pl-e">JsonPickler</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">definedByIntWriter</span><span class="pl-k">:</span> <span class="pl-en">Writer</span>[<span class="pl-en">DefinedByInt</span>] <span class="pl-k">=</span> <span class="pl-en">Writer</span> {
    <span class="pl-k">case</span> <span class="pl-en">DefinedByInt</span>(x, _) <span class="pl-k">=&gt;</span> backend.makeNumber(x)
  }
 
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">definedByIntReader</span><span class="pl-k">:</span> <span class="pl-en">Reader</span>[<span class="pl-en">DefinedByInt</span>] <span class="pl-k">=</span> <span class="pl-en">Reader</span> {
    <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-en">Number</span>(x) <span class="pl-k">=&gt;</span> <span class="pl-en">DefinedByInt</span>(x.intValue(), x.intValue().toString)
  }
}</pre>
  </div> 
  <p>Alternatively, you can import internals of some pickler and define serializers anywhere, but then you need to add an import for wherever these serializers are defined in:</p> 
  <pre><code>object CustomPickler extends JsonPickler

object CustomSerializers {
  import CustomPickler._
  
  implicit val definedByIntWriter: Writer[DefinedByInt] = Writer {
    case DefinedByInt(x, _) =&gt; backend.makeNumber(x)
  }
 
  implicit val definedByIntReader: Reader[DefinedByInt] = Reader {
    case backend.Extract.Number(x) =&gt; DefinedByInt(x.intValue(), x.intValue().toString)
  }
}

import CustomSerializers._

CustomPickler.write(DefinedByInt(10, "10")) shouldEqual """10"""
</code></pre> 
  <p>This way also prohibits you from using the same serializers for different kinds of picklers in your program.</p> 
  <p>picopickle provides several utilities which help you writing custom serializers and deserializers; at first, however, we need to explain what backends are.</p> 
  <h3><a id="user-content--backends" class="anchor" href="https://github.com/netvl/picopickle#-backends" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-backends" target="_blank" href=""></a> Backends</h3> 
  <p>A <em>backend</em> in picopickle defines an intermediate AST called <em>backend representation</em> which is the media which values of other types can be serialized into. For example, for JSON it is JSON AST, that is, a set of classes which together can be used to form any correct JSON object tree. Additionally, a backend provides methods to construct these values generically from basic Scala types and collections and to deconstruct these values back into these basic types.</p> 
  <p>In general, a backend may be arbitrarily complex. It can consist of a lot of classes with various relationships between them and all the necessary methods to construct them. However, in order to provide the ability to serialize arbitrary types to arbitrary backend representations, some restrictions should be put on the structure of the backend representation, that is, there should be some minimal set of primitives which should be supported by all backends. picopickle requires that all backends support basic JSON-like tree AST, that is, objects keyed by strings, arrays indexed by integers, strings, numbers, booleans and null. Using these primitives, picopickle is able to provide serializers for basic primitive types and sealed trait hierarchies out of the box.</p> 
  <p><code>Backend</code> trait is used to represent backends in Scala code. This trait contains abstract types which define the AST and a lot of methods to construct the AST from basic types. Each implementation of this trait should provide the following abstract types:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">BValue</span>
<span class="pl-k">type</span> <span class="pl-en">BObject</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">BValue</span>
<span class="pl-k">type</span> <span class="pl-en">BArray</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">BValue</span>
<span class="pl-k">type</span> <span class="pl-en">BString</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">BValue</span>
<span class="pl-k">type</span> <span class="pl-en">BNumber</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">BValue</span>
<span class="pl-k">type</span> <span class="pl-en">BBoolean</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">BValue</span>
<span class="pl-k">type</span> <span class="pl-en">BNull</span> <span class="pl-k">&lt;</span><span class="pl-k">:</span> <span class="pl-en">BValue</span></pre>
  </div> 
  <p>Also each implementation must provide a set of methods for converting between these abstract types and basic Scala types. The mapping is as follows:</p> 
  <pre><code>BObject  -&gt; Map[String, BValue]
BArray   -&gt; Vector[BValue]
BString  -&gt; String
BNumber  -&gt; Number
BBoolean -&gt; Boolean
BNull    -&gt; Null
</code></pre> 
  <p>That is, each backend should provide methods to convert from <code>BValue</code> to <code>Map[String, BValue]</code> and back etc. These methods can be divided into three groups:</p> 
  <ul> 
   <li>those which convert Scala values to backend representation: prefixed with <code>make</code>;</li> 
   <li>those which convert backend representation to Scala values: prefixed with <code>from</code>;</li> 
   <li>those which extract concrete backend type (e.g. <code>BObject</code>, <code>BString</code>) from the abstract <code>BValue</code>: prefixed with <code>get</code>.</li> 
  </ul> 
  <p>The last group of methods return <code>Option[&lt;corresponding type&gt;]</code> because they are partial in their nature.</p> 
  <p>There are also some convenience methods like <code>makeEmptyObject</code> or <code>getArrayValueAt</code> which can be defined via a conversion with the corresponding <code>from</code> method and then a query on the resulting Scala object, but these methods may query the underlying backend representation directly, saving on the intermediate objects construction.</p> 
  <p>In order to create a custom backend you need to implement <code>Backend</code> trait first:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyBackend</span> <span class="pl-k">extends</span> <span class="pl-e">Backend</span> {
  <span class="pl-k">type</span> <span class="pl-en">BValue</span> <span class="pl-k">=</span> ...
  ...
}</pre>
  </div> 
  <p>Then you need to create a cake component for this backend; this component must implement <code>BackendComponent</code> trait:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">MyBackendComponent</span> <span class="pl-k">extends</span> <span class="pl-e">BackendComponent</span> {
  <span class="pl-k">override</span> <span class="pl-k">val</span> <span class="pl-en">backend</span> <span class="pl-k">=</span> <span class="pl-en">MyBackend</span>
}</pre>
  </div> 
  <p>And finally you should extend <code>DefaultPickler</code>, mixing it with your backend component:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">MyPickler</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultPickler</span> <span class="pl-k">with</span> <span class="pl-e">MyBackendComponent</span>
<span class="pl-k">object</span> <span class="pl-en">MyPickler</span> <span class="pl-k">extends</span> <span class="pl-e">MyPickler</span></pre>
  </div> 
  <p>Naturally, you can choose not to merge the <code>DefaultPickler</code> fully into your pickler if you don't want to, for example, if you don't need the automatic writers materialization for sealed trait hierarchies. In that case you can mix in only those traits you need. See <code>DefaultPickler</code> documentation to find out which components it consists of (<strong>TODO</strong>).</p> 
  <p>After this <code>MyPickler.read</code> and <code>MyPickler.write</code> methods will work with your backend representation.</p> 
  <h3><a id="user-content--extending-backends" class="anchor" href="https://github.com/netvl/picopickle#-extending-backends" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-extending-backends" target="_blank" href=""></a> Extending backends</h3> 
  <p>Sometimes the set of types and methods provided by the default <code>Backend</code> trait is simply not enough because the desired target representation supports more types. One example is BSON, which supports, aside from all the standard JSON types, also things like date and time, object ids, explicit 32-bit and 64-bit integers and byte arrays. Naturally, one would like to automatically serialize Scala types to the most efficient representation available.</p> 
  <p>picopickle is extensible in this regard too. Because backends are just implementations of one trait, nothing prevents you adding new concrete types into your backend implementation, adding new conversion functions and build your own serializers which make use of these functions:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> Define a new backend</span>
<span class="pl-k">object</span> <span class="pl-en">BsonBackend</span> <span class="pl-k">extends</span> <span class="pl-e">Backend</span> {
  <span class="pl-c"><span class="pl-c">//</span> implement required types</span>
  <span class="pl-k">override</span> <span class="pl-k">type</span> <span class="pl-en">BValue</span> <span class="pl-k">=</span> <span class="pl-en">BsonValue</span>
  <span class="pl-k">override</span> <span class="pl-k">type</span> <span class="pl-en">BObject</span> <span class="pl-k">=</span> <span class="pl-en">BsonDocument</span>
  ...
  
  <span class="pl-c"><span class="pl-c">//</span> add new types</span>
  <span class="pl-k">type</span> <span class="pl-en">BObjectId</span> <span class="pl-k">=</span> <span class="pl-en">BsonObjectId</span>
  <span class="pl-k">type</span> <span class="pl-en">BInt32</span> <span class="pl-k">=</span> <span class="pl-en">BsonInt32</span>
  <span class="pl-k">type</span> <span class="pl-en">BInt64</span> <span class="pl-k">=</span> <span class="pl-en">BsonInt64</span>
  ...
  
  <span class="pl-c"><span class="pl-c">//</span> add new conversion functions, possibly following the existing interface</span>
  <span class="pl-k">def</span> <span class="pl-en">fromObjectId</span>(<span class="pl-v">oid</span>: <span class="pl-en">BObjectId</span>)<span class="pl-k">:</span> <span class="pl-en">ObjectId</span> <span class="pl-k">=</span> ...
  <span class="pl-k">def</span> <span class="pl-en">makeObjectId</span>(<span class="pl-v">oid</span>: <span class="pl-en">ObjectId</span>)<span class="pl-k">:</span> <span class="pl-en">BObjectId</span> <span class="pl-k">=</span> ...
  <span class="pl-k">def</span> <span class="pl-en">getObjectId</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">BObjectId</span> <span class="pl-k">=</span> ...
  
  <span class="pl-k">def</span> <span class="pl-en">fromInt32</span>(<span class="pl-v">n</span>: <span class="pl-en">BInt32</span>)<span class="pl-k">:</span> <span class="pl-k">Int</span> <span class="pl-k">=</span> ...
  ...
  
  <span class="pl-k">def</span> <span class="pl-en">fromInt64</span>(<span class="pl-v">n</span>: <span class="pl-en">BInt64</span>)<span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> ...
  ...
}

<span class="pl-c"><span class="pl-c">//</span> define a backend component</span>
<span class="pl-k">trait</span> <span class="pl-en">BsonBackendComponent</span> <span class="pl-k">extends</span> <span class="pl-e">BackendComponent</span> {
  <span class="pl-k">override</span> <span class="pl-k">val</span> <span class="pl-en">backend</span> <span class="pl-k">=</span> <span class="pl-en">BsonBackend</span>
}

<span class="pl-c"><span class="pl-c">//</span> define a trait with custom serializers</span>
<span class="pl-k">trait</span> <span class="pl-en">BsonBackendSerializers</span> {
  <span class="pl-c"><span class="pl-c">//</span> it should depend on the concrete BsonBackendComponent, not on generic BackendComponent</span>
  <span class="pl-c1">this</span><span class="pl-k">:</span> <span class="pl-en">BsonBackendComponent</span> <span class="pl-k">with</span> <span class="pl-e">TypesComponent</span> <span class="pl-k">=&gt;</span>
  
  <span class="pl-k">import</span> <span class="pl-v">backend.</span><span class="pl-v">_</span>
  
  <span class="pl-c"><span class="pl-c">//</span> and here we can use all custom functions defined in the custom backend</span>
  
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">objectIdReadWriter</span><span class="pl-k">:</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">ObjectId</span>] <span class="pl-k">=</span> 
    <span class="pl-en">ReadWriter</span>.writing(backend.makeObjectId).reading {
      <span class="pl-k">case</span> <span class="pl-v">bv</span>: <span class="pl-en">BObjectId</span> <span class="pl-k">=&gt;</span> backend.fromObjectId(bv)
    }
    
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">intReadWriter</span><span class="pl-k">:</span> <span class="pl-en">ReadWriter</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span>
    <span class="pl-en">ReadWriter</span>.writing(backend.makeInt32).reading {
      <span class="pl-k">case</span> <span class="pl-v">bv</span>: <span class="pl-en">BInt32</span> <span class="pl-k">=&gt;</span> backend.fromInt32(bv)
    }
  
  ...
}

<span class="pl-c"><span class="pl-c">//</span> finally, define the pickler trait by mixing it all together</span>
<span class="pl-k">trait</span> <span class="pl-en">BsonPickler</span> <span class="pl-k">extends</span> <span class="pl-e">DefaultPickler</span> <span class="pl-k">with</span> <span class="pl-e">BsonBackendComponent</span> <span class="pl-k">with</span> <span class="pl-e">BsonBackendSerializers</span>
<span class="pl-k">object</span> <span class="pl-en">BsonPickler</span> <span class="pl-k">extends</span> <span class="pl-e">BsonPickler</span></pre>
  </div> 
  <p>Note that picklers defined in the custom trait will have a greater priority than picklers inherited from the <code>DefaultPickler</code> trait. Therefore, <code>intReadWriter</code> defined in the trait above will be used instead of the <code>intReader</code>/<code>intWriter</code> pair defined in <code>PrimitiveReadWritersComponent</code> which is inherited by <code>DefaultPickler</code>.</p> 
  <p>You can find an example of this technique in the <a href="https://github.com/netvl/picopickle/blob/master/mongodb/src/main/scala/io/github/netvl/picopickle/backends/mongodb/bson.scala" target="_blank">official BSON backend implementation</a>.</p> 
  <h3><a id="user-content--creating-custom-serializers" class="anchor" href="https://github.com/netvl/picopickle#-creating-custom-serializers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-creating-custom-serializers" target="_blank" href=""></a> Creating custom serializers</h3> 
  <p>picopickle defines <code>Writer</code> and <code>Reader</code> basic types in <code>TypesComponent</code> which are called <em>serializers</em>. They are responsible for converting arbitrary types to their backend representation and back, respectively. The most basic way to construct custom serializers is to use <code>apply</code> method on <code>Reader</code> and <code>Writer</code> companion objects, which take <code>PartialFunction[backend.BValue, T]</code> and <code>T =&gt; backend.BValue</code>, respectively (you can find examples of both above).</p> 
  <p>(Terminology note: <code>Writer</code> and <code>Reader</code> are called <em>serializers</em>, while typed serialization objects described above, that is, the ones returned by the call of <code>serializer[T]</code> method, are called <em>serializer objects</em>. While related, these are different things. Serializer objects are completely optional, you won't have to use them if you don't want; on the other hand, serializers are the key entities in picopickle and you can't do away with them.)</p> 
  <p>Any <code>Writer</code>, since it receives a total function, should be able to serialize any values of its corresponding type. <code>Reader</code>, however, can fail to match the backend representation. See below for more information on error handling in picopickle.</p> 
  <p><code>TypesComponent</code> also defines a combined serializer called <code>ReadWriter</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">T</span>] <span class="pl-k">=</span> <span class="pl-en">Reader</span>[<span class="pl-en">T</span>] <span class="pl-k">with</span> <span class="pl-e">Writer</span>[<span class="pl-en">T</span>]</pre>
  </div> 
  <p>Its companion object also provides convenient facilities to create its instances. The example above can be rewritten with <code>ReadWriter</code> like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">definedByIntReadWriter</span><span class="pl-k">:</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">DefinedByInt</span>] <span class="pl-k">=</span> <span class="pl-en">ReadWriter</span>.reading {
  <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-en">Number</span>(x) <span class="pl-k">=&gt;</span> <span class="pl-en">DefinedByInt</span>(x.intValue(), x.intValue().toString)
}.writing {
  <span class="pl-k">case</span> <span class="pl-en">DefinedByInt</span>(x, _) <span class="pl-k">=&gt;</span> backend.makeNumber(x)
}</pre>
  </div> 
  <p>You can switch <code>reading</code>/<code>writing</code> branches order if you like.</p> 
  <h3><a id="user-content--extractors-and-backend-conversion-implicits" class="anchor" href="https://github.com/netvl/picopickle#-extractors-and-backend-conversion-implicits" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-extractors-and-backend-conversion-implicits" target="_blank" href=""></a> Extractors and backend conversion implicits</h3> 
  <p><code>Backend</code> trait provides methods to create and deconstruct objects of backend representation: these are <code>make*</code>, <code>from*</code> and <code>get*</code> methods described above. To simplify writing custom serializers, however, picopickle provides a set of tools which help you writing conversions. The most basic of them are <em>extractors</em> and <em>backend conversion implicits</em>.</p> 
  <p>Backend object contains several singleton objects with <code>unapply</code> methods which can be used to pattern-match on <code>backend.BValue</code> and obtain the low-level values out of it, for example, to get a <code>Map[String, backend.BValue]</code> out of <code>backend.BObject</code>, if this particular <code>backend.BValue</code> which you're matching on indeed is a <code>backend.BObject</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>backend.makeObject(...) <span class="pl-k">match</span> {
  <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-en">Object</span>(m) <span class="pl-k">=&gt;</span>  <span class="pl-c"><span class="pl-c">//</span> m is of type Map[String, backend.BValue]</span>
}</pre>
  </div> 
  <p>There are extractors for all of the main backend representation variants:</p> 
  <ul> 
   <li><code>backend.Extract.Object</code></li> 
   <li><code>backend.Extract.Array</code></li> 
   <li><code>backend.Extract.String</code></li> 
   <li><code>backend.Extract.Number</code></li> 
   <li><code>backend.Extract.Boolean</code></li> 
  </ul> 
  <p>Their <code>unapply</code> implementation simply calls corresponding <code>get*</code> and <code>from*</code> methods, like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Extractors</span> {
  <span class="pl-k">object</span> <span class="pl-en">String</span> {
    <span class="pl-k">def</span> <span class="pl-en">unapply</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> getString(value).map(fromString)
  }
}</pre>
  </div> 
  <p>The opposite conversion (from primitives to the backend representation) can be done with <code>make*</code> methods on the backend, but picopickle also provides a set of implicit decorators which provide <code>toBackend</code> method on all of the basic types. These decorators are defined in <code>backend.conversionImplicits</code> object:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">backend.conversionImplicits.</span><span class="pl-v">_</span>
 
<span class="pl-k">val</span> <span class="pl-en">s</span><span class="pl-k">:</span> backend.<span class="pl-en">BString</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>.toBackend
 
<span class="pl-c"><span class="pl-c">//</span> the above is equivalent to this:</span>
 
<span class="pl-k">val</span> <span class="pl-en">s</span><span class="pl-k">:</span> backend.<span class="pl-en">BString</span> <span class="pl-k">=</span> backend.makeString(<span class="pl-s"><span class="pl-pds">"</span>hello world<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>These implicit methods are somewhat more convenient than <code>make*</code> functions.</p> 
  <h2><a id="user-content--converters" class="anchor" href="https://github.com/netvl/picopickle#-converters" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-converters" target="_blank" href=""></a> Converters</h2> 
  <p>Low-level conversions, however, may be overly verbose to write. picopickle provides a declarative way of defining how the backend representation should be translated to the desired Scala objects and vice versa. This is done with <em>converters</em>.</p> 
  <p>A converter looks much like a <code>ReadWriter</code>; however, it is parameterized by two types, source and target:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">Converter</span>[<span class="pl-k">-</span><span class="pl-en">T</span>, <span class="pl-k">+</span><span class="pl-en">U</span>] {
  <span class="pl-k">def</span> <span class="pl-en">toBackend</span>(<span class="pl-v">v</span>: <span class="pl-en">T</span>)<span class="pl-k">:</span> backend.<span class="pl-en">BValue</span>
  <span class="pl-k">def</span> <span class="pl-en">isDefinedAt</span>(<span class="pl-v">bv</span>: backend.<span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-k">Boolean</span>
  <span class="pl-k">def</span> <span class="pl-en">fromBackend</span>(<span class="pl-v">bv</span>: backend.<span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">U</span>
}</pre>
  </div> 
  <p>The converters library defines several implicit conversions which allow any converter to be used as the corresponding <code>Reader</code>, <code>Writer</code> or <code>ReadWriter</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Converter</span>[<span class="pl-en">T</span>, _] <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">Writer</span>[<span class="pl-en">T</span>]
<span class="pl-en">Converter</span>[_, <span class="pl-en">U</span>] <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">Reader</span>[<span class="pl-en">U</span>]
<span class="pl-en">Converter</span>[<span class="pl-en">T</span>, <span class="pl-en">T</span>] <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">T</span>]</pre>
  </div> 
  <p>A converter which consumes and produces the same type is called an <em>identity</em> converter for that type. Naturally, only identity converters can be used as <code>ReadWriter</code>s. Identity converters have a convenient type alias <code>Converter.Id[T]</code>.</p> 
  <p>Converters library also defines several combinators on converters which allow combining them to obtain new converters, and it also provides built-in converters for basic primitive types and objects and arrays.</p> 
  <p>For example, here is how you can define a conversion for some case class manually:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">a</span>: <span class="pl-k">Boolean</span>, <span class="pl-v">b</span>: <span class="pl-k">Double</span>)
 
<span class="pl-k">trait</span> <span class="pl-en">CustomSerializers</span> <span class="pl-k">extends</span> <span class="pl-e">JsonPickler</span> {
  <span class="pl-k">import</span> <span class="pl-v">shapeless.</span><span class="pl-v">_</span>
  <span class="pl-k">import</span> <span class="pl-v">converters.</span><span class="pl-v">_</span>
 
  <span class="pl-k">val</span> <span class="pl-en">aConverter</span><span class="pl-k">:</span> <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> unlift(<span class="pl-en">A</span>.unapply) <span class="pl-k">&gt;&gt;&gt;</span> obj {
    <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> bool <span class="pl-k">::</span>
    <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> num.double <span class="pl-k">::</span>
    <span class="pl-en">HNil</span>
  } <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-en">A</span>.apply _
 
  <span class="pl-k">val</span> <span class="pl-en">aReadWriter</span><span class="pl-k">:</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> aConverter  <span class="pl-c"><span class="pl-c">//</span> an implicit conversion is used here</span>
}</pre>
  </div> 
  <p>Here <code>obj.apply</code> is used to define an identity converter for <code>Boolean :: Double :: HNil</code>, and <code>&gt;&gt;&gt;</code> operations "prepend" and "append" a deconstructor and a constructor for class <code>A</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">A</span>.unapply          <span class="pl-k">:</span> <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Option</span>[(<span class="pl-k">Boolean</span>, <span class="pl-k">Double</span>)]
unlift(<span class="pl-en">A</span>.unapply)  <span class="pl-k">:</span> <span class="pl-en">A</span> <span class="pl-k">=&gt;</span> (<span class="pl-k">Boolean</span>, <span class="pl-k">Double</span>)
 
<span class="pl-en">A</span>.apply <span class="pl-v">_</span>          : (<span class="pl-k">Boolean</span>, <span class="pl-k">Double</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>
 
obj {
  <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> bool <span class="pl-k">::</span>
  <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> num.double <span class="pl-k">::</span>
  <span class="pl-en">HNil</span>
}                  <span class="pl-k">:</span> <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-k">Boolean</span> <span class="pl-k">::</span> <span class="pl-k">Double</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>]</pre>
  </div> 
  <p><code>bool</code> and <code>num.double</code> are identity converters for <code>Boolean</code> and <code>Double</code>, respectively.</p> 
  <p><code>&gt;&gt;&gt;</code> operations employ a little of shapeless magic to convert the functions like the ones above to functions which consume and produce <code>HList</code>s. There is also <code>&gt;&gt;</code> combinator which does not use shapeless and "prepends" and "appends" a function of corresponding type directly:</p> 
  <div class="highlight highlight-source-scala">
   <pre>(<span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>) <span class="pl-k">&gt;&gt;</span> <span class="pl-en">Converter</span>[<span class="pl-en">B</span>, <span class="pl-en">C</span>] <span class="pl-k">&gt;&gt;</span> (<span class="pl-en">C</span> <span class="pl-k">=&gt;</span> <span class="pl-en">D</span>)  <span class="pl-k">-</span><span class="pl-k">&gt;</span>  <span class="pl-en">Converter</span>[<span class="pl-en">A</span>, <span class="pl-en">D</span>]
 
<span class="pl-c"><span class="pl-c">//</span> compare:</span>
 
(<span class="pl-en">A</span> <span class="pl-k">=&gt;</span> (<span class="pl-en">T1</span>, <span class="pl-en">T2</span>, ..., <span class="pl-en">Tn</span>)) <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-en">T1</span> <span class="pl-k">::</span> <span class="pl-en">T2</span> <span class="pl-k">::</span> ... <span class="pl-k">::</span> <span class="pl-en">Tn</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>] <span class="pl-k">&gt;&gt;&gt;</span> ((<span class="pl-en">T1</span>, <span class="pl-en">T2</span>, ..., <span class="pl-en">Tn</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>)  <span class="pl-k">-</span><span class="pl-k">&gt;</span>  <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-en">A</span>]</pre>
  </div> 
  <p>Note that this is very type-safe. For example, if you get the order or the types of fields in <code>obj</code> wrong, it won't compile.</p> 
  <p>picopickle additionally provides a convenient implicit alias for <code>andThen</code> on functions, also called <code>&gt;&gt;</code>. Together with <code>&gt;&gt;</code> on converters this allows writing chains of transformations easily. For example, suppose you have an object which can be represented as an array of bytes. Then you want to serialize this byte array as a string in Base64 encoding. This can be written as follows:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">java.util.</span><span class="pl-v">Base64</span>
<span class="pl-k">import</span> <span class="pl-v">java.nio.charset.</span><span class="pl-v">StandardCharsets</span>
 
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Data</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>)
<span class="pl-k">object</span> <span class="pl-en">Data</span> {
  <span class="pl-k">def</span> <span class="pl-en">asBytes</span>(<span class="pl-v">d</span>: <span class="pl-en">Data</span>) <span class="pl-k">=</span> d.s.getBytes(<span class="pl-en">StandardCharsets</span>.<span class="pl-en">UTF_8</span>)
  <span class="pl-k">def</span> <span class="pl-en">fromBytes</span>(<span class="pl-v">b</span>: <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]) <span class="pl-k">=</span> <span class="pl-en">Data</span>(<span class="pl-k">new</span> <span class="pl-en">String</span>(b, <span class="pl-en">StandardCharsets</span>.<span class="pl-en">UTF_8</span>))
}
 
<span class="pl-k">val</span> <span class="pl-en">dataReadWriter</span><span class="pl-k">:</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">Data</span>] <span class="pl-k">=</span>
  <span class="pl-en">Data</span>.asBytes _ <span class="pl-k">&gt;&gt;</span>
  <span class="pl-en">Base64</span>.getEncoder.encodeToString _ <span class="pl-k">&gt;&gt;</span>
  str <span class="pl-k">&gt;&gt;</span>
  <span class="pl-en">Base64</span>.getDecoder.decode _ <span class="pl-k">&gt;&gt;</span>
  <span class="pl-en">Data</span>.fromBytes _</pre>
  </div> 
  <p>The sequence of functions chained with <code>&gt;&gt;</code> naturally defines the transformation order in both directions.</p> 
  <p>Similar thing is also possible for arrays. For example, you can serialize your case class as an array of fields:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">aReadWriter</span><span class="pl-k">:</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> unlift(<span class="pl-en">A</span>.unapply) <span class="pl-k">&gt;&gt;&gt;</span> arr(bool <span class="pl-k">::</span> num.double <span class="pl-k">::</span> <span class="pl-en">HNil</span>) <span class="pl-k">&gt;&gt;&gt;</span> <span class="pl-en">A</span>.apply _</pre>
  </div> 
  <p>Naturally, there are converters for homogeneous arrays and objects too - they allow mapping to Scala collections:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">intListConv</span><span class="pl-k">:</span> <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-en">List</span>[<span class="pl-k">Int</span>]] <span class="pl-k">=</span> arr.as[<span class="pl-en">List</span>].of(num.int)
<span class="pl-k">val</span> <span class="pl-en">vecTreeMapConv</span><span class="pl-k">:</span> <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-en">TreeMap</span>[<span class="pl-k">String</span>, <span class="pl-en">Vector</span>[<span class="pl-k">Double</span>]]] <span class="pl-k">=</span> obj.as[<span class="pl-en">TreeMap</span>].to(arr.as[<span class="pl-en">Vector</span>].of(num.double))</pre>
  </div> 
  <p>There is also a converter which delegates to <code>Reader</code> and <code>Writer</code> if corresponding implicit instances are available:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">optionStringConv</span><span class="pl-k">:</span> <span class="pl-en">Converter</span>.<span class="pl-en">Id</span>[<span class="pl-en">Option</span>[<span class="pl-k">String</span>]] <span class="pl-k">=</span> value[<span class="pl-en">Option</span>[<span class="pl-k">String</span>]]</pre>
  </div> 
  <p>You can find more on converters in their Scaladoc section (<strong>TODO</strong>).</p> 
  <h2><a id="user-content--supported-types" class="anchor" href="https://github.com/netvl/picopickle#-supported-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-supported-types" target="_blank" href=""></a> Supported types</h2> 
  <p>By default picopickle provides a lot of serializers for various types which do their best to represent their respective types in the serialized form as close as possible. These serializers are then mixed into a single pickler.</p> 
  <p>The serializers are defined in a couple of traits:</p> 
  <pre><code>io.github.netvl.picopickle.{CollectionReaders, CollectionWriters, CollectionReaderWritersComponent}
io.github.netvl.picopickle.{ShapelessReaders, ShapelessWriters, ShapelessReaderWritersComponent}
io.github.netvl.picopickle.{PrimitiveReaders, PrimitiveWriters, PrimitiveReaderWritersComponent}
io.github.netvl.picopickle.{TupleReaders, TupleWriters, TupleReaderWritersComponent}  // generated automatically
</code></pre> 
  <p>Every serializer is an overloadable <code>def</code> or <code>val</code>, so you can easily customize serialization format by overriding the corresponding implicit definition with your own one.</p> 
  <p>Examples below use <code>JsonPickler</code>, so it is implicitly assumed that something like</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.backends.jawn.JsonPickler.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>is present in the code.</p> 
  <h3><a id="user-content--primitives-and-basic-types" class="anchor" href="https://github.com/netvl/picopickle#-primitives-and-basic-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-primitives-and-basic-types" target="_blank" href=""></a> Primitives and basic types</h3> 
  <p>picopickle natively supports serialization of all primitive and basic types:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-c1">1</span><span class="pl-k">:</span> <span class="pl-k">Int</span>)       shouldEqual <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">2L</span><span class="pl-k">:</span> <span class="pl-k">Long</span>)     shouldEqual <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">12.2</span><span class="pl-k">:</span> <span class="pl-k">Double</span>) shouldEqual <span class="pl-s"><span class="pl-pds">"</span>3<span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">'a'</span>)          shouldEqual <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>a<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>
writeString(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>)      shouldEqual <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>hello<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">true</span>)         shouldEqual <span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">false</span>)        shouldEqual <span class="pl-s"><span class="pl-pds">"</span>false<span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">null</span>)         shouldEqual <span class="pl-s"><span class="pl-pds">"</span>null<span class="pl-pds">"</span></span>
writeString(<span class="pl-en">'symbol</span>)      shouldEqual <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>symbol<span class="pl-cce">\"</span><span class="pl-pds">"</span></span></pre>
  </div> 
  <p>By default characters are serialized as strings, but, for example, collections backend redefines this behavior.</p> 
  <p>picopickle also can serialize <code>Option[T]</code> and <code>Either[L, R]</code> as long as there are serializers for their type parameters:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-en">Some</span>(<span class="pl-c1">1</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1]<span class="pl-pds">"</span></span>
writeString(<span class="pl-c1">None</span>)    shouldEqual <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>

writeString(<span class="pl-en">Left</span>(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>))   shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>[0,"hello"]<span class="pl-pds">"""</span></span>
writeString(<span class="pl-en">Right</span>(<span class="pl-en">'goodbye</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>[1,"goodbye"]<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Optional values are also handled specially when they are a part of case class definition; see below for more explanation.</p> 
  <p>Please note that <code>Either[L, R]</code> serialization format is not final and can change in future versions.</p> 
  <h3><a id="user-content--numbers-and-accuracy" class="anchor" href="https://github.com/netvl/picopickle#-numbers-and-accuracy" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-numbers-and-accuracy" target="_blank" href=""></a> Numbers and accuracy</h3> 
  <p>Most JSON libraries represent numbers as 64-bit floats, i.e. <code>Double</code>s, but some numerical values do not fit into <code>Double</code>, and rounding occurs:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c1">80000000000000000.0</span> shouldEqual <span class="pl-c1">80000000000000008.0</span>   <span class="pl-c"><span class="pl-c">//</span> does not throw</span></pre>
  </div> 
  <p>In order to represent numbers as accurately as possible picopickle by default serializes all <code>Long</code>s which cannot be represented as <code>Double</code> precisely as strings:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-c1">80000000000000000L</span>)      shouldEqual <span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>80000000000000000<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>
writeString(<span class="pl-k">Double</span>.<span class="pl-en">PositiveInfinity</span>) shouldEqual <span class="pl-s"><span class="pl-pds">"</span>Infinity<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>The same mechanism will probably be used when <code>BigInt</code>/<code>BigDecimal</code> handlers will be added.</p> 
  <p>In some backends, however, this behavior can be overridden, as is done, for example, in the official BSON backend.</p> 
  <h3><a id="user-content--tuples" class="anchor" href="https://github.com/netvl/picopickle#-tuples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-tuples" target="_blank" href=""></a> Tuples</h3> 
  <p>Tuples are serialized as arrays:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString((<span class="pl-c1">1</span>, <span class="pl-c1">true</span>, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>))  shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,true,<span class="pl-cce">\"</span>a<span class="pl-cce">\"</span>]<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>The only exception is a tuple of zero items, usually called <code>Unit</code>. It is serialized as an empty object:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(())           shouldEqual <span class="pl-s"><span class="pl-pds">"</span>{}<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Naturally, all elements of tuples must be serializable as well.</p> 
  <p>Tuple serializer instances are generated as a part of build process, and currently only tuples with the length up to and including 22 are supported.</p> 
  <h3><a id="user-content--collections" class="anchor" href="https://github.com/netvl/picopickle#-collections" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-collections" target="_blank" href=""></a> Collections</h3> 
  <p>Most of Scala collections library classes are supported, including all of the abstract ones below the <code>Iterable</code>, as well as arrays:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-en">Iterable</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>))    shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,2,3,4]<span class="pl-pds">"</span></span>
writeString(<span class="pl-en">Seq</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>))         shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,2,3,4]<span class="pl-pds">"</span></span>
writeString(<span class="pl-en">Set</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>))         shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,2,3,4]<span class="pl-pds">"</span></span>
writeString(<span class="pl-en">Map</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>, <span class="pl-c1">3</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>))     shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[[1,2],[3,4]]<span class="pl-pds">"</span></span>

writeString(<span class="pl-c1">1</span> <span class="pl-k">::</span> <span class="pl-c1">2</span> <span class="pl-k">::</span> <span class="pl-c1">3</span> <span class="pl-k">::</span> <span class="pl-c1">Nil</span>)      shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,2,3]<span class="pl-pds">"</span></span>
writeString(<span class="pl-en">Vector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>))         shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,2,3]<span class="pl-pds">"</span></span>
wrtieString(<span class="pl-en">TreeMap</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>, <span class="pl-c1">3</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[[1,2],[3,4]]<span class="pl-pds">"</span></span>

writeString(<span class="pl-en">Array</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>))          shouldEqual <span class="pl-s"><span class="pl-pds">"</span>[1,2,3]<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Mutable collections can be [de]serialized as well.</p> 
  <p>Maps are serialized like iterables of two-element tuples, that is, into arrays of two-element arrays. However, if the map has string keys (which is determined statically), it will be serialized as an object:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"a":1,"b":2}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>The above behavior of serializing maps with string keys is the default, but it can be extended. See below.</p> 
  <p>If you're using abstract collection types like <code>Seq</code>, <code>Set</code> or <code>Map</code>, picopickle will work flawlessly. If you use concrete collection types, however, there could be problems. picopickle has a lot of instances for most of the main concrete implementations, but not for all of them. If you need something which is not present in the library, feel free to file an issue.</p> 
  <h3><a id="user-content--map-serialization-with-non-string-keys" class="anchor" href="https://github.com/netvl/picopickle#-map-serialization-with-non-string-keys" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-map-serialization-with-non-string-keys" target="_blank" href=""></a> Map serialization with non-string keys</h3> 
  <p>JSON-like languages usually don't allow using non-string values as object keys, and picopickle enforces this restriction by its <code>BObject</code> representation which requires string keys. However, this is sometimes overly restrictive, especially in a richly typed language like Scala and because of common patterns which follow from this.</p> 
  <p>It is not unusual for Scala projects to have a newtype or several for <code>String</code>, for example, for different kind of identifiers:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">PostId</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">UserId</span>(<span class="pl-v">id</span>: <span class="pl-k">String</span>)</pre>
  </div> 
  <p>Alternatively, it is possible to have such simple value class which does not wrap a <code>String</code> but which can easily be converted to and from a string:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">EntityPath</span>(<span class="pl-v">elems</span>: <span class="pl-en">Vector</span>[<span class="pl-k">String</span>]) {
  <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toString</span> <span class="pl-k">=</span> elems.mkString(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>)
}
<span class="pl-k">object</span> <span class="pl-en">EntityPath</span> {
  <span class="pl-k">def</span> <span class="pl-en">fromString</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> <span class="pl-en">EntityPath</span>(s.split(<span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>).toVector)
}</pre>
  </div> 
  <p>It is sometimes desirable to have these classes as keys in maps:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">UserMap</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>[<span class="pl-en">UserId</span>, <span class="pl-en">User</span>]
<span class="pl-k">type</span> <span class="pl-en">EntityLocations</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>[<span class="pl-en">EntityPath</span>, <span class="pl-en">Entity</span>]</pre>
  </div> 
  <p>One would naturally want for these maps to have an object-based representation (instead of an array of arrays) because keys are easily converted to and from strings. In picopickle, however, only maps of type <code>Map[String, T]</code> can be directly serialized as objects.</p> 
  <p>To allow this kind of pattern, picopickle provides a way to define custom converters for map keys. When a map with keys of type <code>T</code> is serialized or deserialized, and if there is an instance of type <code>ObjectKeyReader[T]</code>/<code>ObjectKeyWriter[T]</code>/<code>ObjectKeyReadWriter[T]</code> in scope, then it will be used to obtain a <code>String</code> from <code>T</code> (or vice versa) which will then be used as an object key:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">userIdObjectKeyReadWriter</span> <span class="pl-k">=</span> <span class="pl-en">ObjectKeyReadWriter</span>(_.id, <span class="pl-en">UserId</span>)

<span class="pl-c"><span class="pl-c">//</span> below a `_.toString` conversion is implicitly used</span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">entityPathObjectKeyReadWriter</span> <span class="pl-k">=</span> <span class="pl-en">ObjectKeyReadWriter</span>(<span class="pl-en">EntityPath</span>.fromString)

write[<span class="pl-en">UserMap</span>](<span class="pl-en">Map</span>(<span class="pl-en">UserId</span>(<span class="pl-s"><span class="pl-pds">"</span>u1<span class="pl-pds">"</span></span>) <span class="pl-k">-</span><span class="pl-k">&gt;</span> ..., <span class="pl-en">UserId</span>(<span class="pl-s"><span class="pl-pds">"</span>u2<span class="pl-pds">"</span></span>) <span class="pl-k">-</span><span class="pl-k">&gt;</span> ...)) shouldEqual 
  <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>u1<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> ..., <span class="pl-s"><span class="pl-pds">"</span>u2<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> ...)
  
write[<span class="pl-en">EntityLocations</span>](<span class="pl-en">Map</span>(<span class="pl-en">EntityPath</span>(<span class="pl-en">Vector</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> ..., <span class="pl-en">EntityPath</span>(<span class="pl-en">Vector</span>(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>c<span class="pl-pds">"</span></span>)) <span class="pl-k">-</span><span class="pl-k">&gt;</span> ...)) shouldEqual
  <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>a/b<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> ..., <span class="pl-s"><span class="pl-pds">"</span>a/c<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> ...)

<span class="pl-c"><span class="pl-c">//</span> reading works just as well</span></pre>
  </div> 
  <p>However, with this flexibility in large codebases where one pickler is shared by lots of different classes it is easy to accidentally add a conversion which would break serialization format in some other part of the project. To allow controlling this picopickle supports <em>disabling</em> of automatic map serialization for unknown key types. You would need then to define an object key serializer for this particular type or explicitly allow maps with this type as a key to be serialized as an array of arrays. You need to create a custom pickler and mix <code>MapPicklingDisabledByDefault</code> trait into it:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">CustomPickler</span> <span class="pl-k">extends</span> <span class="pl-e">CollectionsPickler</span> <span class="pl-k">with</span> <span class="pl-e">MapPicklingDisabledByDefault</span>

<span class="pl-c"><span class="pl-c">//</span> won't compile because there is no ObjectKeyWriter[Int] in scope and serialization of maps</span>
<span class="pl-c"><span class="pl-c">//</span> with Int keys is not allowed</span>
write(<span class="pl-en">Map</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>))  

<span class="pl-c"><span class="pl-c">//</span> ---</span>

<span class="pl-k">object</span> <span class="pl-en">CustomPickler</span> <span class="pl-k">extends</span> <span class="pl-e">CollectionsPickler</span> <span class="pl-k">with</span> <span class="pl-e">MapPicklingDisabledByDefault</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">intObjectKeyReadWriter</span> <span class="pl-k">=</span> <span class="pl-en">ObjectKeyReadWriter</span>(_.toInt)
}

<span class="pl-c"><span class="pl-c">//</span> works because we have defined an object key serializer for Int</span>
write(<span class="pl-en">Map</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>2<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> ---</span>

<span class="pl-k">object</span> <span class="pl-en">CustomPickler</span> <span class="pl-k">extends</span> <span class="pl-e">CollectionsPickler</span> <span class="pl-k">with</span> <span class="pl-e">MapPicklingDisabledByDefault</span> {
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">intObjectKeyAllowed</span> <span class="pl-k">=</span> allowMapPicklingWithKeyOfType[<span class="pl-k">Int</span>]
}

<span class="pl-c"><span class="pl-c">//</span> works because we explicitly allowed maps of type Map[Int, T] to be serialized as an array of arrays</span>
write(<span class="pl-en">Map</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>, <span class="pl-c1">2</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-en">Vector</span>(<span class="pl-en">Vector</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>), <span class="pl-en">Vector</span>(<span class="pl-c1">1</span>, <span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>))</pre>
  </div> 
  <p>Note that currently even if map pickling is allowed like in the above piece of code, putting an object key serializer for the corresponding type will force picopickle to use it, allowing potential unexpected changes of serialization format like described above. However: first, this will be fixed in future versions; second, it still disallows one to <em>accidentally</em> serialize maps as arrays of arrays and then have broken format by deliberate introduction of keys serializer, which looks like the most likely possibility of introducing such breaking changes.</p> 
  <h3><a id="user-content--sealed-trait-hierarchies" class="anchor" href="https://github.com/netvl/picopickle#-sealed-trait-hierarchies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-sealed-trait-hierarchies" target="_blank" href=""></a> Sealed trait hierarchies</h3> 
  <p>picopickle supports automatic serialization of sealed trait hierarchies (STH), that is, case classes, probably inheriting a sealed trait. In other words, picopickle can serialize algebraic data types.</p> 
  <p>The most trivial examples of STH are standalone case objects and case classes:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">A</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">B</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-en">A</span>)

writeString(<span class="pl-en">A</span>)        shouldEqual <span class="pl-s"><span class="pl-pds">"</span>{}<span class="pl-pds">"</span></span>
writeString(<span class="pl-en">B</span>(<span class="pl-c1">10</span>, <span class="pl-en">A</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":10,"y":{}}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>By default picopickle serializes case classes as objects with keys being the names of the fields. Case objects are serialized as empty objects.</p> 
  <p>Case classes and objects can have a sealed trait as their parent:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Root</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">A</span> <span class="pl-k">extends</span> <span class="pl-e">Root</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">B</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-v">y</span>: <span class="pl-k">Boolean</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">C</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">y</span>: <span class="pl-en">Root</span>) <span class="pl-k">extends</span> <span class="pl-e">Root</span></pre>
  </div> 
  <p>When you explicitly set the serialized type to <code>Root</code> (or pass a value of type <code>Root</code> but not of some concrete subclass), it will be serialized as an object with a <em>discriminator key</em>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString[<span class="pl-en">Root</span>](<span class="pl-en">A</span>)           shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"$variant":"A"}<span class="pl-pds">"""</span></span>
writeString[<span class="pl-en">Root</span>](<span class="pl-en">B</span>(<span class="pl-c1">10</span>, <span class="pl-c1">true</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"$variant":"B","x":10,"y":true}<span class="pl-pds">"""</span></span>
writeString[<span class="pl-en">Root</span>](<span class="pl-en">C</span>(<span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>, <span class="pl-en">A</span>))  shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"$variant":"C","name":"me","y":{"$variant":"A"}}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>If you don't request <code>Root</code> explicitly, the classes will be serialized as if they were not a part of an STH:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-en">B</span>(<span class="pl-c1">10</span>, <span class="pl-c1">true</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":10,"y":true}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Usually this is not a problem, however, because if you are working with a sealed trait, you usually have variables of its type, not of its subtypes.</p> 
  <p>Sealed trait hierarchies serialization is implemented using shapeless <code>LabelledGeneric</code> implicitly materialized instances and a bit of custom macros which handle field renaming and default values (both are not supported by shapeless natively).</p> 
  <h3><a id="user-content--changing-the-discriminator-key" class="anchor" href="https://github.com/netvl/picopickle#-changing-the-discriminator-key" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-changing-the-discriminator-key" target="_blank" href=""></a> Changing the discriminator key</h3> 
  <p>You can customize the discriminator key used by shapeless serializers by overriding <code>discriminatorKey</code> field defined in <code>io.github.netvl.picopickle.SealedTraitDiscriminator</code> trait (its default value is <code>"$variant"</code>):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">CustomPickler</span> <span class="pl-k">extends</span> <span class="pl-e">JsonPickler</span> {
  <span class="pl-k">override</span> <span class="pl-k">val</span> <span class="pl-en">discriminatorKey</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>$type<span class="pl-pds">"</span></span>
}

<span class="pl-c"><span class="pl-c">//</span> STH is from the example above</span>
<span class="pl-en">CustomPickler</span>.writeString[<span class="pl-en">Root</span>](<span class="pl-en">A</span>) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"$type":"A"}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Of course, you can extract it into a separate trait and mix it into different picklers if you want.</p> 
  <p>Alternatively, since 0.2.0 you can specify the discriminator key for the specific sealed trait hierarchy by putting a <code>@discriminator</code> annotation on the sealed trait:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.</span><span class="pl-v">discriminator</span>

<span class="pl-k">@</span>discriminator(<span class="pl-s"><span class="pl-pds">"</span>status<span class="pl-pds">"</span></span>) <span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Root</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">Stopped</span> <span class="pl-k">extends</span> <span class="pl-e">Root</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Running</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>) <span class="pl-k">extends</span> <span class="pl-e">Root</span>

writeString[<span class="pl-en">Root</span>](<span class="pl-en">Stopped</span>)       shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{status:"Stopped"}<span class="pl-pds">"""</span></span>
writeString[<span class="pl-en">Root</span>](<span class="pl-en">Running</span>(<span class="pl-s"><span class="pl-pds">"</span>me<span class="pl-pds">"</span></span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{status:"Running","name":"me"}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>If <code>@discriminator</code> annotation is present, then its value will be used as discriminator key; otherwise, the default value from <code>discriminatorKey</code> pickler field will be used.</p> 
  <h3><a id="user-content--serialization-of-optional-fields" class="anchor" href="https://github.com/netvl/picopickle#-serialization-of-optional-fields" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-serialization-of-optional-fields" target="_blank" href=""></a> Serialization of optional fields</h3> 
  <p>If a case class has a field of type <code>Option[T]</code>, then this field is serialized in a different way than a regular option: if the value of the field is <code>None</code>, then the corresponding key will be absent from the serialized data, and if it is <code>Some(x)</code>, then the key will be present and its value will be just <code>x</code>, without an additional layer of an array:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">x</span>: <span class="pl-en">Option</span>[<span class="pl-k">Long</span>])

writeString(<span class="pl-en">A</span>(<span class="pl-s"><span class="pl-pds">"</span>absent<span class="pl-pds">"</span></span>))            shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"name":"absent"}<span class="pl-pds">"""</span></span>
writeString(<span class="pl-en">A</span>(<span class="pl-s"><span class="pl-pds">"</span>present<span class="pl-pds">"</span></span>, <span class="pl-en">Some</span>(<span class="pl-c1">42L</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"name":"present","x":42}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>This allows easy evolution of your data structures - you can always add an <code>Option</code>al field and the data serialized before this update will still be deserialized correctly, putting a <code>None</code> into the new field.</p> 
  <p>If an optional field again contains an option:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-en">Option</span>[<span class="pl-en">Option</span>[<span class="pl-k">Long</span>]])</pre>
  </div> 
  <p>then the "outer" option is serialized as described in the above paragraph while the "inner" option is serialized as a possibly empty array, just like options are serialized in other contexts:</p> 
  <div class="highlight highlight-source-scala">
   <pre>writeString(<span class="pl-en">A</span>(<span class="pl-c1">None</span>))            shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{}<span class="pl-pds">"""</span></span>
writeString(<span class="pl-en">A</span>(<span class="pl-en">Some</span>(<span class="pl-c1">None</span>)))      shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":[]}<span class="pl-pds">"""</span></span>
writeString(<span class="pl-en">A</span>(<span class="pl-en">Some</span>(<span class="pl-en">Some</span>(<span class="pl-c1">10L</span>)))) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":[10]}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <h3><a id="user-content--renaming-fields-and-sealed-trait-variants" class="anchor" href="https://github.com/netvl/picopickle#-renaming-fields-and-sealed-trait-variants" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-renaming-fields-and-sealed-trait-variants" target="_blank" href=""></a> Renaming fields and sealed trait variants</h3> 
  <p>picopickle also provides an ability to rename fields and STH variant labels. This can be done by annotating fields with <code>@key</code> annotation:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">io.github.netvl.picopickle.</span><span class="pl-v">key</span>

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Root</span>
<span class="pl-k">@</span>key(<span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>) <span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">A</span>
<span class="pl-k">@</span>key(<span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>) <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">B</span>(<span class="pl-k">@</span>key(<span class="pl-s"><span class="pl-pds">"</span>a<span class="pl-pds">"</span></span>) <span class="pl-v">x</span>: <span class="pl-k">Int</span>, <span class="pl-k">@</span>key(<span class="pl-s"><span class="pl-pds">"</span>b<span class="pl-pds">"</span></span>) <span class="pl-v">y</span>: <span class="pl-k">Boolean</span>)

writeString[<span class="pl-en">Root</span>](<span class="pl-en">A</span>)            shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"$variant":"0"}<span class="pl-pds">"""</span></span>
writeString[<span class="pl-en">Root</span>](<span class="pl-en">B</span>(<span class="pl-c1">10</span>, <span class="pl-c1">false</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"$variant":"1","a":10,"b":false}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Keys always are strings, though.</p> 
  <h3><a id="user-content--default-values-of-case-class-fields" class="anchor" href="https://github.com/netvl/picopickle#-default-values-of-case-class-fields" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-default-values-of-case-class-fields" target="_blank" href=""></a> Default values of case class fields</h3> 
  <p>picopickle also respects default values defined in a case class, which simplifies changes in your data classes even more. If a field has a default value and the serialized object does not contain the corresponding field, the default value will be used:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">n</span>: <span class="pl-k">Int</span> <span class="pl-k">=</span> <span class="pl-c1">11</span>)

readString[<span class="pl-en">A</span>](<span class="pl-s"><span class="pl-pds">"""</span>{"n":22}<span class="pl-pds">"""</span></span>) shouldEqual <span class="pl-en">A</span>(<span class="pl-c1">22</span>)
readString[<span class="pl-en">A</span>](<span class="pl-s"><span class="pl-pds">"""</span>{}<span class="pl-pds">"""</span></span>)       shouldEqual <span class="pl-en">A</span>()</pre>
  </div> 
  <p>As you can see, this mechanism naturally interferes with the optional fields handling. picopickle resolves this conflict in the following way: if no value is present at the corresponding key and a default value is set for the field, then it takes precedence over option handling. This affects a rather rare case when there is an optional field with a default value other than <code>None</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">n</span>: <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-c1">10</span>))

readString[<span class="pl-en">A</span>](<span class="pl-s"><span class="pl-pds">"</span>{}<span class="pl-pds">"</span></span>) shouldEqual <span class="pl-en">A</span>(<span class="pl-en">Some</span>(<span class="pl-c1">10</span>))  <span class="pl-c"><span class="pl-c">//</span> not A(None)</span></pre>
  </div> 
  <p>This is what usually expected in such situation.</p> 
  <h3><a id="user-content--varargs" class="anchor" href="https://github.com/netvl/picopickle#-varargs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-varargs" target="_blank" href=""></a> Varargs</h3> 
  <p>Since version 0.2.0 picopickle supports reading and writing case classes with variable arguments. All of the arguments passed to such case class will be serialized as an array:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span><span class="pl-k">*</span>)

writeString(<span class="pl-en">A</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"""</span>{"x":[1,2,3]}<span class="pl-pds">"""</span></span></pre>
  </div> 
  <p>Naturally, all elements of this array are serialized with their respective serializers.</p> 
  <h3><a id="user-content--nulls" class="anchor" href="https://github.com/netvl/picopickle#-nulls" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-nulls" target="_blank" href=""></a> Nulls</h3> 
  <p><code>null</code> value, as is widely known, tends to cause problems, and it is discouraged in idiomatic Scala code. Unfortunately, sometimes you need to interact with external systems which do use nulls. JSON has null value as well. Because of this picopickle supports nulls (it even has <code>BNull</code> as one of the fundamental backend types) but it also provides means to control how nulls should be handled.</p> 
  <p><code>Reader</code> and <code>Writer</code> traits do not contain any special logic to handle nulls. Instances of <code>Reader</code> and <code>Writer</code> created through their companion objects, however, do have such logic: they delegate null handling to a <code>NullHandler</code> instance provided by <code>NullHandlerComponent</code>. <code>NullHandler</code> is a trait of the following structure:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">NullHandler</span> {
  <span class="pl-k">def</span> <span class="pl-en">handlesNull</span><span class="pl-k">:</span> <span class="pl-k">Boolean</span>
  <span class="pl-k">def</span> <span class="pl-en">toBackend</span>[<span class="pl-en">T</span>](<span class="pl-v">value</span>: <span class="pl-en">T</span>, <span class="pl-v">cont</span>: <span class="pl-en">T</span> <span class="pl-k">=&gt;</span> backend.<span class="pl-en">BValue</span>)<span class="pl-k">:</span> backend.<span class="pl-en">BValue</span>
  <span class="pl-k">def</span> <span class="pl-en">fromBackend</span>[<span class="pl-en">T</span>](<span class="pl-v">value</span>: backend.<span class="pl-en">BValue</span>, <span class="pl-v">cont</span>: backend.<span class="pl-en">BValue</span> <span class="pl-k">=&gt;</span> <span class="pl-en">T</span>)<span class="pl-k">:</span> <span class="pl-en">T</span>
}</pre>
  </div> 
  <p>That is, it is a kind of a preprocessor which inspects the passed value for nulls and can [de]serialize them specially or prohibit the [de]serialization at all.</p> 
  <p>By default picopickle allows nulls everywhere (<code>DefaultPickler</code> includes <code>DefaultNullHandlerComponent</code>). That is, if a null is serialized, it will be represented unconditionally with <code>backend.BNull</code>, and <code>backend.BNull</code> will be deserialized (again, unconditionally) as a <code>null</code>.</p> 
  <p>There is another <code>NullHandlerComponent</code> implementation, namely <code>ProhibitiveNullHandlerComponent</code>, which disallows serialization of nulls, throwing an exception if it encounters a null value either in Scala object or in a backend object. If you don't need to keep compatibility with some external system which uses null values then it may be sensible to extend the desired pickler, overriding the default null handler:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">MyJsonPickler</span> <span class="pl-k">extends</span> <span class="pl-e">JsonPickler</span> <span class="pl-k">with</span> <span class="pl-e">ProhibitiveNullHandlerComponent</span></pre>
  </div> 
  <p>As long as you use <code>Reader</code>/<code>Writer</code> companion objects or converters to create your custom serializers, the null handling behavior will be consistent for all types handled by your pickler.</p> 
  <h3><a id="user-content--accurate-numbers-serialization" class="anchor" href="https://github.com/netvl/picopickle#-accurate-numbers-serialization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-accurate-numbers-serialization" target="_blank" href=""></a> Accurate numbers serialization</h3> 
  <p>Some backends do not allow serializing some numbers accurately. For example, most JSON implementations represent all numbers with 64-bit floating point numbers, i.e. <code>Double</code>s. Scala <code>Long</code>, for example, can't be represented accurately with <code>Double</code> in its entirety. This is even more true for big integers and decimals.</p> 
  <p>picopickle backends provide means to serialize arbitrary numbers as accurately as possible with these methods:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">makeNumberAccurately</span>(<span class="pl-v">n</span>: <span class="pl-en">Number</span>)<span class="pl-k">:</span> <span class="pl-en">BValue</span>
<span class="pl-k">def</span> <span class="pl-en">fromNumberAccurately</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Number</span></pre>
  </div> 
  <p>You can see that these methods take and return <code>BValue</code> instead of <code>BNumber</code>. Backend implementations can take advantage of this and serialize long numbers as strings or in some other format in order to keep the precision. Built-in serializers for numbers use these methods by default.</p> 
  <p>picopickle also provides a special trait, <code>DoubleOrStringNumberRepr</code>, which provides methods to store a number as a <code>BNumber</code> if it can be represented precisely in <code>Double</code> as a <code>BString</code> otherwise. This trait is useful e.g. when writing a JSON-based backend.</p> 
  <h3><a id="user-content--value-classes" class="anchor" href="https://github.com/netvl/picopickle#-value-classes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-value-classes" target="_blank" href=""></a> Value classes</h3> 
  <p>With picopickle, you can opt-in to serialize value classes (i.e. the ones extending the <code>AnyVal</code> class) directly as values, bypassing the usual map representation of objects. To enable this behavior, extend your pickler with <code>ValueClassReaderWritersComponent</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">MyJsonPickler</span> <span class="pl-k">extends</span> <span class="pl-e">JsonPickler</span> <span class="pl-k">with</span> <span class="pl-e">ValueClassReaderWritersComponent</span>
<span class="pl-k">import</span> <span class="pl-v">MyJsonPickler.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-k">val</span> <span class="pl-en">x</span><span class="pl-k">:</span> <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">AnyVal</span>
writeString(<span class="pl-en">A</span>(<span class="pl-c1">10</span>)) shouldEqual <span class="pl-s"><span class="pl-pds">"</span>10<span class="pl-pds">"</span></span>  <span class="pl-c"><span class="pl-c">//</span> not """{"x":10}"""</span></pre>
  </div> 
  <h2><a id="user-content--official-backends" class="anchor" href="https://github.com/netvl/picopickle#-official-backends" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-official-backends" target="_blank" href=""></a> Official backends</h2> 
  <h3><a id="user-content--collections-pickler" class="anchor" href="https://github.com/netvl/picopickle#-collections-pickler" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-collections-pickler" target="_blank" href=""></a> Collections pickler</h3> 
  <p>picopickle has several "official" backends. One of them, provided by <code>picopickle-core</code> library, allows serialization into a tree of collections. This backend is available immediately with only the <code>core</code> dependency:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.github.netvl.picopickle<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>picopickle-core<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.3.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>In this backend the following AST mapping holds:</p> 
  <pre><code>BValue   -&gt; Any
BObject  -&gt; Map[String, Any]
BArray   -&gt; Vector[Any]
BString  -&gt; String
BNumber  -&gt; Number
BBoolean -&gt; Boolean
BNull    -&gt; Null
</code></pre> 
  <p>In this backend the backend representation coincide with the target media, so no conversion methods except the basic <code>read</code>/<code>write</code> are necessary.</p> 
  <p>This backend also tweaks the default <code>Char</code> serializer to write and read characters as <code>Char</code>s, not as <code>String</code>s (which is the default behavior).</p> 
  <p>Note that everything else, even other collections, are still serialized as usual, so, for example, tuples are represented as vectors and maps are represented as vectors of vectors:</p> 
  <div class="highlight highlight-source-scala">
   <pre>write((<span class="pl-c1">2</span><span class="pl-k">:</span> <span class="pl-k">Int</span>, <span class="pl-s"><span class="pl-pds">"</span>abcde<span class="pl-pds">"</span></span><span class="pl-k">:</span> <span class="pl-k">String</span>))  <span class="pl-k">-</span><span class="pl-k">&gt;</span>  <span class="pl-en">Vector</span>(<span class="pl-c1">2</span>, <span class="pl-s"><span class="pl-pds">"</span>abcde<span class="pl-pds">"</span></span>)
write(<span class="pl-en">Map</span>(<span class="pl-c1">1</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">2</span>, <span class="pl-c1">3</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">4</span>))        <span class="pl-k">-</span><span class="pl-k">&gt;</span>  <span class="pl-en">Vector</span>(<span class="pl-en">Vector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>), <span class="pl-en">Vector</span>(<span class="pl-c1">3</span>, <span class="pl-c1">4</span>))</pre>
  </div> 
  <p>Collections pickler also do not use accurate number serialization because its backend representation is already as accurate as possible.</p> 
  <h3><a id="user-content--json-pickler" class="anchor" href="https://github.com/netvl/picopickle#-json-pickler" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-json-pickler" target="_blank" href=""></a> JSON pickler</h3> 
  <p>Another official backend is used for conversion to and from JSON. JSON parsing is done with <a href="https://github.com/non/jawn" target="_blank">jawn</a> library; JSON rendering, however, is custom. This backend is available in <code>picopickle-backend-jawn</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.github.netvl.picopickle<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>picopickle-backend-jawn<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.3.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>This backend's AST is defined in <code>io.github.netvl.picopickle.backends.jawn.JsonAst</code> and consists of several basic case classes corresponding to JSON basic types. No additional utilities for JSON manipulation are provided; you should use another library if you want this.</p> 
  <p>JSON backend additionally provides two sets of methods: <code>readAst</code>/<code>writeAst</code>, which convert JSON AST from and to the JSON rendered as a string, and <code>readString</code>/<code>writeString</code>, which [de]serialize directly from and to a string. Usually the last pair of methods is what you want to use when you want to work with JSON serialization.</p> 
  <p>No support for streaming serialization is available and is not likely to appear in the future because of the abstract nature of backends (not every backend support streaming, for example, collections backend doesn't) and because it would require a completely different architecture.</p> 
  <h3><a id="user-content--bson-pickler" class="anchor" href="https://github.com/netvl/picopickle#-bson-pickler" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-bson-pickler" target="_blank" href=""></a> BSON pickler</h3> 
  <p>Another official backend is used for conversion to and from BSON AST, as defined by <a href="http://mongodb.github.io/mongo-java-driver/3.0/bson/" target="_blank">MongoDB BSON</a> library.</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>io.github.netvl.picopickle<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>picopickle-backend-mongodb-bson<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.3.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>In this backend the following AST mapping holds:</p> 
  <pre><code>BValue   -&gt; BsonValue
BObject  -&gt; BsonDocument
BArray   -&gt; BsonArray
BString  -&gt; BsonString
BNumber  -&gt; BsonNumber
BBoolean -&gt; BsonBoolean
BNull    -&gt; BsonNull
</code></pre> 
  <p>BSON backend also defines additional types as follows:</p> 
  <pre><code>BObjectId -&gt; BsonObjectId
BInt32    -&gt; BsonInt32
BInt64    -&gt; BsonInt64
BDouble   -&gt; BsonDouble
BDateTime -&gt; BsonDateTime
BBinary   -&gt; BsonBinary
BSymbol   -&gt; BsonSymbol
</code></pre> 
  <p>Additional functions for conversion from Scala core types to these types are available in the backend:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">def</span> <span class="pl-en">fromBinary</span>(<span class="pl-v">bin</span>: <span class="pl-en">BBinary</span>)<span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]
  <span class="pl-k">def</span> <span class="pl-en">makeBinary</span>(<span class="pl-v">arr</span>: <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>])<span class="pl-k">:</span> <span class="pl-en">BBinary</span>
  <span class="pl-k">def</span> <span class="pl-en">getBinary</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BBinary</span>]
  
  <span class="pl-k">def</span> <span class="pl-en">fromObjectId</span>(<span class="pl-v">oid</span>: <span class="pl-en">BObjectId</span>)<span class="pl-k">:</span> <span class="pl-en">ObjectId</span>
  <span class="pl-k">def</span> <span class="pl-en">makeObjectId</span>(<span class="pl-v">oid</span>: <span class="pl-en">ObjectId</span>)<span class="pl-k">:</span> <span class="pl-en">BObjectId</span>
  <span class="pl-k">def</span> <span class="pl-en">getObjectId</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BObjectId</span>]
  
  <span class="pl-k">def</span> <span class="pl-en">fromDateTime</span>(<span class="pl-v">dt</span>: <span class="pl-en">BDateTime</span>)<span class="pl-k">:</span> <span class="pl-k">Long</span>
  <span class="pl-k">def</span> <span class="pl-en">makeDateTime</span>(<span class="pl-v">n</span>: <span class="pl-k">Long</span>)<span class="pl-k">:</span> <span class="pl-en">BDateTime</span>
  <span class="pl-k">def</span> <span class="pl-en">getDateTime</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BDateTime</span>]

  <span class="pl-k">def</span> <span class="pl-en">fromSymbol</span>(<span class="pl-v">sym</span>: <span class="pl-en">BSymbol</span>)<span class="pl-k">:</span> <span class="pl-k">Symbol</span>
  <span class="pl-k">def</span> <span class="pl-en">makeSymbol</span>(<span class="pl-v">sym</span>: <span class="pl-k">Symbol</span>)<span class="pl-k">:</span> <span class="pl-en">BSymbol</span>
  <span class="pl-k">def</span> <span class="pl-en">getSymbol</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BSymbol</span>]

  <span class="pl-k">def</span> <span class="pl-en">fromInt32</span>(<span class="pl-v">n</span>: <span class="pl-en">BInt32</span>)<span class="pl-k">:</span> <span class="pl-k">Int</span>
  <span class="pl-k">def</span> <span class="pl-en">makeInt32</span>(<span class="pl-v">n</span>: <span class="pl-k">Int</span>)<span class="pl-k">:</span> <span class="pl-en">BInt32</span>
  <span class="pl-k">def</span> <span class="pl-en">getInt32</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BsonInt32</span>]

  <span class="pl-k">def</span> <span class="pl-en">fromInt64</span>(<span class="pl-v">n</span>: <span class="pl-en">BInt64</span>)<span class="pl-k">:</span> <span class="pl-k">Long</span>
  <span class="pl-k">def</span> <span class="pl-en">makeInt64</span>(<span class="pl-v">n</span>: <span class="pl-k">Long</span>)<span class="pl-k">:</span> <span class="pl-en">BInt64</span>
  <span class="pl-k">def</span> <span class="pl-en">getInt64</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BsonInt64</span>]

  <span class="pl-k">def</span> <span class="pl-en">fromDouble</span>(<span class="pl-v">n</span>: <span class="pl-en">BDouble</span>)<span class="pl-k">:</span> <span class="pl-k">Double</span>
  <span class="pl-k">def</span> <span class="pl-en">makeDouble</span>(<span class="pl-v">n</span>: <span class="pl-k">Double</span>)<span class="pl-k">:</span> <span class="pl-en">BDouble</span>
  <span class="pl-k">def</span> <span class="pl-en">getDouble</span>(<span class="pl-v">value</span>: <span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">BsonDouble</span>]</pre>
  </div> 
  <p>Corresponding extractors are available in <code>backend.BsonExtract</code> object, and backend conversion implicits are defined in <code>backend.bsonConversionImplicits</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-en">Reader</span> {
    <span class="pl-k">case</span> backend.<span class="pl-en">BsonExtract</span>.<span class="pl-en">ObjectId</span>(oid) <span class="pl-k">=&gt;</span>
      <span class="pl-c"><span class="pl-c">//</span> oid: backend.BObjectId == org.bson.BsonObjectId</span>
  }
  
  <span class="pl-k">import</span> <span class="pl-v">backend.bsonConversionImplicits.</span><span class="pl-v">_</span>
  
  <span class="pl-k">val</span> <span class="pl-en">bin</span><span class="pl-k">:</span> backend.<span class="pl-en">BBinary</span> <span class="pl-k">=</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>](<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>).toBackend</pre>
  </div> 
  <p>This backend overrides numerical readers and writers to serialize Scala numbers to the smallest type possible, i.e. <code>Byte</code>, <code>Short</code> and <code>Int</code> are serialized as <code>BInt32</code>, <code>Long</code> is serialized as <code>BInt64</code>, and <code>Float</code> and <code>Double</code> are serialized as <code>BDouble</code>. You can see that in this backend there is no need to use additional measures to serialize numbers accurately.</p> 
  <p>This backend also provides serializers for <code>Array[Byte]</code>, <code>Symbol</code>, <code>Date</code> and <code>ObjectId</code> types which are serialized as <code>BBinary</code>, <code>BSymbol</code>, <code>BDateTime</code> and <code>BObjectId</code>, respectively.</p> 
  <p>And finally, this backend provides identity serializers for all <code>BValue</code> children types, that is, it serializes <code>BValue</code> as <code>BValue</code>, <code>BString</code> as <code>BString</code>, <code>BInt64</code> as <code>BInt64</code> and so on.</p> 
  <h2><a id="user-content--error-handling" class="anchor" href="https://github.com/netvl/picopickle#-error-handling" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-error-handling" target="_blank" href=""></a> Error handling</h2> 
  <p>While serialization is straightforward and should never fail (if it does, it is most likely a bug in the library or in some <code>Writer</code> implementation), deserialization is prone to errors because the serialized representation usually has free-form structure and is not statically mapped on its Scala representation.</p> 
  <p>picopickle has a special exception type which is thrown upon deserialization errors. This exception is defined in <code>ExceptionsComponent</code> like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">ReadException</span>(<span class="pl-v">message</span>: <span class="pl-k">String</span>, <span class="pl-v">data</span>: backend.<span class="pl-en">BValue</span>, <span class="pl-v">cause</span>: <span class="pl-en">Throwable</span> <span class="pl-k">=</span> <span class="pl-c1">null</span>)
    <span class="pl-k">extends</span> <span class="pl-e">BaseException</span>(message, cause)

  <span class="pl-k">object</span> <span class="pl-en">ReadException</span> {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>(<span class="pl-v">reading</span>: <span class="pl-k">String</span>, <span class="pl-v">expected</span>: <span class="pl-k">String</span>, <span class="pl-v">got</span>: backend.<span class="pl-en">BValue</span>)<span class="pl-k">:</span> <span class="pl-en">ReadException</span> <span class="pl-k">=</span>
      <span class="pl-en">ReadException</span>(s<span class="pl-s"><span class="pl-pds">"</span>reading $reading, expected $expected, got $got<span class="pl-pds">"</span></span>, data <span class="pl-k">=</span> got)
  }</pre>
  </div> 
  <p>When deserialization of some type is attempted over a backend representation which is incompatible with the requested type, for most of the built-in deserializers the exception will contain the message about what was being read, what was expected and what was actually provided to the deserializer:</p> 
  <div class="highlight highlight-source-scala">
   <pre>readString[<span class="pl-k">Int</span>](<span class="pl-s"><span class="pl-pds">"""</span>{"some":"thing"}<span class="pl-pds">"""</span></span>)
io.github.netvl.picopickle.<span class="pl-en">ExceptionsComponent</span>$<span class="pl-en">ReadException</span><span class="pl-k">:</span> reading number, expected number or string containing a number, got <span class="pl-en">JsonObject</span>(<span class="pl-en">Map</span>(some <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">JsonString</span>(thing)))</pre>
  </div> 
  <p>You can participate in this exception handling with your own deserializers very easily. <code>Reader</code> and <code>ReadWriter</code> has certain methods to create deserializers which allow you to use custom messages for errors:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>)

<span class="pl-c"><span class="pl-c">//</span> Pre-defined message format, like above</span>
<span class="pl-en">Reader</span>.reading[<span class="pl-en">A</span>] {
  <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-k">String</span>(s) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>(s)
}.orThrowing(whenReading <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, expected <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> Arbitrary custom message</span>
<span class="pl-en">Reader</span>.reading[<span class="pl-en">A</span>] {
  <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-k">String</span>(s) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>(s)
}.orThrowing(v <span class="pl-k">=&gt;</span> s<span class="pl-s"><span class="pl-pds">"</span>Got $v instead of string when reading A<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> ReadWriters also can be customized</span>
<span class="pl-en">ReadWriter</span>.writing[<span class="pl-en">A</span>](_.name.toBackend)
  .reading { <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-k">String</span>(s) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>(s) }
  .orThrowing(whenReading <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, expected <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>)
  
<span class="pl-c"><span class="pl-c">//</span> Works in any order</span>
<span class="pl-en">ReadWriter</span>.reading[<span class="pl-en">A</span>] { <span class="pl-k">case</span> backend.<span class="pl-en">Extract</span>.<span class="pl-k">String</span>(s) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>(s) }
  .orThrowing(whenReading <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, expected <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>)
  .writing(_.name.toBackend)</pre>
  </div> 
  <p>In readers constructed in the above form the error will be thrown when the partial function used for reading is not defined on the incoming value. That is, the following reader won't ever throw a <code>ReadException</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Reader</span>.reading[<span class="pl-en">A</span>] {
  <span class="pl-k">case</span> value <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>(backend.fromString(value.<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">BString</span>]))
}.orThrowing(whenReading <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, expected <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>It will throw a <code>ClassCastException</code> instead if something which is not a string is supplied.</p> 
  <p>If you still need to use a catch-all partial function for a reader, you can always throw a <code>ReadException</code> yourself:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Reader</span>[<span class="pl-en">A</span>] {
  <span class="pl-k">case</span> value <span class="pl-k">=&gt;</span> <span class="pl-k">if</span> (value.<span class="pl-c1">isInstanceOf</span>[<span class="pl-k">String</span>]) <span class="pl-en">A</span>(backend.fromString(value.<span class="pl-c1">asInstanceOf</span>[<span class="pl-en">BString</span>])
                <span class="pl-k">else</span> <span class="pl-k">throw</span> <span class="pl-en">ReadException</span>(reading <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>A<span class="pl-pds">"</span></span>, expected <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>string<span class="pl-pds">"</span></span>, got <span class="pl-k">=</span> value)
}</pre>
  </div> 
  <p>While the example above is absolutely contrived, there are legitimate use cases for it.</p> 
  <p>Additional backend implementations may inherit <code>ExceptionsComponent.BaseException</code> to implement custom errors. For example, this is done in JSON backend to wrap a Jawn parse exception.</p> 
  <p>Finally, <code>Pickler</code> trait provides <code>tryRead()</code> method which returns <code>Try[T]</code> instead of <code>T</code> returned by <code>read()</code>. This method never throws any exceptions and instead returns them as a <code>Failure</code> variant of <code>Try[T]</code>. Serializer objects also have such methods, as well as official backends with custom serialization methods, like Jawn's <code>tryReadString()</code>.</p> 
  <h2><a id="user-content--limitations" class="anchor" href="https://github.com/netvl/picopickle#-limitations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-limitations" target="_blank" href=""></a> Limitations</h2> 
  <p>picopickle does not support serializing <code>Any</code> in any form because it relies on the static knowledge of types being serialized. However, its design, as far as I can tell, in principle does not disallow writing a serializer for <code>Any</code> which would use reflection. This is not even in plans, however.</p> 
  <p>It also seems that trying to serialize sealed trait hierarchies where the sealed trait itself has a type parameter causes the compiler to die horribly. Regular parameterized case classes work fine, however.</p> 
  <p>Object graphs with circular loops are not supported and will cause stack overflows. This is not usually a problem because it is only possible to construct such graphs when at least a part of them is mutable (e.g. a <code>var</code> field or a mutable collection) which is discouraged in idiomatic Scala code.</p> 
  <p>Due to limitations of how Scala reflection/macros work, it is better not to re-define serializers in the same place as the serialized classes if these classes form a sealed trait hierarchy. For example, something like this won't work:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Serializers</span> {
  <span class="pl-k">import</span> <span class="pl-v">SomePickler.</span><span class="pl-v">_</span>
  
  <span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Root</span>
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Root</span>
  <span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">B</span> <span class="pl-k">extends</span> <span class="pl-e">Root</span>
  
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">rootReadWriter</span> <span class="pl-k">=</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">Root</span>]
}</pre>
  </div> 
  <p>This won't compile because it is impossible to inspect the sealed trait hierarchy of <code>Root</code> at the point where a <code>LabelledGeneric</code> is materialized here (in the implicit parameters of <code>ReadWriter[Root]</code> call). If you want to pre-generate serializers for your classes, write them in another object:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">Classes</span> {
  <span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Root</span>
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">A</span>(<span class="pl-v">x</span>: <span class="pl-k">Int</span>) <span class="pl-k">extends</span> <span class="pl-e">Root</span>
  <span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">B</span> <span class="pl-k">extends</span> <span class="pl-e">Root</span>
}

<span class="pl-k">object</span> <span class="pl-en">Serializers</span> {
  <span class="pl-k">import</span> <span class="pl-v">SomePicker.</span><span class="pl-v">_</span>
  <span class="pl-k">import</span> <span class="pl-v">Classes.</span><span class="pl-v">_</span>
  
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">rootReadWriter</span> <span class="pl-k">=</span> <span class="pl-en">ReadWriter</span>[<span class="pl-en">Root</span>]
}</pre>
  </div> 
  <h2><a id="user-content--plans" class="anchor" href="https://github.com/netvl/picopickle#-plans" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-plans" target="_blank" href=""></a> Plans</h2> 
  <ul> 
   <li>Consider adding support for more types</li> 
   <li>Consider adding more converters (e.g. for tuples)</li> 
   <li>Add proper support for error handling in conversions</li> 
   <li>Add more tests</li> 
   <li>Add more documentation</li> 
  </ul> 
  <h2><a id="user-content--changelog" class="anchor" href="https://github.com/netvl/picopickle#-changelog" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a name="user-content-changelog" target="_blank" href=""></a> Changelog</h2> 
  <h3><a id="user-content-030" class="anchor" href="https://github.com/netvl/picopickle#030" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.3.0</h3> 
  <ul> 
   <li>Updated scala to 2.11.8</li> 
   <li>Added support for serializing value classes as values</li> 
  </ul> 
  <h3><a id="user-content-021" class="anchor" href="https://github.com/netvl/picopickle#021" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.2.1</h3> 
  <ul> 
   <li>Updated shapeless to 2.3.0, macroparadise to 2.1.0, jawn to 0.8.4, bson to 3.2.2, scala to 2.10.6</li> 
   <li>Switched to macro-compat instead of hand-written macro API for 2.10 and 2.11</li> 
  </ul> 
  <h3><a id="user-content-020" class="anchor" href="https://github.com/netvl/picopickle#020" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.2.0</h3> 
  <ul> 
   <li>Updated shapeless to 2.2.3, jawn to 0.8.8, scala to 2.11.7</li> 
   <li>Fixed support for varargs (consequence of shapeless update)</li> 
   <li>Improved reader interface (added <code>readOrElse</code> method and changed existing code to depend on it)</li> 
   <li>Added proper error handling (#2)</li> 
   <li>Added new BSON-based backend (#6)</li> 
   <li>Added support for changing STH discriminator key on per-STH basis (#7)</li> 
  </ul> 
  <h3><a id="user-content-013" class="anchor" href="https://github.com/netvl/picopickle#013" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.3</h3> 
  <ul> 
   <li>Added serializer object feature (#5)</li> 
   <li>Added support for serializing arbitrary types as map keys provided there is a converter (#4)</li> 
  </ul> 
  <h3><a id="user-content-012" class="anchor" href="https://github.com/netvl/picopickle#012" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.2</h3> 
  <ul> 
   <li>Updated Scala 2.10 minor version (4 -&gt; 5)</li> 
  </ul> 
  <h3><a id="user-content-011" class="anchor" href="https://github.com/netvl/picopickle#011" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.1</h3> 
  <ul> 
   <li>Fixed handling of classes with overloaded <code>apply</code> method in companions (#1)</li> 
  </ul> 
  <h3><a id="user-content-010" class="anchor" href="https://github.com/netvl/picopickle#010" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.1.0</h3> 
  <ul> 
   <li>More serializer instances</li> 
   <li>Added generic handling for accurate numbers serialization</li> 
   <li>Added collections backend</li> 
   <li>Support for recursive types</li> 
   <li>Added converters</li> 
   <li>Improved API for custom serializers</li> 
   <li>Added support for renaming fields and sealed trait variants</li> 
   <li>Added support for default values in case classes</li> 
   <li>Added proper support for nulls</li> 
   <li>Added test generators</li> 
   <li>Started adding tests</li> 
  </ul> 
  <h3><a id="user-content-002" class="anchor" href="https://github.com/netvl/picopickle#002" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.0.2</h3> 
  <ul> 
   <li>Added more instances for primitive types</li> 
   <li>Improved API</li> 
  </ul> 
  <h3><a id="user-content-001" class="anchor" href="https://github.com/netvl/picopickle#001" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>0.0.1</h3> 
  <ul> 
   <li>Initial release</li> 
  </ul> 
 </article>
</div>