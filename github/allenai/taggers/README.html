<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/allenai/taggers#taggers" aria-hidden="true" class="anchor" id="user-content-taggers" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Taggers</h1> 
  <p>A tagger is a function from a sentence to a list of <code>Type</code>s. A <code>Type</code> consists of a name and the token interval it came from in the source sentence.</p> 
  <h2><a href="https://github.com/allenai/taggers#example" aria-hidden="true" class="anchor" id="user-content-example" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Example</h2> 
  <p>For example, you might have a tagger that identifies animals. Following is the string serialized form of a tagger. To the left of <code>:=</code> is the name of the tagger - when the tagger finds a type it will have this name. To the right of <code>:=</code> is the tagger class. This is a Java/Scala class; if no package is specified <code>taggers</code> will look in <code>org.allenai.taggers.tag</code>. Between the braces <code>{}</code> are the arguments to the tagger.</p> 
  <pre><code>Animal := LemmatizedKeywordTagger {
  cat
  kitten
  dog
  puppy
}
</code></pre> 
  <p>If this tagger were to run over the following sentence, we would get some types.</p> 
  <blockquote> 
   <p>Kittens are very cute , but they turn into cats .</p> 
  </blockquote> 
  <pre><code>Type(name=Animal, text="Kittens", interval=[0, 1))
Type(name=Animal, text="cats", interval=[10, 11))
</code></pre> 
  <h2><a href="https://github.com/allenai/taggers#running" aria-hidden="true" class="anchor" id="user-content-running" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running</h2> 
  <p>The <code>taggers</code> project is composed of three subprojects: <code>core</code>, which contains the algorithms, <code>cli</code> which has a small cli application, and <code>webapp</code>, which contains the web demo. The project is built with <code>sbt</code>. For example, to run the web demo, you can execute the following command.</p> 
  <pre><code>sbt compile 'project webapp' run
</code></pre> 
  <p>You can also run taggers as a cli.</p> 
  <pre><code>sbt compile 'project cli' 'run examples/reverb.taggers'
</code></pre> 
  <p>If you want an example of how to use the taggers project as a dependency, please look at <code>taggers-webapp</code>.</p> 
  <h2><a href="https://github.com/allenai/taggers#cascades" aria-hidden="true" class="anchor" id="user-content-cascades" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Cascades</h2> 
  <p>Taggers can be organized into a cascade with multiple levels. A cascade is defined by a cascade file which contains a list of taggers files (separated by newline) followed by any number of extractor definitions (see the "Extractors" section).</p> 
  <p>For example, we might have <code>hello.cascade</code> as follows:</p> 
  <pre><code>first.taggers
second.taggers
</code></pre> 
  <p>We can use the multiple files to organize our tagger definitions. Cascades can also share tagger definition files between them.</p> 
  <h2><a href="https://github.com/allenai/taggers#types-of-taggers" aria-hidden="true" class="anchor" id="user-content-types-of-taggers" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Types of Taggers</h2> 
  <h3><a href="https://github.com/allenai/taggers#openregex" aria-hidden="true" class="anchor" id="user-content-openregex" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>OpenRegex</h3> 
  <p>This tagger compiles regular expressions over the tokens in a sentence into an NFA (for more information, see the <a href="https://github.com/knowitall/openregex" target="_blank">Open Regex</a> and Open Regex Scala libraries). A token is describedas a logical formula between angled brackets <code>&lt;&gt;</code>. There are a number of fields that can be matched upon for each token.</p> 
  <ul> 
   <li><strong>string</strong></li> 
   <li><strong>lemma</strong>: the lemmatized form of the token string (see MorphaStemmer in nlpstack)</li> 
   <li><strong>pos</strong>: the part-of-speech tag</li> 
   <li><strong>chunk</strong>: the chunk tag</li> 
   <li><strong>type</strong>: any type that intersects this token</li> 
   <li><strong>typeStart</strong>: any type that starts at this token</li> 
   <li><strong>typeEnd</strong>: any type that ends at this token</li> 
   <li><strong>typeCont</strong>: any type that intersects at this token but does not start or end there</li> 
  </ul> 
  <p>A field can be matched in one of three ways.</p> 
  <ol> 
   <li>With double quotes <code>"</code>. Strings are interpreted the same was as Java strings (backslash is the escape character).</li> 
   <li>With single quotes <code>'</code>. The text between two single quotes will be taken verbatim (there is no escape character).</li> 
   <li>With slashes <code>/</code>. The text between the slashes will be interpreted as a regular expression. Backslash is the escape character so <code>\\</code> becomes a single backslash and <code>\/</code> escapes the forward slash.</li> 
  </ol> 
  <p>If a quotation prefixed by "i" then the match will be case-insensitive (i.e. <code>string = i"cat"</code> will match "cAt").</p> 
  <p>A pattern tagger makes types with the tagger name, but also <code>LinkedType</code>s for each matching group. A <code>LinkedType</code> has an Optional <code>Type</code> field that points to its parent <code>Type</code> and a name field with a special syntax. If the tagger is named <code>T</code> and a matching group is named <code>G1</code> for example, the tagger will create a <code>LinkedType</code> with the name <code>T.G1</code>. If there is an unnamed matching group a <code>LinkedType</code> will be created with the group number (i.e. <code>T.1</code>).</p> 
  <p>There is a lot of redundancy in their expressiveness. For example, OpenRegex supports pattern matching on the fields .This is not necessary but is an optimization and a shorthand. For example, the following two' patterns match the same text.</p> 
  <pre><code>&lt;pos=/NNPS?/&gt;
&lt;pos="NNP"&gt; | &lt;pos="NNPS"&gt;
</code></pre> 
  <p>Here are some more equivalent examples:</p> 
  <pre><code>&lt;pos="JJ"&gt;* &lt;pos=/NNP./&gt;+
&lt;pos="JJ"&gt;* &lt;pos=/NNPS?/&gt;+
&lt;pos="JJ"&gt;* &lt;pos="NNP" | pos="NNPS"&gt;+
&lt;pos="JJ"&gt;* (?:&lt;pos="NNP"&gt; | &lt;pos="NNPS"&gt;)+
</code></pre> 
  <p>Note that (3) and (4) are not preferred for efficiency reasons. Regex OR (in example (4)) should only be used on multi-token sequences.</p> 
  <p>The Regular Expressions support named groups <code>(&lt;name&gt;: ... )</code>, unnamed groups <code>(?: ... )</code>, and capturing groups <code>( ... )</code>. The operators allowed are <code>+</code>, <code>?</code>, <code>*</code>, and <code>|</code>. The Logic Expressions (that describe each token) allow grouping <code>( ... )</code>, not <code>!</code>, or <code>|</code>, and and <code>&amp;</code>. To learn more about the regular expression language, see <a href="https://github.com/knowitall/openregex" target="_blank">https://github.com/knowitall/openregex</a>.</p> 
  <p>Named groups create output subtypes. For example, if we had the following <code>OpenRegex</code> applied to the example below.</p> 
  <pre><code>DescribedNoun := OpenRegex {
    (&lt;Description&gt;:&lt;pos='JJ'&gt;+) (&lt;Noun&gt;:&lt;pos='NN'&gt;+)
}
</code></pre> 
  <blockquote> 
   <p>The huge fat cat lingered in the hallway.</p> 
  </blockquote> 
  <p>We would get the following output types.</p> 
  <pre><code>DescribedNoun(huge fat cat)
DescribedNoun.Description(huge fat)
DescribedNoun.Noun(cat)
</code></pre> 
  <h3><a href="https://github.com/allenai/taggers#typedopenregex" aria-hidden="true" class="anchor" id="user-content-typedopenregex" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>TypedOpenRegex</h3> 
  <p>The <code>TypedOpenRegex</code> extends the <code>OpenRegex</code> with added syntax to match types. Since a type can span multiple tokens but the pattern language operates on the token level, matching types can be tedious and error prone. For example, if you want to match the type <code>Animal</code>, you need the following pattern.</p> 
  <pre><code>(?:(?:&lt;typeStart='Animal' &amp; typeEnd='Animal'&gt;) | (?: &lt;typeStart='Animal' &amp; !typeEnd='Animal'&gt; &lt;typeCont='Animal' &amp; !typeEnd='Animal'&gt;* &lt;typeEnd='Animal'&gt;))
</code></pre> 
  <p>Matching many types in this manner quickly makes unreadable patterns, so the <code>TypedOpenRegex</code> adds the syntax <code>@Type</code> which, if the type is Animal (<code>@Animal</code>) it would expand into the above expression. With this syntax, it's easy to match on types. For an implementation of <code>ReVerb</code>, see <code>examples/reverb.taggers</code>.</p> 
  <h2><a href="https://github.com/allenai/taggers#extractors" aria-hidden="true" class="anchor" id="user-content-extractors" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Extractors</h2> 
  <p>You can define extractors which build a structured string from a matched type. Extractors look similar to a Scala anonymous function.</p> 
  <pre><code>x: NestedExtraction =&gt; (${x.Arg1}, ${x.NestedRelation}, (${x.BaseArg1}, ${x.BaseRelation}, ${x.BaseArg2}))
</code></pre> 
  <p>The left part (split it by <code>=&gt;</code>) says we should apply this pattern to any <code>NestedExtraction</code> type. The right part tells us what string we should build from that <code>NestedExtraction</code>.</p> 
  <p>String substitutions are used to build an interesting string. If the bound variable (look all the way to the left) is <code>x</code>, A string substitution looks like <code>${x.expr|expr|...}</code> where <code>expr</code> is either just a subtype, or a subtype with a matching expression. Expressions can be chained with <code>|</code> in case one might fail. The last part of a fallback chain may be a string.</p> 
  <pre><code>${x.Arg1|x.Arg2|'fallback'}
</code></pre> 
  <p>If the last fallback option fails, an exception is thrown.</p> 
  <p>Sometimes you want to move to another type. In this case, the <code>x.subtype1:matching.subtype2</code> pattern is used. Here matching is the type that overlaps <code>x.subtype1</code> and <code>subtype2</code> is a subtype of `matching. You may chain matching expressions.</p> 
 </article>
</div>