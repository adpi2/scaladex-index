<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-akka-kryo-serialization---kryo-based-serializers-for-scala-and-akka" class="anchor" href="https://github.com/romix/akka-kryo-serialization#akka-kryo-serialization---kryo-based-serializers-for-scala-and-akka" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>akka-kryo-serialization - kryo-based serializers for Scala and Akka</h1> 
  <p>This library provides custom Kryo-based serializers for Scala and Akka. It can be used for more efficient akka actor's remoting.</p> 
  <p>It can also be used for a general purpose and very efficient Kryo-based serialization of such Scala types like Option, Tuple, Enumeration and most of Scala's collection types.</p> 
  <h2><a id="user-content-features" class="anchor" href="https://github.com/romix/akka-kryo-serialization#features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <ul> 
   <li>It is more efficient than Java serialization - both in size and speed</li> 
   <li>Does not require any additional build steps like compiling proto files, when using protobuf serialization</li> 
   <li>Almost any Scala and Java class can be serialized using it without any additional configuration or code changes</li> 
   <li>Efficient serialization of such Scala types like Option, Tuple, Enumeration, most of Scala's collection types</li> 
   <li>Greatly improves performance of Akka's remoting</li> 
   <li>Supports transparent AES encryption and different modes of compression</li> 
   <li>Apache 2.0 license</li> 
  </ul> 
  <h2><a id="user-content-how-to-use-this-library-in-your-project" class="anchor" href="https://github.com/romix/akka-kryo-serialization#how-to-use-this-library-in-your-project" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How to use this library in your project</h2> 
  <p>We provide several versions of the libraray:</p> 
  <ul> 
   <li>v0.5.1 is build against Akka-2.4 and Kryo-4.0 and is available for Scala-2.11 and Scala-2.12</li> 
   <li>v0.4.2 is build against Akka-2.4 and Kryo-3.0 and is available for Scala-2.11</li> 
   <li>v0.3.3 is build against Akka-2.3 and in available for Scala-2.10 and 2.11</li> 
  </ul> 
  <p>To use this serializer, you need to do two things:</p> 
  <ul> 
   <li> <p>Include a dependency on this library into your project:</p> <p><code>libraryDependencies += "com.github.romix.akka" %% "akka-kryo-serialization" % "0.5.1"</code></p> <p>or if you need Kryo-3.0 compatibility:</p> <p><code>libraryDependencies += "com.github.romix.akka" %% "akka-kryo-serialization" % "0.4.2"</code></p> <p>or if you are building for Akka-2.3 or Scala-2.10:</p> <p><code>libraryDependencies += "com.github.romix.akka" %% "akka-kryo-serialization" % "0.3.3"</code></p> </li> 
   <li> <p>Add some new elements to your Akka configuration file, e.g. <code>application.conf</code></p> </li> 
  </ul> 
  <h2><a id="user-content-which-maven-repository-contains-this-library" class="anchor" href="https://github.com/romix/akka-kryo-serialization#which-maven-repository-contains-this-library" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Which Maven repository contains this library?</h2> 
  <p>You can find the JARs on Sonatype Maven repository.</p> 
  <p>Please use the following fragment in your pom.xml:</p> 
  <p>To use the official release of akka-kryo-serialization, please use the following snippet in your pom.xml</p> 
  <div class="highlight highlight-text-xml">
   <pre>    &lt;<span class="pl-ent">repository</span>&gt;
        &lt;<span class="pl-ent">snapshots</span>&gt;
            &lt;<span class="pl-ent">enabled</span>&gt;false&lt;/<span class="pl-ent">enabled</span>&gt;
        &lt;/<span class="pl-ent">snapshots</span>&gt;
        &lt;<span class="pl-ent">id</span>&gt;central&lt;/<span class="pl-ent">id</span>&gt;
        &lt;<span class="pl-ent">name</span>&gt;Maven Central Repository&lt;/<span class="pl-ent">name</span>&gt;
        &lt;<span class="pl-ent">url</span>&gt;http://repo1.maven.org/maven2&lt;/<span class="pl-ent">url</span>&gt;
    &lt;/<span class="pl-ent">repository</span>&gt;

    &lt;<span class="pl-ent">dependency</span>&gt;
        &lt;<span class="pl-ent">groupId</span>&gt;com.github.romix.akka&lt;/<span class="pl-ent">groupId</span>&gt;
        &lt;<span class="pl-ent">artifactId</span>&gt;akka-kryo-serialization_2.11&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.5.1&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;</pre>
  </div> 
  <p>If you want to test the latest snapshot of this library, please use the following snippet in your pom.xml</p> 
  <div class="highlight highlight-text-xml">
   <pre>    &lt;<span class="pl-ent">repository</span>&gt;
       &lt;<span class="pl-ent">id</span>&gt;sonatype-snapshots&lt;/<span class="pl-ent">id</span>&gt;
       &lt;<span class="pl-ent">name</span>&gt;sonatype snapshots repo&lt;/<span class="pl-ent">name</span>&gt;
       &lt;<span class="pl-ent">url</span>&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/<span class="pl-ent">url</span>&gt;
    &lt;/<span class="pl-ent">repository</span>&gt;

    &lt;<span class="pl-ent">dependency</span>&gt;
       &lt;<span class="pl-ent">groupId</span>&gt;com.github.romix.akka&lt;/<span class="pl-ent">groupId</span>&gt;
       &lt;<span class="pl-ent">artifactId</span>&gt;akka-kryo-serialization_2.11&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.5.2-SNAPSHOT&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;</pre>
  </div> 
  <p>For your SBT project files, you can use the following coordinates:</p> 
  <pre><code>"com.github.romix.akka" %% "akka-kryo-serialization" % "0.5.1"
</code></pre> 
  <p>or</p> 
  <pre><code>"com.github.romix.akka" %% "akka-kryo-serialization" % "0.4.2"
</code></pre> 
  <p>or</p> 
  <pre><code>"com.github.romix.akka" %% "akka-kryo-serialization" % "0.3.3"
</code></pre> 
  <h2><a id="user-content-how-do-i-build-this-library-on-my-own" class="anchor" href="https://github.com/romix/akka-kryo-serialization#how-do-i-build-this-library-on-my-own" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How do I build this library on my own?</h2> 
  <p>If you wish to build the library on your own, you need to check out the project from Github and do</p> 
  <pre><code>`sbt compile publish-local`
</code></pre> 
  <p>If you wish to use it within an OSGi environment, you can add OSGi headers to the build by executing: <code>sbt osgi-bundle publish-local</code></p> 
  <p>Note that the OSGi build uses the sbt-osgi plugin, which may not be available from Maven Central or the Typesafe repo, so it may require a local build as well. sbt-osgi can be found at <a href="https://github.com/sbt/sbt-osgi" target="_blank">https://github.com/sbt/sbt-osgi</a>.</p> 
  <h2><a id="user-content-configuration-of-akka-kryo-serialization" class="anchor" href="https://github.com/romix/akka-kryo-serialization#configuration-of-akka-kryo-serialization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuration of akka-kryo-serialization</h2> 
  <p>The following options are available for configuring this serializer:</p> 
  <ul> 
   <li>You need to add a following line to the list of your Akka extensions:</li> 
  </ul> 
  <pre><code>extensions = ["com.romix.akka.serialization.kryo.KryoSerializationExtension$"]
</code></pre> 
  <ul> 
   <li> <p>You need to add a new <code>kryo</code> section to the akka.actor part of configuration</p> <pre><code>  kryo  {
      # Possibles values for type are: graph or nograph
      # graph supports serialization of object graphs with shared nodes
      # and cyclic references, but this comes at the expense of a small
      # overhead nograph does not support object grpahs with shared nodes,
      # but is usually faster
      type = "graph"

      # Possible values for idstrategy are:
      # default, explicit, incremental, automatic
      #
      # default - slowest and produces bigger serialized representation.
      # Contains fully-qualified class names (FQCNs) for each class. Note
      # that selecting this strategy does not work in version 0.3.2, but
      # is available from 0.3.3 onward.
      #
      # explicit - fast and produces compact serialized representation.
      # Requires that all classes that will be serialized are pre-registered
      # using the "mappings" and "classes" sections. To guarantee that both
      # sender and receiver use the same numeric ids for the same classes it
      # is advised to provide exactly the same entries in the "mappings"
      # section.
      #
      # incremental - fast and produces compact serialized representation.
      # Support optional pre-registering of classes using the "mappings"
      # and "classes" sections. If class is not pre-registered, it will be
      # registered dynamically by picking a next available id To guarantee
      # that both sender and receiver use the same numeric ids for the same
      # classes it is advised to pre-register them using at least the "classes" section.
      #
      # automatic -  use the pre-registered classes with fallback to FQCNs
      # Contains fully-qualified class names (FQCNs) for each non pre-registered
      # class in the "mappings" and "classes" sections. This strategy was
      # added in version 0.4.1 and will not work with the previous versions

      idstrategy = "incremental"

      # Define a default queue builder, by default ConcurrentLinkedQueue is used.
      # Create your own queue builder by implementing the trait QueueBuilder,
      # useful for paranoid GC users that want to use JCtools MpmcArrayQueue for example.
      #
      # If you pass a bounded queue make sure its capacity is equal or greater than the
      # maximum concurrent remote dispatcher threads your application will ever have
      # running; failing to do this will have a negative performance impact:
      #
      # custom-queue-builder = "a.b.c.KryoQueueBuilder"

      # Define a default size for byte buffers used during serialization
      buffer-size = 4096

      # The serialization byte buffers are doubled as needed until they
      # exceed max-buffer-size and an exception is thrown. Can be -1
      # for no maximum.
      max-buffer-size = -1

      # If set, akka uses manifests to put a class name
      # of the top-level object into each message
      use-manifests = false

      # If set it will use the UnsafeInput and UnsafeOutput
      # Kyro IO instances. Please note that there is no guarantee
      # for backward/forward compatibility of unsafe serialization.
      # It is also not compatible with the safe-serialized values.
      # The unsafe IO usually creates bugger payloads but is faster
      # for some types, e.g. native arrays.
      use-unsafe = false

      # The transformations that have be done while serialization
      # Supported transformations: compression and encryption
      # accepted values(comma separated if multiple): off | lz4 | deflate | aes
      # Transformations occur in the order they are specified
      post-serialization-transformations = "lz4,aes"

      # Settings for aes encryption, if included in transformations AES
      # algo mode, key and custom key class can be specified AES algo mode
      # defaults to 'AES/CBC/PKCS5Padding' and key to 'ThisIsASecretKey'.
      # If custom key class is provided, Kryo will use the class specified
      # by a fully qualified class name to get custom AES key. Such a
      # class should define the method 'kryoAESKey'. This key overrides 'key'.
      # If class doesn't contain 'kryoAESKey' method, specified key is used.
      # If this is not present, default key is used
      encryption {
          aes {
              mode = "AES/CBC/PKCS5Padding"
              key = j68KkRjq21ykRGAQ
              IV-length = 16
              custom-key-class = "CustomAESKeyClass"
          }
      }

      # Log implicitly registered classes. Useful, if you want to know all
      # classes which are serialized. You can then use this information in
      # the mappings and/or classes sections
      implicit-registration-logging = false

      # If enabled, Kryo logs a lot of information about serialization process.
      # Useful for debugging and lowl-level tweaking
      kryo-trace = false

      # If proviced, Kryo uses the class specified by a fully qualified
      # class name to perform a custom initialization of Kryo instances in
      # addition to what is done automatically based on the config file.
      kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"

      # If enabled, allows Kryo to resolve subclasses of registered Types.
      #
      # This is primarily useful when idstrategy is set to "explicit". In this
      # case, all classes to be serialized must be explicitly registered. The
      # problem is that a large number of common Scala and Akka types (such as
      # Map and ActorRef) are actually traits that mask a large number of
      # specialized classes that deal with various situations and optimizations.
      # It isn't straightforward to register all of these, so you can instead
      # register a single supertype, with a serializer that can handle *all* of
      # the subclasses, and the subclasses get serialized with that.
      #
      # Use this with care: you should only rely on this when you are confident
      # that the superclass serializer covers all of the special cases properly.
      resolve-subclasses = false

      # Define mappings from a fully qualified class name to a numeric id.
      # Smaller ids lead to smaller sizes of serialized representations.
      #
      # This section is:
      # - mandatory for idstrategy="explicit"
      # - ignored   for idstrategy="default"
      # - optional  for incremental and automatic
      #
      # The smallest possible id should start at 20 (or even higher), because
      # ids below it are used by Kryo internally e.g. for built-in Java and
      # Scala types
      mappings {
          "package1.name1.className1" = 20,
          "package2.name2.className2" = 21
      }

      # Define a set of fully qualified class names for
      # classes to be used for serialization.
      # The ids for those classes will be assigned automatically,
      # but respecting the order of declaration in this section
      #
      # This section is ignored for idstrategy="default" and optional for
      # all other.
      classes = [
          "package3.name3.className3",
          "package4.name4.className4"
      ]
  }
</code></pre> </li> 
   <li> <p>You should declare in the <code>akka.actor.serializers</code> section a new kind of serializer:</p> </li> 
  </ul> 
  <pre><code>serializers {
    java = "akka.serialization.JavaSerializer"
    # Define kryo serializer
    kryo = "com.romix.akka.serialization.kryo.KryoSerializer"
}
</code></pre> 
  <ul> 
   <li>As usual, you should declare in the Akka <code>serialization-bindings</code> section which classes should use kryo serialization. One thing to keep in mind is that classes that you register in this section are supposed to be <em>TOP-LEVEL</em> classes that you wish to serialize. I.e. this is a class of object that you send over the wire. It should not be a class that is used internally by a top-level class. The reason for it: Akka sees only an object of a top-level class to be sent. It picks a matching serializer for this top-level class, e.g. a default Java serializer, and then it serializes the whole object graph with this object as a root using this Java serializer.</li> 
  </ul> 
  <h2><a id="user-content-kryo-queue-builder-examples" class="anchor" href="https://github.com/romix/akka-kryo-serialization#kryo-queue-builder-examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Kryo queue builder examples:</h2> 
  <ul> 
   <li> <p>Scala bounded queue builder with a capacity of 32:</p> <pre><code>  package a.b.c

  import akka.serialization.Serializer
  import com.romix.akka.serialization.kryo.QueueBuilder
  import org.jctools.queues.MpmcArrayQueue
  import java.util.Queue

  class KryoQueueBuilder extends QueueBuilder {
    def build: Queue[Serializer] = {
      new MpmcArrayQueue[Serializer](32)
    }
  }
</code></pre> </li> 
   <li> <p>Java bounded queue builder with a capacity of 32:</p> <pre><code>  package a.b.c;

  import akka.serialization.Serializer;
  import com.romix.akka.serialization.kryo.QueueBuilder;
  import org.jctools.queues.MpmcArrayQueue;
  import java.util.Queue;

  public class KryoQueueBuilder implements QueueBuilder {

    @Override
    public Queue&lt;Serializer&gt; build() {
      return new MpmcArrayQueue&lt;&gt;(32);
    }
  }
</code></pre> </li> 
  </ul> 
  <h2><a id="user-content-how-do-you-create-mappings-or-classes-sections-with-proper-content" class="anchor" href="https://github.com/romix/akka-kryo-serialization#how-do-you-create-mappings-or-classes-sections-with-proper-content" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How do you create mappings or classes sections with proper content?</h2> 
  <p>One of the easiest ways to understand which classes you need to register in those sections is to leave both sections first empty and then set</p> 
  <pre><code>implicit-registration-logging = true
</code></pre> 
  <p>As a result, you'll eventually see log messages about implicit registration of some classes. By default, they will receive some random default ids. Once you see the names of implicitly registered classes, you can copy them into your mappings or classes sections and assign an id of your choice to each of those classes.</p> 
  <p>You may need to repeat the process several times until you see no further log messages about implicitly registered classes.</p> 
  <p>Another useful trick is to provide your own custom initializer for Kryo (see below) and inside it you registerclasses of a few objects that are typically used by your application, for example:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    kryo.register(myObj1.getClass);
    kryo.register(myObj2.getClass);</pre>
  </div> 
  <p>Obviously, you can also explicitly assign IDs to your classes in the initializer, if you wish:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    kryo.register(myObj3.getClass, <span class="pl-c1">123</span>);</pre>
  </div> 
  <p>If you use this library as an alternative serialization method when sending messages between actors, it is extremely important that the order of class registration and the assigned class IDs are the same for senders and for receivers!</p> 
  <h2><a id="user-content-how-to-create-a-custom-initializer-for-kryo" class="anchor" href="https://github.com/romix/akka-kryo-serialization#how-to-create-a-custom-initializer-for-kryo" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How to create a custom initializer for Kryo</h2> 
  <p>Sometimes you need to customize Kryo beyond what is possible by means of the configuration parameters in the config file. Typically, you may want to register very specific serializers for certain classes or tweak some settings of the Kryo instance. This is possible by providing the following optional parameter in the config file:</p> 
  <pre><code>kryo-custom-serializer-init = "CustomKryoSerializerInitFQCN"
</code></pre> 
  <p>Where <code>CustomKryoSerializerInitFQCN</code> is a fully qualified class name of your custom serializer class. And custom serializer class can be just any class with a default no-arg constructor and a method called <code>customize</code>, which takes one parameter of type Kryo and has a voidreturn type, i.e.</p> 
  <div class="highlight highlight-source-scala">
   <pre>    public void customize(<span class="pl-en">Kryo</span> kryo); <span class="pl-c"><span class="pl-c">//</span> for Java</span>
    <span class="pl-k">def</span> <span class="pl-en">customize</span>(kryo<span class="pl-k">:</span><span class="pl-en">Kryo</span>)<span class="pl-k">:</span><span class="pl-k">Unit</span> <span class="pl-c"><span class="pl-c">//</span> for Scala</span></pre>
  </div> 
  <p>An example of such a custom Kryo serializer initialization class could be something like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-k">class</span> <span class="pl-en">KryoInit</span> {
        <span class="pl-k">def</span> <span class="pl-en">customize</span>(<span class="pl-v">kryo</span>: <span class="pl-en">Kryo</span>)<span class="pl-k">:</span> <span class="pl-k">Unit</span>  <span class="pl-k">=</span> {
            kryo.register(<span class="pl-c1">classOf</span>[<span class="pl-en">DateTime</span>], <span class="pl-k">new</span> <span class="pl-en">JodaDateTimeSerializer)</span>
            kryo.setReferences(<span class="pl-c1">false</span>)
        }
    }</pre>
  </div> 
  <h2><a id="user-content-how-to-use-a-custom-key-for-aes" class="anchor" href="https://github.com/romix/akka-kryo-serialization#how-to-use-a-custom-key-for-aes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How to use a custom key for aes</h2> 
  <p>Sometimes you need to pass a custom aes key, depending on the context you are in, instead of having a static key. For example, you might have the key in a data store, or provided by some other application. In such instances, you might want to provide the key dynamically to kryo serializer.</p> 
  <p>You can provide the following optional parameter in the config file:</p> 
  <pre><code>custom-key-class = "CustomAESKeyClass"
</code></pre> 
  <p>Where <code>CustomAESKeyClass</code> is a fully qualified class name of your custom aes key provider class. Such a class can be just any class with a method called <code>kryoAESKey</code>, which has a string return type i.e.</p> 
  <div class="highlight highlight-source-scala">
   <pre>    public string kryoAESKey(...); <span class="pl-c"><span class="pl-c">//</span> for Java</span>
    <span class="pl-k">def</span> <span class="pl-en">kryoAESKey</span>(...)<span class="pl-k">:</span><span class="pl-k">String</span> <span class="pl-c"><span class="pl-c">//</span> for Scala</span></pre>
  </div> 
  <p>An example of such a custom aes-key supplier class could be something like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-k">class</span> <span class="pl-en">KryoAESKeySupplier</span> {
        <span class="pl-k">def</span> <span class="pl-en">kryoAESKey</span><span class="pl-k">:</span> <span class="pl-k">String</span>  <span class="pl-k">=</span> {
            <span class="pl-s"><span class="pl-pds">"</span>ThisIsASecretKey<span class="pl-pds">"</span></span>
        }
    }</pre>
  </div> 
  <h2><a id="user-content-resolving-subclasses" class="anchor" href="https://github.com/romix/akka-kryo-serialization#resolving-subclasses" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Resolving Subclasses</h2> 
  <p>If you are using <code>idstrategy="explicit"</code>, you may find that some of the standard Scala and Akka types are a bit hard to register properly. This is because these types are exposed in the API as simple traits or abstract classes, but they are actually implemented as many specialized subclasses that are used as necessary. Examples include:</p> 
  <ul> 
   <li>scala.collection.immutable.Map</li> 
   <li>scala.collection.immutable.Set</li> 
   <li>akka.actor.ActorRef</li> 
   <li>akka.actor.ActorPath</li> 
  </ul> 
  <p>The problem is that Kryo thinks in terms of the <em>exact</em> class being serialized, but you are rarely working with the actual implementation class -- the application code only cares about the more abstract trait. The implementation class often isn't obvious, and is sometimes private to the library it comes from. This isn't an issue for idstrategies that add registrations when needed, or which use the class name, but in <code>explicit</code> you must register every class to be serialized, and that may turn out to be more than you expect.</p> 
  <p>For cases like these, you can use the <code>SubclassResolver</code>. This is a variant of the standard Kryo ClassResolver, which is able to deal with subclasses of the registered types. You turn it on by setting</p> 
  <pre><code>resolve-subclasses = true
</code></pre> 
  <p>With that turned on, unregistered subclasses of a registered supertype are serialized as that supertype. So for example, if you have registered <code>immutable.Set</code>, and the object being serialized is actually an <code>immutable.Set.Set3</code> (the subclass used for Sets of 3 elements), it will serialize and deserialize that as an <code>immutable.Set</code>.</p> 
  <p>If you register <code>immutable.Map</code>, you should use the <code>ScalaImmutableAbstractMapSerializer</code> with it. If you register <code>immutable.Set</code>, you should use the <code>ScalaImmutableAbstractSetSerializer</code>. These serializers are specifically designed to work with those traits.</p> 
  <p>The <code>SubclassResolver</code> approach should only be used in cases where the implementation types are completely opaque, chosen by the implementation library, and not used explicitly in application code. If you have subclasses that have their own distinct semantics, such as <code>immutable.ListMap</code>, you should register those separately. You can register both a higher-level class like <code>immutable.Map</code> and a subclass like <code>immutable.ListMap</code> -- the resolver will choose the more-specific one when appropriate.</p> 
  <p><code>SubclassResolver</code> should be used with care -- even when it is turned on, you should define and register most of your classes explicitly, as usual. But it is a helpful way to tame the complexity of some class hierarchies, when that complexity can be treated as an implementation detail and all of the subclasses can be serialized and deserialized identically.</p> 
  <h2><a id="user-content-usage-as-a-general-purpose-scala-serialization-library" class="anchor" href="https://github.com/romix/akka-kryo-serialization#usage-as-a-general-purpose-scala-serialization-library" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage as a general purpose Scala serialization library</h2> 
  <p>Simply add this library to your classpath. It does not have any external dependencies besides Kryo. All serializers for Scala classes can be found in the package <code>com.romix.scala.serialization.kryo</code></p> 
  <p>If you want to use any of those serializers in your code, add some of the following lines to your code as required:</p> 
  <div class="highlight highlight-source-scala">
   <pre>    <span class="pl-c"><span class="pl-c">//</span> Serialization of Scala enumerations</span>
    kryo.addDefaultSerializer(<span class="pl-c1">classOf</span>[scala.<span class="pl-en">Enumeration</span>#<span class="pl-en">Value</span>], <span class="pl-c1">classOf</span>[<span class="pl-en">EnumerationSerializer</span>])
    kryo.register(<span class="pl-en">Class</span>.forName(<span class="pl-s"><span class="pl-pds">"</span>scala.Enumeration$Val<span class="pl-pds">"</span></span>))
    kryo.register(<span class="pl-c1">classOf</span>[scala.<span class="pl-en">Enumeration</span>#<span class="pl-en">Value</span>])

    <span class="pl-c"><span class="pl-c">//</span> Serialization of Scala maps like Trees, etc</span>
    kryo.addDefaultSerializer(<span class="pl-c1">classOf</span>[scala.collection.<span class="pl-en">Map</span>[_,_]], <span class="pl-c1">classOf</span>[<span class="pl-en">ScalaMapSerializer</span>])
    kryo.addDefaultSerializer(<span class="pl-c1">classOf</span>[scala.collection.generic.<span class="pl-en">MapFactory</span>[scala.collection.<span class="pl-en">Map</span>]], <span class="pl-c1">classOf</span>[<span class="pl-en">ScalaMapSerializer</span>])

    <span class="pl-c"><span class="pl-c">//</span> Serialization of Scala sets</span>
    kryo.addDefaultSerializer(<span class="pl-c1">classOf</span>[scala.collection.<span class="pl-en">Set</span>[_]], <span class="pl-c1">classOf</span>[<span class="pl-en">ScalaSetSerializer</span>])
    kryo.addDefaultSerializer(<span class="pl-c1">classOf</span>[scala.collection.generic.<span class="pl-en">SetFactory</span>[scala.collection.<span class="pl-en">Set</span>]], <span class="pl-c1">classOf</span>[<span class="pl-en">ScalaSetSerializer</span>])

    <span class="pl-c"><span class="pl-c">//</span> Serialization of all Traversable Scala collections like Lists, Vectors, etc</span>
    kryo.addDefaultSerializer(<span class="pl-c1">classOf</span>[scala.collection.<span class="pl-en">Traversable</span>[_]], <span class="pl-c1">classOf</span>[<span class="pl-en">ScalaCollectionSerializer</span>])</pre>
  </div> 
 </article>
</div>