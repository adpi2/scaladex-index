<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-development-status" class="anchor" href="https://github.com/comcast/money#development-status" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Development Status</h2> 
  <p>We are actively working on version 0.9 that will offer several improvements over both the API and module implementations. 0.8.x is being used in several projects currently, and we will continue to enhance 0.8.x for the foreseeable future while 0.9 work takes place.</p> 
  <p>If you want to work on 0.9, feel free to reach out!</p> 
  <h3><a id="user-content-availability" class="anchor" href="https://github.com/comcast/money#availability" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Availability</h3> 
  <p>We have requests in to deploy to a public repo, that should be available shortly</p> 
  <h2><a id="user-content-distributed-tracing-reads" class="anchor" href="https://github.com/comcast/money#distributed-tracing-reads" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Distributed Tracing Reads</h2> 
  <p><a href="http://www.nctatechnicalpapers.com/Paper/2015/2015-distributed-trace-for-video-systems/download" target="_blank">Distributed Trace For Video Systems</a> written by Michael Bevilacqua-Linn discusses our experiences at Comcast implementing distributed traces.</p> 
  <h2><a id="user-content-money-distributed-tracing-made-simple" class="anchor" href="https://github.com/comcast/money#money-distributed-tracing-made-simple" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Money: Distributed Tracing Made Simple</h2> 
  <h3><a id="user-content-money-makes-it-simple-to-trace-across-threads-and-systems" class="anchor" href="https://github.com/comcast/money#money-makes-it-simple-to-trace-across-threads-and-systems" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Money makes it simple to trace across threads and systems</h3> 
  <p>Money is a modular distributed tracing platform that can be seamlessly incorporated into modern applications. <em>It's purpose is to provide a foundation for operational analytics through distributed tracing.</em></p> 
  <p>Money is built on Scala and Akka, to be non-blocking from the core. It is purposefully un-opinionated, keeping undesired pull-through dependencies to a minimum.</p> 
  <p>Money modules build on the core, so implementing tracing is a snap. From Apache Http Components to Spring 4, from thread pools to Scala Futures, Money has modules to support a wide range of architectures.</p> 
  <h2><a id="user-content-why-is-it-different" class="anchor" href="https://github.com/comcast/money#why-is-it-different" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why is it different?</h2> 
  <p>Money was inspired by inspired by <a href="http://research.google.com/pubs/pub36356.html" target="_blank">Google Dapper</a> and <a href="http://twitter.github.io/zipkin/" target="_blank">Twitter Zipkin</a>; however there are some subtle yet fundamental differences between those systems and Money, the biggest one being...</p> 
  <h3><a id="user-content-spans-start-and-end-within-a-single-process" class="anchor" href="https://github.com/comcast/money#spans-start-and-end-within-a-single-process" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Spans start and end within a single process</h3> 
  <p>In Dapper, a Span can encompass the communication between a client and a server. Let's use an example of an <em>Order System</em> calling an <em>Inventory Management System</em>. With Dapper, you could have the following:</p> 
  <ul> 
   <li><em>span-name</em> - GetInventory</li> 
   <li><em>start-time</em></li> 
   <li><em>client-send</em> - the time that the client sent the request</li> 
   <li><em>server-recv</em> - the time that the server received the request</li> 
   <li><em>server-send</em> - the time that the server responded to the request</li> 
   <li><em>client-recv</em> - the time that the client received the request</li> 
   <li><em>foo</em> - any arbitrary annotation (note) made by either the client or the server</li> 
  </ul> 
  <p>The idea being that everything can be calculated when the data is at rest.</p> 
  <p>In Money, it is theoretically possible to do the same, but by default we always extend a span when the server starts processing. We do this because we like to record important notes by default, namely the <em>span-duration</em> and the <em>span-success</em>. Using the example above, with Money we would get:</p> 
  <ul> 
   <li><em>app-name</em> - OrderSystem</li> 
   <li><em>span-name</em> - GetInventory</li> 
   <li><em>start-time</em> - time that the get inventory request started</li> 
   <li><em>span-duration</em> - duration in Microseconds the entire request took</li> 
   <li><em>span-success</em> - a boolean indicating success or failure of the operation from the Order System</li> 
   <li><em>host</em> - the machine name generating the data</li> 
   <li><em>foo</em> - any arbitrary bit of data</li> 
  </ul> 
  <p>... and on the server we would get...</p> 
  <ul> 
   <li><em>app-name</em> - InventoryManagement</li> 
   <li><em>span-name</em> - GetInventory</li> 
   <li><em>start-time</em> - time that the server began processing the request</li> 
   <li><em>span-duration</em> - how long it took for the server to process the request</li> 
   <li><em>span-success</em> - a success or failure indicator of the operation</li> 
   <li><em>host</em> - the machine name generating the data</li> 
   <li><em>bar</em> - any arbitrary bit of data</li> 
  </ul> 
  <h4><a id="user-content-why-do-that" class="anchor" href="https://github.com/comcast/money#why-do-that" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why do that?</h4> 
  <p>There are a tradeoffs with any decision. </p> 
  <p>Here are some disadvantages:</p> 
  <ul> 
   <li>More data, we get twice as much data for the same RPC, this can be a problem for extremely large volume systems as much more data will be generated</li> 
   <li>Memory pressure - as we calculate duration and success, we need to maintain some state in process, which will add some memory overhead</li> 
  </ul> 
  <p>Here are some advantages:</p> 
  <ul> 
   <li>You can use Money as a basis for operational analytics. Money generates 3 important stats: latency, throughput and error rate. We find that these are the most important stats in analyzing system performance and capacity. You could calculate these at rest in Dapper; but we believe that these can be understood more quickly to support real-time monitoring</li> 
   <li>You can very quickly integrate with monitoring tools. As opposed to having to calculate metrics at rest in Dapper and Zipkin, you can publish span data directly to Graphite (for instance), and create charts immediately. This is a very strong advantage to calculating metrics at the source. Money actually comes with a <em>Graphite Emtitter</em> out-of-the box. Given that money is pluggable, it is quite trivial to integrate with many other systems.</li> 
   <li>In distributed system calls, it is important to know that the server "succeeded" or "failed", allowing you to more quickly focus your troubleshooting efforts when things go wrong. For example, if the server succeeded, then we can direct our efforts toward the client or the network</li> 
   <li>Less calculation is needed on the data - we have basic measures that we can use for calculations, allowing us to process data and perform analytics faster</li> 
  </ul> 
  <h3><a id="user-content-we-dont-sampleyet" class="anchor" href="https://github.com/comcast/money#we-dont-sampleyet" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>We don't sample...yet</h3> 
  <p>I can see rocks starting to fly here, and I understand. Money was not built in its present incarnation to support systems which generate 10s of millions of events per second. Money was built to use distributed tracing as a foundation for operational analytics. </p> 
  <p>We were much more interested in creating a standard set of metrics that we could use as a basis to perform operational analytics. As such, for us, every event does matter as we can build aggregates very easy (even success).</p> 
  <p>We have been able to instrument systems that do generate many millions of events per hour with success, but Money did not have the same considerations that went into the Dapper design. Being able to process our base metrics gets us closer to real-time understanding of processing; distributing the calculations to the origin systems gave us a lot of flexibility and speed in processing the data at rest.</p> 
  <blockquote> 
   <p>We are committed to support sampling and are evaluating designs...ideas are welcome. Look for basic sampling to be added shortly</p> 
  </blockquote> 
  <h3><a id="user-content-we-do-not-provide-a-backend-like-zipkin" class="anchor" href="https://github.com/comcast/money#we-do-not-provide-a-backend-like-zipkin" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>We do not provide a backend like Zipkin</h3> 
  <p>Zipkin comes with an entire infrastructure built around Scribe and Cassandra that actually allows you to see data. This is super cool, and something we aspire to complete. We have looked at Spark Streaming and Akka Cluster Sharding as implementation mechanisms (and have some prototype / experimental code to that end), but we have not yet gotten our act together.</p> 
  <p>One of the main advantages of Money is that it provides usable operational analytics out-of-the-box; whether reporting to Graphite, exposing data via JMX, and/or aggregating logs in Logstash. As such, we have been able to gain key insight into traces and performance using standard open source tools; here are some examples:</p> 
  <ul> 
   <li>Splunk / LogStash - we use log aggregators to perform metrics across systems at rest. The nice thing about log aggregators is that you can not only see your metrics, but you can also look at all of the log entries that happend for a single Span</li> 
   <li>Graphite / Prometheus - we use common analytic systems for monitoring and altering on Money data</li> 
  </ul> 
  <h2><a id="user-content-should-i-use-money" class="anchor" href="https://github.com/comcast/money#should-i-use-money" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Should I use Money?</h2> 
  <p>This depends on the scale of your implementation. Money <em>tries</em> to serve a wide range of implementations.</p> 
  <p>Certainly, if you want to implement an application that is serving 1000s or 10000s of request per second per JVM, Money should work for you. You can easily funnel data into your log aggregator or other reporting system and start getting the benefits immediately.</p> 
  <p>If your implementation is in the order of 50000+ RPS with lots of spans, then things will get difficult as you will have to manage a lot of data. Spooling span events to disk and sending them as you can is one approach. You can use FluentD, Heka, PipeD or something else to eventually get the data off of disk. Theoretically it is possible, but without sampling, Money is generating a ton of data. If you are not using that data for analytics, you can filter it out (or contribute back a sampling feature); either way, it becomes a challenge.</p> 
  <h2><a id="user-content-i-dont-need-no-docs-gimme-money" class="anchor" href="https://github.com/comcast/money#i-dont-need-no-docs-gimme-money" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>I don't need no docs, gimme Money!</h2> 
  <p>Add a dependency as follows for maven:</p> 
  <div class="highlight highlight-text-xml">
   <pre>    &lt;<span class="pl-ent">dependency</span>&gt;
        &lt;<span class="pl-ent">groupId</span>&gt;com.comcast.money&lt;/<span class="pl-ent">groupId</span>&gt;
        &lt;<span class="pl-ent">artifactId</span>&gt;money-core&lt;/<span class="pl-ent">artifactId</span>&gt;
        &lt;<span class="pl-ent">version</span>&gt;0.8.12&lt;/<span class="pl-ent">version</span>&gt;
    &lt;/<span class="pl-ent">dependency</span>&gt;</pre>
  </div> 
  <h2><a id="user-content-user-guide" class="anchor" href="https://github.com/comcast/money#user-guide" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>User Guide</h2> 
  <p><a href="https://github.com/Comcast/money/wiki" target="_blank">Money Documentation</a></p> 
 </article>
</div>