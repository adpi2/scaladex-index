<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-log4s" class="anchor" href="https://github.com/larsrh/log4s#log4s" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Log4s</h1> 
  <p><em>Note:</em> This is a fork of <a href="https://github.com/Log4s/log4s" target="_blank">log4s</a> for the sole purpose of making it ready for Scala 2.12.x. Credit goes to the original authors (see bottom of this file).</p> 
  <h2><a id="user-content-introduction" class="anchor" href="https://github.com/larsrh/log4s#introduction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Introduction</h2> 
  <p>This is a simple project to wrap the excellent <a href="http://slf4j.org/" target="_blank">SLF4J</a> logging façade with a Scala-friendly API that is lightweight and very convenient. Using Scala 2.10's macros and value classes, it is possible to implement simple API that incurs zero runtime costs and outperforms typical Java-based practices.</p> 
  <p>Logging is mostly a solved problem on the JVM, thanks largely to the excellent work of Ceki Gülcü and many others. I have no goal to invent a new logging library or introduce yet another wrapper system. SLF4J solves the problems of modularity and separation of concerns beautifully. My only goal is to <em>enhance</em> the usability of SLF4J by offering an idiomatic Scala interface.</p> 
  <p>Please feel free to contact me if you have suggestions for how to enhance or improve this library—as long as those suggestions are compatible with the project's goals.</p> 
  <h2><a id="user-content-installation" class="anchor" href="https://github.com/larsrh/log4s#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h2> 
  <p>To use Log4s, add the following to your SBT build:</p> 
  <pre><code>libraryDependencies += "info.hupel.fork.org.log4s" %% "log4s" % "2.0"
</code></pre> 
  <p>Scala 2.10.x, 2.11.x and 2.12.x are fully supported.</p> 
  <h2><a id="user-content-examples" class="anchor" href="https://github.com/larsrh/log4s#examples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Examples</h2> 
  <ul> 
   <li><a href="https://github.com/larsrh/log4s#getting-a-logger" target="_blank">Getting a logger</a></li> 
   <li><a href="https://github.com/larsrh/log4s#logging-messages" target="_blank">Logging messages</a></li> 
   <li><a href="https://github.com/larsrh/log4s#exception-logging" target="_blank">Exception logging</a></li> 
   <li><a href="https://github.com/larsrh/log4s#diagnostic-contexts" target="_blank">Diagnostic contexts</a></li> 
   <li><a href="https://github.com/larsrh/log4s#unsupported-features" target="_blank">Unsupported features</a></li> 
  </ul> 
  <h3><a id="user-content-getting-a-logger" class="anchor" href="https://github.com/larsrh/log4s#getting-a-logger" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting a logger</h3> 
  <p>Most of the time, you simply want to define a logger with a name that matches the enclosing class or module. Log4s makes this common case as easy as possible, transparently deriving the name for you with zero overhead at runtime.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">package</span> <span class="pl-en">com.example.project</span>
<span class="pl-k">import</span> <span class="pl-v">org.log4s.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">DemoClass</span> {
  <span class="pl-c">// Retrieves a logger for "com.example.project.DemoClass"</span>
  <span class="pl-k">private</span>[<span class="pl-v">this</span>] <span class="pl-k">val</span> <span class="pl-en">logger</span> <span class="pl-k">=</span> getLogger
  <span class="pl-k">???</span>
}</pre>
  </div> 
  <p>There is no requirement that you mark your loggers with <code>private[this]</code>, but the compiler may bypass accessors and generate direct field access if you do.</p> 
  <p>It is not required that you import <code>org.log4s._</code> into your classes: calling <code>org.log4s.getLogger</code> will also have the same effect. I generally recommend importing the entire <code>log4s</code> package: it doesn't have many symbols that are likely to conflict, and importing the package makes it easy to access other logging features if needed.</p> 
  <p>Automatic logger naming also works for modules (a.k.a. objects or singletons).</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">DemoClass</span> {
  <span class="pl-c">// Will log against category "com.example.project.DemoClass"</span>
  <span class="pl-k">private</span> <span class="pl-k">val</span> <span class="pl-en">logger</span> <span class="pl-k">=</span> org.log4s.getLogger
  <span class="pl-k">???</span>
}</pre>
  </div> 
  <p>Notice that by default, Log4s does not include a <em>$</em> at the end of logger categories for modules. This is slightly different behavior from the common idiom <code>LoggerFactory.getLogger(getClass)</code> used to get a logger for a module, but this behavior is more consistent with Java practices and I suspect is what a majority of users will prefer. Future enhancements may provide a mechanism to allow the user to choose whether to include the trailing <em>$</em>.</p> 
  <h4><a id="user-content-custom-logger-names" class="anchor" href="https://github.com/larsrh/log4s#custom-logger-names" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Custom Logger Names</h4> 
  <p>There are situations where you may want to use a custom logger name. E.g., you may want to have a special category for some kind of high-level events, or you may want to consolidate the logging of two related classes.</p> 
  <p>To accomplish this, you can simply pass a name directly to <code>getLogger</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.log4s.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">CustomNamed</span> {
  <span class="pl-k">private</span>[<span class="pl-v">this</span>] <span class="pl-k">val</span> <span class="pl-en">queryLogger</span> <span class="pl-k">=</span> getLogger(<span class="pl-s"><span class="pl-pds">"</span>queries<span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <p>Although this is fully supported, I recommend that you use the automatic class-named loggers most of the time. Class-named loggers provide useful debugging information and usually align well with the decisions you'll make about which logging statements you want to enable in which situations. By letting the compiler provide the name for you, you also reduce the chance of errors as you refactor your code.</p> 
  <h4><a id="user-content-instance-or-static" class="anchor" href="https://github.com/larsrh/log4s#instance-or-static" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Instance or static?</h4> 
  <p>My recommendation is that by default you create your loggers as instance variables and mark them as <code>private[this]</code>. This may be more compatible with some complex classloading environments, and this practice is more friendly to principles of encapsulation.</p> 
  <p>However, if a specific class will be instantiated very frequently, you may want to move its logger to the companion module and mark it <code>private</code>. There are some cases where greater visibility is justified, but these are infrequent for most applications.</p> 
  <p>The SLF4J FAQ has a good discussion of the <a href="http://slf4j.org/faq.html#declared_static" target="_blank">tradeoffs between static and instance loggers</a>.</p> 
  <h3><a id="user-content-logging-messages" class="anchor" href="https://github.com/larsrh/log4s#logging-messages" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Logging messages</h3> 
  <p>The logger interfaces are extremely simple, but they're more powerful than they look. All the standard loggers take a single argument of type string.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">MyClass</span>(<span class="pl-k">val</span> <span class="pl-en">data</span><span class="pl-k">:</span> <span class="pl-en">Map</span>[<span class="pl-k">String</span>,<span class="pl-k">Int</span>]) {
  <span class="pl-k">private</span>[<span class="pl-v">this</span>] <span class="pl-k">val</span> <span class="pl-en">logger</span> <span class="pl-k">=</span> org.log4s.getLogger

  logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Constructing new instance of MyClass<span class="pl-pds">"</span></span>)
  logger.trace(s<span class="pl-s"><span class="pl-pds">"</span>New instance's data set: $data<span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <p>Unlike SLF4J, there are no special methods for parameterized logging, because it turns out to be completely unnecessary. Parameterized logging serves two primary purposes: it provides an easy way to construct complex strings, and it helps avoid some of the costs of building a dynamic message when the message is at a level that is not enabled.</p> 
  <p>As you can see from the example, Scala 2.10's <a href="http://docs.scala-lang.org/overviews/core/string-interpolation.html" target="_blank">string interpolation</a> is a much more powerful solution to the first of these issues—and it even saves the runtime work of parsing a format string by splitting up the string into easily concatenated pieces at compile time.</p> 
  <p>Log4s goes even further in that it uses macros to manipulate the execution so that the string interpolations are not even performed unless the logger is enabled. It does this by inspecting the structure of the argument that you pass into the logger.</p> 
  <p>If you pass a constant string literal, Log4s will make a direct, in-line call to the underlying SLF4J log method. If you pass in any kind of more complex expression, Log4s will wrap it in an <tt>is<i>Level</i>Enabled</tt> call automatically. This is what SLF4J does when you use parameterized logging, but Log4s does it transparently and can even auto-wrap additional calculation.</p> 
  <p>Compare the following:</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">class</span> <span class="pl-en">JavaClass</span> {
    <span class="pl-c1">...</span>
    logger.<span class="pl-en">trace</span>("<span class="pl-smi">Element</span> <span class="pl-v">1000</span>: {}", <span class="pl-v">linkedList</span>.<span class="pl-v">get</span>(<span class="pl-v">1000</span>));
    <span class="pl-c1">...</span>
}</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">ScalaClass</span> {
  ...
  logger.trace(s<span class="pl-s"><span class="pl-pds">"</span>Element 1000: ${linkedList(1000)}<span class="pl-pds">"</span></span>)
  ...
}</pre>
  </div> 
  <p>In the Java API, parameterized logging is not enough: unless you wrap the call with <code>isTraceEnabled</code>, you will still incur the cost of stepping through the linked list to find element 1000 even if trace-level logging is disabled. Without manual intervention, SLF4J only avoids the cost of string concatenations.</p> 
  <p>However, Log4s can do better. Its macros discover at compile time that you are constructing a dynamic log statement and automatically wrap the entire calculation with <code>isTraceEnabled</code>.</p> 
  <p>The string interpolation syntax is not required for this detection, but it is usually the easiest and best-performing approach.</p> 
  <p>You can also use message nesting with entire code blocks. If logging is not enabled at the provided level, the block is skipped entirely.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">ComplexTrace</span> {
  ...
  logger trace {
    <span class="pl-k">def</span> <span class="pl-en">helper</span>(<span class="pl-v">s</span>: <span class="pl-k">String</span>) <span class="pl-k">=</span> <span class="pl-k">???</span>
    <span class="pl-k">val</span> <span class="pl-en">x</span> <span class="pl-k">=</span> ...
    <span class="pl-k">val</span> <span class="pl-en">y</span> <span class="pl-k">=</span> helper(...)
    s<span class="pl-s"><span class="pl-pds">"</span>Combined trace message for $x: $y<span class="pl-pds">"</span></span>
  }
}</pre>
  </div> 
  <p>You can, of course, accomplish the same thing using <code>if (logger.isTraceEnabled) ...</code>. If the logger is disabled, they will have identical performance. However, the explicit test may perform slightly better than a block in the case where the logger is enabled as a closure may be required to compile the block. (In most situations, these differences are <em>completely</em> negligible, but designing for zero overhead and documenting any usage patterns that do add overhead is a major goal of Log4s.)</p> 
  <h3><a id="user-content-exception-logging" class="anchor" href="https://github.com/larsrh/log4s#exception-logging" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Exception logging</h3> 
  <p>When logging an exception, it's always the best practice to send the actual exception object into your logging system. This gives you flexibility in how it's displayed, the ability to do filtering, and additional options for things like database logging.</p> 
  <p>Log4s allows you to pass exceptions into your logger, while still maintining the simple string-interpolation style API that makes it so convenient. To log an exception, use the following syntax.</p> 
  <pre><code>try {
  ...
} catch {
  case e: Exception =&gt; logger.error(e)("Some error message")
}
</code></pre> 
  <p>There is no method to log an error message without any message, because this is generally not a good practice. You can always feed it an empty string if you really want. It's usually not desirable to use the exception's message, as most logging systems will output this anyway.</p> 
  <p>Like regular message logging, dynamic arguments are only evaluated if the provided logger is turned on. This includes both the <code>Throwable</code> and the message itself.</p> 
  <p>This means you could use the following pattern to see who is calling a method, and if you were to disable trace logging you would only pay for the call to <code>isTraceEnabled</code>, which has a cost of only a few nanoseconds (according to the <a href="http://www.slf4j.org/faq.html#trace" target="_blank">SLF4J FAQ</a>).</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyObject</span> {
  <span class="pl-k">def</span> <span class="pl-en">xyz</span>() {
    logger.trace(<span class="pl-k">new</span> <span class="pl-en">RuntimeException</span>())(<span class="pl-s"><span class="pl-pds">"</span>Got call into xyz<span class="pl-pds">"</span></span>)
    <span class="pl-k">???</span>
  }
}</pre>
  </div> 
  <p>(This is more an illustration of the possibilities of dynamic message processing than a suggestion that this is the best way to get caller information. However, sometimes a low-tech solution like this can be a good complement to more complex solutions like profilers and debuggers.)</p> 
  <h3><a id="user-content-diagnostic-contexts" class="anchor" href="https://github.com/larsrh/log4s#diagnostic-contexts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Diagnostic contexts</h3> 
  <p>Mapped diagnostic contexts (MDCs) are a great way to put share common contextual information across all log statements. Frameworks like Logback have the ability to not just output them, but also use them in filtering to select the type of logging to perform or even persist certain information in databases.</p> 
  <p>MDCs in Log4s have the same semantics as those of standard MDCs in SLF4J. In keeping with the design goal of making SLF4J idiomatic to Scala, Log4s's MDCs implement the standard interface for a <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.mutable.Map" target="_blank">Scala mutable map</a>.</p> 
  <p><strong>Though I cover the map-style API first, see the <a href="https://github.com/larsrh/log4s#mdc-convenience-and-safety" target="_blank">MDC convenience and safety</a> section below for the simpler idiom that I recommend for most situations.</strong></p> 
  <h4><a id="user-content-mdc-map-style-api" class="anchor" href="https://github.com/larsrh/log4s#mdc-map-style-api" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MDC Map-style API</h4> 
  <p>The direct way to manipulate MDCs is through the <code>org.log4s.MDC</code> object.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.log4s.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">DiagnosticExample</span> {
  <span class="pl-k">private</span>[<span class="pl-v">this</span>] <span class="pl-k">val</span> <span class="pl-en">logger</span> <span class="pl-k">=</span> getLogger

  <span class="pl-k">def</span> <span class="pl-en">doRequest</span>(<span class="pl-v">user</span>: <span class="pl-k">String</span>) {
    <span class="pl-k">val</span> <span class="pl-en">requestId</span> <span class="pl-k">=</span> java.util.<span class="pl-en">UUID</span>.randomUUID

    <span class="pl-c">// Empty out the MDC for this thread</span>
    <span class="pl-en">MDC</span>.clear

    <span class="pl-c">/* *************************** */</span>
    <span class="pl-c">/* Set some context in the MDC */</span>
    <span class="pl-c">/* *************************** */</span>

    <span class="pl-c">// Set a single value</span>
    <span class="pl-en">MDC</span>(<span class="pl-s"><span class="pl-pds">"</span>request-id<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> requestId.toString
    <span class="pl-c">// Set multiple values</span>
    <span class="pl-en">MDC</span> <span class="pl-k">+</span><span class="pl-k">=</span> (<span class="pl-s"><span class="pl-pds">"</span>request-user<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> user, <span class="pl-s"><span class="pl-pds">"</span>request-time<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">System</span>.currentTimeMillis)

    <span class="pl-c">// Note that Log4s requires the caller to do string conversion. This helps</span>
    <span class="pl-c">// ensure that it's really the implementation that you want.</span>

    <span class="pl-c">/* *************** */</span>
    <span class="pl-c">/* Use our context */</span>
    <span class="pl-c">/* *************** */</span>

    <span class="pl-c">// No need to put the request ID in the message: it's in the context</span>
    logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Processing request<span class="pl-pds">"</span></span>)

    <span class="pl-c">/* ************************ */</span>
    <span class="pl-c">/* Remove context variables */</span>
    <span class="pl-c">/* ************************ */</span>

    <span class="pl-c">// Remove a single value</span>
    <span class="pl-en">MDC</span> <span class="pl-k">-</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>request-id<span class="pl-pds">"</span></span>
    <span class="pl-c">// Remove multiple values</span>
    <span class="pl-en">MDC</span> <span class="pl-k">-</span><span class="pl-k">=</span> (<span class="pl-s"><span class="pl-pds">"</span>request-user<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>request-time<span class="pl-pds">"</span></span>)
  }
}</pre>
  </div> 
  <p>These are a few common examples, but all the mutator methods of a mutable map will work. It's also possible to intermix calls to SLF4J's MDC methods directly: the Log4s map is backed by the actual SLF4J MDC.</p> 
  <h4><a id="user-content-mdc-convenience-and-safety" class="anchor" href="https://github.com/larsrh/log4s#mdc-convenience-and-safety" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MDC convenience and safety</h4> 
  <p>Note that the example above has a common bug: if some exception happens during request processing, the MDC will not get cleaned up and it will leak to other operations. Because of this common situation, there's a convenience method that does cleanup in a finalizer block. I recommend using this approach for most common settings.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">org.log4s.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">BlockExample</span> {
  <span class="pl-k">def</span> <span class="pl-en">doRequest</span>(<span class="pl-v">user</span>: <span class="pl-k">String</span>) {
    <span class="pl-k">val</span> <span class="pl-en">requestId</span> <span class="pl-k">=</span> java.util.<span class="pl-en">UUID</span>.randomUUID

    <span class="pl-c">// This context operates only for the block, then cleans itself up</span>
    <span class="pl-en">MDC</span>.withCtx (<span class="pl-s"><span class="pl-pds">"</span>request-id<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> requestId.toString, <span class="pl-s"><span class="pl-pds">"</span>request-user<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> user) {
      logger.debug(<span class="pl-s"><span class="pl-pds">"</span>Processing request<span class="pl-pds">"</span></span>)
    }
  }
}</pre>
  </div> 
  <p>Nesting context blocks is permitted. The inner context block retains the values of the outer context. If there are conflicts, the inner block wins, but the outer value is restored when the inner block is completed.</p> 
  <p>This ability to restore previous values on block exit does require their storage in a map which adds slight memory overhead. If you are in a tight loop with nested contexts, you may have better performance if you add and remove values directly. These performance costs apply only to the block-based API, not the map-style API.</p> 
  <h3><a id="user-content-unsupported-features" class="anchor" href="https://github.com/larsrh/log4s#unsupported-features" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Unsupported features</h3> 
  <p>The following potential or suggested features are not implemented. If some missing feature is particularly valuable to you, feel free to reach out with your requests or suggestions. I'm also—of course—open to pull requests, but please drop me an email first if there are significant new APIs or features so we can agree on the general design.</p> 
  <ul> 
   <li>A <code>scalac</code> compiler flag or environment variable to automatically disable all logging below a certain level.</li> 
   <li>Marker support.</li> 
  </ul> 
  <h3><a id="user-content-contributors" class="anchor" href="https://github.com/larsrh/log4s#contributors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributors</h3> 
  <p>Here are all the contributors (chronologically). Thanks to all!</p> 
  <ul> 
   <li><a href="https://github.com/sarahgerweck/" target="_blank">Sarah Gerweck</a> (primary author)</li> 
   <li><a href="https://github.com/bryce-anderson" target="_blank">Bryce Anderson</a></li> 
   <li><a href="https://github.com/dyross" target="_blank">David Ross</a></li> 
  </ul> 
 </article>
</div>