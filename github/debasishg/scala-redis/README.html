<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-redis-scala-client" class="anchor" href="https://github.com/debasishg/scala-redis#redis-scala-client" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Redis Scala client</h1> 
  <h2><a id="user-content-key-features-of-the-library" class="anchor" href="https://github.com/debasishg/scala-redis#key-features-of-the-library" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Key features of the library</h2> 
  <ul> 
   <li>Native Scala types Set and List responses.</li> 
   <li>Transparent serialization</li> 
   <li>Connection pooling</li> 
   <li>Consistent Hashing on the client.</li> 
   <li>Support for Clustering of Redis nodes.</li> 
  </ul> 
  <h2><a id="user-content-information-about-redis" class="anchor" href="https://github.com/debasishg/scala-redis#information-about-redis" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Information about redis</h2> 
  <p>Redis is a key-value database. It is similar to memcached but the dataset is not volatile, and values can be strings, exactly like in memcached, but also lists and sets with atomic operations to push/pop elements.</p> 
  <p><a href="http://redis.io" target="_blank">http://redis.io</a></p> 
  <h3><a id="user-content-key-features-of-redis" class="anchor" href="https://github.com/debasishg/scala-redis#key-features-of-redis" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Key features of Redis</h3> 
  <ul> 
   <li>Fast in-memory store with asynchronous save to disk.</li> 
   <li>Key value get, set, delete, etc.</li> 
   <li>Atomic operations on sets and lists, union, intersection, trim, etc.</li> 
  </ul> 
  <h2><a id="user-content-requirements" class="anchor" href="https://github.com/debasishg/scala-redis#requirements" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Requirements</h2> 
  <ul> 
   <li>sbt (get it at <a href="http://www.scala-sbt.org/" target="_blank">http://www.scala-sbt.org/</a>)</li> 
  </ul> 
  <h2><a id="user-content-installation" class="anchor" href="https://github.com/debasishg/scala-redis#installation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation</h2> 
  <p>Add to <code>Build.scala</code> or <code>build.sbt</code></p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
    <span class="pl-s"><span class="pl-pds">"</span>net.debasishg<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>redisclient<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>3.2<span class="pl-pds">"</span></span>
)</pre>
  </div> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/debasishg/scala-redis#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>Start your redis instance (usually redis-server will do it)</p> 
  <pre><code>$ cd scala-redis
$ sbt
&gt; update
&gt; console
</code></pre> 
  <p>And you are ready to start issuing commands to the server(s)</p> 
  <p>Redis 2 implements a new protocol for binary safe commands and replies</p> 
  <p>Let us connect and get a key:</p> 
  <pre><code>scala&gt; import com.redis._
import com.redis._

scala&gt; val r = new RedisClient("localhost", 6379)
r: com.redis.RedisClient = localhost:6379

scala&gt; r.set("key", "some value")
res3: Boolean = true

scala&gt; r.get("key")
res4: Option[String] = Some(some value)
</code></pre> 
  <p>Let us try out some List operations:</p> 
  <pre><code>scala&gt; r.lpush("list-1", "foo")
res0: Option[Int] = Some(1)

scala&gt; r.rpush("list-1", "bar")
res1: Option[Int] = Some(2)

scala&gt; r.llen("list-1")
res2: Option[Int] = Some(2)
</code></pre> 
  <p>Let us look at some serialization stuff:</p> 
  <pre><code>scala&gt; import serialization._
import serialization._

scala&gt; import Parse.Implicits._
import Parse.Implicits._

scala&gt; r.hmset("hash", Map("field1" -&gt; "1", "field2" -&gt; 2))
res0: Boolean = true

scala&gt; r.hmget[String,String]("hash", "field1", "field2")
res1: Option[Map[String,String]] = Some(Map(field1 -&gt; 1, field2 -&gt; 2))

scala&gt; r.hmget[String,Int]("hash", "field1", "field2")
res2: Option[Map[String,Int]] = Some(Map(field1 -&gt; 1, field2 -&gt; 2))

scala&gt; val x = "debasish".getBytes("UTF-8")
x: Array[Byte] = Array(100, 101, 98, 97, 115, 105, 115, 104)

scala&gt; r.set("key", x)
res3: Boolean = true

scala&gt; import Parse.Implicits.parseByteArray
import Parse.Implicits.parseByteArray

scala&gt; val s = r.get[Array[Byte]]("key")
s: Option[Array[Byte]] = Some([B@6e8d02)

scala&gt; new String(s.get)
res4: java.lang.String = debasish

scala&gt; r.get[Array[Byte]]("keey")
res5: Option[Array[Byte]] = None
</code></pre> 
  <h2><a id="user-content-using-client-pooling" class="anchor" href="https://github.com/debasishg/scala-redis#using-client-pooling" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using Client Pooling</h2> 
  <p>scala-redis is a blocking client, which serves the purpose in most of the cases since Redis is also single threaded. But there may be situations when clients need to manage multiple RedisClients to ensure thread-safe programming.</p> 
  <p>scala-redis includes a Pool implementation which can be used to serve this purpose. Based on Apache Commons Pool implementation, RedisClientPool maintains a pool of instances of RedisClient, which can grow based on demand. Here's a sample usage ..</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">clients</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">RedisClientPool</span>(<span class="pl-s"><span class="pl-pds">"</span>localhost<span class="pl-pds">"</span></span>, <span class="pl-c1">6379</span>)
<span class="pl-k">def</span> <span class="pl-en">lp</span>(<span class="pl-v">msgs</span>: <span class="pl-en">List</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
  clients.withClient {
    client <span class="pl-k">=&gt;</span> {
      msgs.foreach(client.lpush(<span class="pl-s"><span class="pl-pds">"</span>list-l<span class="pl-pds">"</span></span>, _))
      client.llen(<span class="pl-s"><span class="pl-pds">"</span>list-l<span class="pl-pds">"</span></span>)
    }
  }
}</pre>
  </div> 
  <p>Using a combination of pooling and futures, scala-redis can be throttled for more parallelism. This is the typical recommended strategy if you are looking forward to scale up using this redis client. Here's a sample usage .. we are doing a parallel throttle of an lpush, rpush and set operations in redis, each repeated a number of times ..</p> 
  <p>If we have a pool initialized, then we can use the pool to repeat the following operations.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// lpush</span>
<span class="pl-k">def</span> <span class="pl-en">lp</span>(<span class="pl-v">msgs</span>: <span class="pl-en">List</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
  clients.withClient {
    client <span class="pl-k">=&gt;</span> {
      msgs.foreach(client.lpush(<span class="pl-s"><span class="pl-pds">"</span>list-l<span class="pl-pds">"</span></span>, _))
      client.llen(<span class="pl-s"><span class="pl-pds">"</span>list-l<span class="pl-pds">"</span></span>)
    }
  }
}

<span class="pl-c">// rpush</span>
<span class="pl-k">def</span> <span class="pl-en">rp</span>(<span class="pl-v">msgs</span>: <span class="pl-en">List</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
  clients.withClient {
    client <span class="pl-k">=&gt;</span> {
      msgs.foreach(client.rpush(<span class="pl-s"><span class="pl-pds">"</span>list-r<span class="pl-pds">"</span></span>, _))
      client.llen(<span class="pl-s"><span class="pl-pds">"</span>list-r<span class="pl-pds">"</span></span>)
    }
  }
}

<span class="pl-c">// set</span>
<span class="pl-k">def</span> <span class="pl-en">set</span>(<span class="pl-v">msgs</span>: <span class="pl-en">List</span>[<span class="pl-k">String</span>]) <span class="pl-k">=</span> {
  clients.withClient {
    client <span class="pl-k">=&gt;</span> {
      <span class="pl-k">var</span> <span class="pl-en">i</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
      msgs.foreach { v <span class="pl-k">=&gt;</span>
        client.set(<span class="pl-s"><span class="pl-pds">"</span>key-%d<span class="pl-pds">"</span></span>.format(i), v)
        i <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
      }
      <span class="pl-en">Some</span>(<span class="pl-c1">1000</span>)
    }
  }
}</pre>
  </div> 
  <p>And here's the snippet that throttles our redis server with the above operations in a non blocking mode using Scala futures:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> (<span class="pl-c1">0</span> until <span class="pl-c1">5000</span>).map(_.toString).toList
<span class="pl-k">val</span> <span class="pl-en">fns</span> <span class="pl-k">=</span> <span class="pl-en">List</span>[<span class="pl-en">List</span>[<span class="pl-k">String</span>] <span class="pl-k">=&gt;</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>]](lp, rp, set)
<span class="pl-k">val</span> <span class="pl-en">tasks</span> <span class="pl-k">=</span> fns map (fn <span class="pl-k">=&gt;</span> scala.actors.<span class="pl-en">Futures</span>.future { fn(l) })
<span class="pl-k">val</span> <span class="pl-en">results</span> <span class="pl-k">=</span> tasks map (future <span class="pl-k">=&gt;</span> future.apply())</pre>
  </div> 
  <h2><a id="user-content-implementing-asynchronous-patterns-using-pooling-and-futures" class="anchor" href="https://github.com/debasishg/scala-redis#implementing-asynchronous-patterns-using-pooling-and-futures" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementing asynchronous patterns using pooling and Futures</h2> 
  <p>scala-redis is a blocking client for Redis. But you can develop high performance asynchronous patterns of computation using scala-redis and Futures. RedisClientPool allows you to work with multiple RedisClient instances and Futures offer a non-blocking semantics on top of this. The combination can give you good numbers for implementing common usage patterns like scatter/gather. Here's an example that you will also find in the test suite. It uses the scatter/gather technique to do loads of push across many lists in parallel. The gather phase pops from all those lists in parallel and does some compuation over them.</p> 
  <p>Here's the main routine that implements the pattern:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// set up Executors</span>
<span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>(<span class="pl-s"><span class="pl-pds">"</span>ScatterGatherSystem<span class="pl-pds">"</span></span>)
<span class="pl-k">import</span> <span class="pl-v">system.</span><span class="pl-v">dispatcher</span>

<span class="pl-k">val</span> <span class="pl-en">timeout</span> <span class="pl-k">=</span> <span class="pl-c1">5</span> minutes

<span class="pl-k">private</span>[<span class="pl-v">this</span>] <span class="pl-k">def</span> <span class="pl-en">flow</span>[<span class="pl-en">A</span>](<span class="pl-v">noOfRecipients</span>: <span class="pl-k">Int</span>, <span class="pl-v">opsPerClient</span>: <span class="pl-k">Int</span>, <span class="pl-v">keyPrefix</span>: <span class="pl-k">String</span>,
  <span class="pl-v">fn</span>: (<span class="pl-k">Int</span>, <span class="pl-k">String</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">A</span>) <span class="pl-k">=</span> {
  (<span class="pl-c1">1</span> to noOfRecipients) map {i <span class="pl-k">=&gt;</span>
    <span class="pl-en">Future</span> {
      fn(opsPerClient, <span class="pl-s"><span class="pl-pds">"</span>list_<span class="pl-pds">"</span></span> <span class="pl-k">+</span> i)
    }
  }
}

<span class="pl-c">// scatter across clients and gather them to do a sum</span>
<span class="pl-k">def</span> <span class="pl-en">scatterGatherWithList</span>(<span class="pl-v">opsPerClient</span>: <span class="pl-k">Int</span>)(<span class="pl-k">implicit</span> <span class="pl-v">clients</span>: <span class="pl-en">RedisClientPool</span>) <span class="pl-k">=</span> {
  <span class="pl-c">// scatter</span>
  <span class="pl-k">val</span> <span class="pl-en">futurePushes</span> <span class="pl-k">=</span> flow(<span class="pl-c1">100</span>, opsPerClient, <span class="pl-s"><span class="pl-pds">"</span>list_<span class="pl-pds">"</span></span>, listPush)

  <span class="pl-c">// concurrent combinator: Future.sequence</span>
  <span class="pl-k">val</span> <span class="pl-en">allPushes</span> <span class="pl-k">=</span> <span class="pl-en">Future</span>.sequence(futurePushes)

  <span class="pl-c">// sequential combinator: flatMap</span>
  <span class="pl-k">val</span> <span class="pl-en">allSum</span> <span class="pl-k">=</span> allPushes flatMap {result <span class="pl-k">=&gt;</span>
    <span class="pl-c">// gather</span>
    <span class="pl-k">val</span> <span class="pl-en">futurePops</span> <span class="pl-k">=</span> flow(<span class="pl-c1">100</span>, opsPerClient, <span class="pl-s"><span class="pl-pds">"</span>list_<span class="pl-pds">"</span></span>, listPop)
    <span class="pl-k">val</span> <span class="pl-en">allPops</span> <span class="pl-k">=</span> <span class="pl-en">Future</span>.sequence(futurePops)
    allPops map {members <span class="pl-k">=&gt;</span> members.sum}
  }
  <span class="pl-en">Await</span>.result(allSum, timeout).<span class="pl-c1">asInstanceOf</span>[<span class="pl-k">Long</span>]
}

<span class="pl-c">// scatter across clietns and gather the first future to complete</span>
<span class="pl-k">def</span> <span class="pl-en">scatterGatherFirstWithList</span>(<span class="pl-v">opsPerClient</span>: <span class="pl-k">Int</span>)(<span class="pl-k">implicit</span> <span class="pl-v">clients</span>: <span class="pl-en">RedisClientPool</span>) <span class="pl-k">=</span> {
  <span class="pl-c">// scatter phase: push to 100 lists in parallel</span>
  <span class="pl-k">val</span> <span class="pl-en">futurePushes</span> <span class="pl-k">=</span> flow(<span class="pl-c1">100</span>, opsPerClient, <span class="pl-s"><span class="pl-pds">"</span>seq_<span class="pl-pds">"</span></span>, listPush)

  <span class="pl-c">// wait for the first future to complete</span>
  <span class="pl-k">val</span> <span class="pl-en">firstPush</span> <span class="pl-k">=</span> <span class="pl-en">Future</span>.firstCompletedOf(futurePushes)

  <span class="pl-c">// do a sum on the list whose key we got from firstPush</span>
  <span class="pl-k">val</span> <span class="pl-en">firstSum</span> <span class="pl-k">=</span> firstPush map {key <span class="pl-k">=&gt;</span>
    listPop(opsPerClient, key)
  }
  <span class="pl-en">Await</span>.result(firstSum, timeout).<span class="pl-c1">asInstanceOf</span>[<span class="pl-k">Int</span>]
}</pre>
  </div> 
  <h2><a id="user-content-license" class="anchor" href="https://github.com/debasishg/scala-redis#license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>This software is licensed under the Apache 2 license, quoted below.</p> 
  <p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> 
  <pre><code>http://www.apache.org/licenses/LICENSE-2.0
</code></pre> 
  <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> 
 </article>
</div>