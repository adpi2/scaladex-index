<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-gopher-asynchronous-implementation-of-go-like-channelsselectors-in-scala" class="anchor" href="https://github.com/rssh/scala-gopher#gopher-asynchronous-implementation-of-go-like-channelsselectors-in-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Gopher: asynchronous implementation of go-like channels/selectors in scala</h2> 
  <h1></h1> 
  <h3><a id="user-content-dependences" class="anchor" href="https://github.com/rssh/scala-gopher#dependences" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependences:</h3> 
  <ul> 
   <li>scala 2.11.7 +</li> 
   <li>akka 2.4.2 +</li> 
   <li>scala-async 0.9.5</li> 
  </ul> 
  <h4><a id="user-content-download" class="anchor" href="https://github.com/rssh/scala-gopher#download" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Download:</h4> 
  <pre><code>libraryDependencies += "com.github.rssh" %% "scala-gopher" % "0.99.7"
</code></pre> 
  <p>(or <code>0.99.8-SNAPSHOT</code> for development version).</p> 
  <p>Scala-gopher is open source (license is Apache2); binaries are available from the maven-central repository.</p> 
  <h2><a id="user-content-overview" class="anchor" href="https://github.com/rssh/scala-gopher#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h2> 
  <p>Scala-gopher is a scala library, build on top of Akka and SIP-22 async, which provide an implementation of CSP [Communicate Sequential Processes] primitives, known as 'Go-like channels.' Also, analogs of go/defer/recover control-flow constructions are provided. </p> 
  <p>Note, which this is not an emulation of go language structures in Scala, but rather a reimplementation of the main ideas in 'scala-like' manner.</p> 
  <h3><a id="user-content-initialization" class="anchor" href="https://github.com/rssh/scala-gopher#initialization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Initialization</h3> 
  <p>You need an instance of gopherApi for creating channels and selectors. The easiest way is to use one as Akka extension:</p> 
  <pre><code>  import akka.actors._
  import gopher._

  ......

  val actorSystem = ActorSystem.create("system")
  val gopherApi = Gopher(actorSystem)    
</code></pre> 
  <p>In akka.conf we can place config values in 'gopher' entry. </p> 
  <h2><a id="user-content-control-flow-constructions" class="anchor" href="https://github.com/rssh/scala-gopher#control-flow-constructions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Control flow constructions:</h2> 
  <h3><a id="user-content-goscope" class="anchor" href="https://github.com/rssh/scala-gopher#goscope" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>goScope</h3> 
  <p><code>goScope[T](body: =&gt;T)</code> is expression, which allows to use inside <code>body</code> go-like 'defer' and 'recover' expression.</p> 
  <p>Typical usage:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">gopher.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">java.io.</span><span class="pl-v">_</span>

<span class="pl-k">object</span> <span class="pl-en">CopyFile</span> {

  <span class="pl-k">def</span> <span class="pl-en">main</span>(<span class="pl-v">args</span>: <span class="pl-en">Array</span>[<span class="pl-k">String</span>])<span class="pl-k">:</span> <span class="pl-k">Unit</span> <span class="pl-k">=</span> {
    <span class="pl-k">if</span> (args.length <span class="pl-k">!=</span> <span class="pl-c1">3</span>) {
      <span class="pl-en">System</span>.err.println(<span class="pl-s"><span class="pl-pds">"</span>usage: copy in out<span class="pl-pds">"</span></span>);
    }
    copy(<span class="pl-k">new</span> <span class="pl-en">File</span>(args(<span class="pl-c1">1</span>)), <span class="pl-k">new</span> <span class="pl-en">File</span>(args(<span class="pl-c1">2</span>)))
  }

  <span class="pl-k">def</span> <span class="pl-en">copy</span>(<span class="pl-v">inf</span>: <span class="pl-en">File</span>, <span class="pl-v">outf</span>: <span class="pl-en">File</span>)<span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span>
    goScope {
      <span class="pl-k">val</span> <span class="pl-en">in</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FileInputStream</span>(inf)
      defer {
        in.close()
      }
      <span class="pl-k">val</span> <span class="pl-en">out</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">FileOutputStream</span>(outf);
      defer {
        out.close()
      }
      out.getChannel() transferFrom(in.getChannel(), <span class="pl-c1">0</span>, <span class="pl-k">Long</span>.<span class="pl-en">MaxValue</span>)
    }

}</pre>
  </div> 
  <p>Here statements inside defer block executed at the end of goScope block in reverse order.</p> 
  <p>Inside goScope we can use two pseudo functions:</p> 
  <ul> 
   <li><code>defer(body: =&gt;Unit):Unit</code> - defer execution of <code>body</code> until the end of <code>go</code> or <code>goScope</code> block and previous defered blocks.</li> 
   <li><code>recover[T](f:PartialFunction[Throwable,T]):Boolean</code> -- can be used only within <code>defer</code> block with next semantics:</li> 
   <li>* if exception was raised inside <code>go</code> or <code>goScope</code> than <code>recover</code> try to apply <code>f</code> to this exception and</li> 
   <li>* * if <code>f</code> is applicable - set <code>f(e)</code> as return value of the block and return true</li> 
   <li>* * otherwise - do nothing and return false </li> 
   <li>* during normal exit - return false.</li> 
  </ul> 
  <p>You can look on <code>defer</code> as on stackable finally clauses, and on <code>defer</code> with <code>recover</code> inside as on <code>catch</code> clause. Small example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> goScope{ 
           defer{ recover{
                     <span class="pl-k">case</span> <span class="pl-v">ex</span>: <span class="pl-en">Throwable</span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>CCC<span class="pl-pds">"</span></span>
           }    } 
           <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">Exception</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>)
           <span class="pl-s"><span class="pl-pds">"</span>QQQ<span class="pl-pds">"</span></span> 
        }</pre>
  </div> 
  <p>will set <code>s</code> to "CCC".</p> 
  <h3><a id="user-content-go" class="anchor" href="https://github.com/rssh/scala-gopher#go" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>go</h3> 
  <p><code>go[T](body: =&gt;T)(implicit ex:ExecutionContext):Future[T]</code> starts asynchronous execution of <code>body</code> in provided execution context. Inside go we can use <code>defer</code>/<code>recover</code> clauses and blocked read/write channel operations. </p> 
  <p>Go implemented on top of <a href="http://docs.scala-lang.org/sips/pending/async.html" target="_blank">SIP-22</a> async and share the same limitations. </p> 
  <h2><a id="user-content-channels" class="anchor" href="https://github.com/rssh/scala-gopher#channels" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Channels</h2> 
  <p>Channels are used for asynchronous communication between execution flows.</p> 
  <p>When using channel inside <em>go</em> block, you can look at one as on classic blocked queue with fixed size with methods read and write:</p> 
  <pre><code> val channel = gopherApi.makeChannel[Int];

 go {
   channel.write(a)
 }
 ......
 go {
   val i = channel.read 
 }
</code></pre> 
  <ul> 
   <li><code>channel.write(x)</code> - send x to channel and wait until one will be sent (it is possible us as synonyms <code>channel&lt;~x</code> and <code>channel!x</code> if you prefer short syntax)</li> 
   <li><code>channel.read</code> or <code>(channel ?)</code> - blocking read</li> 
  </ul> 
  <p>Blocking operations can be used only inside <code>go</code> or <code>Async.await</code> blocks. </p> 
  <p>Outside we can use asynchronous version:</p> 
  <ul> 
   <li><code>channel.awrite(x)</code> will write <code>x</code> and return to us <code>Future[Unit]</code> which will be executed after x will send</li> 
   <li><code>channel.aread</code> will return future to the value, which will be read.</li> 
  </ul> 
  <p>Also, channels can be closed. After this attempt to write will cause throwing 'ClosedChannelException.' Reading will be still possible up to 'last written value', after this attempt to read will cause the same exception. </p> 
  <p>Note, closing channels is not mandatory; unreachable channels are garbage-collected regardless of they are closed or not. </p> 
  <p>Channels can be buffered and unbuffered. In a unbuffered channel, write return control to the caller after another side actually will start processing; buffered channel force provider to wait only if internal channel buffer is full.</p> 
  <p>Also, you can use only <code>Input</code> or <code>Output</code> interfaces, where appropriative read/write operations are defined. For <code>Input</code>, exists usual collection functions, like <code>map</code>, <code>zip</code>, <code>takeN</code>, <code>fold</code> ... etc. Scala Iterable can be represented as <code>channels.Input</code> via method <code>gopherApi.iterableInput</code>. Also, we can use Scala futures as channels, which produce one value and then closes. For obtaining such input use <code>gopherApi.futureInput</code>.</p> 
  <p><code>|</code> (i.e. or) operator used for merged inputs, i.e. <code>(x|y).read</code> will read a value from channel x or y when one will be available.</p> 
  <p>For each input and output you can create a facility with tracked timeout, i.e. if <code>in</code> is input, then</p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">val</span> (inReady, inTimeouts) <span class="pl-k">=</span> in.withInputTimeouts(<span class="pl-c1">10</span> seconds)</pre>
  </div> 
  <p>will return two inputs, where reading from <code>inReady</code> will return the same as reading from <code>in</code>. And if waiting for reading takes longer than 10 seconds then the value of timeout will be available in <code>inTimeouts</code>. Analogically we can create output with timeouts:</p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">val</span> (outReady, outTimeouts) <span class="pl-k">=</span> out.withOutputTimeouts(<span class="pl-c1">10</span> seconds)</pre>
  </div> 
  <p>Also, note that you can provide own Input and Output implementations by implementing callback <code>cbread</code> and <code>cbwrite</code> methods.</p> 
  <h2><a id="user-content-select-loops-and-folds" class="anchor" href="https://github.com/rssh/scala-gopher#select-loops-and-folds" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Select loops and folds</h2> 
  <p>'select statement' is somewhat similar to Unix 'select' syscall: from a set of blocking operations select one who is ready to input/output and run it.</p> 
  <p>The usual pattern of channel processing in go language is to wrap select operation into an endless loop.</p> 
  <p>Gopher provides similar functionality:</p> 
  <div class="highlight highlight-source-scala">
   <pre>go{
  <span class="pl-k">for</span>( s <span class="pl-k">&lt;</span><span class="pl-k">-</span> gopherApi.select.forever) 
    s <span class="pl-k">match</span> {
      <span class="pl-k">case</span> i<span class="pl-k">:</span>channelA.read <span class="pl-k">=&gt;</span> ..<span class="pl-k">do</span><span class="pl-k">-</span>something<span class="pl-k">-</span>with<span class="pl-k">-</span>i
      <span class="pl-k">case</span> ch<span class="pl-k">:</span>channelB.read .. <span class="pl-k">do</span><span class="pl-k">-</span>something<span class="pl-k">-</span>with<span class="pl-k">-</span>b
  }
}</pre>
  </div> 
  <p>Here we read in the loop from channelA or channelB. </p> 
  <p>Body of select loop must consist only of one <code>match</code> statement where left parts in <code>case</code> clauses must have the following form</p> 
  <ul> 
   <li><code>v:channel.read</code> (for reading from channel) </li> 
   <li><code>v:Tye if (v==read(ch))</code> (for reading from channel or future) </li> 
   <li><code>v:channel.write if (v==expr)</code> (for writing <code>expr</code> into channel).</li> 
   <li><code>v:Type if (v==write(ch,expr))</code> (for writing <code>expr</code> into channel).</li> 
   <li><p><code>_</code> - for 'idle' action.</p> <p>For endless loop inside <code>go</code> we can use the shortcut with syntax of partial function:</p></li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre>     gopherApi.select.forever{ 
         <span class="pl-k">case</span> i<span class="pl-k">:</span>channelA.read <span class="pl-k">=&gt;</span> ... <span class="pl-k">do</span><span class="pl-k">-</span>something<span class="pl-k">-</span>with<span class="pl-k">-</span>i
         <span class="pl-k">case</span> ch<span class="pl-k">:</span>channelB.read ... <span class="pl-k">do</span><span class="pl-k">-</span>something<span class="pl-k">-</span>with<span class="pl-k">-</span>b
     }</pre>
  </div> 
  <p>Inside case actions, we can use blocking read/writes and await operations. Call of doExit in the implicit instance of <code>FlowTermination[T]</code> (for a forever loop this is <code>FlowTermination[Unit]</code>) can be used for exiting from the loop. <code>select.exit</code> and <code>select.shutdown</code> macroses can be used as shortcuts.</p> 
  <p>Example: </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">channel</span> <span class="pl-k">=</span> gopherApi.makeChannel[<span class="pl-k">Int</span>](<span class="pl-c1">100</span>)

<span class="pl-k">val</span> <span class="pl-en">producer</span> <span class="pl-k">=</span> channel.awrite(<span class="pl-c1">1</span> to <span class="pl-c1">1000</span>)

<span class="pl-k">@</span>volatile <span class="pl-k">var</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>;
<span class="pl-k">val</span> <span class="pl-en">consumer</span> <span class="pl-k">=</span> gopherApi.select.forever{
        <span class="pl-k">case</span> <span class="pl-v">i</span>: channerl.read  <span class="pl-k">=&gt;</span>
                  sum <span class="pl-k">=</span> sum <span class="pl-k">+</span> i
                  <span class="pl-k">if</span> (i<span class="pl-k">==</span><span class="pl-c1">1000</span>)  {
                    select.shutdown()
                  }
}

<span class="pl-en">Await</span>.ready(consumer, <span class="pl-c1">5.</span>second)</pre>
  </div> 
  <p>Combination of variable and select loop better modeled with help 'fold over select' construction:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> gopherApi.select.afold(<span class="pl-c1">0</span>) { (state, selector) <span class="pl-k">=&gt;</span>
   selector <span class="pl-k">match</span> {
        <span class="pl-k">case</span> <span class="pl-v">i</span>: channel.read  <span class="pl-k">=&gt;</span>
                          <span class="pl-k">val</span> <span class="pl-en">nstate</span> <span class="pl-k">=</span> state <span class="pl-k">+</span> i
                          <span class="pl-k">if</span> (i<span class="pl-k">==</span><span class="pl-c1">1000</span>) {
                            select.exit(nstate)
                          }
                          nstate
   }
}</pre>
  </div> 
  <p>More than one variables in state can be modelled with partial function case syntax:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">fib</span> <span class="pl-k">=</span> select.afold((<span class="pl-c1">0</span>,<span class="pl-c1">1</span>)) { <span class="pl-k">case</span> ((x,y), s) <span class="pl-k">=&gt;</span>
    s <span class="pl-k">match</span> {
      <span class="pl-k">case</span> x<span class="pl-k">:</span>channel.write <span class="pl-k">=&gt;</span> (y,y<span class="pl-k">+</span>x)
      <span class="pl-k">case</span> q<span class="pl-k">:</span>quit.read <span class="pl-k">=&gt;</span> select.exit((x,y))
    }
}</pre>
  </div> 
  <p>Also, we can use 'map over select' to represent results of handling of different events as input side of channel:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">multiplexed</span> <span class="pl-k">=</span> select amap {
   <span class="pl-k">case</span> x<span class="pl-k">:</span>ch1.read <span class="pl-k">=&gt;</span> (s1,x)
   <span class="pl-k">case</span> y<span class="pl-k">:</span>ch2.read <span class="pl-k">=&gt;</span> (s2,y)
 } </pre>
  </div> 
  <p>For using select operation not enclosed in a loop, scala-gopher provide <em>select.once</em> syntax:</p> 
  <div class="highlight highlight-source-scala">
   <pre>gopherApi.select.once{
  <span class="pl-k">case</span> <span class="pl-v">i</span>: channelA.read <span class="pl-k">=&gt;</span> s<span class="pl-s"><span class="pl-pds">"</span>Readed(${i})<span class="pl-pds">"</span></span>
  <span class="pl-k">case</span> x<span class="pl-k">:</span>channelB.write <span class="pl-k">if</span> (x<span class="pl-k">==</span><span class="pl-c1">1</span>) <span class="pl-k">=&gt;</span> s<span class="pl-s"><span class="pl-pds">"</span>Written(${x})<span class="pl-pds">"</span></span> 
}</pre>
  </div> 
  <p>Such form can be called from any environment and will return <code>Future[String]</code>. Inside <code>go</code> you can wrap this in await of use 'for' syntax as with <code>forever</code>.</p> 
  <div class="highlight highlight-source-scala">
   <pre>go {
  .....
  <span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> <span class="pl-k">for</span>(s <span class="pl-k">&lt;</span><span class="pl-k">-</span>gopherApi.select.once) 
             s <span class="pl-k">match</span> {
               <span class="pl-k">case</span> <span class="pl-v">i</span>: channelA.read <span class="pl-k">=&gt;</span> s<span class="pl-s"><span class="pl-pds">"</span>Readed(${i})<span class="pl-pds">"</span></span>
               <span class="pl-k">case</span> <span class="pl-v">x</span>: channelB.write <span class="pl-k">if</span> (x<span class="pl-k">==</span><span class="pl-c1">1</span>) <span class="pl-k">=&gt;</span> s<span class="pl-s"><span class="pl-pds">"</span>Written(${x})<span class="pl-pds">"</span></span> 
             }

}  </pre>
  </div> 
  <p>and afold become fold:</p> 
  <div class="highlight highlight-source-scala">
   <pre>go {
  ...
  <span class="pl-k">val</span> <span class="pl-en">sum</span> <span class="pl-k">=</span> select.fold(<span class="pl-c1">0</span>) { (n,s) <span class="pl-k">=&gt;</span>
             s <span class="pl-k">match</span> {
               <span class="pl-k">case</span> <span class="pl-v">x</span>: channelA.read <span class="pl-k">=&gt;</span> n<span class="pl-k">+</span>x
               <span class="pl-k">case</span> <span class="pl-v">q</span>: quit.read <span class="pl-k">=&gt;</span> select.exit(n)
             }
            }
}</pre>
  </div> 
  <p>amap - map</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">multiplexed</span> <span class="pl-k">=</span> <span class="pl-k">for</span>(s <span class="pl-k">&lt;</span><span class="pl-k">-</span> select) <span class="pl-k">yield</span>
                    s <span class="pl-k">match</span> {
                      <span class="pl-k">case</span> x<span class="pl-k">:</span>ch1.read <span class="pl-k">=&gt;</span> (s1,x)
                      <span class="pl-k">case</span> y<span class="pl-k">:</span>ch2.read <span class="pl-k">=&gt;</span> (s2,y)
                    }</pre>
  </div> 
  <h2><a id="user-content-effectedinputoutputchannel" class="anchor" href="https://github.com/rssh/scala-gopher#effectedinputoutputchannel" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Effected{Input,Output,Channel}</h2> 
  <p>One useful programming pattern, often used in CSP-style programming: have a channel from wich we read (or to where we write) as a part of a state. In Go language, this is usually modelled as a mutable variable, changed inside the same select statement, where one is read/written.</p> 
  <p>In scala-gopher, we have the ability to use a technique of 'EffectedChannel', which can be seen as an entity, which holds channel, can be used in read/write and can be changed only via effect (operation, which accepts previous state and return next).</p> 
  <p>Let's look on example:</p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">def</span> <span class="pl-en">generate</span>(n<span class="pl-k">:</span><span class="pl-k">Int</span>, quit<span class="pl-k">:</span><span class="pl-en">Promise</span>[<span class="pl-k">Boolean</span>])<span class="pl-k">:</span><span class="pl-en">Channel</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span>
  {
    <span class="pl-k">val</span> <span class="pl-en">channel</span> <span class="pl-k">=</span> makeChannel[<span class="pl-k">Int</span>]()
    channel.awriteAll(<span class="pl-c1">2</span> to n) andThen (_ <span class="pl-k">=&gt;</span> quit success <span class="pl-c1">true</span>)
    channel
  }

 <span class="pl-k">def</span> <span class="pl-en">filter</span>(in<span class="pl-k">:</span><span class="pl-en">Channel</span>[<span class="pl-k">Int</span>])<span class="pl-k">:</span><span class="pl-en">Input</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span>
  {
     <span class="pl-k">val</span> <span class="pl-en">filtered</span> <span class="pl-k">=</span> makeChannel[<span class="pl-k">Int</span>]()
     <span class="pl-k">val</span> <span class="pl-en">sieve</span> <span class="pl-k">=</span> makeEffectedInput(in)
     sieve.aforeach { prime <span class="pl-k">=&gt;</span>
            sieve <span class="pl-k">&lt;&lt;=</span> (_.filter(_ <span class="pl-k">%</span> prime <span class="pl-k">!=</span> <span class="pl-c1">0</span>))
            filtered <span class="pl-k">&lt;</span><span class="pl-k">~</span> prime
      }
    filtered
  }</pre>
  </div> 
  <p>Here in 'filter', we generate a set of prime numbers, and make a sieve of Eratosthenes by sequentially applying 'filter' effect to state of sieve EffectedInput.</p> 
  <h2><a id="user-content-transputers" class="anchor" href="https://github.com/rssh/scala-gopher#transputers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Transputers</h2> 
  <p>The logic of data transformation between channels can be encapsulated in special <code>Transputer</code> concept. (Word 'transputer' was chosen as a reminder about INMOS processor, for which one of the first CSP languages, Occam, was developed). You can view on transputer as representation of restartable process that consists from:</p> 
  <ul> 
   <li>Set of named input and output ports.</li> 
   <li>Logic for propagating information from the input to the output ports.</li> 
   <li>Possible state</li> 
   <li>Logic of error recovering.</li> 
  </ul> 
  <p>I.e. we saw that Transputer is similar to Actor with the following difference: When Actor provides reaction to incoming messages from the mailbox and sending signals to other actors, Transputers provide processing of incoming messages from input ports and sending outcoming messages to output ports. When operations inside Actor must not be blocked, operations inside Transputer can wait.</p> 
  <p>Transformers are build hierarchically with help of 3 operations:</p> 
  <ul> 
   <li>select (logic is execution of a select statement )</li> 
   <li>parallel combination (logic is parallel execution of parts)</li> 
   <li>replication (logic is parallel execution of a set of identical transformers.)</li> 
  </ul> 
  <h3><a id="user-content-select-transputer" class="anchor" href="https://github.com/rssh/scala-gopher#select-transputer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Select transputer</h3> 
  <p>Let's look at a simple example: transputer with two input ports and one output. When the same number has come from <code>inA</code> and <code>inB</code>, then transputer prints <code>Bingo</code> on console and output this number to <code>out</code>:</p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">trait</span> <span class="pl-en">BingoTransputer</span> <span class="pl-k">extends</span> <span class="pl-e">SelectTransputer</span>
 {
    <span class="pl-k">val</span> <span class="pl-en">inA</span> <span class="pl-k">=</span> <span class="pl-en">InPort</span>[<span class="pl-k">Int</span>]
    <span class="pl-k">val</span> <span class="pl-en">inB</span> <span class="pl-k">=</span> <span class="pl-en">InPort</span>[<span class="pl-k">Int</span>]
    <span class="pl-k">val</span> <span class="pl-en">out</span> <span class="pl-k">=</span> <span class="pl-en">OutPort</span>[<span class="pl-k">Boolean</span>]

    loop {
      <span class="pl-k">case</span> x<span class="pl-k">:</span>inA.read <span class="pl-k">=&gt;</span>
             y <span class="pl-k">=</span> inB.read
             out.write(x<span class="pl-k">==</span>y)
             <span class="pl-k">if</span> (x<span class="pl-k">==</span>y) {
               <span class="pl-en">Console</span>.println(s<span class="pl-s"><span class="pl-pds">"</span>Bingo: ${x}<span class="pl-pds">"</span></span>)
             }
    }

 }</pre>
  </div> 
  <p>A select loop is described in <code>loop</code> statement.</p> 
  <p>To create transputer we can use <code>gopherApi.makeTransputer</code> call:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">bing</span> <span class="pl-k">=</span> gopherApi.makeTransputer[<span class="pl-en">BingoTransputer</span>]</pre>
  </div> 
  <p>after the creation of transputer, we can create channels, connect one to ports and start transformer. </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">inA</span> <span class="pl-k">=</span> makeChannel[<span class="pl-k">Int</span>]()
bingo.inA.connect(inA)
<span class="pl-k">val</span> <span class="pl-en">inB</span> <span class="pl-k">=</span> makeChannel[<span class="pl-k">Int</span>]()
bingo.inB.connect(inB)
<span class="pl-k">val</span> <span class="pl-en">out</span> <span class="pl-k">=</span> makeChannel[<span class="pl-k">Int</span>]()
bingo.out.connect(out)

<span class="pl-k">val</span> <span class="pl-en">shutdownFuture</span> <span class="pl-k">=</span> bingo.start()</pre>
  </div> 
  <p>Then after we will write to <code>inA</code> and <code>inB</code> values <code>(1,1)</code> then <code>true</code> will become available for reading from <code>out</code>.</p> 
  <h4><a id="user-content-error-recovery" class="anchor" href="https://github.com/rssh/scala-gopher#error-recovery" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Error recovery</h4> 
  <p>On an exception from a loop statement, transputer will be restarted with ports, connected to the same channels. Such behaviour is default; we can configure one by setting recovery policy:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">t</span> <span class="pl-k">=</span> makeTransputer[<span class="pl-en">MyType</span>].recover {
           <span class="pl-k">case</span> <span class="pl-v">ex</span>: <span class="pl-en">MyException</span> <span class="pl-k">=&gt;</span> <span class="pl-en">SupervisorStrategy</span>.<span class="pl-en">Escalate</span>
        }</pre>
  </div> 
  <p>Recovery policy is a partial function from throwable to akka <code>SupervisorStrategy.Direction</code>. Escalated exceptions are passed to parent transputers or to TransputerSupervisor actor, which handle failures according to akka default supervisor strategy.</p> 
  <p>How many times transputer can be restarted within given period can be configured via failureLimit call:</p> 
  <div class="highlight highlight-source-scala">
   <pre> t.failureLimit(maxFailures <span class="pl-k">=</span> <span class="pl-c1">20</span>, windowDuration <span class="pl-k">=</span> <span class="pl-c1">10</span> seconds)</pre>
  </div> 
  <p>This setting means that if 20 failures will occur during 10 seconds, then exception Transputer.TooManyFailures will be escalated to parent.</p> 
  <h3><a id="user-content-par-transputers" class="anchor" href="https://github.com/rssh/scala-gopher#par-transputers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Par transputers.</h3> 
  <p>'Par' is a group of transputers running in parallel. Par transputer can be created with the help of plus operator:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">par</span> <span class="pl-k">=</span> (t1 <span class="pl-k">+</span> t1 <span class="pl-k">+</span> t3)
par.start()</pre>
  </div> 
  <p>When one from <code>t1</code>, <code>t2</code>, ... is stopped or failed, then all other members of <code>par</code> are stopped. After this <code>par</code> can be restarted according to current recovery policy.</p> 
  <h3><a id="user-content-replication" class="anchor" href="https://github.com/rssh/scala-gopher#replication" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Replication</h3> 
  <p>Replicated transputer is a set of identical transputers t_{i}, running in parallel. It cam be created with <code>gopherApi.replicate</code> call. Next code fragment:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">r</span> <span class="pl-k">=</span> gopherApi.replicate[<span class="pl-en">MyTransputer</span>](<span class="pl-c1">10</span>)</pre>
  </div> 
  <p>will produce ten copies of MyTransputer (<code>r</code> will be a container transputer for them). Ports of all replicated internal transputers will be shared with ports of the container. (I.e. if we will write something to input port then it will be read by one of the replicas; if one of the replicas will write something to out port, this will be visible in out port of container.)</p> 
  <p>Mapping from a container to replica port can be changed from sharing to other approaches, like duplicating or distributing, via applying port transformations.</p> 
  <p>For example, next code fragment:</p> 
  <div class="highlight highlight-source-scala">
   <pre>r.inA.duplicate()
 .inB.distribute( _.hashCode )</pre>
  </div> 
  <p>will set port <code>inA</code> be duplicated in replicas (i.e. message, send to container port <code>inA</code> will be received by each instance) and messages from <code>inB</code> will be distributed by hashcode: i.e. messages with the same hashcode will be directed to the same replica. Such behaviour is useful when we keep in replicated transputer some state information about messages.</p> 
  <p>Stopping and recovering of replicated transformer is the same as in <code>par</code> (i.e. stopping/failing of one instance will cause stopping/failing of container)</p> 
  <p>Also note, that we can receive a sequence of replicated instances with the help of <code>ReplicateTransformer.replicated</code> method.</p> 
  <h2><a id="user-content-unsugared-interfaces" class="anchor" href="https://github.com/rssh/scala-gopher#unsugared-interfaces" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Unsugared interfaces</h2> 
  <p>It is worth to know that exists gopher API without macro-based syntax sugar. </p> 
  <div class="highlight highlight-source-scala">
   <pre>(
   <span class="pl-k">new</span> <span class="pl-en">ForeverSelectorBuilder</span>(gopherApi)
          .reading(ch1){ x <span class="pl-k">=&gt;</span> something<span class="pl-k">-</span>x }
          .writing(ch2,y){ y <span class="pl-k">=&gt;</span> something<span class="pl-k">-</span>y }
          .idle(something idle).go
)</pre>
  </div> 
  <p>can be used instead of appropriative macro-based call. </p> 
  <p>Moreover, for tricky things exists even low-level interface, which can combine computations by adding to functional interfaces, similar to continuations:</p> 
  <div class="highlight highlight-source-scala">
   <pre>{
  <span class="pl-k">val</span> <span class="pl-en">selector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Selector</span>[<span class="pl-k">Unit</span>](gopherApi)
  selector.addReader(ch1, cont<span class="pl-k">=&gt;</span><span class="pl-en">Some</span>{ in <span class="pl-k">=&gt;</span> something<span class="pl-k">-</span>x
                                        <span class="pl-en">Future</span> successful cont
                                    }
                    )
 selector.addWriter(ch2, cont<span class="pl-k">=&gt;</span><span class="pl-en">Some</span>{(y,{something y;
                                           <span class="pl-en">Future</span> successful cont
                    })})                  
 selector.addIdle(cont <span class="pl-k">=&gt;</span> {..<span class="pl-k">do</span><span class="pl-k">-</span>something<span class="pl-k">-</span>when<span class="pl-k">-</span>idle; <span class="pl-en">Future</span> successful cont})
} </pre>
  </div> 
  <p>Please, consult with source code for details.</p> 
  <h2><a id="user-content-additional-informatiom" class="anchor" href="https://github.com/rssh/scala-gopher#additional-informatiom" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Additional Informatiom</h2> 
  <hr> 
  <ul> 
   <li>API reference: <a href="http://rssh.github.io/scala-gopher/api/index.html#package" target="_blank">http://rssh.github.io/scala-gopher/api/index.html#package</a></li> 
   <li>source code: <a href="https://github.com/rssh/scala-gopher" target="_blank">https://github.com/rssh/scala-gopher</a></li> 
   <li><p>presentations: </p> 
    <ul> 
     <li>Odessa Java/Scala Labs; Kiev Scala Meetup: Oct. 2014: <a href="http://www.slideshare.net/rssh1/scala-gopher2014" target="_blank">http://www.slideshare.net/rssh1/scala-gopher2014</a><br></li> 
     <li>Wix R&amp;D meetup. Mart 2016: <a href="http://www.slideshare.net/rssh1/csp-scala-wixmeetup2016" target="_blank">http://www.slideshare.net/rssh1/csp-scala-wixmeetup2016</a></li> 
    </ul> <p>Some related links:</p></li> 
   <li><p><a href="http://www.usingcsp.com" target="_blank">Communicating Sequential Processes book by Tony Hoare</a></p></li> 
   <li><a href="http://swtch.com/%7Ersc/thread/" target="_blank">brief history of CSP in Bell-labs</a></li> 
   <li><a href="http://blog.golang.org/defer-panic-and-recover" target="_blank">introduction article about go defer/recover</a><br></li> 
  </ul> 
 </article>
</div>