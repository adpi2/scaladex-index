<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-taggy" class="anchor" href="https://github.com/acjay/taggy#taggy" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Taggy</h1> 
  <p>Single-line helper for better type safety.</p> 
  <h2><a id="user-content-meta" class="anchor" href="https://github.com/acjay/taggy#meta" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Meta</h2> 
  <ul> 
   <li><strong>State:</strong> development</li> 
   <li><strong>Point People:</strong> <a href="https://github.com/acjay" target="_blank">@acjay</a></li> 
  </ul> 
  <p>Types let programmers rely on the compiler catch programmer errors, where an operation is attempted on inapplicable data. But in real-world applications, the type of a variable isn't specific enough to capture the fact that data of the same type often aren't interchangeable from a business perspective. With tagged types, you assert the <em>purpose</em> of the data when it enters your system, and you're protected from misusing it as it flows through the logic layers. This is particularly applicable where you find that your system--or a subsystem of it--passes values along without inspecting or modifying them.</p> 
  <p>For example, you might have a function that returns longitude and latitude for a street address:</p> 
  <pre><code>def locateAddress(address: String): (Double, Double) = ???
</code></pre> 
  <p>This typed interface might catch some errors for you, but it won't stop you from accidentally calling your function on a person's name (<code>locateAddress(person.name)</code>). Or maybe more likely, since the results are both <code>Double</code>s, it would be pretty easy to get them mixed up (<code>val (latitude, longitude) = locateAddress(address)</code>).</p> 
  <p>With tagged types, the function would take the same values, but its signature might look like:</p> 
  <pre><code>def locateAddress(address: Address): (Longitude, Latitude) = ???
</code></pre> 
  <p>More safe, and more readable!</p> 
  <p>As a bonus, even if you used converted this function to an anonymous function of type <code>Address =&gt; (Longitude, Latitude)</code>, it would be pretty much self-explanatory.</p> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/acjay/taggy#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <h3><a id="user-content-sbt-setup" class="anchor" href="https://github.com/acjay/taggy#sbt-setup" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SBT setup</h3> 
  <p>Include the following line in your <code>build.sbt</code>:</p> 
  <pre><code>libraryDependencies ++= Seq(
  "com.chuusai" %% "shapeless" % "2.3.2",
  "com.acjay" %% "taggy" % "0.0.1"
)

// Enable Scala Meta macros for taggy
addCompilerPlugin("org.scalameta" % "paradise" % "3.0.0-M10" cross CrossVersion.full)

scalacOptions += "-Xplugin-require:macroparadise"

// temporary workaround for https://github.com/scalameta/paradise/issues/10
scalacOptions in (Compile, console) ~= (_ filterNot (_ contains "paradise"))
</code></pre> 
  <h3><a id="user-content-using-in-your-code" class="anchor" href="https://github.com/acjay/taggy#using-in-your-code" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using in your code</h3> 
  <p>Import the annotation:</p> 
  <pre><code>import com.acjay.taggy.tagged
</code></pre> 
  <p>Then, declare your tagged type, specifying the underlying type as a string literal:</p> 
  <pre><code>@tagged("String") type Address
@tagged("Double") type Longitude
@tagged("Double") type Latitude
</code></pre> 
  <p>When data enters your system as a string, upgrade it to the tagged type:</p> 
  <pre><code>val address = Address.fromString("123 Main Street")
val longitude = Longitude.fromDouble(44.12345)
</code></pre> 
  <p>In a lot of cases, the compiler will let you pass a tagged type where its underlying type is expected, but not always. When you need to widen back to the underlying type:</p> 
  <pre><code>val addressAsPlainString = address.untagged // addressAsPlainString: String
</code></pre> 
  <h3><a id="user-content-additional-notes" class="anchor" href="https://github.com/acjay/taggy#additional-notes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Additional notes</h3> 
  <ul> 
   <li> <p>You can often write generic implicits for [de]serialization of tagged types. For example, to do this with Spray-JSON serialization, you might do something like:</p> <pre><code>implicit def taggedStringTypeFormat[NewTypeTag](implicit reader: JsonReader[String], writer: JsonWriter[String]): JsonFormat[String @@ NewTypeTag] = new JsonFormat[String @@ NewTypeTag] {
  def read(json: JsValue) = tag[NewTypeTag](reader.read(json))
  def write(obj: String @@ NewTypeTag): JsValue = writer.write(obj)
}
</code></pre> <p>Note that this only works as a generic JsonFormat for all the new types that have an underlying type of <code>String</code>, and it relies on the implementation detail that taggy sythesizes a phantom type tag of the same name as the <code>NewType</code>, but with <code>Tag</code> appended at the end.</p> <p>A fully generic version doesn't seem to work:</p> <pre><code>// THIS CODE FAILS DUE TO IMPLICIT DIVERGENCE
implicit def taggedTypeFormat[NewTypeTag, UnderlyingType](implicit reader: JsonReader[UnderlyingType], writer: JsonWriter[UnderlyingType]): JsonFormat[UnderlyingType @@ NewTypeTag] = new JsonFormat[UnderlyingType @@ NewTypeTag] {
  def read(json: JsValue) = tag[NewTypeTag](reader.read(json))
  def write(obj: UnderlyingType @@ NewTypeTag): JsValue = writer.write(obj)
}
</code></pre> <p>A PR to this readme with a fully working generic version would be much appreciated!</p> 
    <ul> 
     <li> <p>IntelliJ currently flags the declaration line as an error, where the <code>@tagged</code> is applied. But fortunately, it doesn't flag places where the tagged types or helper methods are used. Hopefully, IntelliJ will eventually internally expand macros before checking syntax.</p> </li> 
     <li> <p>One known issue is that the Scala Meta compiler plugin for macro annotations appears to conflict with the code that ScalaPB produces. We solved this by moving our Protobuf <code>.proto</code> files into their own SBT subproject, without the macroparadise compiler option enabled. If you encounter any issues that seem similar, see if this approach works for you.</p> </li> 
    </ul> </li> 
  </ul> 
  <h2><a id="user-content-technologies" class="anchor" href="https://github.com/acjay/taggy#technologies" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Technologies</h2> 
  <p>This project uses <a href="http://scalameta.org/" target="_blank">Scalameta</a> to generate a bunch of boilerplate for making tagged types as convenient as possible to work with. It requires <a href="https://github.com/milessabin/shapeless/" target="_blank">Shapeless</a> for its implementation of type tagging, but perhaps in the future other options will be offered, too.</p> 
  <h2><a id="user-content-running-the-demos" class="anchor" href="https://github.com/acjay/taggy#running-the-demos" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the demos</h2> 
  <p>To try out the example run <code>sbt '+ exampleJS/run' '+ exampleJVM/run'</code>, which will run it for each supported Scala version.</p> 
  <h2><a id="user-content-releasing-new-versions" class="anchor" href="https://github.com/acjay/taggy#releasing-new-versions" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Releasing new versions</h2> 
  <p>For testing changes:</p> 
  <ol> 
   <li>Bump the version in <code>build.sbt</code> as appropriate, and add <code>-SNAPSHOT</code> to the end of the version number.</li> 
   <li>Update the <code>libraryDependencies</code> line above in anticipation of the next version.</li> 
   <li>Use the <code>sbt +publish</code> task to push snapshots to Maven Central.</li> 
   <li>Update the <em>Changelog</em> as noteworthy changes are made.</li> 
   <li>During the testing period, merge new changes into the <code>development</code> branch, so that the <code>master</code> branch on Github always reflects the latest version on Maven Central.</li> 
  </ol> 
  <p>For releasing new versions:</p> 
  <ol> 
   <li>Remove the <code>-SNAPSHOT</code> suffix in <code>build.sbt</code>.</li> 
   <li>Publish to Maven Central staging using <code>sbt +publish-signed</code>.</li> 
   <li>Follow <a href="http://central.sonatype.org/pages/releasing-the-deployment.html" target="_blank">the Maven Central workflow</a> for releasing the next version, logging in to Maven Central Nexus with an account set up with the privilege to publish to <a href="https://issues.sonatype.org/browse/OSSRH-20964" target="_blank">the Open Source Project Repository Atomic Store entry</a>.</li> 
   <li>Merge <code>development</code> into <code>master</code> to update the canonical version on Github.</li> 
  </ol> 
  <p>For reference on this process, you may want to see the following links:</p> 
  <ul> 
   <li><a href="http://www.scala-sbt.org/0.13/docs/Using-Sonatype.html" target="_blank">SBT: Deploying to Sonatype</a></li> 
   <li><a href="http://www.scala-sbt.org/sbt-pgp/usage.html" target="_blank">SBT-PGP Usage docs</a></li> 
   <li><a href="http://central.sonatype.org/pages/releasing-the-deployment.html" target="_blank">The Central Repository: Releasing The sdDeployment</a></li> 
  </ul> 
  <h2><a id="user-content-todos" class="anchor" href="https://github.com/acjay/taggy#todos" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Todos</h2> 
  <ul> 
   <li>Get full publish-and-release workflow going with sbt-release and CircleCI</li> 
   <li>Optional overrides for all generated names</li> 
   <li>Tests (does-not-compile test)</li> 
   <li>Streamline inclusion via SBT (as a plugin maybe?)</li> 
   <li>Other tagging approaches (e.g. wrapper class)</li> 
   <li>Cross-build for Scala Native?</li> 
  </ul> 
  <h2><a id="user-content-changelog" class="anchor" href="https://github.com/acjay/taggy#changelog" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changelog</h2> 
  <p><em>0.0.1</em></p> 
  <ul> 
   <li>Initial release.</li> 
  </ul> 
 </article>
</div>