<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-matryoshka" class="anchor" href="https://github.com/slamdata/matryoshka#matryoshka" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Matryoshka</h1> 
  <p>Generalized folds, unfolds, and traversals for fixed point data structures in Scala.</p> 
  <p><a href="http://typelevel.org" target="_blank"><img src="https://camo.githubusercontent.com/4dfd4e728b69fb04a284f6b7ae669940c873d459/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f747970656c6576656c2d696e63756261746f722d4635314332422e737667" alt="Typelevel incubator" data-canonical-src="https://img.shields.io/badge/typelevel-incubator-F51C2B.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/slamdata/matryoshka" target="_blank"><img src="https://camo.githubusercontent.com/1b331631547a5fda06c1be63457e138ebc01cec2/68747470733a2f2f7472617669732d63692e6f72672f736c616d646174612f6d617472796f73686b612e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/slamdata/matryoshka.svg?branch=master" style="max-width:100%;"></a> <a href="https://codecov.io/github/slamdata/matryoshka?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/65801134a9350f2198bbc10296b1fe880e945062/68747470733a2f2f636f6465636f762e696f2f6769746875622f736c616d646174612f6d617472796f73686b612f636f7665726167652e7376673f6272616e63683d6d6173746572" alt="codecov.io" data-canonical-src="https://codecov.io/github/slamdata/matryoshka/coverage.svg?branch=master" style="max-width:100%;"></a> <a href="https://gitter.im/slamdata/matryoshka?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/b6a2aed2a7b1c0f6889db47503cb12a13773dd59/68747470733a2f2f6261646765732e6769747465722e696d2f736c616d646174612f6d617472796f73686b612e737667" alt="Join the chat at https://gitter.im/slamdata/matryoshka" data-canonical-src="https://badges.gitter.im/slamdata/matryoshka.svg" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-external-resources" class="anchor" href="https://github.com/slamdata/matryoshka#external-resources" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>External Resources</h2> 
  <ul> 
   <li><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125" target="_blank">Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire</a> – the iconic paper that collected a lot of this info for the first time</li> 
   <li><a href="http://comonad.com/reader/2009/recursion-schemes/" target="_blank">Recursion Schemes: A Field Guide (Redux)</a> – Ed Kmett’s summary of various folds and unfolds, with links to Haskell code</li> 
   <li><a href="http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/urs.pdf" target="_blank">Unifying Structured Recursion Schemes</a> – a newer paper on how to generalize recursion schemes</li> 
   <li><a href="https://github.com/sellout/recursion-scheme-talk/blob/master/nanopass-compiler-talk.org" target="_blank">Efficient Nanopass Compilers using Cats and Matryoshka</a> – Greg Pfeil’s talk on this library (and some other things)</li> 
   <li><a href="https://github.com/sellout/recursion-scheme-talk/blob/master/recursion-scheme-talk.org" target="_blank">Fix Haskell (by eliminating recursion)</a> – Greg Pfeil’s talk on recursion schemes in Haskell</li> 
  </ul> 
  <h2><a id="user-content-usage" class="anchor" href="https://github.com/slamdata/matryoshka#usage" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Usage</h2> 
  <p>To use Matryoshka, the following import should bring in pretty much everything:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">matryoshka.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">matryoshka.implicits.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>Also, there are a number of implicits that scalac has trouble finding. Adding @milessabin’s <a href="https://github.com/milessabin/si2712fix-plugin" target="_blank">SI-2712 fix compiler plugin</a> will simplify a ton of Matryoshka-related code.</p> 
  <h2><a id="user-content-introduction" class="anchor" href="https://github.com/slamdata/matryoshka#introduction" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Introduction</h2> 
  <p>This library is predicated on the idea of rewriting your recursive data structures, replacing the recursive type reference with a fresh type parameter.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Expr</span>
<span class="pl-k">final</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Num</span>(<span class="pl-v">value</span>: <span class="pl-k">Long</span>)      <span class="pl-k">extends</span> <span class="pl-e">Expr</span>
<span class="pl-k">final</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Mul</span>(<span class="pl-v">l</span>: <span class="pl-en">Expr</span>, <span class="pl-v">r</span>: <span class="pl-en">Expr</span>) <span class="pl-k">extends</span> <span class="pl-e">Expr</span></pre>
  </div> 
  <p>could be rewritten as</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Expr</span>[<span class="pl-en">A</span>]
<span class="pl-k">final</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Num</span>[<span class="pl-en">A</span>](<span class="pl-v">value</span>: <span class="pl-k">Long</span>) <span class="pl-k">extends</span> <span class="pl-e">Expr</span>[<span class="pl-en">A</span>]
<span class="pl-k">final</span> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Mul</span>[<span class="pl-en">A</span>](<span class="pl-v">l</span>: <span class="pl-en">A</span>, <span class="pl-v">r</span>: <span class="pl-en">A</span>)  <span class="pl-k">extends</span> <span class="pl-e">Expr</span>[<span class="pl-en">A</span>]</pre>
  </div> 
  <p>This trait generally allows a <code>Traverse</code> instance (or at least a <code>Functor</code> instance). Then you use one of the fixed point type constructors below to regain your recursive type.</p> 
  <h3><a id="user-content-fixpoint-types" class="anchor" href="https://github.com/slamdata/matryoshka#fixpoint-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Fixpoint Types</h3> 
  <p>These types take a one-arg type constructor and provide a recursive form of it.</p> 
  <p>All of these types have instances for <code>Recursive</code>, <code>Corecursive</code>, <code>FunctorT</code>, <code>TraverseT</code>, <code>Equal</code>, <code>Show</code>, and <code>Arbitrary</code> type classes unless otherwise noted.</p> 
  <ul> 
   <li><code>Fix</code> – This is the simplest fixpoint type, implemented with general recursion.</li> 
   <li><code>Mu</code> – This is for inductive (finite) recursive structures, models the concept of “data”, aka, the “least fixed point”.</li> 
   <li><code>Nu</code> – This is for coinductive (potentially infinite) recursive structures, models the concept of “codata”, aka, the “greatest fixed point”.</li> 
   <li><code>Cofree[?[_], A]</code> – Only has a <code>Corecursive</code> instance if there’s a <code>Monoid</code> for <code>A</code>. This represents a structure with some metadata attached to each node. In addition to the usual operations, it can also be folded using an Elgot algebra.</li> 
   <li><code>Free[?[_], A]</code> – Does not have a <code>Recursive</code> instance. In addition to the usual operations, it can also be created by unfolding with an Elgot coalgebra.</li> 
  </ul> 
  <p>So a type like <code>Mu[Expr]</code> is now isomorphic to the original recursive type. However, the point is to avoid operating on recursive types directly …</p> 
  <h3><a id="user-content-algebras" class="anchor" href="https://github.com/slamdata/matryoshka#algebras" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Algebras</h3> 
  <p>A structure like this makes it possible to separate recursion from your operations. You can now write transformations that operate on only a single node of your structure at a time.</p> 
  <p><a href="https://github.com/slamdata/matryoshka/blob/master/resources/algebras.png" target="_blank"><img src="https://github.com/slamdata/matryoshka/raw/master/resources/algebras.png" alt="algebras and coalgebras" style="max-width:100%;"></a></p> 
  <p>This diagram covers the major classes of transformations. The most basic ones are in the center and the arrows show how they can be generalized in various ways.</p> 
  <p>Here is a very simple example of an algebra (<code>eval</code>) and how to apply it to a recursive structure.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">eval</span><span class="pl-k">:</span> <span class="pl-en">Algebra</span>[<span class="pl-en">Expr</span>, <span class="pl-k">Long</span>] <span class="pl-k">=</span> { <span class="pl-c">// i.e. Expr[Long] =&gt; Long</span>
  <span class="pl-k">case</span> <span class="pl-en">Num</span>(x)    <span class="pl-k">=&gt;</span> x
  <span class="pl-k">case</span> <span class="pl-en">Mul</span>(x, y) <span class="pl-k">=&gt;</span> x <span class="pl-k">*</span> y
}

<span class="pl-k">def</span> <span class="pl-en">someExpr</span>[<span class="pl-en">T</span>[_[_]]<span class="pl-k">:</span> <span class="pl-en">Corecursive</span>]<span class="pl-k">:</span> <span class="pl-en">T</span>[<span class="pl-en">Expr</span>] <span class="pl-k">=</span>
  <span class="pl-en">Mul</span>(<span class="pl-en">Num</span>[<span class="pl-en">T</span>[<span class="pl-en">Expr</span>]](<span class="pl-c1">2</span>).embed, <span class="pl-en">Mul</span>(<span class="pl-en">Num</span>[<span class="pl-en">T</span>[<span class="pl-en">Expr</span>]](<span class="pl-c1">3</span>).embed,
      <span class="pl-en">Num</span>[<span class="pl-en">T</span>[<span class="pl-en">Expr</span>]](<span class="pl-c1">4</span>).embed).embed).embed

someExpr[<span class="pl-en">Mu</span>].cata(eval) <span class="pl-c">// ⇒ 24</span></pre>
  </div> 
  <p>The <code>.embed</code> calls in <code>someExpr</code> wrap the nodes in the fixed point type. <code>embed</code> is generic, and we abstract <code>someExpr</code> over the fixed point type (only requiring that it has an instance of <code>Corecursive</code>), so we can postpone the choice of the fixed point as long as possible.</p> 
  <h3><a id="user-content-recursion-schemes" class="anchor" href="https://github.com/slamdata/matryoshka#recursion-schemes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Recursion Schemes</h3> 
  <p>Here is a cheat-sheet (also available <a href="https://github.com/slamdata/matryoshka/blob/master/resources/recursion-schemes.pdf" target="_blank">in PDF</a>) for some of them.</p> 
  <p><a href="https://github.com/slamdata/matryoshka/blob/master/resources/recursion-schemes.png" target="_blank"><img src="https://github.com/slamdata/matryoshka/raw/master/resources/recursion-schemes.png" alt="folds and unfolds" style="max-width:100%;"></a></p> 
  <h4><a id="user-content-folds" class="anchor" href="https://github.com/slamdata/matryoshka#folds" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Folds</h4> 
  <p>Those algebras can be applied recursively to your structures using many different folds. <code>cata</code> in the example above is the simplest fold. It traverses the structure bottom-up, applying the algebra to each node. That is the general behavior of a fold, but more complex ones allow for various comonads and monads to affect the result.</p> 
  <h4><a id="user-content-unfolds" class="anchor" href="https://github.com/slamdata/matryoshka#unfolds" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Unfolds</h4> 
  <p>These are the dual of folds – using coalgebras to deconstruct values into parts, top-down. They are defined in the <code>Corecursive</code> type class.</p> 
  <h4><a id="user-content-refolds" class="anchor" href="https://github.com/slamdata/matryoshka#refolds" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Refolds</h4> 
  <p>Refolds compose an unfold with a fold, never actually constructing the intermediate fixed-point structure. Therefore, they are available on any value, and are not part of a type class.</p> 
  <h4><a id="user-content-transformations" class="anchor" href="https://github.com/slamdata/matryoshka#transformations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Transformations</h4> 
  <p>The structure of these type classes is similar to <code>Recursive</code> and <code>Corecursive</code>, but rather than separating them between bottom-up and top-down traversals, <code>FunctorT</code> has both bottom-up and top-down traversals (and refold), while <code>TraverseT</code> has all the Kleisli variants (paralleling how <code>Traverse</code> extends <code>Functor</code>). A fixed-point type that has both <code>Recursive</code> and <code>Corecursive</code> instances has an implied <code>TraverseT</code> instance.</p> 
  <p>The benefits of these classes is that it is possible to define the required <code>map</code> and <code>traverse</code> operations on fixed-point types that lack either a <code>project</code> or an <code>embed</code> (e.g., <code>Cofree[?[_], A]</code> lacks <code>embed</code> unless <code>A</code> has a <code>Monoid</code> instance, but can easily be <code>map</code>ped over).</p> 
  <p>The tradeoff is that these operations can only transform between one fixed-point functor and another (or, in some cases, need to maintain the same functor).</p> 
  <p>The names of these operations are the same as those in <code>Recursive</code> and <code>Corecursive</code>, but prefixed with <code>trans</code>.</p> 
  <p>There is an additional (restricted) set of operations that also have a <code>T</code> suffix (e.g., <code>transCataT</code>). These only generalize in “the Elgot position” and require you to maintain the same functor. However, it can be the most natural way to write certain transformations, like <code>matryoshka.algebras.substitute</code>.</p> 
  <h3><a id="user-content-generalization" class="anchor" href="https://github.com/slamdata/matryoshka#generalization" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Generalization</h3> 
  <p>There are generalized forms of most recursion schemes. From the basic <code>cata</code> (and its dual, <code>ana</code>), we can generalize in a few ways. We name them using either a prefix or suffix, depending on how they’re generalized.</p> 
  <h4><a id="user-content-g" class="anchor" href="https://github.com/slamdata/matryoshka#g" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>G…</h4> 
  <p>Most well known (in fact, even referred to as “generalized recursion schemes”) is generalizing over a <code>Comonad</code> (or <code>Monad</code>), converting an algebra like <code>F[A] =&gt; A</code> to <code>F[W[A]] =&gt; A</code>. Many of the other named folds are instances of this –</p> 
  <ul> 
   <li>when <code>W[A] = (T[F], A)</code>, it’s <code>para</code>,</li> 
   <li>when <code>W[A] = (B, A)</code>, it’s <code>zygo</code>, and</li> 
   <li>when <code>W[A] = Cofree[F, A]</code>, it’s <code>histo</code>.</li> 
  </ul> 
  <p>These specializations can give rise to other generalizations. <code>zygoT</code> uses <code>EnvT[B, ?[_], A]</code> and <code>ghisto</code> uses <code>Cofree[?[_], A]</code>.</p> 
  <h4><a id="user-content-m" class="anchor" href="https://github.com/slamdata/matryoshka#m" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>…M</h4> 
  <p>Less unique to recursion schemes, there are Kleisli variants that return the result in any monad.</p> 
  <h4><a id="user-content-elgot" class="anchor" href="https://github.com/slamdata/matryoshka#elgot" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Elgot…</h4> 
  <p>This generalization, stolen from the “Elgot algebra”, is similar to standard generalization, except it uses <code>W[F[A]] =&gt; A</code> rather than <code>F[W[A]] =&gt; A</code>, with the <code>Comonad</code> outside the functor. Not all of the forms seem to be as useful as the <code>G</code> variants, but in some cases, like <code>elgotZygo</code>, it offers benefits of its own.</p> 
  <h4><a id="user-content-gelgotm" class="anchor" href="https://github.com/slamdata/matryoshka#gelgotm" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>GElgot…M</h4> 
  <p>Any of these generalizations can be combined, so you can have an algebra that is generalized along two or three dimensions. A fold like <code>cofPara</code> takes an algebra that’s generalized like <code>zygo</code> (<code>(B, ?)</code>) in the “Elgot” dimension and like <code>para</code> (<code>(T[F], ?)</code>) in the “G” dimension, which looks like <code>(B, F[(T[F], A)]) =&gt; A</code>. It’s honestly useful. I swear.</p> 
  <h3><a id="user-content-implementation" class="anchor" href="https://github.com/slamdata/matryoshka#implementation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Implementation</h3> 
  <p>Since we can actually derive almost everything from a fairly small number of operations, why don’t we? Well, there are a few reasons, enumerated here in descending order of how valid I think they are:</p> 
  <ol> 
   <li>Reducing constraints. In the case of <code>para</code>, using <code>gcata(distPara, …)</code> would introduce a <code>Corecursive</code> constraint, and all of the Kleisli variants require <code>Traverse</code> for the functor, not just <code>Functor</code>.</li> 
   <li>Improving performance. <code>cata</code> implemented directly (presumably) performs better than <code>gcata[Id, …]</code>. We should have some benchmarks added eventually to actually determine when this is worth doing.</li> 
   <li>Helping inference. While we are (planning to) use kinda-curried type parameters to help with this, it’s still the case that <code>gcata</code> generally requires all the type parameters to be specified, while, say, <code>zygo</code> doesn’t. You can notice these instances because their definition actually is just to call the generalized version, rather than being implemented directly.</li> 
  </ol> 
  <h2><a id="user-content-contributing" class="anchor" href="https://github.com/slamdata/matryoshka#contributing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributing</h2> 
  <p>Please note that this project is released with a <a href="https://github.com/slamdata/matryoshka/blob/master/CODE_OF_CONDUCT.md" target="_blank">Contributor Code of Conduct</a>. By participating in this project you agree to abide by its terms.</p> 
  <h2><a id="user-content-users" class="anchor" href="https://github.com/slamdata/matryoshka#users" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Users</h2> 
  <ul> 
   <li><a href="https://github.com/quasar-analytics/quasar" target="_blank">Quasar</a></li> 
  </ul> 
 </article>
</div>