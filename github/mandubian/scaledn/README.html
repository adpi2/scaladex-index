<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-scaledn-edn-scala-api" class="anchor" href="https://github.com/mandubian/scaledn#scaledn-edn-scala-api" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SCALEDN, <a href="https://github.com/edn-format/edn" target="_blank">EDN</a> Scala API</h1> 
  <p>A Scala <a href="https://github.com/edn-format/edn" target="_blank">EDN</a> parser/serializer/validator based on :</p> 
  <ul> 
   <li><a href="https://github.com/sirthias/parboiled2" target="_blank">Parboiled2</a>,</li> 
   <li><a href="https://github.com/milessabin/shapeless" target="_blank">Shapeless</a>,</li> 
   <li><a href="https://github.com/jto/validation" target="_blank">Generic Validation</a></li> 
   <li>Scala Macros</li> 
  </ul> 
  <blockquote> 
   <p>It works only in Scala 2.11.x</p> 
  </blockquote> 
  <h2><a id="user-content-using-it-in-your-project" class="anchor" href="https://github.com/mandubian/scaledn#using-it-in-your-project" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using it in your project</h2> 
  <blockquote> 
   <p>For now, the deps are still snapshots as the API is being robustified according to comments of you, users. So <strong>I deliver Jars on Bintray for now based on ugly Git hashes</strong>.</p> 
  </blockquote> 
  <h3><a id="user-content-add-bintray-sbt-to-your-project" class="anchor" href="https://github.com/mandubian/scaledn#add-bintray-sbt-to-your-project" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Add Bintray SBT to your project</h3> 
  <blockquote> 
   <p>Follow instructions on <a href="https://github.com/softprops/bintray-sbt" target="_blank">bintray-sbt</a></p> 
  </blockquote> 
  <h4><a id="user-content-add-sbt-bintray-to-your-sbt-projectpluginssbt" class="anchor" href="https://github.com/mandubian/scaledn#add-sbt-bintray-to-your-sbt-projectpluginssbt" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Add sbt-bintray to your sbt <code>project/plugins.sbt</code></h4> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-en">Resolver</span>.url(
  <span class="pl-s"><span class="pl-pds">"</span>bintray-sbt-plugin-releases<span class="pl-pds">"</span></span>,
    url(<span class="pl-s"><span class="pl-pds">"</span>http://dl.bintray.com/content/sbt/sbt-plugin-releases<span class="pl-pds">"</span></span>))(
        <span class="pl-en">Resolver</span>.ivyStylePatterns)

addSbtPlugin(<span class="pl-s"><span class="pl-pds">"</span>me.lessis<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>bintray-sbt<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.1.2<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h4><a id="user-content-add-sbt-013x-to-your-sbt-projectbuildproperties" class="anchor" href="https://github.com/mandubian/scaledn#add-sbt-013x-to-your-sbt-projectbuildproperties" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Add sbt 0.13.x to your sbt <code>project/build.properties</code></h4> 
  <blockquote> 
   <p>this plugin targets sbt 0.13.</p> 
  </blockquote> 
  <p>You will need to add the following to your <code>project/build.properties</code> file if you have multiple versions of sbt installed</p> 
  <pre><code>sbt.version=0.13.7
</code></pre> 
  <h4><a id="user-content-add-bintray-resolver--deps-to-your-buildsbt" class="anchor" href="https://github.com/mandubian/scaledn#add-bintray-resolver--deps-to-your-buildsbt" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Add Bintray resolver + deps to your <code>build.sbt</code></h4> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> bintray.<span class="pl-en">Opts</span>.resolver.mavenRepo(<span class="pl-s"><span class="pl-pds">"</span>mandubian<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">scalednVersion</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1.0.0-e8180d08620a607ec47613f8c2585f7784e86625<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
  <span class="pl-c">// only need scaledn parser?</span>
    <span class="pl-s"><span class="pl-pds">"</span>com.mandubian<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scaledn-parser<span class="pl-pds">"</span></span>     <span class="pl-k">%</span> scalednVersion
  <span class="pl-c">// only need scaledn validation/serialization?</span>
  , <span class="pl-s"><span class="pl-pds">"</span>com.mandubian<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scaledn-validation<span class="pl-pds">"</span></span> <span class="pl-k">%</span> scalednVersion
  <span class="pl-c">// only need scaledn macros?</span>
  , <span class="pl-s"><span class="pl-pds">"</span>com.mandubian<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scaledn-macros<span class="pl-pds">"</span></span>     <span class="pl-k">%</span> scalednVersion
)


<span class="pl-c">//or for custom subprojects</span>

scalednVersion <span class="pl-k">:</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>1.0.0-f77f98cc305ce8a304d8941f800505c6b3d41d74<span class="pl-pds">"</span></span>

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">myproj</span> <span class="pl-k">=</span> project
  .settings(
    resolvers <span class="pl-k">+</span><span class="pl-k">=</span> bintray.<span class="pl-en">Opts</span>.resolver.mavenRepo(<span class="pl-s"><span class="pl-pds">"</span>mandubian<span class="pl-pds">"</span></span>)
  )
  .settings(
    libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Seq</span>(
      <span class="pl-c">// only need scaledn parser?</span>
        <span class="pl-s"><span class="pl-pds">"</span>com.mandubian<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scaledn-parser<span class="pl-pds">"</span></span>     <span class="pl-k">%</span> scalednVersion
      <span class="pl-c">// only need scaledn validation/serialization?</span>
      , <span class="pl-s"><span class="pl-pds">"</span>com.mandubian<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scaledn-validation<span class="pl-pds">"</span></span> <span class="pl-k">%</span> scalednVersion
      <span class="pl-c">// only need scaledn macros?</span>
      , <span class="pl-s"><span class="pl-pds">"</span>com.mandubian<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>scaledn-macros<span class="pl-pds">"</span></span>     <span class="pl-k">%</span> scalednVersion
    )
  )</pre>
  </div> 
  <blockquote> 
   <p>There is a <a href="https://github.com/mandubian/scaledn/blob/master/samples/helloedn" target="_blank">helloedn sample</a></p> 
  </blockquote> 
  <h2><a id="user-content-why-edn" class="anchor" href="https://github.com/mandubian/scaledn#why-edn" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why EDN?...</h2> 
  <blockquote> 
   <p>Because Json is not enough &amp; quite limitating</p> 
  </blockquote> 
  <p>EDN is described as an <em>extensible data notation</em> specified (not really standardized) <a href="https://github.com/edn-format/edn" target="_blank">there</a>. Clojure &amp; Datalog used in Datomic are supersets of EDN.</p> 
  <p>EDN allows much more things than Json while keeping the same simplicity.</p> 
  <p>Here are the main points making EDN great to represent &amp; exchange Data</p> 
  <p><br></p> 
  <h3><a id="user-content-edn-manages-number-types-far-better-than-json" class="anchor" href="https://github.com/mandubian/scaledn#edn-manages-number-types-far-better-than-json" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN manages number types far better than Json</h3> 
  <p>For Json, all numbers (floating or integer, exponential or not) are all considered in the same way so numbers can only be mapped to the biggest number format: <code>BigDecimal</code>. It is really bad in terms of semantics and performance.</p> 
  <p>In EDN, numbers can be :</p> 
  <ul> 
   <li>64bits integer aka <code>Long</code> in Scala:</li> 
  </ul> 
  <pre><code>12345
</code></pre> 
  <ul> 
   <li>64bits floating point numbers &amp; exponentials aka <code>Double</code> in Scala:</li> 
  </ul> 
  <pre><code>123.45e-9
</code></pre> 
  <ul> 
   <li>Natural Integers aka <code>BigInt</code> in Scala:</li> 
  </ul> 
  <pre><code>1234567891234N
</code></pre> 
  <ul> 
   <li>Exact Floating Number aka <code>BigDecimal</code> in Scala:</li> 
  </ul> 
  <pre><code>123.4578972345M
</code></pre> 
  <p><br></p> 
  <h3><a id="user-content-edn-knows-much-more-about-collections" class="anchor" href="https://github.com/mandubian/scaledn#edn-knows-much-more-about-collections" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN knows much more about collections</h3> 
  <p>Collections in Json are just:</p> 
  <ul> 
   <li>lists of heterogenous json values</li> 
   <li>maps of key strings and json values.</li> 
  </ul> 
  <p>In EDN, you can have:</p> 
  <ul> 
   <li>heterogenous lists</li> 
  </ul> 
  <pre><code>(1 true "toto)
</code></pre> 
  <ul> 
   <li>heterogenous vectors/arrays</li> 
  </ul> 
  <pre><code>[1 true "toto]
</code></pre> 
  <ul> 
   <li>heterogenous sets</li> 
  </ul> 
  <pre><code>#{1 true "toto}
</code></pre> 
  <ul> 
   <li>heterogenous maps with heterogenous keys &amp; values</li> 
  </ul> 
  <pre><code>{1 "toto", "foo" 2}
</code></pre> 
  <p><br></p> 
  <h3><a id="user-content-edn-accepts-characters--unicode" class="anchor" href="https://github.com/mandubian/scaledn#edn-accepts-characters--unicode" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN accepts characters &amp; unicode</h3> 
  <p>Json doesn't know about characters outside strings.</p> 
  <p>EDN can manage chars:</p> 
  <pre><code>// simple char
\c

// special chars
\newline
\return
\space
\tag
\\

// unicode
\u0308
</code></pre> 
  <p><br></p> 
  <h3><a id="user-content-edn-accepts-comments--discarded-values" class="anchor" href="https://github.com/mandubian/scaledn#edn-accepts-comments--discarded-values" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN accepts comments &amp; discarded values</h3> 
  <p>There are special syntaxes:</p> 
  <ul> 
   <li>comments are lines starting with <code>;</code></li> 
   <li>values starting with <code>#_</code> are parsed but discarded</li> 
  </ul> 
  <p><br></p> 
  <h3><a id="user-content-edn-knows-about-symbols--keywords" class="anchor" href="https://github.com/mandubian/scaledn#edn-knows-about-symbols--keywords" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN knows about symbols &amp; keywords</h3> 
  <p>These are notions that don't exist in Json.</p> 
  <p>Symbols can reference anything external or internal that you want to identify. A <code>Symbol</code> can have a namespace such as <code>foo/bar</code>.</p> 
  <p>Keywords are unique identifiers or enumerated values that can be reused in your data structure. A <code>Keyword</code> is just a symbol preceded by a <code>:</code> such as :foo/bar.</p> 
  <p><br></p> 
  <h3><a id="user-content-edn-is-extensible-using-tags" class="anchor" href="https://github.com/mandubian/scaledn#edn-is-extensible-using-tags" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN is extensible using tags</h3> 
  <p>EDN is an extensible format using tags starting with <code>#</code> such as:</p> 
  <pre><code>#foo/bar value
</code></pre> 
  <p>When parsing EDN format, the parser should provide tag handlers that can be applied when a tag is discovered. In this way, you can extend default format with your own formats.</p> 
  <p>EDN specifies 2 tag handlers by default:</p> 
  <ul> 
   <li><code>#inst "1985-04-12T23:20:50.52Z"</code> for RFC-3339 instants</li> 
   <li><code>#uuid "f81d4fae-7dec-11d0-a765-00a0c91e6bf6"</code> for UUID</li> 
  </ul> 
  <p><br></p> 
  <h3><a id="user-content-edn-has-no-root-node--can-be-streamed" class="anchor" href="https://github.com/mandubian/scaledn#edn-has-no-root-node--can-be-streamed" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>EDN has no root node &amp; can be streamed</h3> 
  <p>Json is defined to have a root <code>map</code> node: <code>{ key : value }</code> or <code>[ ... ]</code>.</p> 
  <p>Json can't accept single values outside of this. So Json isn't really meant to be streamed as you need to find closing tags to finish parsing a value.</p> 
  <p>EDN doesn't require this and can consist in multiple heterogenous values:</p> 
  <p><code>1 123.45 "toto" true nil (1 2 3)</code></p> 
  <p>As a consequence, EDN can be used to stream your data structures.</p> 
  <p><br></p> 
  <h3><a id="user-content-conclusion-edn-should-be-preferred-to-json" class="anchor" href="https://github.com/mandubian/scaledn#conclusion-edn-should-be-preferred-to-json" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Conclusion: EDN should be preferred to Json</h3> 
  <p>All of these points make EDN a far better &amp; stricter &amp; more evolutive notation to represent data structures than Json. It can be used in the same way as Json but could make a far better RPC string format than Json.</p> 
  <p>I still wonder why Json has become the de-facto standard except for the reason that the <em>not so serious</em> Javascript language parses it natively and because people were so sick about XML that they would have accepted anything changing their daily life.</p> 
  <p>But JS could also parse EDN without any problem and all more robust &amp; typed backend languages would earn a lot from using EDN instead of JSON for their interfaces.</p> 
  <p>EDN could be used in REST API &amp; also for streaming API. That's exactly why, I wanted to provide a complete Scala API for EDN to test this idea a bit further.</p> 
  <p><br> <br></p> 
  <h2><a id="user-content-scaledn-insight" class="anchor" href="https://github.com/mandubian/scaledn#scaledn-insight" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scaledn insight</h2> 
  <p><br></p> 
  <h3><a id="user-content-runtime-parsing" class="anchor" href="https://github.com/mandubian/scaledn#runtime-parsing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Runtime Parsing</h3> 
  <p>Scaledn can be used to parse the EDN string or arrays of chars received by your API.</p> 
  <p>All types described in EDN format are isomorphic to Scala types so I've decided to skip the complete AST wrapping those types and directly parse to Scala types.</p> 
  <ul> 
   <li><code>"foobar"</code> is parsed to <code>String</code></li> 
   <li><code>123</code> is parsed to <code>Long</code></li> 
   <li><code>(1 2 3)</code> is parsed to <code>List[Long]</code></li> 
   <li><code>(1 "toto" 3)</code> is parsed to <code>List[Any]</code></li> 
   <li><code>{"toto" 1 "tata" 2}</code> is parsed to <code>Map[String, Long]</code></li> 
   <li><code>{1 "toto" 2 "tata"}</code> is parsed to <code>Map[Long, String]</code></li> 
   <li><code>{1 "toto" true 3}</code> is parsed to <code>Map[Any, Any]</code></li> 
   <li>etc...</li> 
  </ul> 
  <p>The parser (based on <a href="https://github.com/sirthias/parboiled2" target="_blank">Parboiled2</a>) provides 2 main functions:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">parser.</span><span class="pl-v">_</span>

<span class="pl-c">// parses only the first EDN value discovered in the String input</span>
<span class="pl-k">def</span> <span class="pl-en">parseEDN</span>(<span class="pl-v">in</span>: <span class="pl-en">ParserInput</span>)<span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">EDN</span>] <span class="pl-k">=</span> ...

<span class="pl-c">// parses all EDN values discovered in the String input</span>
<span class="pl-k">def</span> <span class="pl-en">parseEDNs</span>(<span class="pl-v">in</span>: <span class="pl-en">ParserInput</span>)<span class="pl-k">:</span> <span class="pl-en">Try</span>[<span class="pl-en">Seq</span>[<span class="pl-en">EDN</span>]] <span class="pl-k">=</span> ...</pre>
  </div> 
  <p>If you look in common package, you'll see that <code>EDN</code> is just an alias for <code>Any</code> ;)</p> 
  <p>Here is how you can use it:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">parser.</span><span class="pl-v">_</span>

<span class="pl-c">// Single Value</span>
parseEDN(<span class="pl-s"><span class="pl-pds">"""</span>{1 "foo", "bar" 1.234M, :foo/bar [1,2,3]} #_foo/bar :bar/foo<span class="pl-pds">"""</span></span>) <span class="pl-k">match</span> {
  <span class="pl-k">case</span> <span class="pl-en">Success</span>(t) <span class="pl-k">=&gt;</span> \<span class="pl-k">/-</span>(t)
  <span class="pl-k">case</span> <span class="pl-en">Failure</span>(<span class="pl-v">f</span> : org.parboiled2.<span class="pl-en">ParseError</span>) <span class="pl-k">=&gt;</span> <span class="pl-k">-</span>\<span class="pl-k">/</span>(parser.formatError(f))
}

<span class="pl-c">// Multiple Value</span>
parseEDNs(<span class="pl-s"><span class="pl-pds">"""</span>{1 "foo", "bar" 1.234M, :foo/bar [1,2,3]} :bar/foo<span class="pl-pds">"""</span></span>).success.value should be (
  <span class="pl-en">Vector</span>(
    <span class="pl-en">Map</span>(
      <span class="pl-c1">1L</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>,
      <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">BigDecimal</span>(<span class="pl-s"><span class="pl-pds">"</span>1.234<span class="pl-pds">"</span></span>),
      <span class="pl-en">EDNKeyword</span>(<span class="pl-en">EDNSymbol</span>(<span class="pl-s"><span class="pl-pds">"</span>foo/bar<span class="pl-pds">"</span></span>, <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>))) <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-en">Vector</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)
    ),
    <span class="pl-en">EDNKeyword</span>(<span class="pl-en">EDNSymbol</span>(<span class="pl-s"><span class="pl-pds">"</span>bar/foo<span class="pl-pds">"</span></span>, <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)))
  )
))</pre>
  </div> 
  <blockquote> 
   <p>Some people will think <code>Any</code> is a bit too large and I agree but it's quite practical to use. Moreover, using validation explained a bit later, you can parse your EDN and then map it to a stronger typed scala structure and then <code>Any</code> disappears.</p> 
  </blockquote> 
  <p><br></p> 
  <h2><a id="user-content-compile-time-parsing-with-macros" class="anchor" href="https://github.com/mandubian/scaledn#compile-time-parsing-with-macros" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Compile-time parsing with Macros</h2> 
  <p>When you use static EDN structures in your Scala code, you can write them in their string format and <em>scaledn</em> can parse them at compile-time using Scala macros and thus prevent a lot of errors you can encounter in dynamic languages.</p> 
  <p>The macro mechanism is based on quasiquotes &amp; whitebox macro contexts which allow to infer types of your parsed EDN structures at compile-time. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">&gt;</span> <span class="pl-k">val</span> <span class="pl-en">s</span><span class="pl-k">:</span><span class="pl-k">Long</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>toto<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>)

[error]  <span class="pl-v">found</span>   : <span class="pl-k">String</span>(<span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>)
[error]  <span class="pl-v">required</span>: <span class="pl-k">Long</span>
[error]     <span class="pl-k">val</span> <span class="pl-en">e</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>toto<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>)
</pre>
  </div> 
  <p>Whooohooo magic :)</p> 
  <p><br></p> 
  <h3><a id="user-content-classic-scala-types" class="anchor" href="https://github.com/mandubian/scaledn#classic-scala-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Classic Scala types</h3> 
  <p>Here is how you can use it:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">macros.</span><span class="pl-v">_</span>

<span class="pl-c">// All types are just for info and can be omitted below, the macro infers them quite well</span>
<span class="pl-k">val</span> <span class="pl-en">e</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>toto<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">bt</span><span class="pl-k">:</span> <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>true<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">bf</span><span class="pl-k">:</span> <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>false<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">l</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>123<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">d</span><span class="pl-k">:</span> <span class="pl-k">Double</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>123.456<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">bi</span><span class="pl-k">:</span> <span class="pl-en">BigInt</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>123M<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">bd</span><span class="pl-k">:</span> <span class="pl-en">BigDecimal</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>123.456N<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">s</span><span class="pl-k">:</span> <span class="pl-en">EDNSymbol</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>foo/bar<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">kw</span><span class="pl-k">:</span> <span class="pl-en">EDNKeyword</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"</span>:foo/bar<span class="pl-pds">"</span></span>)

<span class="pl-c">// Homogenous collection inferred as Vecto[String]</span>
<span class="pl-k">val</span> <span class="pl-en">vector</span><span class="pl-k">:</span> <span class="pl-en">Vector</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-en">EDN</span>(<span class="pl-s"><span class="pl-pds">"""</span>["tata" "toto" "tutu"]<span class="pl-pds">"""</span></span>)

<span class="pl-c">// multiple heterogenous values inferred as Seq[Any]</span>
<span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> <span class="pl-en">EDNs</span>(<span class="pl-s"><span class="pl-pds">"""</span>(1 2 3) "toto" [true false] :foo/bar<span class="pl-pds">"""</span></span>)
<span class="pl-c">// note the small s at the end of EDN to inform the macro there are several values</span></pre>
  </div> 
  <h3><a id="user-content-shapeless-heterogenous-collections" class="anchor" href="https://github.com/mandubian/scaledn#shapeless-heterogenous-collections" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Shapeless heterogenous collections</h3> 
  <p>EDN allows to manipulate heterogenous collections. In Scala, when one thinks <em>heterogenous collection</em>, one thinks <a href="https://github.com/milessabin/shapeless" target="_blank">Shapeless</a>. Scaledn macros can parse &amp; map your EDN stringified structures to Scala strongly typed structures.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">macros.</span><span class="pl-v">_</span>

<span class="pl-k">import</span> <span class="pl-v">shapeless.</span>{<span class="pl-v">HNil</span>, <span class="pl-v">::</span>}
<span class="pl-k">import</span> <span class="pl-v">shapeless.record.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">shapeless.syntax.singleton.</span><span class="pl-v">_</span>

<span class="pl-c">// Heterogenous list</span>
<span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> <span class="pl-en">EDNH</span>(<span class="pl-s"><span class="pl-pds">"""</span>(1 "toto" true)<span class="pl-pds">"""</span></span>)
s should equal (<span class="pl-c1">1L</span> <span class="pl-k">::</span> <span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span> <span class="pl-k">::</span> <span class="pl-c1">true</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>)

<span class="pl-c">// Heterogenous Map/Record</span>
<span class="pl-k">val</span> <span class="pl-en">s3</span> <span class="pl-k">=</span> <span class="pl-en">EDNH</span>(<span class="pl-s"><span class="pl-pds">"""</span>{1 "toto" true 1.234 "foo" (1 2 3)}<span class="pl-pds">"""</span></span>)
s3 should equal (
  <span class="pl-c1">1L</span> <span class="pl-k">-</span><span class="pl-k">&gt;&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span> <span class="pl-k">::</span>
  <span class="pl-c1">true</span> <span class="pl-k">-</span><span class="pl-k">&gt;&gt;</span> <span class="pl-c1">1.234</span> <span class="pl-k">::</span>
  <span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;&gt;</span> <span class="pl-en">List</span>(<span class="pl-c1">1L</span>, <span class="pl-c1">2L</span>, <span class="pl-c1">3L</span>) <span class="pl-k">::</span>
  <span class="pl-en">HNil</span>
)</pre>
  </div> 
  <blockquote> 
   <p>please note the <code>H</code> in <code>EDNH</code> for heterogenous</p> 
   <p>I must say using these macros, it might be even simpler to write Shapeless hlists or records than using scala API ;)</p> 
  </blockquote> 
  <p><br></p> 
  <h3><a id="user-content-macro-api" class="anchor" href="https://github.com/mandubian/scaledn#macro-api" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Macro API</h3> 
  <p>Scaledn provides different macros depending on the depth of introspection you require in your collection with respect to heterogeneity.</p> 
  <p>Have a look directly at <a href="https://github.com/mandubian/scaledn/blob/master/macros/src/main/scala/macros.scala" target="_blank">Macro API</a></p> 
  <p><br></p> 
  <h3><a id="user-content-mixing-macro-with-scala-string-interpolation" class="anchor" href="https://github.com/mandubian/scaledn#mixing-macro-with-scala-string-interpolation" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Mixing macro with Scala string interpolation</h3> 
  <p>Following ideas implemented by Daniel James in <a href="http://pellucidanalytics.github.io/datomisca/" target="_blank">Datomisca</a>, scaledn proposes to use String interpolation mixed with parsing macro such as:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">macros.</span><span class="pl-v">_</span>

<span class="pl-k">import</span> <span class="pl-v">shapeless.</span>{<span class="pl-v">HNil</span>, <span class="pl-v">::</span>}

<span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> <span class="pl-c1">123L</span>
<span class="pl-k">val</span> <span class="pl-en">s</span> <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-s"><span class="pl-pds">"</span>foo<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>bar<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">r</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">=</span> <span class="pl-en">EDN</span>(s<span class="pl-s"><span class="pl-pds">"</span>$l<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">r1</span><span class="pl-k">:</span> <span class="pl-en">Seq</span>[<span class="pl-en">Any</span>] <span class="pl-k">=</span> <span class="pl-en">EDN</span>(s<span class="pl-s"><span class="pl-pds">"</span>($l $s)<span class="pl-pds">"</span></span>)
<span class="pl-k">val</span> <span class="pl-en">r2</span><span class="pl-k">:</span> <span class="pl-k">Long</span> <span class="pl-k">::</span> <span class="pl-en">List</span>[<span class="pl-k">String</span>] <span class="pl-k">::</span> <span class="pl-en">HNil</span> <span class="pl-k">=</span> <span class="pl-en">EDNH</span>(s<span class="pl-s"><span class="pl-pds">"</span>($l $s)<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Nothing to add, macros are cool sometimes :)</p> 
  <p><br> <br></p> 
  <h2><a id="user-content-runtime-validation-of-edn-to-scala" class="anchor" href="https://github.com/mandubian/scaledn#runtime-validation-of-edn-to-scala" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Runtime validation of EDN to Scala</h2> 
  <p>When writing REST or external API, the received data can never be trusted before being validated. So, you generally try to validate what is received and map it to a strong-typed structures. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// parse the received string input</span>
parseEDN(<span class="pl-s"><span class="pl-pds">"""</span>{ 1 "toto" 2 "tata" 3 "tutu" }<span class="pl-pds">"""</span></span>)
<span class="pl-c">// then validate it to a Scala type</span>
  .map(validateEDN[<span class="pl-en">Map</span>[<span class="pl-k">Long</span>, <span class="pl-k">String</span>]])
  .success.value should be (
    play.api.data.mapping.<span class="pl-en">Success</span>(<span class="pl-en">Map</span>(
      <span class="pl-c1">1L</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>,
      <span class="pl-c1">2L</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>tata<span class="pl-pds">"</span></span>,
      <span class="pl-c1">3L</span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>tutu<span class="pl-pds">"</span></span>
    ))
  )</pre>
  </div> 
  <p>The validation API is the following:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">validate.</span><span class="pl-v">_</span>

<span class="pl-k">def</span> <span class="pl-en">validateEDN</span>[<span class="pl-en">T</span>](<span class="pl-v">edn</span>: <span class="pl-en">EDN</span>)(<span class="pl-k">implicit</span> <span class="pl-v">r</span>: <span class="pl-en">RuleLike</span>[<span class="pl-en">EDN</span>, <span class="pl-en">T</span>])<span class="pl-k">:</span> <span class="pl-en">Validation</span>[<span class="pl-en">EDN</span>, <span class="pl-en">T</span>] <span class="pl-k">=</span> r.validate(edn)</pre>
  </div> 
  <p>Scaledn validation is based on <a href="https://github.com/jto/validation" target="_blank">Generic Validation API</a> developed by my <a href="http://www.mfglabs.com" target="_blank">MFGLabs</a>'s colleague &amp; friend <a href="https://github.com/jto" target="_blank">Julien Tournay</a>. This API was developed for Play Framework &amp; Typesafe last year to generalize Json validation API to all data formats. But it will never be integrated in Play as Typesafe considers it to be too pure Scala &amp; pure FP-oriented. Yet, we use this API in production at <a href="http://www.mfglabs.com" target="_blank">MFGLabs</a> and maintain/extend it ourselves.</p> 
  <p>As explained before, Scaledn parser parses EDN values directly to Scala types as they are bijective so validation is often just a runtime cast and not very interesting in general.</p> 
  <p>What's much more interesting is to validate to Shapeless HList, Records and even more interesting to CaseClasses &amp; Tuples based on Shapeless fantastic auto-generated Generic macros.</p> 
  <p>Let's take a few examples to show the power of this feature:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">validate.</span><span class="pl-v">_</span>

<span class="pl-k">import</span> <span class="pl-v">play.api.data.mapping.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">shapeless.</span>{<span class="pl-v">HNil</span>, <span class="pl-v">::</span>}

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">CP</span>(<span class="pl-v">cp</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Address</span>(<span class="pl-v">street</span>: <span class="pl-k">String</span>, <span class="pl-v">cp</span>: <span class="pl-en">CP</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>, <span class="pl-v">addr</span>: <span class="pl-en">Address</span>)
<span class="pl-c">// Remark that NO implicits must be declared on our case classes</span>

<span class="pl-c">// HLISTS</span>
parseEDN(<span class="pl-s"><span class="pl-pds">"""</span>(1 "toto" true nil)<span class="pl-pds">"""</span></span>).map(
  validateEDN[<span class="pl-k">Long</span> <span class="pl-k">::</span> <span class="pl-k">String</span> <span class="pl-k">::</span> <span class="pl-k">Boolean</span> <span class="pl-k">::</span> <span class="pl-en">EDNNil</span>.<span class="pl-k">type</span> <span class="pl-en">::</span> <span class="pl-en">HNil</span>]
).success.value should be (
  <span class="pl-en">Success</span>(<span class="pl-c1">1L</span> <span class="pl-k">::</span> <span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span> <span class="pl-k">::</span> <span class="pl-c1">true</span> <span class="pl-k">::</span> <span class="pl-en">EDNNil</span> <span class="pl-k">::</span> <span class="pl-en">HNil</span>)
)

<span class="pl-c">// TUPLES</span>
parseEDN(<span class="pl-s"><span class="pl-pds">"""</span>("toto" 34 {"street" "chboing", "cp" {"cp" 75009}})<span class="pl-pds">"""</span></span>).map(
  validateEDN[<span class="pl-en">Tuple3</span>[<span class="pl-k">String</span>, <span class="pl-k">Int</span>, <span class="pl-en">Address</span>]]
).success.value should be (
  <span class="pl-en">Success</span>((<span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>, <span class="pl-c1">34</span>, <span class="pl-en">Address</span>(<span class="pl-s"><span class="pl-pds">"</span>chboing<span class="pl-pds">"</span></span>, <span class="pl-en">CP</span>(<span class="pl-c1">75009</span>))))
)

<span class="pl-c">// CASECLASSES</span>
parseEDN(<span class="pl-s"><span class="pl-pds">"""</span>("toto" 34 ("chboing" (75009)))<span class="pl-pds">"""</span></span>).map(
  validateEDN[<span class="pl-en">Person</span>]
).success.value should be (
  <span class="pl-en">Success</span>(<span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>, <span class="pl-c1">34</span>, <span class="pl-en">Address</span>(<span class="pl-s"><span class="pl-pds">"</span>chboing<span class="pl-pds">"</span></span>, <span class="pl-en">CP</span>(<span class="pl-c1">75009</span>))))
)

parseEDN(<span class="pl-s"><span class="pl-pds">"""</span>{"name" "toto", "age" 34, "addr" {"street" "chboing", "cp" {"cp" 75009}}}<span class="pl-pds">"""</span></span>).map(
  validateEDN[<span class="pl-en">Person</span>]
).success.value should be (
  <span class="pl-en">Success</span>(<span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>, <span class="pl-c1">34</span>, <span class="pl-en">Address</span>(<span class="pl-s"><span class="pl-pds">"</span>chboing<span class="pl-pds">"</span></span>, <span class="pl-en">CP</span>(<span class="pl-c1">75009</span>))))
)
</pre>
  </div> 
  <blockquote> 
   <p>I think here you can see the power of this validation feature without writing any boilerplate...</p> 
  </blockquote> 
  <p><br> <br></p> 
  <h2><a id="user-content-serializing-scala-to-edn" class="anchor" href="https://github.com/mandubian/scaledn#serializing-scala-to-edn" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Serializing Scala to EDN</h2> 
  <p>Using <a href="https://github.com/jto/validation" target="_blank">Generic Validation API</a>, you can also write scala structures to any other data format.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">write.</span><span class="pl-v">_</span>

toEDNString(<span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>) should equal (<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\"</span>toto<span class="pl-cce">\"</span><span class="pl-pds">"</span></span>)
toEDNString(<span class="pl-en">List</span>(<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>)) should equal (<span class="pl-s"><span class="pl-pds">"""</span>(1 2 3)<span class="pl-pds">"""</span></span>)</pre>
  </div> 
  <p>The write API is the following:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">write.</span><span class="pl-v">_</span>

<span class="pl-k">def</span> <span class="pl-en">toEDNString</span>[<span class="pl-en">I</span>](<span class="pl-v">i</span>: <span class="pl-en">I</span>)(<span class="pl-k">implicit</span> <span class="pl-v">w</span>: <span class="pl-en">WriteLike</span>[<span class="pl-en">I</span>, <span class="pl-k">String</span>])<span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> w.writes(i) </pre>
  </div> 
  <p>Once again, what's more interesting is using shapeless &amp; caseclasses &amp; tuples.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scaledn.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">write.</span><span class="pl-v">_</span>

<span class="pl-k">import</span> <span class="pl-v">shapeless.</span>{<span class="pl-v">HNil</span>, <span class="pl-v">::</span>}

<span class="pl-c">// HLIST</span>
toEDNString(<span class="pl-c1">1</span> <span class="pl-k">::</span> <span class="pl-c1">true</span> <span class="pl-k">::</span> <span class="pl-en">List</span>(<span class="pl-c1">1L</span>, <span class="pl-c1">2L</span>, <span class="pl-c1">3L</span>) <span class="pl-k">::</span> <span class="pl-en">HNil</span>) should equal (<span class="pl-s"><span class="pl-pds">"""</span>(1 true (1 2 3))<span class="pl-pds">"""</span></span>)

<span class="pl-c">// TUPLE</span>
toEDNString((<span class="pl-c1">23</span>, <span class="pl-c1">true</span>)) should equal (<span class="pl-s"><span class="pl-pds">"""</span>(23 true)<span class="pl-pds">"""</span></span>)

<span class="pl-c">// CASE CLASS</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Address</span>(<span class="pl-v">street</span>: <span class="pl-k">String</span>, <span class="pl-v">cp</span>: <span class="pl-k">Int</span>)
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Person</span>(<span class="pl-v">name</span>: <span class="pl-k">String</span>, <span class="pl-v">age</span>: <span class="pl-k">Int</span>, <span class="pl-v">addr</span>: <span class="pl-en">Address</span>)
<span class="pl-c">// Remark that NO implicits must be declared on our case classes</span>

toEDNString(<span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">"</span>toto<span class="pl-pds">"</span></span>, <span class="pl-c1">34</span>, <span class="pl-en">Address</span>(<span class="pl-s"><span class="pl-pds">"</span>chboing<span class="pl-pds">"</span></span>, <span class="pl-c1">75009</span>))) should equal (
  <span class="pl-s"><span class="pl-pds">"""</span>{"name" "toto", "age" 34, "addr" {"street" "chboing", "cp" 75009}}<span class="pl-pds">"""</span></span>
)</pre>
  </div> 
  <h2><a id="user-content-todo" class="anchor" href="https://github.com/mandubian/scaledn#todo" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>TODO</h2> 
  <p>This project is a first draft so it requires a bit more work.</p> 
  <p>Here are a few points to work on:</p> 
  <ul> 
   <li>patch remaining glitches/bugs</li> 
   <li>write more tests for all cases</li> 
   <li>study streamed parser asap</li> 
   <li>write sample apps</li> 
  </ul> 
  <p>Don't hesitate to test, find bugs, contribute, give remarks, ideas...</p> 
  <p>Have fun in EDN world..</p> 
 </article>
</div>