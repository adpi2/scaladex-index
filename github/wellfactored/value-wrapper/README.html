<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://circleci.com/gh/WellFactored/value-wrapper" target="_blank"><img src="https://camo.githubusercontent.com/f312f5e29aa3ee53c4fdfaff3693c497e222dcd3/68747470733a2f2f636972636c6563692e636f6d2f67682f57656c6c466163746f7265642f76616c75652d777261707065722e7376673f7374796c653d737667" alt="CircleCI" data-canonical-src="https://circleci.com/gh/WellFactored/value-wrapper.svg?style=svg" style="max-width:100%;"></a> <a href="https://waffle.io/WellFactored/value-wrapper" target="_blank"><img src="https://camo.githubusercontent.com/6cd5bbc24c4a5dcfa933208f03b92be2d17e6c25/68747470733a2f2f62616467652e776166666c652e696f2f57656c6c466163746f7265642f76616c75652d777261707065722e706e673f6c6162656c3d7265616479267469746c653d5265616479" alt="Stories in Ready" data-canonical-src="https://badge.waffle.io/WellFactored/value-wrapper.png?label=ready&amp;title=Ready" style="max-width:100%;"></a> <a href="https://www.codacy.com/app/doug/value-wrapper?utm_source=github.com&amp;utm_medium=referral&amp;utm_content=WellFactored/value-wrapper&amp;utm_campaign=Badge_Grade" target="_blank"><img src="https://camo.githubusercontent.com/286c8b196bf187482905d55d7b3c7ebc537153ae/68747470733a2f2f6170692e636f646163792e636f6d2f70726f6a6563742f62616467652f47726164652f6262643833346530323064373465666162656537383664373638633264363039" alt="Codacy Badge" data-canonical-src="https://api.codacy.com/project/badge/Grade/bbd834e020d74efabee786d768c2d609" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/com.wellfactored/value-wrapper_2.11" target="_blank"><img src="https://camo.githubusercontent.com/14e99658d2c727b22fd71cc61df8b71dc98a7cc0/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e77656c6c666163746f7265642f76616c75652d777261707065725f322e31312f62616467652e706e67" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.wellfactored/value-wrapper_2.11/badge.png" style="max-width:100%;"></a></p> 
  <h1><a href="https://github.com/wellfactored/value-wrapper#value-wrapper" aria-hidden="true" class="anchor" id="user-content-value-wrapper" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>value-wrapper</h1> 
  <h2><a href="https://github.com/wellfactored/value-wrapper#a-micro-library-to-provide-a-convenient-way-of-wrapping-and-unwrapping-scala-value-classes" aria-hidden="true" class="anchor" id="user-content-a-micro-library-to-provide-a-convenient-way-of-wrapping-and-unwrapping-scala-value-classes" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>A micro-library to provide a convenient way of wrapping and unwrapping scala value classes</h2> 
  <p>A value class is a case class, of type <code>W</code>, that wraps a single value, of type <code>V</code> and optionally extends <code>AnyVal</code>. Value classes are a really convenient and lightweight way of strongly typing primitive values to avoid passing them to functions incorrectly.</p> 
  <p>For example:</p> 
  <pre><code>case class PersonId(id: Long) extends AnyVal
case class AccountId(id: Long) extends AnyVal

case class Person(id: PersonId, name: String)
case class Account(id: AccountId, name: String)

def getPerson(id: PersonId): Person
def getAccount(id: Account): Account
</code></pre> 
  <p>Although both <code>Person</code>s and <code>Account</code>s are identified by <code>Long</code>s, by wrapping those <code>Long</code> values in different value classes we can be sure that we can't accidentally pass an identifier to a <code>Person</code> to the <code>getAccount</code> function without the compiler telling us we've done the wrong thing.</p> 
  <h2><a href="https://github.com/wellfactored/value-wrapper#value-classes-can-cause-some-unwanted-friction" aria-hidden="true" class="anchor" id="user-content-value-classes-can-cause-some-unwanted-friction" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Value classes can cause some unwanted friction</h2> 
  <p>As useful as value classes are, there are a lot of situations where wrapping and unwrapping the values can cause enough friction in your code that you wonder if they're worth the effort. For example, if you render the <code>Person</code> class defined above to JSON using Play Framework's very handy macro-generated <code>Writes</code> instances you end up with an undesirable extra level of structure in the output, e.g.</p> 
  <pre><code>    {
        "id": {
            "id": 1
        },
        "name": "Fred"
    }
</code></pre> 
  <p>when we'd rather just have</p> 
  <pre><code>    {
        "id": 1,
        "name": "Fred"
    }
</code></pre> 
  <p>To get around this you end up having to write your own <code>Writes</code>, and associated <code>Reads</code> implementation to deal with the extra structure. This quickly adds up to a lot of annoying boilerplate. The purpose of the <code>value-wrapper</code> library is to eliminate that boilerplate. By providing instances of <code>ValueWrapper</code> for a given wrapper and wrapped type we can build generic versions of things like <code>Reads</code> and <code>Writes</code> that work for all value classes.</p> 
  <h2><a href="https://github.com/wellfactored/value-wrapper#going-fully-generic-with-shapeless" aria-hidden="true" class="anchor" id="user-content-going-fully-generic-with-shapeless" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Going fully generic with Shapeless</h2> 
  <p>But building instances of <code>ValueWrapper</code> for our value classes still leaves us with boilerplate like this:</p> 
  <pre><code>implicit val personIdWrapper = new ValueWrapper[PersonId, Long]  {
  def wrap(l: Long) : Either[String, PersonId] = Right(PersonId(l))  // or could do validation here
  def unwrap(p: PersonId): Long = p.id
}
</code></pre> 
  <p>This is less boilerplate than before and the typeclass instance can be used to construct multiple different kinds of other typeclasses, e.g. Play's <code>QueryStringBindable</code>s and <code>PathBindable</code>s, but given that the implementation is pretty much the same for all single-value case classes, wouldn't it be great if we could eliminate it altogether? Turns out we can, with a small dash of Shapeless.</p> 
  <p>The <code>ValueWrapperGen</code> trait provided in this library provides an implicit function that tells the compiler how to generate a <code>ValueWrapper</code> instance for any single-value case class (and, in fact, any class that Shapeless considers to look enough like a single-value case class that it can build an appropriate <code>Generic</code> instance for). Extend <code>ValueWrapperGen</code> or import <code>ValueWrapperGen._</code> to bring that implicit function into scope and any other function you have that defines an implicit parameter of type <code>ValueWrapper[W, V]</code> will get provided with a compiler-generated instance with no additional code!</p> 
  <p>So now you can write something like this:</p> 
  <pre><code>trait ValueClassWrites extends ValueWrapperGen {
  implicit def genericWrites[W, V](implicit vw: ValueWrapper[W, V],
                                   wv: Writes[V]): Writes[W] =
    new Writes[W] {
      override def writes(w: W): JsValue = wv.writes(vw.unwrap(w))
    }
}
</code></pre> 
  <p>and use that implicit function to generate a <code>Writes</code> instance for any value class. In fact, this is exactly what the <a href="https://github.com/WellFactored/play-bindings" target="_blank"><code>play-bindings</code></a> library provides, as well as generic instance constructors for <code>Reads</code>, <code>PathBindable</code> and <code>QueryStringBindable</code>.</p> 
  <h2><a href="https://github.com/wellfactored/value-wrapper#validation-and-normalisation-of-values" aria-hidden="true" class="anchor" id="user-content-validation-and-normalisation-of-values" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Validation and Normalisation of values</h2> 
  <p>Sometimes you want to validate the value before allowing the value class to be created. <code>value-wrapper</code> provides a type class called <code>Validator[W, V]</code> that will let you do this. For example, we might want to ensure that the <code>Long</code> being used to construct a <code>UserId</code> must be non-negative. We could provide an instance of <code>Validator[W, V]</code> that looks like this:</p> 
  <pre><code>implicit val vl = new Validator[UserId, Long] {
  override def validate(l: Long): Either[String, Long] = if (l &gt;= 0) Right(l) else Left(s"Id must be non-negative ($l)")
}
</code></pre> 
  <p>If this validator is in implicit scope at the point where the compiler is instantiating a <code>ValueWrapper</code> for <code>UserId</code> then it will get picked up and used as part of the code that constructs the instance of <code>W</code>.</p> 
  <p>Looking at the declaration of <code>validate</code> there are a couple of things to note:</p> 
  <ul> 
   <li>If validation is successful then it returns a <code>Right[V]</code>, not a <code>Right[W]</code>. The purpose of <code>validate</code> is to validate the value of type <code>V</code> <em>in the context of</em> the type <code>W</code>, not to construct the instance of <code>W</code>. This allows us to define different validations applied to a primitive type, say <code>Long</code> depending on the type it is going to be wrapped in.</li> 
   <li>The value wrapped in the <code>Right[V]</code> is the value that will be used by the binders to construct the instance of <code>W</code>. This gives us the chance to change the value as part of the validation. For example, we might want to normalise strings by stripping whitespace like this:</li> 
  </ul> 
  <pre><code>case class Foo(s:String)

implicit val vl = new Validator[Foo, String] {
  override def validate(s:String): Either[String, String] = Right(s.trim)
}
</code></pre> 
 </article>
</div>