<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a href="https://github.com/njeuk/dbmapper#dbmapper---simple-asynchronous-postgres-db-access-for-scala" aria-hidden="true" class="anchor" id="user-content-dbmapper---simple-asynchronous-postgres-db-access-for-scala" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>dbmapper - simple asynchronous Postgres db access for Scala</h1> 
  <p><a href="https://travis-ci.org/njeuk/dbmapper" target="_blank"><img src="https://camo.githubusercontent.com/8fcfbfdc3da4001297036fb69eefd3ddbea79b7e/68747470733a2f2f7472617669732d63692e6f72672f6e6a65756b2f64626d61707065722e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/njeuk/dbmapper.svg?branch=master" style="max-width:100%;"></a> <a href="https://coveralls.io/r/njeuk/dbmapper?branch=master" target="_blank"><img src="https://camo.githubusercontent.com/863a49daa71c8208895217d127984d6cd0c81267/68747470733a2f2f636f766572616c6c732e696f2f7265706f732f6e6a65756b2f64626d61707065722f62616467652e706e673f6272616e63683d6d6173746572" alt="Coverage Status" data-canonical-src="https://coveralls.io/repos/njeuk/dbmapper/badge.png?branch=master" style="max-width:100%;"></a></p> 
  <h2><a href="https://github.com/njeuk/dbmapper#features" aria-hidden="true" class="anchor" id="user-content-features" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Features</h2> 
  <ul> 
   <li>Wraps <a href="https://github.com/mauricio/postgresql-async" target="_blank">postgresql-async</a> to provide a simple asynchronous access to Postgres</li> 
   <li>SQL Queries with interpolation</li> 
   <li>Macro generated mapping layer from Scala type to Database Table</li> 
   <li>Provides a Table Data Gateway model <a href="http://martinfowler.com/eaaCatalog/tableDataGateway.html" target="_blank">P of EAA</a></li> 
   <li>If you are familiar with <a href="https://github.com/StackExchange/Dapper" target="_blank">Dapper</a> then you will be familiar with dbmapper.</li> 
   <li>Fast</li> 
  </ul> 
  <h2><a href="https://github.com/njeuk/dbmapper#not-features" aria-hidden="true" class="anchor" id="user-content-not-features" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Not Features</h2> 
  <ul> 
   <li>No new Domain Specific Language to access data. You know a pretty good database access DSL, it is called SQL. This is not <a href="https://github.com/slick/slick%5DSlick" target="_blank">Typesafe's Slick</a></li> 
   <li>No ORM. No Hibernate magic.</li> 
  </ul> 
  <h2><a href="https://github.com/njeuk/dbmapper#warnings" aria-hidden="true" class="anchor" id="user-content-warnings" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Warnings</h2> 
  <p>I use this code personally in some rather high transaction websites, it works well for me and I trust it.</p> 
  <p>However, there are advantages in 'going with the crowd', and maybe you should consider using Slick. Slick now supports asynchronous queries, but it is quite an over engineered beast.</p> 
  <h2><a href="https://github.com/njeuk/dbmapper#queries-with-interpolation-for-query-arguments" aria-hidden="true" class="anchor" id="user-content-queries-with-interpolation-for-query-arguments" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Queries with interpolation for query arguments</h2> 
  <div class="highlight highlight-source-scala">
   <pre>  
  <span class="pl-c"><span class="pl-c">//</span> Scala class that maps to the book table, with columns to match the class members</span>
  <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Book</span>(
    <span class="pl-v">bookId</span>: <span class="pl-k">Int</span>,
    <span class="pl-v">title</span>: <span class="pl-k">String</span>,
    <span class="pl-v">retailPrice</span>: <span class="pl-en">BigDecimal</span>,
    <span class="pl-v">publishDate</span>: <span class="pl-en">LocalDate</span>)
    
  <span class="pl-c"><span class="pl-c">//</span> mapping function from table row to Book class, auto generated at compile time by Scala Macro  </span>
  <span class="pl-k">implicit</span> <span class="pl-k">def</span> <span class="pl-en">rowToBook</span><span class="pl-k">:</span> <span class="pl-en">RowData</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Book</span> <span class="pl-k">=</span> (r) <span class="pl-k">=&gt;</span> <span class="pl-en">DbCodeGenerator</span>.rowToClass[<span class="pl-en">Book</span>](r)
  
  <span class="pl-c"><span class="pl-c">//</span> query returning future list of books, safe query interpolation, converting maxPrice to a query argument  </span>
  <span class="pl-k">val</span> <span class="pl-en">maxPrice</span> <span class="pl-k">=</span> <span class="pl-c1">11.99</span>
  <span class="pl-k">val</span> <span class="pl-en">allBooksFuture</span> <span class="pl-k">=</span> <span class="pl-en">DbAsync</span>.exec[<span class="pl-en">Book</span>](q<span class="pl-s"><span class="pl-pds">"</span>select * from book where retail_price &lt; $maxPrice<span class="pl-pds">"</span></span>)        
  
  <span class="pl-k">val</span> <span class="pl-en">oneBook</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Book</span>] <span class="pl-k">=</span> <span class="pl-en">DbAsync</span>.execOne[<span class="pl-en">Book</span>](q<span class="pl-s"><span class="pl-pds">"</span>select * from book where book_id = 2<span class="pl-pds">"</span></span>)
 
  <span class="pl-c"><span class="pl-c">//</span> returns Future[Option[]]     </span>
  <span class="pl-k">val</span> <span class="pl-en">maybeOneBook</span><span class="pl-k">:</span> <span class="pl-en">Future</span>[<span class="pl-en">Option</span>[<span class="pl-en">Book</span>]] <span class="pl-k">=</span> <span class="pl-en">DbAsync</span>.execOneOrNone[<span class="pl-en">Book</span>](q<span class="pl-s"><span class="pl-pds">"</span>select * from book where book_id = -123<span class="pl-pds">"</span></span>)
      </pre>
  </div> 
  <h2><a href="https://github.com/njeuk/dbmapper#crud-via-data-access-object-data-table-gateway" aria-hidden="true" class="anchor" id="user-content-crud-via-data-access-object-data-table-gateway" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>CRUD via Data Access object (Data Table Gateway)</h2> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">SuperHero</span>(
  <span class="pl-v">superHeroId</span>: <span class="pl-k">Int</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>,
  <span class="pl-v">name</span>: <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>,
  <span class="pl-v">wearsTights</span>: <span class="pl-k">Boolean</span> <span class="pl-k">=</span> <span class="pl-c1">false</span>,
  <span class="pl-v">partner</span>: <span class="pl-en">Option</span>[<span class="pl-k">String</span>] <span class="pl-k">=</span> <span class="pl-c1">None</span>
)

<span class="pl-k">class</span> <span class="pl-en">SuperHeroAccess</span> <span class="pl-k">extends</span> <span class="pl-e">TableAccess</span>[<span class="pl-en">SuperHero</span>](
  () <span class="pl-k">=&gt;</span> <span class="pl-en">DbCodeGenerator</span>.codeToSql[<span class="pl-en">SuperHero</span>](),
  (r) <span class="pl-k">=&gt;</span> <span class="pl-en">DbCodeGenerator</span>.rowToClass[<span class="pl-en">SuperHero</span>](r),
  (u) <span class="pl-k">=&gt;</span> <span class="pl-en">DbCodeGenerator</span>.updateSql[<span class="pl-en">SuperHero</span>](u),
  (i) <span class="pl-k">=&gt;</span> <span class="pl-en">DbCodeGenerator</span>.insertSql[<span class="pl-en">SuperHero</span>](i),
  (i) <span class="pl-k">=&gt;</span> <span class="pl-en">DbCodeGenerator</span>.identityInsertSql[<span class="pl-en">SuperHero</span>](i),
  (t, i) <span class="pl-k">=&gt;</span> t.copy(superHeroId <span class="pl-k">=</span> i)) {}

<span class="pl-c"><span class="pl-c">//</span> get SuperHero with id 2, all results are Future[] </span>
<span class="pl-k">val</span> <span class="pl-en">hero</span> <span class="pl-k">=</span> superHeroAccess.get(<span class="pl-c1">2</span>)

<span class="pl-c"><span class="pl-c">//</span> update Batman</span>
<span class="pl-k">val</span> <span class="pl-en">batman</span> <span class="pl-k">=</span> await( superHeroAccess.load(<span class="pl-c1">1</span>) )
superHeroAccess.update(batman.copy(partner <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>Robin<span class="pl-pds">"</span></span>)))

<span class="pl-c"><span class="pl-c">//</span> insert Catwoman</span>
<span class="pl-k">val</span> <span class="pl-en">catwoman</span> <span class="pl-k">=</span> <span class="pl-en">SuperHero</span>(<span class="pl-c1">0</span>, <span class="pl-s"><span class="pl-pds">"</span>Catwoman<span class="pl-pds">"</span></span>)
superHeroAccess.insert(catwoman)

<span class="pl-c"><span class="pl-c">//</span> delete Batman</span>
superHeroAccess.delete(<span class="pl-c1">1</span>)
</pre>
  </div> 
  <h2><a href="https://github.com/njeuk/dbmapper#full-code-samples" aria-hidden="true" class="anchor" id="user-content-full-code-samples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Full Code Samples</h2> 
  <p><a href="https://github.com/njeuk/dbmapper/tree/master/src/test/scala/com/github/njeuk/dbmapper/examples" target="_blank">Executable Code Samples</a></p> 
  <p>The default connection string is for the samples is:</p> 
  <p><code>jdbc:postgresql://localhost/dbmappersamples?user=postgres&amp;password=secret</code></p> 
  <p>Either change the connection string for your environment, or create a database named <em>dbmappersamples</em>, accessible by the postgres user with that password.</p> 
  <h2><a href="https://github.com/njeuk/dbmapper#full-scaladocs" aria-hidden="true" class="anchor" id="user-content-full-scaladocs" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Full ScalaDocs</h2> 
  <p><a href="https://njeuk.github.io/dbmapper/latest/api" target="_blank">ScalaDocs</a> on GitHub</p> 
  <p><a href="https://njeuk.github.io/dbmapper/latest/api/#com.github.njeuk.dbmapper.DbAsync$" target="_blank">Best Starting Point</a> in the docs</p> 
  <h2><a href="https://github.com/njeuk/dbmapper#dependencies" aria-hidden="true" class="anchor" id="user-content-dependencies" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dependencies</h2> 
  <p>The artifacts are hosted in JCenter on Bintray.</p> 
  <p>If you are using SBT &gt;= 0.13.5 then the Bintray resolver is already known, just add the following to your libDependencies in build.sbt:</p> 
  <pre><code>"com.github.njeuk" %% "dbmapper" % "3.3"
</code></pre> 
  <p>and a resolver to the JCenter Bintray Repository</p> 
  <pre><code>resolvers += Resolver.jcenterRepo
</code></pre> 
  <p>If you are using SBT &lt; 0.13.5, then you need to add a resolver for BinTray, see here: <a href="https://github.com/softprops/bintray-sbt" target="_blank">https://github.com/softprops/bintray-sbt</a></p> 
  <h2><a href="https://github.com/njeuk/dbmapper#quick-start" aria-hidden="true" class="anchor" id="user-content-quick-start" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick start</h2> 
  <ol> 
   <li>Place the dependency in you libDependencies of build.sbt</li> 
  </ol> 
  <pre><code>    libraryDependencies ++= Seq(
      ...
      "org.scalatestplus.play" % "scalatestplus-play_2.12" % "3.1.1" % "test",      
      "com.github.njeuk" %% "dbmapper" % "3.3"      
    )
</code></pre> 
  <p>1a. Depending on your SBT version, you will need to add a resolver to BinTray, most likely you need to add:</p> 
  <pre><code>resolvers += Resolver.jcenterRepo
</code></pre> 
  <ol start="2"> 
   <li>Create a Case Class to represent the table in the database. For example, assume there is a table called books:</li> 
  </ol> 
  <div class="highlight highlight-source-sql">
   <pre>  <span class="pl-k">create</span> <span class="pl-k">table</span> <span class="pl-en">book</span>(
    book_id <span class="pl-k">serial</span>, 
    title <span class="pl-k">text</span> <span class="pl-k">not null</span>, 
    retail_price <span class="pl-k">numeric</span>(<span class="pl-c1">10</span>,<span class="pl-c1">2</span>) <span class="pl-k">not null</span>, 
    publish_date <span class="pl-k">date</span> <span class="pl-k">not null</span>)</pre>
  </div> 
  <p>The corresponding Case Class would look like:</p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Book</span>(
   <span class="pl-v">bookId</span>: <span class="pl-k">Int</span>,
   <span class="pl-v">title</span>: <span class="pl-k">String</span>,
   <span class="pl-v">retailPrice</span>: <span class="pl-en">BigDecimal</span>,
   <span class="pl-v">publishDate</span>: <span class="pl-en">LocalDate</span>)</pre>
  </div> 
  <p>What happens if you don't like the name mapping conventions between from Scala and the DB?</p> 
  <p>You can override them with @attributes, see <a href="https://github.com/njeuk/dbmapper/blob/master/src/test/scala/com/github/njeuk/dbmapper/examples/CrudSqlWithCustomNameMapping.scala" target="_blank">this sample</a></p> 
  <ol start="3"> 
   <li>Ensure that the implicit object DbAsyncConfig is in scope.</li> 
  </ol> 
  <p>You can setup the config explicitly like this:</p> 
  <p><code>implicit val dbAsyncConfig = DbAsyncConfig(URLParser.parse("jdbc:postgresql://localhost/dbmappersamples?user=postgres&amp;password=secret"), Duration("500 ms"))</code></p> 
  <p>Or more simply just import:</p> 
  <p><code>import com.github.njeuk.dbmapper.Implicits._</code></p> 
  <p>which will create a config that pulls <a href="https://www.playframework.com/documentation/2.3.x/SettingsJDBC" target="_blank">PlayFramework style database settings</a> from your application.conf details. We only look at username/password/url.</p> 
  <ol start="4"> 
   <li>Ensure there is an implicit function in scope to map a the database rowData to the Scala object.</li> 
  </ol> 
  <p><code>implicit def rowToBook: RowData =&gt; Book = (r) =&gt; DbCodeGenerator.rowToClass[Book](r)</code></p> 
  <p>This one will generate the code based on the names in the Book class.</p> 
  <ol start="5"> 
   <li>Write your queries:</li> 
  </ol> 
  <pre><code>async {
  val allBooks = await( DbAsync.exec[Book]("select * from book") )
  val titles = allBooks.map(b =&gt; b.title)
  println(s"Title where $titles")
}
</code></pre> 
  <h2><a href="https://github.com/njeuk/dbmapper#how-to-use" aria-hidden="true" class="anchor" id="user-content-how-to-use" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How to use</h2> 
  <h3><a href="https://github.com/njeuk/dbmapper#async-code" aria-hidden="true" class="anchor" id="user-content-async-code" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Async code</h3> 
  <p>dbmapper is asynchronous. We have used this codebase to implement completely asynchronous PlayFramework websites. We find using the Scala Async/Await mechanism the most straight forward to deal with Future results.</p> 
  <p>For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">scala.async.Async.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">scala.concurrent.ExecutionContext.Implicits.</span><span class="pl-v">global</span>
<span class="pl-k">import</span> <span class="pl-v">com.github.njeuk.dbmapper.Implicits.</span><span class="pl-v">_</span>

...

async {
  <span class="pl-k">val</span> <span class="pl-en">batmanFuture</span> <span class="pl-k">=</span> superHeroAccess.load(<span class="pl-c1">1</span>)
  
  <span class="pl-k">val</span> <span class="pl-en">batman</span> <span class="pl-k">=</span> await(batmanFuture)
  <span class="pl-c"><span class="pl-c">//</span> code here continues after batmanFuture succeeds</span>
    
  <span class="pl-c"><span class="pl-c">//</span> now we have found batman, update his partner</span>
  await(superHeroAccess.update(batman.copy(partner <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>Robin<span class="pl-pds">"</span></span>))))
  
  <span class="pl-c"><span class="pl-c">//</span> load updated Batman,  note await in the line above stalls this code until the update has completed </span>
  <span class="pl-k">val</span> <span class="pl-en">batmanWithRobin</span> <span class="pl-k">=</span> superHeroAccess.load(<span class="pl-c1">1</span>)
  batmanWithRobin.partner should be (<span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>Robin<span class="pl-pds">"</span></span>))
}

...
</pre>
  </div> 
  <h3><a href="https://github.com/njeuk/dbmapper#name-mapping-conventions--db-schema-assumptions" aria-hidden="true" class="anchor" id="user-content-name-mapping-conventions--db-schema-assumptions" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Name mapping conventions / db schema assumptions</h3> 
  <p>dbmapper needs to map from the scala identifier to the database identifier. To do this it makes certain assumptions about the identifier names. These assumptions can be changed via attributes in your code, see the example <a href="https://github.com/njeuk/dbmapper/blob/master/src/test/scala/com/github/njeuk/dbmapper/examples/CrudSqlWithCustomNameMapping.scala" target="_blank">CrudSqlWithCustomNameMapping</a></p> 
  <p>The default assumptions are:</p> 
  <p>Scala identifiers are in <a href="http://en.wikipedia.org/wiki/CamelCase" target="_blank">camelCase</a> or PascalCase, these are represented in the database by identifiers in lowercase <a href="http://en.wikipedia.org/wiki/Snake_case" target="_blank">snake_case</a>.</p> 
  <p>The table name is not pluralised, but is a straight conversion from the class name.</p> 
  <p>Each table has an Integer <a href="http://en.wikipedia.org/wiki/Surrogate_key" target="_blank">surrogate key</a>.<br> The surrogate key is named &lt;class&gt;Id (e.g. bookId) in Scala and &lt;table&gt;_id (e.g. book_id) in the database.</p> 
  <p>If a variable is defined as an Option[] then dbmapper will convert null column values to None. Otherwise null column values will cause an exception.</p> 
  <p>See <a href="https://github.com/njeuk/dbmapper-macros/blob/master/src/main/scala/com/github/njeuk/dbmapper/macros/ScalaToSqlNameConversion.scala" target="_blank">ScalaToSqlNameConversion</a></p> 
  <h3><a href="https://github.com/njeuk/dbmapper#db-connections" aria-hidden="true" class="anchor" id="user-content-db-connections" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>DB Connections</h3> 
  <p>dbmapper needs to pass the data base connection information on to postgresql-async to access the database.</p> 
  <p>All the of the public dbmapper functions take an implicit arguments of type DbAsyncConfig.<br> This contains the connection information and details about what logging is wanted.</p> 
  <p>So prior to calling into dbmapper there needs to be a DbAsyncConfig in scope.</p> 
  <p>You have a number of ways to do this.</p> 
  <p>The easiest method is to: <code>import com.github.njeuk.dbmapper.Implicits._</code></p> 
  <p>This uses a DbAsyncConfig which gets the connection information from config file settings / jvm properties using <a href="https://github.com/typesafehub/config" target="_blank">com.typesafe.config</a>. DbAsyncConfig expects PlayFramework style db configurations. Read their documents for the details of locations looked, some like this in application.conf works:</p> 
  <pre><code>db.default.url="jdbc:postgresql://some-domain-name-here/some-db-name-here"
db.default.user=your-db-user-here
db.default.password=your-password-here
</code></pre> 
  <p>You can also construct a DbAsyncConfig directly:</p> 
  <p><code>implicit val dbAsyncConfig = DbAsyncConfig(URLParser.parse("jdbc:postgresql://localhost/dbmappersamples?user=postgres&amp;password=secret"), Duration("500 ms"))</code></p> 
  <h3><a href="https://github.com/njeuk/dbmapper#code-generators" aria-hidden="true" class="anchor" id="user-content-code-generators" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Code Generators</h3> 
  <p>dbmapper uses Scala Macros to build code to map between the database row data and the scala class.</p> 
  <p>The Macros run at compile time, of course, and exist in the project <a href="https://github.com/njeuk/dbmapper-macros" target="_blank">dbmapper-macros</a>. The project is split to help with testing of dbmapper. The macros project is a dbmapper dependency, and thus automatically obtained from JCenter, you don't need to be aware of it.</p> 
  <p>If you have specific requirements, you could handcraft the code the macros generate.</p> 
  <p>See <a href="https://github.com/njeuk/dbmapper-macros/blob/master/src/main/scala/com/github/njeuk/dbmapper/macros/DbCodeGenerator.scala#L164" target="_blank">DbCodeGenerator</a></p> 
  <h3><a href="https://github.com/njeuk/dbmapper#query-interpolation" aria-hidden="true" class="anchor" id="user-content-query-interpolation" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Query interpolation</h3> 
  <p>To make SQL queries simpler dbmapper provide query interpolation.</p> 
  <p>This is like string interpolation, but the embed variable references are converted to argument for the database call.</p> 
  <p>This provides a clean coding experience which is also protected from SQL Injection. The string is prefixed with a 'q' to signal Query Interpolation.</p> 
  <p>For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">name</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Bruce<span class="pl-pds">"</span></span>
<span class="pl-k">val</span> <span class="pl-en">bruce</span> <span class="pl-k">=</span> <span class="pl-en">DbAsync</span>.exec[<span class="pl-en">Person</span>](q<span class="pl-s"><span class="pl-pds">"</span>select * from person where name = $name<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <p>Lists and direct string interpolation are also supported, see the <a href="http://njeuk.github.io/dbmapper/latest/api/#com.github.njeuk.dbmapper.SqlInterpolation$" target="_blank">scaladocs</a> for more examples.</p> 
  <h3><a href="https://github.com/njeuk/dbmapper#data-access-objects--table-data-gateway" aria-hidden="true" class="anchor" id="user-content-data-access-objects--table-data-gateway" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Data access objects / Table Data Gateway</h3> 
  <p>Using the Macro generated code and the table mappings, you can easily build a Data Access object. The full example of this is shown in <a href="https://github.com/njeuk/dbmapper/blob/master/src/test/scala/com/github/njeuk/dbmapper/examples/CrudSql.scala" target="_blank">CrudSql.scala</a></p> 
  <h3><a href="https://github.com/njeuk/dbmapper#logging" aria-hidden="true" class="anchor" id="user-content-logging" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Logging</h3> 
  <p>By default, dbmapper will log any query that takes longer than 500ms. This is controlled via a setting in DbAsyncConfig. Setting this to zero will cause dbmapper to log all SQL that it executes with the execution lapsed time.</p> 
  <h3><a href="https://github.com/njeuk/dbmapper#errors-you-might-get" aria-hidden="true" class="anchor" id="user-content-errors-you-might-get" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Errors you might get</h3> 
  <p>A common compile error with dbmapper is:</p> 
  <p><code>not found: type CodeToSql () =&gt; DbCodeGenerator.codeToSql[T]()</code></p> 
  <p>you need: <code>import com.github.njeuk.dbmapper.macros.CodeToSql</code></p> 
  <h2><a href="https://github.com/njeuk/dbmapper#problems" aria-hidden="true" class="anchor" id="user-content-problems" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Problems</h2> 
  <p><strong>strange compile error</strong></p> 
  <p>Seeing the following compile error:</p> 
  <p><code>value get is not a member of com.github.mauricio.async.db.RowData [error] implicit def rowToBook: RowData =&gt; Contact = (r) =&gt; DbCodeGenerator.rowToClass[Contact](r)</code></p> 
  <p>You need to import</p> 
  <p><code>import com.github.njeuk.dbmapper.RowDataExtension._</code></p> 
  <p>The macro generates code that relies on that import, unfortunately the intellij IDE doesn't know about the macro generated code and will constantly try and 'tidy up' your imports and remove that import!</p> 
  <p>We could change the macro to generate code that doesn't depend on the RowDataExtension in the future, avoiding the import.</p> 
  <p><strong>5 second delay on first connect when using OSX</strong></p> 
  <p>There is an issue with the interplay between the Java DNS resolver and the Mac, see <a href="https://github.com/mauricio/postgresql-async/issues/222" target="_blank">https://github.com/mauricio/postgresql-async/issues/222</a> for the resolution.</p> 
  <h2><a href="https://github.com/njeuk/dbmapper#limitations" aria-hidden="true" class="anchor" id="user-content-limitations" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Limitations</h2> 
  <h3><a href="https://github.com/njeuk/dbmapper#postgresql-only" aria-hidden="true" class="anchor" id="user-content-postgresql-only" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Postgresql only.</h3> 
  <p>Extending to MySql would be simple, but not implemented because I have no need for it. (You should probably think very carefully about implementing a new project in MySql anyway ;-) )</p> 
  <p>Sql Server and Oracle would be a lot harder, you need a replacement for <a href="https://github.com/mauricio/postgresql-async" target="_blank">postgresql-async</a>, not impossible, just not a straightforward job to do.</p> 
  <h3><a href="https://github.com/njeuk/dbmapper#hard-coded-identifier-mappings" aria-hidden="true" class="anchor" id="user-content-hard-coded-identifier-mappings" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Hard coded identifier mappings.</h3> 
  <p>The code generation assumes that you use camelCase in Code and snake_case in the database. It also assumes that table names are not pluralized unlike Rails ActiveRecord.</p> 
  <p>You can override theses assumptions on a case by case basis using @attributes. But if you do this a lot your code is going to look pretty horrendous.<br> Maybe we could pass the algorithm in to the code generators and evaluate them using <a href="https://github.com/twitter/util/blob/master/util-eval/src/main/scala/com/twitter/util/Eval.scala" target="_blank">Twitters Eval</a>. Not sure how bad this will impact compile speeds.</p> 
  <h3><a href="https://github.com/njeuk/dbmapper#only-built-for-scala-212-and-above" aria-hidden="true" class="anchor" id="user-content-only-built-for-scala-212-and-above" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Only built for Scala 2.12 and above</h3> 
  <p>Haven't built or tested for other older Scala versions. It probably will work, but no idea, I don't use those version any more.</p> 
  <h2><a href="https://github.com/njeuk/dbmapper#changes" aria-hidden="true" class="anchor" id="user-content-changes" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changes</h2> 
  <p>As of version 3.3 we only compile for Scala 2.12.</p> 
  <p>Joda dates are no longer used, the standard Java date handling is better.</p> 
  <h2><a href="https://github.com/njeuk/dbmapper#license" aria-hidden="true" class="anchor" id="user-content-license" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>License</h2> 
  <p>This project is freely available under the Apache 2 licence, have fun....</p> 
 </article>
</div>