{
  "data":{
    "repository":{
      "issues":{
        "nodes":[
          {
            "number":618,
            "title":"Space removed after annotation - Want to keep it",
            "bodyText":"When using Play DI Guice, I would like to keep the space after the @Inject annotation\nVersion: scalafmt 0.5.0-RC2\nIntegration: cli\nConfiguration: style=defaultWithAlign\nclass Foo @Inject() (conf: Configuration)\nScalafmt:\nclass Foo @Inject()(conf: Configuration)\nI would like the input to look like this:\nclass Foo @Inject() (conf: Configuration)\nI think I can help with a PR if you could point me in the right direction/where to start.\nAnd thank you for this amazing project 🍻 , I've been using it for a few weeks now, it has been really useful since I moved from IntelliJ to Emacs",
            "url":"https://github.com/scalameta/scalafmt/issues/618"
          },
          {
            "number":664,
            "title":"Locally add align.tokens",
            "bodyText":"This template is a guideline, not a strict requirement.\n\nVersion: 0.5\nIntegration: IntelliJ\nConfiguration: defaultWithAlign\n\nmaxColumn = 100\n\nOriginal\nval l = List(\n  (1, \"a\", 1.0),\n  (123, \"abc\", 123.123),\n  (12, \"ab\", 12.12)\n)\nAdd a special comment to locally add/modify align.tokens list.\nExpected\nval l = List( // format.align.tokens.add: \",\"\n  (1,   \"a\",   1.0),\n  (123, \"abc\", 123.123),\n  (12,  \"ab\",  12.12)\n)",
            "url":"https://github.com/scalameta/scalafmt/issues/664"
          },
          {
            "number":670,
            "title":"unstage files should be formatted",
            "bodyText":"This template is a guideline, not a strict requirement.\n\nVersion: 0.5\nIntegration: cli\nConfiguration:\n\nstyle = defaultWithAlign\ndocstrings = JavaDoc\nassumeStandardLibraryStripMargin = true\nproject.excludeFilters = [\n  scalalib/\n]\nproject.git = true",
            "url":"https://github.com/scalameta/scalafmt/issues/670"
          },
          {
            "number":717,
            "title":"Feature request: PreferBlockApplication",
            "bodyText":"-    phases.foreach(phase => {\n+    phases.foreach { phase =>\n      g.phase = phase\n      g.globalPhase = phase\n-    })\n+    }",
            "url":"https://github.com/scalameta/scalafmt/issues/717"
          },
          {
            "number":895,
            "title":"Unexpected indent for single select + match",
            "bodyText":"is scalafmt\n\n\nis expected\n\n    new ClassloadObject(this.getClass.getClassLoader)\n      .createInstanceFor(fqn) match {\n-        case Success(e) => Configured.Ok(e)\n-        case Failure(e) => Configured.NotOk(ConfError.msg(e.getMessage))\n-      }\n+          case Success(e) => Configured.Ok(e)\n+          case Failure(e) => Configured.NotOk(ConfError.msg(e.getMessage))\n+        }",
            "url":"https://github.com/scalameta/scalafmt/issues/895"
          },
          {
            "number":912,
            "title":"Print unified diff on --test failure",
            "bodyText":"./scalafmt --test --diff                                                                                      1   master\nException in thread \"main\" org.scalafmt.Error$MisformattedFile: /Users/ollie/dev/scalafix/build.sbt is mis-formatted. To fix this, run `./scalafmt` from the project base directory\n\tat org.scalafmt.cli.InputMethod$FileContents.write(InputMethod.scala:47)\n\tat org.scalafmt.cli.Cli$.org$scalafmt$cli$Cli$$handleFile(Cli.scala:144)\n\tat org.scalafmt.cli.Cli$$anonfun$runFormat$1.apply(Cli.scala:217)\n\tat org.scalafmt.cli.Cli$$anonfun$runFormat$1.apply(Cli.scala:215)\n\tat scala.collection.Iterator$class.foreach(Iterator.scala:893)\n\tat scala.collection.AbstractIterator.foreach(Iterator.scala:1336)\n\tat scala.collection.parallel.ParIterableLike$Foreach.leaf(ParIterableLike.scala:972)\n\tat scala.collection.parallel.Task$$anonfun$tryLeaf$1.apply$mcV$sp(Tasks.scala:49)\n\tat scala.collection.parallel.Task$$anonfun$tryLeaf$1.apply(Tasks.scala:48)\n\tat scala.collection.parallel.Task$$anonfun$tryLeaf$1.apply(Tasks.scala:48)\n\tat scala.collection.parallel.Task$class.tryLeaf(Tasks.scala:51)\n\tat scala.collection.parallel.ParIterableLike$Foreach.tryLeaf(ParIterableLike.scala:969)\n\tat scala.collection.parallel.AdaptiveWorkStealingTasks$WrappedTask$class.compute(Tasks.scala:152)\n\tat scala.collection.parallel.AdaptiveWorkStealingForkJoinTasks$WrappedTask.compute(Tasks.scala:443)\n\tat scala.concurrent.forkjoin.RecursiveAction.exec(RecursiveAction.java:160)\n\tat scala.concurrent.forkjoin.ForkJoinTask.doExec(ForkJoinTask.java:260)\n\tat scala.concurrent.forkjoin.ForkJoinPool$WorkQueue.runTask(ForkJoinPool.java:1339)\n\tat scala.concurrent.forkjoin.ForkJoinPool.runWorker(ForkJoinPool.java:1979)\n\tat scala.concurrent.forkjoin.ForkJoinWorkerThread.run(ForkJoinWorkerThread.java:107)\n\nit would be nice if that error showed the actual diff instead of stack trace.\nIf someone wants to take a swing at this, a good place would be to see how unified diffs are created in the test suite here \n  \n    \n      scalafmt/scalafmt-tests/src/test/scala/org/scalafmt/util/DiffAssertions.scala\n    \n    \n         Line 56\n      in\n      908ca61\n    \n    \n    \n    \n\n        \n          \n           def compareContents(original: Seq[String], revised: Seq[String]): String = { \n        \n    \n  \n\n using Google's javadiff library. We could depend on that library in scalafmt-cli.\nA good place to test this would be in CliTest using the same infrastructure as these tests \n  \n    \n      scalafmt/scalafmt-tests/src/test/scala/org/scalafmt/cli/CliTest.scala\n    \n    \n         Line 333\n      in\n      908ca61\n    \n    \n    \n    \n\n        \n          \n           test(\"--config accepts absolute paths\") {",
            "url":"https://github.com/scalameta/scalafmt/issues/912"
          },
          {
            "number":915,
            "title":"Space on both sides of operator method definition",
            "bodyText":"Feature request: an option to surround symbolic method names with exactly one space on both sides.\n\nVersion: 0.6.8\nIntegration: sbt\nConfiguration: default\n\nProblem\nScalafmt formats code like this:\ntrait Test[A] {\n  def <=>[B](that: Test[B]): Int\n}\nExpectation\nI would like the formatted output to look like this:\ntrait Test[A] {\n  def <=> [B](that: Test[B]): Int\n}\nNote the space immediately after the <=> method name. It mirrors how it would typically appear at callsites: x <=> y. (Obviously the <=> operator is just an example.)",
            "url":"https://github.com/scalameta/scalafmt/issues/915"
          },
          {
            "number":1029,
            "title":"Refactor GitOps",
            "bodyText":"Fetching of files is a bit ad-hock at the moment (using boolean variables to call either some in-line file-fetching function or GitOpsImpl). We should have a single FileFetcher trait that has two implementations: one that uses git and the other that uses plain, recursive file searching.\nAdditionally, GitOpsImpl currently uses sys.process, which is being removed. It should be replaced.",
            "url":"https://github.com/scalameta/scalafmt/issues/1029"
          }
        ]
      }
    }
  }
}