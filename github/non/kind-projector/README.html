<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-kind-projector" class="anchor" href="https://github.com/non/kind-projector#kind-projector" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Kind Projector</h2> 
  <h3><a id="user-content-dedication" class="anchor" href="https://github.com/non/kind-projector#dedication" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dedication</h3> 
  <blockquote> 
   <p>"But I don't want to go among mad people," Alice remarked.</p> 
   <p>"Oh, you can't help that," said the Cat: "we're all mad here. I'm mad. You're mad."</p> 
   <p>"How do you know I'm mad?" said Alice.</p> 
   <p>"You must be," said the Cat, "or you wouldn't have come here."</p> 
   <p>--Lewis Carroll, "Alice's Adventures in Wonderland"</p> 
  </blockquote> 
  <h3><a id="user-content-overview" class="anchor" href="https://github.com/non/kind-projector#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h3> 
  <p>One piece of Scala syntactic noise that often trips people up is the use of type projections to implement anonymous, partially-applied types. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> partially-applied type named "IntOrA"</span>
<span class="pl-k">type</span> <span class="pl-en">IntOrA</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">Either</span>[<span class="pl-k">Int</span>, <span class="pl-en">A</span>]

<span class="pl-c"><span class="pl-c">//</span> type projection implementing the same type anonymously (without a name).</span>
({<span class="pl-k">type</span> <span class="pl-en">L</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">Either</span>[<span class="pl-k">Int</span>, <span class="pl-en">A</span>]})#<span class="pl-en">L</span></pre>
  </div> 
  <p>Many people have wished for a better way to do this.</p> 
  <p>The goal of this plugin is to add a syntax for type lambdas. We do this by rewriting syntactically valid programs into new programs, letting us seem to add new keywords to the language. This is achieved through a compiler plugin performing an (un-typed) tree transformation.</p> 
  <p>One problem with this approach is that it changes the meaning of (potentially) valid programs. In practice this means that you must avoid defining the following identifiers:</p> 
  <ol> 
   <li><code>Lambda</code> and <code>λ</code></li> 
   <li><code>?</code>, <code>+?</code>, and <code>-?</code></li> 
   <li><code>Λ$</code></li> 
   <li><code>α$</code>, <code>β$</code>, ...</li> 
  </ol> 
  <p>If you find yourself using lots of type lambdas, and you don't mind reserving those identifiers, then this compiler plugin is for you!</p> 
  <h3><a id="user-content-using-the-plugin" class="anchor" href="https://github.com/non/kind-projector#using-the-plugin" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Using the plugin</h3> 
  <p>Kind-projector supports Scala 2.10, 2.11, 2.12, and 2.13.0-M1.</p> 
  <p>To use this plugin in your own projects, add the following lines to your <code>build.sbt</code> file:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-en">Resolver</span>.sonatypeRepo(<span class="pl-s"><span class="pl-pds">"</span>releases<span class="pl-pds">"</span></span>)

addCompilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>kind-projector<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.9.4<span class="pl-pds">"</span></span>)

<span class="pl-c"><span class="pl-c">//</span> if your project uses multiple Scala versions, use this for cross building</span>
addCompilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>kind-projector<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.9.4<span class="pl-pds">"</span></span> cross <span class="pl-en">CrossVersion</span>.binary)

<span class="pl-c"><span class="pl-c">//</span> if your project uses both 2.10 and polymorphic lambdas</span>
libraryDependencies <span class="pl-k">++</span><span class="pl-k">=</span> (scalaBinaryVersion.value <span class="pl-k">match</span> {
  <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">"</span>2.10<span class="pl-pds">"</span></span> <span class="pl-k">=&gt;</span>
    compilerPlugin(<span class="pl-s"><span class="pl-pds">"</span>org.scalamacros<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>paradise<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.1.0<span class="pl-pds">"</span></span> cross <span class="pl-en">CrossVersion</span>.full) <span class="pl-k">::</span> <span class="pl-c1">Nil</span>
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span>
    <span class="pl-c1">Nil</span>
})</pre>
  </div> 
  <p>For maven projects, add the plugin to the configuration of the maven-scala-plugin (remember to use <code>_2.10</code>, <code>_2.11</code> or <code>_2.12</code> as appropriate):</p> 
  <pre><code>&lt;plugin&gt;
  &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;
  &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;
  ...
  &lt;configuration&gt;
    &lt;compilerPlugins&gt;
      &lt;compilerPlugin&gt;
        &lt;groupId&gt;org.spire-math&lt;/groupId&gt;
        &lt;artifactId&gt;kind-projector_2.11&lt;/artifactId&gt;
        &lt;version&gt;0.9.4&lt;/version&gt;
      &lt;/compilerPlugin&gt;
    &lt;/compilerPlugins&gt;
  &lt;/configuration&gt;
&lt;/plugin&gt;
</code></pre> 
  <p>That's it!</p> 
  <p>Versions of the plugin earlier than 0.6.2 require a different resolver. For these earlier releases, use this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>bintray/non<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>http://dl.bintray.com/non/maven<span class="pl-pds">"</span></span></pre>
  </div> 
  <h3><a id="user-content-inline-syntax" class="anchor" href="https://github.com/non/kind-projector#inline-syntax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Inline Syntax</h3> 
  <p>The simplest syntax to use is the inline syntax. This syntax resembles Scala's use of underscores to define anonymous functions like <code>_ + _</code>.</p> 
  <p>Since underscore is used for existential types in Scala (and it is probably too late to change this syntax), we use <code>?</code> for the same purpose. We also use <code>+?</code> and <code>-?</code> to handle covariant and contravariant types parameters.</p> 
  <p>Here are a few examples:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Tuple2</span>[<span class="pl-k">?</span>, <span class="pl-k">Double</span>]        <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[A] = Tuple2[A, Double]</span>
<span class="pl-en">Either</span>[<span class="pl-k">Int</span>, <span class="pl-k">+</span><span class="pl-k">?</span>]          <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[+A] = Either[Int, A]</span>
<span class="pl-en">Function2</span>[<span class="pl-k">-</span><span class="pl-k">?</span>, <span class="pl-k">Long</span>, <span class="pl-k">+</span><span class="pl-k">?</span>]  <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[-A, +B] = Function2[A, Long, B]</span>
<span class="pl-en">EitherT</span>[<span class="pl-k">?</span>[_], <span class="pl-k">Int</span>, <span class="pl-k">?</span>]    <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[F[_], B] = EitherT[F, Int, B]</span></pre>
  </div> 
  <p>As you can see, this syntax works when each type parameter in the type lambda is only used in the body once, and in the same order. For more complex type lambda expressions, you will need to use the function syntax.</p> 
  <h3><a id="user-content-function-syntax" class="anchor" href="https://github.com/non/kind-projector#function-syntax" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Function Syntax</h3> 
  <p>The more powerful syntax to use is the function syntax. This syntax resembles anonymous functions like <code>x =&gt; x + 1</code> or <code>(x, y) =&gt; x + y</code>. In the case of type lambdas, we wrap the entire function type in a <code>Lambda</code> or <code>λ</code> type. Both names are equivalent: the former may be easier to type or say, and the latter is less verbose.</p> 
  <p>Here are some examples:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Lambda</span>[<span class="pl-en">A</span> <span class="pl-k">=&gt;</span> (<span class="pl-en">A</span>, <span class="pl-en">A</span>)]              <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[A] = (A, A)</span>
<span class="pl-en">Lambda</span>[(<span class="pl-en">A</span>, <span class="pl-en">B</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">Either</span>[<span class="pl-en">B</span>, <span class="pl-en">A</span>]]   <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[A, B] = Either[B, A]</span>
<span class="pl-en">Lambda</span>[<span class="pl-en">A</span> <span class="pl-k">=&gt;</span> <span class="pl-en">Either</span>[<span class="pl-en">A</span>, <span class="pl-en">List</span>[<span class="pl-en">A</span>]]]  <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[A] = Either[A, List[A]]</span></pre>
  </div> 
  <p>Since types like <code>(+A, +B) =&gt; Either[A, B]</code> are not syntactically valid, we provide two alternate methods to specify variance when using function syntax:</p> 
  <ul> 
   <li>Plus/minus: <code>(+[A], +[B]) =&gt; Either[A, B]</code></li> 
   <li>Backticks: <code>(`+A`, `+B`) =&gt; Either[A, B]</code></li> 
  </ul> 
  <p>(Note that unlike names like <code>?</code>, <code>+</code> and <code>-</code> do not have to be reserved. They will only be interpreted this way when used in parameters to <code>Lambda[...]</code> types, which should never conflict with other usage.)</p> 
  <p>Here are some examples with variance:</p> 
  <div class="highlight highlight-source-scala">
   <pre>λ[`<span class="pl-k">-</span><span class="pl-en">A</span>` <span class="pl-k">=&gt;</span> <span class="pl-en">Function1</span>[<span class="pl-en">A</span>, <span class="pl-k">Double</span>]]          <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[-A] = Function1[A, Double]</span>
λ[(<span class="pl-k">-</span>[<span class="pl-en">A</span>], <span class="pl-k">+</span>[<span class="pl-en">B</span>]) <span class="pl-k">=&gt;</span> <span class="pl-en">Function2</span>[<span class="pl-en">A</span>, <span class="pl-k">Int</span>, <span class="pl-en">B</span>]]  <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[-A, +B] = Function2[A, Int, B]</span>
λ[`<span class="pl-k">+</span><span class="pl-en">A</span>` <span class="pl-k">=&gt;</span> <span class="pl-en">Either</span>[<span class="pl-en">List</span>[<span class="pl-en">A</span>], <span class="pl-en">List</span>[<span class="pl-en">A</span>]]]      <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[+A] = Either[List[A], List[A]]</span></pre>
  </div> 
  <p>The function syntax also supports higher-kinded types as type parameters. The syntax overloads the existential syntax in this case (since the type parameters to a type lambda should never contain an existential).</p> 
  <p>Here are a few examples with higher-kinded types:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Lambda</span>[<span class="pl-en">A</span>[_] <span class="pl-k">=&gt;</span> <span class="pl-en">List</span>[<span class="pl-en">A</span>[<span class="pl-k">Int</span>]]]  <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[A[_]] = List[A[Int]]</span>
<span class="pl-en">Lambda</span>[(<span class="pl-en">A</span>, <span class="pl-en">B</span>[_]) <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>[<span class="pl-en">A</span>]]     <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[A, B[_]] = B[A]</span></pre>
  </div> 
  <p>Finally, variance annotations on higher-kinded sub-parameters are supported using backticks:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Lambda</span>[`x[<span class="pl-k">+</span>_]` <span class="pl-k">=&gt;</span> <span class="pl-en">Q</span>[x, <span class="pl-en">List</span>] <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[x[+_]] = Q[x, List]</span>
<span class="pl-en">Lambda</span>[`f[<span class="pl-k">-</span>_, <span class="pl-k">+</span>_]` <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>[f]   <span class="pl-c"><span class="pl-c">//</span> equivalent to: type R[f[-_, +_]] = B[f]</span></pre>
  </div> 
  <p>The function syntax with backtick type parameters is the most expressive syntax kind-projector supports. The other syntaxes are easier to read at the cost of being unable to express certain (hopefully rare) type lambdas.</p> 
  <h3><a id="user-content-type-lambda-gotchas" class="anchor" href="https://github.com/non/kind-projector#type-lambda-gotchas" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Type lambda gotchas</h3> 
  <p>The inline syntax is the tersest and is often preferable when possible. However, there are some type lambdas which it cannot express.</p> 
  <p>For example, imagine that we have <code>trait Functor[F[_]]</code>.</p> 
  <p>You might want to write <code>Functor[Future[List[?]]]</code>, expecting to get something like:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">type</span> <span class="pl-en">X</span>[a] <span class="pl-k">=</span> <span class="pl-en">Future</span>[<span class="pl-en">List</span>[a]]
<span class="pl-en">Functor</span>[<span class="pl-en">X</span>]</pre>
  </div> 
  <p>However, <code>?</code> always binds at the tightest level, meaning that <code>List[?]</code> is interpreted as <code>type X[a] = List[a]</code>, and that <code>Future[List[?]]</code> is invalid.</p> 
  <p>In these cases you should prefer the lambda syntax, which would be written as:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Functor</span>[<span class="pl-en">Lambda</span>[a <span class="pl-k">=&gt;</span> <span class="pl-en">Future</span>[<span class="pl-en">List</span>[a]]]]</pre>
  </div> 
  <p>Other types which cannot be written correctly using inline syntax are:</p> 
  <ul> 
   <li><code>Lambda[a =&gt; (a, a)]</code> (repeated use of <code>a</code>).</li> 
   <li><code>Lambda[(a, b) =&gt; Either[b, a]]</code> (reverse order of type params).</li> 
   <li><code>Lambda[(a, b) =&gt; Function1[a, Option[b]]]</code> (similar to example).</li> 
  </ul> 
  <p>(And of course, you can use <code>λ[...]</code> instead of <code>Lambda[...]</code> in any of these expressions.)</p> 
  <h3><a id="user-content-under-the-hood" class="anchor" href="https://github.com/non/kind-projector#under-the-hood" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Under The Hood</h3> 
  <p>This section shows the exact code produced for a few type lambda expressions.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">Either</span>[<span class="pl-k">Int</span>, <span class="pl-k">?</span>]
({type Λ$[β$<span class="pl-c1">0</span>$] <span class="pl-k">=</span> <span class="pl-en">Either</span>[<span class="pl-k">Int</span>, β$<span class="pl-c1">0</span>$]})#Λ$

<span class="pl-en">Function2</span>[<span class="pl-k">-</span><span class="pl-k">?</span>, <span class="pl-k">String</span>, <span class="pl-k">+</span><span class="pl-k">?</span>]
({type Λ$[<span class="pl-k">-</span>α$<span class="pl-c1">0</span>$, <span class="pl-k">+</span>γ$<span class="pl-c1">0</span>$] <span class="pl-k">=</span> <span class="pl-en">Function2</span>[α$<span class="pl-c1">0</span>$, <span class="pl-k">String</span>, γ$<span class="pl-c1">0</span>$]})#Λ$

<span class="pl-en">Lambda</span>[<span class="pl-en">A</span> <span class="pl-k">=&gt;</span> (<span class="pl-en">A</span>, <span class="pl-en">A</span>)]
({type Λ$[<span class="pl-en">A</span>] <span class="pl-k">=</span> (<span class="pl-en">A</span>, <span class="pl-en">A</span>)})#Λ$

<span class="pl-en">Lambda</span>[(`<span class="pl-k">+</span><span class="pl-en">A</span>`, <span class="pl-en">B</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">Either</span>[<span class="pl-en">A</span>, <span class="pl-en">Option</span>[<span class="pl-en">B</span>]]]
({type Λ$[<span class="pl-k">+</span><span class="pl-en">A</span>, <span class="pl-en">B</span>] <span class="pl-k">=</span> <span class="pl-en">Either</span>[<span class="pl-en">A</span>, <span class="pl-en">Option</span>[<span class="pl-en">B</span>]]})#Λ$

<span class="pl-en">Lambda</span>[(<span class="pl-en">A</span>, <span class="pl-en">B</span>[_]) <span class="pl-k">=&gt;</span> <span class="pl-en">B</span>[<span class="pl-en">A</span>]]
({type Λ$[<span class="pl-en">A</span>, <span class="pl-en">B</span>[_]] <span class="pl-k">=</span> <span class="pl-en">B</span>[<span class="pl-en">A</span>]})#Λ$</pre>
  </div> 
  <p>As you can see, names like <code>Λ$</code> and <code>α$</code> are forbidden because they might conflict with names the plugin generates.</p> 
  <p>If you dislike these unicode names, pass <code>-Dkp:genAsciiNames=true</code> to scalac to use munged ASCII names. This will use <code>L_kp</code> in place of <code>Λ$</code>, <code>X_kp0$</code> in place of <code>α$</code>, and so on.</p> 
  <h3><a id="user-content-polymorphic-lambda-values" class="anchor" href="https://github.com/non/kind-projector#polymorphic-lambda-values" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Polymorphic lambda values</h3> 
  <p>Scala does not have built-in syntax or types for anonymous function values which are polymorphic (i.e. which can be parameterized with types). To illustrate that consider both of these methods:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">firstInt</span>(<span class="pl-v">xs</span>: <span class="pl-en">List</span>[<span class="pl-k">Int</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> xs.headOption
<span class="pl-k">def</span> <span class="pl-en">firstGeneric</span>[<span class="pl-en">A</span>](<span class="pl-v">xs</span>: <span class="pl-en">List</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> xs.headOption</pre>
  </div> 
  <p>Having implemented these methods, we can see that the second just generalizes the first to work with any type: the function bodies are identical. We'd like to be able to rewrite each of these methods as a function value, but we can only represent the first method (<code>firstInt</code>) this way:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">firstInt0</span><span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-k">Int</span>] <span class="pl-k">=&gt;</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> _.headOption
<span class="pl-k">val</span> <span class="pl-en">firstGeneric0</span> &lt;<span class="pl-ent">what</span> to put here???&gt;</pre>
  </div> 
  <p>(One reason to want to do this rewrite is that we might have a method like <code>.map</code> which we'd like to pass an anonymous function value.)</p> 
  <p>Several libraries define their own polymorphic function types, such as the following polymorphic version of <code>Function1</code> (which we can use to implement <code>firstGeneric0</code>):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">PolyFunction1</span>[<span class="pl-k">-</span><span class="pl-en">F</span>[_], <span class="pl-k">+</span><span class="pl-en">G</span>[_]] {
  <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">A</span>](<span class="pl-v">fa</span>: <span class="pl-en">F</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">G</span>[<span class="pl-en">A</span>]
}

<span class="pl-k">val</span> <span class="pl-en">firstGeneric0</span><span class="pl-k">:</span> <span class="pl-en">PolyFunction1</span>[<span class="pl-en">List</span>, <span class="pl-en">Option</span>] <span class="pl-k">=</span>
  <span class="pl-k">new</span> <span class="pl-en">PolyFunction1</span>[<span class="pl-en">List</span>, <span class="pl-en">Option</span>] {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">A</span>](<span class="pl-v">xs</span>: <span class="pl-en">List</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> xs.headOption
  }</pre>
  </div> 
  <p>It's nice that <code>PolyFunction1</code> enables us to express polymorphic function values, but at the level of syntax it's not clear that we've saved much over defining a polymorphic method (i.e. <code>firstGeneric</code>).</p> 
  <p>Since 0.9.0, Kind-projector provides a value-level rewrite to fix this issue and make polymorphic functions (and other types that share their general shape) easier to work with:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">firstGeneric0</span> <span class="pl-k">=</span> λ[<span class="pl-en">PolyFunction1</span>[<span class="pl-en">List</span>, <span class="pl-en">Option</span>]](_.headOption)</pre>
  </div> 
  <p>Either <code>λ</code> or <code>Lambda</code> can be used (in a value position) to trigger this rewrite. By default, the rewrite assumes that the "target method" to define is called <code>apply</code> (as in the previous example), but a different method can be selected via an explicit call.</p> 
  <p>In the following example we are using the polymorphic lambda syntax to define a <code>run</code> method on an instance of the <code>PF</code> trait:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">PF</span>[<span class="pl-k">-</span><span class="pl-en">F</span>[_], <span class="pl-k">+</span><span class="pl-en">G</span>[_]] {
  <span class="pl-k">def</span> <span class="pl-en">run</span>[<span class="pl-en">A</span>](<span class="pl-v">fa</span>: <span class="pl-en">F</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">G</span>[<span class="pl-en">A</span>]
}

<span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> <span class="pl-en">Lambda</span>[<span class="pl-en">PF</span>[<span class="pl-en">List</span>, <span class="pl-en">Option</span>]].run(_.headOption)</pre>
  </div> 
  <p>It's possible to nest this syntax. Here's an example taken from <a href="http://www.slideshare.net/timperrett/enterprise-algebras-scala-world-2016/49" target="_blank">the wild</a> of using nested polymorphic lambdas to remove boilerplate:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> without polymorphic lambas, as in the slide</span>
<span class="pl-k">def</span> <span class="pl-en">injectFC</span>[<span class="pl-en">F</span>[_], <span class="pl-en">G</span>[_]](<span class="pl-k">implicit</span> <span class="pl-en">I</span><span class="pl-k">:</span> <span class="pl-en">Inject</span>[<span class="pl-en">F</span>, <span class="pl-en">G</span>]) <span class="pl-k">=</span>
  new (<span class="pl-en">FreeC</span>[<span class="pl-en">F</span>, <span class="pl-k">?</span>] <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">FreeC</span>[<span class="pl-en">G</span>, <span class="pl-k">?</span>]) {
    <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">A</span>](<span class="pl-v">fa</span>: <span class="pl-en">FreeC</span>[<span class="pl-en">F</span>, <span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">FreeC</span>[<span class="pl-en">G</span>, <span class="pl-en">A</span>] <span class="pl-k">=</span>
      fa.mapSuspension[<span class="pl-en">Coyoneda</span>[<span class="pl-en">G</span>, <span class="pl-k">?</span>]](
        new (<span class="pl-en">Coyoneda</span>[<span class="pl-en">F</span>, <span class="pl-k">?</span>] <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">Coyoneda</span>[<span class="pl-en">G</span>, <span class="pl-k">?</span>]) {
          <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">B</span>](<span class="pl-v">fb</span>: <span class="pl-en">Coyoneda</span>[<span class="pl-en">F</span>, <span class="pl-en">B</span>])<span class="pl-k">:</span> <span class="pl-en">Coyoneda</span>[<span class="pl-en">G</span>, <span class="pl-en">B</span>] <span class="pl-k">=</span> fb.trans(<span class="pl-en">I</span>)
        }
      )
  }

<span class="pl-c"><span class="pl-c">//</span> with polymorphic lambas</span>
<span class="pl-k">def</span> <span class="pl-en">injectFC</span>[<span class="pl-en">F</span>[_], <span class="pl-en">G</span>[_]](<span class="pl-k">implicit</span> <span class="pl-en">I</span><span class="pl-k">:</span> <span class="pl-en">Inject</span>[<span class="pl-en">F</span>, <span class="pl-en">G</span>]) <span class="pl-k">=</span>
  λ[<span class="pl-en">FreeC</span>[<span class="pl-en">F</span>, <span class="pl-k">?</span>] <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">FreeC</span>[<span class="pl-en">G</span>, <span class="pl-k">?</span>]](
    _.mapSuspension(λ[<span class="pl-en">Coyoneda</span>[<span class="pl-en">F</span>, <span class="pl-k">?</span>] <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">Coyoneda</span>[<span class="pl-en">G</span>, <span class="pl-k">?</span>]](_.trans(<span class="pl-en">I</span>)))
  )</pre>
  </div> 
  <p>Kind-projector's support for type lambdas operates at the <em>type level</em> (in type positions), whereas this feature operates at the <em>value level</em> (in value positions). To avoid reserving too many names the <code>λ</code> and <code>Lambda</code> names were overloaded to do both (mirroring the relationship between types and their companion objects).</p> 
  <p>Here are some examples of expressions, along with whether the lambda symbol involved represents a type (traditional type lambda) or a value (polymorphic lambda):</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c"><span class="pl-c">//</span> type lambda (type level)</span>
<span class="pl-k">val</span> <span class="pl-en">functor</span><span class="pl-k">:</span> <span class="pl-en">Functor</span>[λ[a <span class="pl-k">=&gt;</span> <span class="pl-en">Either</span>[<span class="pl-k">Int</span>, a]]] <span class="pl-k">=</span> implicitly

<span class="pl-c"><span class="pl-c">//</span> polymorphic lambda (value level)</span>
<span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> λ[<span class="pl-en">Vector</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">List</span>](_.toList)

<span class="pl-c"><span class="pl-c">//</span> type lambda (type level)</span>
<span class="pl-k">trait</span> <span class="pl-en">CF2</span> <span class="pl-k">extends</span> <span class="pl-e">Contravariant</span>[λ[a <span class="pl-k">=&gt;</span> <span class="pl-en">Function2</span>[a, a, <span class="pl-k">Double</span>]]] {
  ...
}

<span class="pl-c"><span class="pl-c">//</span> polymorphic lambda (value level)</span>
xyz.translate(λ[<span class="pl-en">F</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">G</span>](fx <span class="pl-k">=&gt;</span> fx.flatMap(g)))</pre>
  </div> 
  <p>One pattern you might notice is that when <code>λ</code> occurs immediately within <code>[]</code> it is referring to a type lambda (since <code>[]</code> signals a type application), whereas when it occurs after <code>=</code> or within <code>()</code> it usually refers to a polymorphic lambda, since those tokens usually signal a value. (The <code>()</code> syntax for tuple and function types is an exception to this pattern.)</p> 
  <p>The bottom line is that if you could replace a λ-expression with a type constructor, it's a type lambda, and if you could replace it with a value (e.g. <code>new Xyz[...] { ... }</code>) then it's a polymorphic lambda.</p> 
  <h3><a id="user-content-polymorphic-lambdas-under-the-hood" class="anchor" href="https://github.com/non/kind-projector#polymorphic-lambdas-under-the-hood" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Polymorphic lambdas under the hood</h3> 
  <p>What follows are the gory details of the polymorphic lambda rewrite.</p> 
  <p>Polymorphic lambdas are a syntactic transformation that occurs just after parsing (before name resolution or typechecking). Your code will be typechecked <em>after</em> the rewrite.</p> 
  <p>Written in its most explicit form, a polymorphic lambda looks like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre>λ[<span class="pl-en">Op</span>[<span class="pl-en">F</span>, <span class="pl-en">G</span>]].someMethod(&lt;<span class="pl-ent">expr</span>&gt;)</pre>
  </div> 
  <p>and is rewritten into something like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">new</span> <span class="pl-en">Op</span>[<span class="pl-en">F</span>, <span class="pl-en">G</span>] {
  <span class="pl-k">def</span> <span class="pl-en">someMethod</span>[<span class="pl-en">A</span>](<span class="pl-v">x</span>: <span class="pl-en">F</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">G</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> &lt;<span class="pl-ent">expr</span>&gt;(x)
}</pre>
  </div> 
  <p>(The names <code>A</code> and <code>x</code> are used for clarity –- in practice unique names will be used for both.)</p> 
  <p>This rewrite requires that the following are true:</p> 
  <ul> 
   <li><code>F</code> and <code>G</code> are unary type constructors (i.e. of shape <code>F[_]</code> and <code>G[_]</code>).</li> 
   <li><code>&lt;expr&gt;</code> is an expression of type <code>Function1[_, _]</code>.</li> 
   <li><code>Op</code> is parameterized on two unary type constructors.</li> 
   <li><code>someMethod</code> is parametric (for any type <code>A</code> it takes <code>F[A]</code> and returns <code>G[A]</code>).</li> 
  </ul> 
  <p>For example, <code>Op</code> might be defined like this:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">Op</span>[<span class="pl-en">M</span>[_], <span class="pl-en">N</span>[_]] {
  <span class="pl-k">def</span> <span class="pl-en">someMethod</span>[<span class="pl-en">A</span>](<span class="pl-v">x</span>: <span class="pl-en">M</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">N</span>[<span class="pl-en">A</span>]
}</pre>
  </div> 
  <p>The entire λ-expression will be rewritten immediately after parsing (and before name resolution or typechecking). If any of these constraints are not met, then a compiler error will occur during a later phase (likely type-checking).</p> 
  <p>Here are some polymorphic lambdas along with the corresponding code after the rewrite:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> <span class="pl-en">Lambda</span>[<span class="pl-en">NaturalTransformation</span>[<span class="pl-en">Stream</span>, <span class="pl-en">List</span>]](_.toList)
<span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">NaturalTransformation</span>[<span class="pl-en">Stream</span>, <span class="pl-en">List</span>] {
  <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">A</span>](<span class="pl-v">x</span>: <span class="pl-en">Stream</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> x.toList
}

<span class="pl-k">type</span> <span class="pl-en">Id</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">A</span>
<span class="pl-k">val</span> <span class="pl-en">g</span> <span class="pl-k">=</span> λ[<span class="pl-en">Id</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">Option</span>].run(x <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(x))
<span class="pl-k">val</span> <span class="pl-en">g</span> <span class="pl-k">=</span> new (<span class="pl-en">Id</span> <span class="pl-k">~</span><span class="pl-k">&gt;</span> <span class="pl-en">Option</span>) {
  <span class="pl-k">def</span> <span class="pl-en">run</span>[<span class="pl-en">A</span>](<span class="pl-v">x</span>: <span class="pl-en">Id</span>[<span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>(x)
}

<span class="pl-k">val</span> <span class="pl-en">h</span> <span class="pl-k">=</span> λ[<span class="pl-en">Either</span>[<span class="pl-k">Unit</span>, <span class="pl-k">?</span>] <span class="pl-en">Convert</span> <span class="pl-en">Option</span>](_.fold(_ <span class="pl-k">=&gt;</span> <span class="pl-c1">None</span>, a <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(a)))
<span class="pl-k">val</span> <span class="pl-en">h</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Convert</span>[<span class="pl-en">Either</span>[<span class="pl-k">Unit</span>, <span class="pl-k">?</span>], <span class="pl-en">Option</span>] {
  <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">A</span>](<span class="pl-v">x</span>: <span class="pl-en">Either</span>[<span class="pl-k">Unit</span>, <span class="pl-en">A</span>])<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span>
    x.fold(_ <span class="pl-k">=&gt;</span> <span class="pl-c1">None</span>, a <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(a))
}

<span class="pl-c"><span class="pl-c">//</span> that last example also includes a type lambda.</span>
<span class="pl-c"><span class="pl-c">//</span> the full expansion would be:</span>
<span class="pl-k">val</span> <span class="pl-en">h</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Convert</span>[({type Λ$[β$<span class="pl-c1">0</span>$] <span class="pl-k">=</span> <span class="pl-en">Either</span>[<span class="pl-k">Unit</span>, β$<span class="pl-c1">0</span>$]})#Λ$, <span class="pl-en">Option</span>] {
  <span class="pl-k">def</span> <span class="pl-en">apply</span>[<span class="pl-en">A</span>](<span class="pl-v">x</span>: ({type Λ$[β$<span class="pl-c1">0</span>$] <span class="pl-k">=</span> <span class="pl-en">Either</span>[<span class="pl-k">Unit</span>, β$<span class="pl-c1">0</span>$]})#Λ$)<span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-en">A</span>] <span class="pl-k">=</span>
    x.fold(_ <span class="pl-k">=&gt;</span> <span class="pl-c1">None</span>, a <span class="pl-k">=&gt;</span> <span class="pl-en">Some</span>(a))
}</pre>
  </div> 
  <p>Unfortunately the type errors produced by invalid polymorphic lambdas are likely to be difficult to read. This is an unavoidable consequence of doing this transformation at the syntactic level.</p> 
  <h3><a id="user-content-building-the-plugin" class="anchor" href="https://github.com/non/kind-projector#building-the-plugin" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Building the plugin</h3> 
  <p>You can build kind-projector using SBT 0.13.0 or newer.</p> 
  <p>Here are some useful targets:</p> 
  <ul> 
   <li><code>compile</code>: compile the code</li> 
   <li><code>package</code>: build the plugin jar</li> 
   <li><code>test</code>: compile the test files (no tests run; compilation is the test)</li> 
   <li><code>console</code>: launch a REPL with the plugin loaded so you can play around</li> 
  </ul> 
  <p>You can use the plugin with <code>scalac</code> by specifying it on the command-line. For instance:</p> 
  <pre><code>scalac -Xplugin:kind-projector_2.10-0.6.0.jar test.scala
</code></pre> 
  <h3><a id="user-content-known-issues--errata" class="anchor" href="https://github.com/non/kind-projector#known-issues--errata" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Known issues &amp; errata</h3> 
  <p>When dealing with type parameters that take covariant or contravariant type parameters, only the function syntax is supported. Huh???</p> 
  <p>Here's an example that highlights this issue:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">def</span> <span class="pl-en">xyz</span>[<span class="pl-en">F</span>[_[<span class="pl-k">+</span>_]]] <span class="pl-k">=</span> <span class="pl-c1">12345</span>
<span class="pl-k">trait</span> <span class="pl-en">Q</span>[<span class="pl-en">A</span>[<span class="pl-k">+</span>_], <span class="pl-en">B</span>[<span class="pl-k">+</span>_]]

<span class="pl-c"><span class="pl-c">//</span> we can use kind-projector to adapt Q for xyz</span>
xyz[λ[`x[<span class="pl-k">+</span>_]` <span class="pl-k">=&gt;</span> <span class="pl-en">Q</span>[x, <span class="pl-en">List</span>]] <span class="pl-c"><span class="pl-c">//</span> ok</span>

<span class="pl-c"><span class="pl-c">//</span> but these don't work (although support for the second form</span>
<span class="pl-c"><span class="pl-c">//</span> could be added in a future release).</span>
xyz[<span class="pl-en">Q</span>[<span class="pl-k">?</span>[<span class="pl-k">+</span>_], <span class="pl-en">List</span>]]          <span class="pl-c"><span class="pl-c">//</span> invalid syntax</span>
xyz[<span class="pl-en">Q</span>[<span class="pl-k">?</span>[`<span class="pl-k">+</span>_`], <span class="pl-en">List</span>]]        <span class="pl-c"><span class="pl-c">//</span> unsupported</span></pre>
  </div> 
  <p>There have been suggestions for better syntax, like <code>[A, B]Either[B, A]</code> or <code>[A, B] =&gt; Either[B, A]</code> instead of <code>Lambda[(A, B) =&gt; Either[B, A]]</code>. Unfortunately this would actually require modifying the parser (i.e. the language itself) which is outside the scope of this project (at least, until there is an earlier compiler phase to plug into).</p> 
  <p>Others have noted that it would be nicer to be able to use <code>_</code> for types the way we do for values, so that we could use <code>Either[Int, _]</code> to define a type lambda the way we use <code>3 + _</code> to define a function. Unfortunately, it's probably too late to modify the meaning of <code>_</code>, which is why we chose to use <code>?</code> instead.</p> 
  <h3><a id="user-content-future-work" class="anchor" href="https://github.com/non/kind-projector#future-work" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Future Work</h3> 
  <p>As of 0.5.3, kind-projector should be able to support any type lambda that can be expressed via type projections, at least using the function syntax. If you come across a type for which kind-projector lacks a syntax, please report it.</p> 
  <h3><a id="user-content-disclaimers" class="anchor" href="https://github.com/non/kind-projector#disclaimers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Disclaimers</h3> 
  <p>Kind projector is an unusual compiler plugin in that it runs <em>before</em> the <code>typer</code> phase. This means that the rewrites and renaming we are doing are relatively fragile, and the author disclaims all warranty or liability of any kind.</p> 
  <p>(That said, there are currently no known bugs.)</p> 
  <p>If you are using kind-projector in one of your projects, please feel free to get in touch to report problems (or a lack of problems)!</p> 
  <h3><a id="user-content-copyright-and-license" class="anchor" href="https://github.com/non/kind-projector#copyright-and-license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Copyright and License</h3> 
  <p>All code is available to you under the MIT license, available at <a href="http://opensource.org/licenses/mit-license.php" target="_blank">http://opensource.org/licenses/mit-license.php</a> and also in the COPYING file.</p> 
  <p>Copyright Erik Osheim, 2011-2016.</p> 
 </article>
</div>