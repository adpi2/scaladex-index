<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a id="user-content-debox" class="anchor" href="https://github.com/non/debox#debox" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Debox</h2> 
  <h3><a id="user-content-overview" class="anchor" href="https://github.com/non/debox#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h3> 
  <p>Debox provides specialized mutable collections that don't box.</p> 
  <p>For performance reasons, Debox's types are not compatible with Scala's collections framework (although conversions are possible). You may find that Debox's structures provide more reliable performance than Scala's mutable collections.</p> 
  <p>Debox is available for Scala 2.10 and 2.11.</p> 
  <h3><a id="user-content-set-up" class="anchor" href="https://github.com/non/debox#set-up" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Set up</h3> 
  <p>If you use SBT to build your project, you can use Debox via the following snippet:</p> 
  <pre><code>resolvers += Resolver.sonatypeRepo("releases"),

libraryDependencies += "org.spire-math" %% "debox" % "0.7.3"
</code></pre> 
  <h3><a id="user-content-debox-types" class="anchor" href="https://github.com/non/debox#debox-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Debox Types</h3> 
  <h4><a id="user-content-buffer" class="anchor" href="https://github.com/non/debox#buffer" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Buffer</h4> 
  <p><code>debox.Buffer</code> is an indexed data structure backed by an array which can be appended to. It corresponds to <code>collection.mutable.ArrayBuffer</code> but has better performance due to specialization. It can also wrap instances of <code>Array</code> to provide specialized versions of foreach and map, which are a bit faster.</p> 
  <p>Buffers can grow internally. Appending, such as <code>+=</code> and <code>++=</code>, and removing and from the end of the buffer, as <code>pop</code> does, will be fast operations. Other operations (like adding to the middle of the buffer with <code>insert</code>) may require internal copying.</p> 
  <p>Large buffers which have most of their elements removed will still maintain a large underlying array. Use <code>compact</code> to reclaim unnecessary memory in these situations.</p> 
  <p>Example usage:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">debox.</span><span class="pl-v">Buffer</span>

<span class="pl-k">val</span> <span class="pl-en">buf</span> <span class="pl-k">=</span> <span class="pl-en">Buffer</span>.empty[<span class="pl-k">Int</span>]
buf <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
buf <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
buf <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">2</span>
buf.foreach { n <span class="pl-k">=&gt;</span> println(n) } <span class="pl-c">// prints 1, 1, 2</span>

<span class="pl-k">val</span> <span class="pl-en">child</span> <span class="pl-k">=</span> buf.copy
child <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">3</span>
child(<span class="pl-c1">0</span>) <span class="pl-k">=</span> <span class="pl-c1">999</span>
child.toString <span class="pl-c">// Buffer(999, 1, 2, 3)</span>

<span class="pl-k">val</span> <span class="pl-en">buf</span> <span class="pl-k">++</span><span class="pl-k">=</span> child
buf.pop
buf.sum  <span class="pl-c">// uses spire</span></pre>
  </div> 
  <h4><a id="user-content-set" class="anchor" href="https://github.com/non/debox#set" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Set</h4> 
  <p><code>debox.Set</code> corresponds to <code>collection.mutable.Set</code>, but without boxing. The hashing is done via an open addressing scheme with re-hashing, which is derived from the strategy used by Python. See <em>Hashing Strategy</em> for a more complete description.</p> 
  <p>Sets are required to maintain extra space to ensure fast average lookup times. Sets will tend to use 33-66% of the underlying storage.</p> 
  <p>Large sets which have most of their elements removed will still maintain a large underlying array. Use <code>compact</code> to reclaim unnecessary memory in these situations.</p> 
  <p>Example usage:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">debox.</span><span class="pl-v">Set</span>

<span class="pl-k">val</span> <span class="pl-en">set</span> <span class="pl-k">=</span> <span class="pl-en">Set</span>.empty[<span class="pl-k">Int</span>]
set <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
set <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">1</span>
set <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">2</span>
set(<span class="pl-c1">0</span>) <span class="pl-c">// false</span>
set(<span class="pl-c1">1</span>) <span class="pl-c">// true</span>

<span class="pl-k">val</span> <span class="pl-en">child</span> <span class="pl-k">=</span> buf.copy
child <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">3</span>
child <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-c1">999</span>
child.size <span class="pl-k">==</span> <span class="pl-c1">4</span> <span class="pl-c">// true</span>

<span class="pl-k">val</span> <span class="pl-en">other</span> <span class="pl-k">=</span> <span class="pl-en">Set</span>(<span class="pl-c1">2</span>, <span class="pl-c1">3</span>, <span class="pl-c1">4</span>)
set &amp;<span class="pl-k">=</span> other
set(<span class="pl-c1">1</span>) <span class="pl-c">// false</span>
set(<span class="pl-c1">2</span>) <span class="pl-c">// true</span>
set.size <span class="pl-k">==</span> <span class="pl-c1">1</span> <span class="pl-c">// true</span></pre>
  </div> 
  <h4><a id="user-content-map" class="anchor" href="https://github.com/non/debox#map" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Map</h4> 
  <p><code>debox.Map</code> corresponds to <code>collection.mutable.Map</code>, but without boxing. As with <code>debox.Set</code> the hashing is done via an open addressing scheme with re-hashing, which is derived from the strategy used by Python. See <em>Hashing Strategy</em> for a more complete description.</p> 
  <p>Maps are required to maintain extra space to ensure fast average lookup times. Maps will tend to use 33-66% of the underlying storage.</p> 
  <p>Large maps which have most of their elements removed will still maintain a large underlying array. Use <code>compact</code> to reclaim unnecessary memory in these situations.</p> 
  <p>Unlike Scala Maps (which store a key and value together as a <code>Tuple2</code>), Debox stores keys and values in separate arrays. This makes iterating over keys or values separately faster, but means that operations which treat a map as a sequence of tuples are slower and/or not supported.</p> 
  <p>Example usage:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">debox.</span><span class="pl-v">Map</span>

<span class="pl-k">val</span> <span class="pl-en">m</span> <span class="pl-k">=</span> <span class="pl-en">Map</span>.empty[<span class="pl-k">String</span>, <span class="pl-k">Int</span>]
m(<span class="pl-s"><span class="pl-pds">"</span>boris<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> <span class="pl-c1">1887</span>
m(<span class="pl-s"><span class="pl-pds">"</span>bela<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> <span class="pl-c1">1880</span>
m(<span class="pl-s"><span class="pl-pds">"</span>bela<span class="pl-pds">"</span></span>) <span class="pl-k">=</span> <span class="pl-c1">1882</span>
m.size <span class="pl-c">// 2</span>

m.contains(<span class="pl-s"><span class="pl-pds">"</span>bela<span class="pl-pds">"</span></span>)   <span class="pl-c">// true</span>
m.contains(<span class="pl-s"><span class="pl-pds">"</span>donald<span class="pl-pds">"</span></span>) <span class="pl-c">// false</span>
m.contains(<span class="pl-c1">12345</span>)    <span class="pl-c">// compile-time error!</span>

m.get(<span class="pl-s"><span class="pl-pds">"</span>bela<span class="pl-pds">"</span></span>) <span class="pl-c">// Some(1882)</span>
m.get(<span class="pl-s"><span class="pl-pds">"</span>donald<span class="pl-pds">"</span></span>) <span class="pl-c">// None</span>

m(<span class="pl-s"><span class="pl-pds">"</span>boris<span class="pl-pds">"</span></span>)  <span class="pl-c">// 1887</span>
m(<span class="pl-s"><span class="pl-pds">"</span>bela<span class="pl-pds">"</span></span>)   <span class="pl-c">// 1882</span>
m(<span class="pl-s"><span class="pl-pds">"</span>donald<span class="pl-pds">"</span></span>) <span class="pl-c">// debox.KeyNotFoundException</span>

m <span class="pl-k">++</span><span class="pl-k">=</span> <span class="pl-en">Map</span>(<span class="pl-s"><span class="pl-pds">"</span>christopher<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">1922</span>, <span class="pl-s"><span class="pl-pds">"</span>vincent<span class="pl-pds">"</span></span> <span class="pl-k">-</span><span class="pl-k">&gt;</span> <span class="pl-c1">1911</span>)
m.keysSet <span class="pl-c">// Set(christopher, vincent, bela, boris), order is arbitrary</span>

<span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> m.mapValues(year <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>born in %d<span class="pl-pds">"</span></span> format year)
b <span class="pl-c">// Map(boris -&gt; born in 1887, bela -&gt; born in 1882, ...)</span></pre>
  </div> 
  <h3><a id="user-content-hashing-strategy" class="anchor" href="https://github.com/non/debox#hashing-strategy" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Hashing Strategy</h3> 
  <p>The hashing used in <code>Set</code> and <code>Map</code> works as follows:</p> 
  <ol> 
   <li>Get the item's hashcode (retrieved by the <code>##</code> operator) as <code>i</code>.</li> 
   <li>Mask this by the underlying array's max index to get <code>j</code>. 
    <ol> 
     <li>If slot <code>j</code> is free, use it and return.</li> 
     <li>Else, re-hash <code>i</code> and repeat.</li> 
    </ol></li> 
  </ol> 
  <p>The re-hashing strategy uses <code>perturbation</code> (initialized to the original hashcode) as well as the current <code>i</code> value. The transition can be expressed as:</p> 
  <div class="highlight highlight-source-scala">
   <pre>i <span class="pl-k">=</span> (i <span class="pl-k">&lt;&lt;</span> <span class="pl-c1">2</span>) <span class="pl-k">+</span> i <span class="pl-k">+</span> perturbation <span class="pl-k">+</span> <span class="pl-c1">1</span>
perturbation <span class="pl-k">&gt;&gt;=</span> <span class="pl-c1">5</span></pre>
  </div> 
  <p>For a much more detailed treatment, you can read the comments on CPython's <code>dictobject.c</code> <a href="http://hg.python.org/cpython/file/56c346e9ae4d/Objects/dictobject.c#l106" target="_blank">here</a>.</p> 
  <h3><a id="user-content-benchmarks" class="anchor" href="https://github.com/non/debox#benchmarks" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Benchmarks</h3> 
  <p>Most of Debox has been developed in tandem with aggressive benchmarking using Caliper and other tools.</p> 
  <p>The benchmarks can be run from SBT via <code>benchmark/run</code>.</p> 
  <h3><a id="user-content-disclaimers-and-provisos" class="anchor" href="https://github.com/non/debox#disclaimers-and-provisos" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Disclaimers and Provisos</h3> 
  <p>Debox aims to achieve the best possible performance through use of features like specialization, macros, arrays, etc. All other concerns (such as visibility, subtyping relationships, type signatures, etc.) are secondary.</p> 
  <p>Unlike many Java (and Scala?) projects, Debox is not interested in hiding its internals beyond what is convenient. To aid inlining, most internals are public. This does not mean that users should modify them directly--attempting to manually update the structures could produce non-deterministic effects.</p> 
  <p>Debox chooses not to provide methods whose implementations are guaranteed to be slow. Rather than trying to provide every possibly useful method, the goal is to provide core functionality which can be implemented efficiently and which plays to the data structure's strengths.</p> 
  <p>It's possible that in the future Debox will use a system of imports to optionally add "slow" methods which have been left off the current API. Since Debox is not at a 1.0 release yet, the API may change from version to version. Debox makes no source- or binary-compatibility guarantees.</p> 
  <p>Criticisms, suggestions and patches are all welcome, as are benchmarking results (especially surprising ones)!</p> 
  <h3><a id="user-content-copyright-and-license" class="anchor" href="https://github.com/non/debox#copyright-and-license" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Copyright and License</h3> 
  <p>All code is available to you under the MIT license, available at <a href="http://opensource.org/licenses/mit-license.php" target="_blank">http://opensource.org/licenses/mit-license.php</a> and also in the COPYING file.</p> 
  <p>Copyright Erik Osheim, 2012-2015.</p> 
 </article>
</div>