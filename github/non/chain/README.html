<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h2><a href="https://github.com/non/chain#chain" aria-hidden="true" class="anchor" id="user-content-chain" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Chain</h2> 
  <h3><a href="https://github.com/non/chain#dedication" aria-hidden="true" class="anchor" id="user-content-dedication" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Dedication</h3> 
  <blockquote> 
   <p>all day long they work so hard / 'til the sun is going down / working on the highways and byways / and wearing, wearing a frown / you hear them moaning their lives away / then you hear somebody say: /</p> 
   <p>that's the sound of the men / working on the chain gang / that's the sound of the men / working on the chain gang /</p> 
   <p>--Sam Cooke, "Chain Gang" (1960)</p> 
  </blockquote> 
  <h3><a href="https://github.com/non/chain#overview" aria-hidden="true" class="anchor" id="user-content-overview" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h3> 
  <p>Lots of small collections got you down? Tired of paying O(n) to concatenate lists, or generating a lot of garbage prepending to a vector? If so, Chain is for you!</p> 
  <p>Chain is a small library that supports efficient concatenation across many collection types, as well as efficient iteration across the results.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">chain.</span><span class="pl-v">Chain</span>

<span class="pl-k">val</span> <span class="pl-en">xs</span><span class="pl-k">:</span> <span class="pl-en">Vector</span>[<span class="pl-k">Long</span>] <span class="pl-k">=</span> ...
<span class="pl-k">val</span> <span class="pl-en">ys</span><span class="pl-k">:</span> <span class="pl-en">Vector</span>[<span class="pl-k">Long</span>] <span class="pl-k">=</span> ...

<span class="pl-c"><span class="pl-c">//</span> copies the entire contents of xs and ys</span>
<span class="pl-c"><span class="pl-c">//</span> before performing the summation</span>
(xs <span class="pl-k">++</span> ys).foldLeft(<span class="pl-c1">0L</span>)(_ <span class="pl-k">+</span> _)

<span class="pl-c"><span class="pl-c">//</span> does not copy anything, just iterates over</span>
<span class="pl-c"><span class="pl-c">//</span> xs and ys in turn.</span>
(<span class="pl-en">Chain</span>(xs) <span class="pl-k">++</span> <span class="pl-en">Chain</span>(ys)).foldLeft(<span class="pl-c1">0L</span>)(_ <span class="pl-k">+</span> _)</pre>
  </div> 
  <p>This example is somewhat contrived, but I bet you have lots of code that builds intermediate collections solely to iterate over them. Chain can help make that code more efficient.</p> 
  <h3><a href="https://github.com/non/chain#quick-start" aria-hidden="true" class="anchor" id="user-content-quick-start" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Quick Start</h3> 
  <p>Chain supports Scala 2.10, 2.11, and 2.12.</p> 
  <p>To include Chain in your projects, you can use the following <code>build.sbt</code> snippet:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>chain<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Chain also supports Scala.js. To use Chain in your Scala.js projects, include the following <code>build.sbt</code> snippet:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>org.spire-math<span class="pl-pds">"</span></span> <span class="pl-k">%%%</span> <span class="pl-s"><span class="pl-pds">"</span>chain<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.2.0<span class="pl-pds">"</span></span></pre>
  </div> 
  <h3><a href="https://github.com/non/chain#details" aria-hidden="true" class="anchor" id="user-content-details" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Details</h3> 
  <p>Chain can wrap any <code>Iterable[A]</code> values, and supports concatenation between mixed collection types. Here's an example that shows off a number of Chain's capabilities:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">chain.</span><span class="pl-v">Chain</span>

<span class="pl-k">val</span> <span class="pl-en">ws</span><span class="pl-k">:</span> <span class="pl-en">Iterable</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-c1">1</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)
<span class="pl-k">val</span> <span class="pl-en">xs</span><span class="pl-k">:</span> <span class="pl-en">List</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-c1">4</span>,<span class="pl-c1">5</span>,<span class="pl-c1">6</span>)
<span class="pl-k">val</span> <span class="pl-en">ys</span><span class="pl-k">:</span> <span class="pl-en">Vector</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Vector</span>(<span class="pl-c1">7</span>,<span class="pl-c1">8</span>,<span class="pl-c1">9</span>,<span class="pl-c1">10</span>,<span class="pl-c1">11</span>)
<span class="pl-k">val</span> <span class="pl-en">zs</span><span class="pl-k">:</span> <span class="pl-en">Option</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-c1">12</span>)

<span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> <span class="pl-en">Chain</span>(ws) <span class="pl-k">++</span> <span class="pl-en">Chain</span>(xs) <span class="pl-c"><span class="pl-c">//</span> no copying</span>
<span class="pl-k">val</span> <span class="pl-en">b</span> <span class="pl-k">=</span> <span class="pl-en">Chain</span>.all(ys, zs)      <span class="pl-c"><span class="pl-c">//</span> same as ys ++ zs, but no copying</span>
<span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> a <span class="pl-k">++</span> b                 <span class="pl-c"><span class="pl-c">//</span> still no copying</span>
<span class="pl-k">val</span> <span class="pl-en">d</span> <span class="pl-k">=</span> <span class="pl-c1">9</span> <span class="pl-k">+</span><span class="pl-k">:</span> c <span class="pl-k">:</span><span class="pl-k">+</span> <span class="pl-c1">100</span>          <span class="pl-c"><span class="pl-c">//</span> supports prepend/append</span>

<span class="pl-k">val</span> <span class="pl-en">ns</span><span class="pl-k">:</span> <span class="pl-en">Iterable</span>[<span class="pl-k">Int</span>] <span class="pl-k">=</span> c.toIterable <span class="pl-c"><span class="pl-c">//</span> thin wrapper for scala compat</span>

c.toVector           <span class="pl-c"><span class="pl-c">//</span> Vector(1,2,3,4,5,6,7,8,9,10,11,12)</span>
c.iterator.toList    <span class="pl-c"><span class="pl-c">//</span> List(1,2,3,4,5,6,7,8,9,10,11,12)</span>
c.foreach(println)   <span class="pl-c"><span class="pl-c">//</span> prints 1-12</span>
c.find(_ <span class="pl-k">&gt;</span> <span class="pl-c1">6</span>)        <span class="pl-c"><span class="pl-c">//</span> Some(7)</span>
c.forall(_ <span class="pl-k">&gt;=</span> <span class="pl-c1">0</span>)     <span class="pl-c"><span class="pl-c">//</span> true</span>
c.exists(_ <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)    <span class="pl-c"><span class="pl-c">//</span> false</span>
c.map(_ <span class="pl-k">*</span> <span class="pl-c1">2</span>)         <span class="pl-c"><span class="pl-c">//</span> Chain(2,4,6,8,10,12,14,16,18,20,22,24)</span>
c.filter(_ <span class="pl-k">%</span> <span class="pl-c1">3</span> <span class="pl-k">==</span> <span class="pl-c1">0</span>) <span class="pl-c"><span class="pl-c">//</span> Chain(3,6,9,12)</span></pre>
  </div> 
  <p>(Note that <code>.toString</code> evaluates the entire contents of the Chain, so displaying a chain value in the REPL will force iteration over the contents of the chain.)</p> 
  <p>Chain is sealed and consists of two concrete case classes:</p> 
  <ul> 
   <li><code>Chain.Elems</code> wraps a single collection.</li> 
   <li><code>Chain.Concat</code> represents a single <code>++</code> invocation.</li> 
  </ul> 
  <p>Together these types create a tree. (Since we do not need to support arbitrary insertion into the tree, there is no need to balance it.) Iteration over the tree takes advantage of an in-memory stack to efficiently walk the contents in O(n) time.</p> 
  <p>Concatenating chains is always O(1), and iteration is always O(n).</p> 
  <p>Empty Chains can be obtained by <code>Chain.empty[A]</code> and are represented as a singleton <code>Chain.Empty</code> which is a <code>Chain(Nil)</code>. This value is immutable and can be shared safely. Chains with a single element are constructed by <code>Chain.single(x)</code> which constructs <code>Chain(x :: Nil)</code> instances. This is done transparently in the case of <code>+:</code> and <code>:+</code>. These encoding are relatively efficient although if you are working entirely with single elements a more efficient data structure is possible.</p> 
  <p>Some operations that transform the Chain will need to allocate a new collection (either directly, or wrapped in a new <code>Chain[A]</code>). The comments explain the exact performance characteristics of each method, but here is a quick list of the methods which will allocate a new collection:</p> 
  <ul> 
   <li><code>.map</code>: always allocates a new collection.</li> 
   <li><code>.flatMap</code>: always allocates a new collection.</li> 
   <li><code>.filter</code>: always allocates a new collection.</li> 
   <li><code>.compress</code>: when not already compressed, allocates a new collection.</li> 
   <li><code>.toVector</code>: usually allocates a new <code>Vector[A]</code>.</li> 
  </ul> 
  <p>(If your chain is a <code>Chain.Elems</code> wrapping a <code>Vector[A]</code>, then <code>.toVector</code> will just return that vector directly.)</p> 
  <h3><a href="https://github.com/non/chain#caveats" aria-hidden="true" class="anchor" id="user-content-caveats" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Caveats</h3> 
  <p>To avoid inheriting inefficient methods (such as <code>.size</code>), <code>Chain</code> itself does not extend any Scala collection interfaces. However <code>.toIterable</code> uses a very thin wrapper to support <code>Iterable[A]</code>, so if you need to interoperate with the Scala collections hierarchy you can use that method.</p> 
  <p>Currently Chain supports the most commonly-used collection methods. Most of the rest should be easy to implement using <code>.iterator</code>, <code>.foldLeft</code>, or .<code>find</code>. Pull requests to add more of these methods will be gladly accepted.</p> 
  <p>The design of Chain assumes that the (relatively small) overhead of using <code>Iterator[A]</code> internally is acceptable. In the case of a large number of very small (or empty) collections this could be less efficient than simply accumulating those values into a single collection. The <code>.compress</code> method can be used in these situations.</p> 
  <p>Chain can be thought of as a limited kind of rope that is specialized to Scala collections (specifically <code>Iterable[A]</code>). You can imagine a similar (but more principled) data structure that is based around a type class like <code>Foldable</code> instead.</p> 
  <p>In general calling <code>.iterator</code> should be relatively low cost. In cases where the chain is right-associated (e.g. <code>Chain(xs) ++ (...)</code>), almost no work will take place. In cases where a chain is deeply left-associated, the call will need to descend until it finds the leftmost concrete collection that is not empty.</p> 
  <h3><a href="https://github.com/non/chain#future-work" aria-hidden="true" class="anchor" id="user-content-future-work" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Future Work</h3> 
  <p>Additional benchmarking and profiling would be great. Almost any chain method implemented with <code>.iterator</code> could be specialized if it proved to be a hotspot.</p> 
  <p>It might be nice to have a few different types to support various expected work loads and collection shapes. The current approach leans towards supporting large collections.</p> 
  <p>As mentioned above, it would be great to have a story for using type classes instead of <code>Iterable[A]</code> (either via an abstraction or a new type). It could also be nice to have a version which supported lazy filtering/mapping (although in many cases this can be emulated with things like <code>.iterator.filter</code>).</p> 
  <h3><a href="https://github.com/non/chain#copyright-and-license" aria-hidden="true" class="anchor" id="user-content-copyright-and-license" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Copyright and License</h3> 
  <p>All code is available to you under the MIT license, available at <a href="http://opensource.org/licenses/mit-license.php" target="_blank">http://opensource.org/licenses/mit-license.php</a>.</p> 
  <p>Copyright Erik Osheim, 2016-2017.</p> 
 </article>
</div>