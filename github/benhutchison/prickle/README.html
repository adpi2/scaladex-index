<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-prickle" class="anchor" href="https://github.com/benhutchison/prickle#prickle" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Prickle</h1> 
  <p>Prickle is a library for easily pickling (serializing) object graphs between Scala and Scala.js. </p> 
  <p>It is based upon scala-js-pickling, but adds several improvements &amp; refinements:</p> 
  <ul> 
   <li><a href="https://github.com/benhutchison/prickle#pickling-to-string-by-default" target="_blank">Pickling to/from Strings</a></li> 
   <li><a href="https://github.com/benhutchison/prickle#support-for-class-hierarchies-and-sum-types" target="_blank">Better support for class hierarchies / sum types</a></li> 
   <li><a href="https://github.com/benhutchison/prickle#support-for-shared-objects" target="_blank">Support for shared objects and cycles in the serialized object graph</a></li> 
   <li><a href="https://github.com/benhutchison/prickle#unpickling-yields-a-try" target="_blank">Unpickling a value of type T yields a Try[T]</a></li> 
   <li>100% identical scala code between JVM and JS; no platform specific dependecy</li> 
   <li><a href="https://github.com/benhutchison/prickle#supporting-static-reference-data" target="_blank">Can handle Static Reference Data in the pickled object graph</a> </li> 
  </ul> 
  <p>Currently, prickle supports automatic, reflection-free recursive pickling of</p> 
  <ul> 
   <li>Case classes</li> 
   <li>Case objects</li> 
   <li>Iterables, Seqs, Sets, Maps and SortedMaps</li> 
   <li>Dates and Durations</li> 
   <li>Primitives</li> 
  </ul> 
  <h2><a id="user-content-getting-prickle" class="anchor" href="https://github.com/benhutchison/prickle#getting-prickle" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Getting Prickle</h2> 
  <p>Scala.jvm 2.11 <code>"com.github.benhutchison" %% "prickle" % "1.1.12"</code></p> 
  <p>Scala.js 0.6+ on 2.11 <code>"com.github.benhutchison" %%% "prickle" % "1.1.12"</code></p> 
  <p>To use, import the package, but do not import on the Pickler &amp; Unpickler objects</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">prickle.</span><span class="pl-v">_</span>

<span class="pl-c">//!Don't do this. Not Necessary</span>
<span class="pl-k">import</span> <span class="pl-v">Pickler.</span><span class="pl-v">_</span></pre>
  </div> 
  <p>Prickle depends upon <a href="https://github.com/benhutchison/MicroJson" target="_blank">microjson</a> in its default pickle configuration.</p> 
  <p>Prickle is open source under the Apache 2 license.</p> 
  <h2><a id="user-content-runnable-example" class="anchor" href="https://github.com/benhutchison/prickle#runnable-example" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><a href="https://github.com/benhutchison/prickle/blob/master/example/src/main/scala/Example.scala" target="_blank">Runnable Example</a></h2> 
  <p>To run:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">&gt;</span> example<span class="pl-k">/</span>run</pre>
  </div> 
  <p>The first example demonstrates: </p> 
  <ul> 
   <li>Basic pickling of values whose static types is the same as their runtime class.</li> 
   <li>Using CompositePicklers to pickle class hierarchies, i.e. values whose static type is more general than their runtime class. </li> 
   <li>Support for shared objects in the pickled graph</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">prickle.</span><span class="pl-v">_</span>

<span class="pl-k">sealed</span> <span class="pl-k">trait</span> <span class="pl-en">Fruit</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Apple</span>(<span class="pl-v">isJuicy</span>: <span class="pl-k">Boolean</span>) <span class="pl-k">extends</span> <span class="pl-e">Fruit</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Lemon</span>(<span class="pl-v">sourness</span>: <span class="pl-k">Double</span>) <span class="pl-k">extends</span> <span class="pl-e">Fruit</span>
<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">FruitSalad</span>(<span class="pl-v">components</span>: <span class="pl-en">Seq</span>[<span class="pl-en">Fruit</span>]) <span class="pl-k">extends</span> <span class="pl-e">Fruit</span>
<span class="pl-k">case</span> <span class="pl-k">object</span> <span class="pl-en">TheDurian</span> <span class="pl-k">extends</span> <span class="pl-e">Fruit</span>

<span class="pl-k">object</span> <span class="pl-en">Example</span> <span class="pl-k">extends</span> <span class="pl-e">App</span> {

  println(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-cce">\n</span>1. No preparation is needed to pickle or unpickle values whose static type is exactly known:<span class="pl-pds">"</span></span>)

  <span class="pl-k">val</span> <span class="pl-en">apples</span> <span class="pl-k">=</span> <span class="pl-en">Seq</span>(<span class="pl-en">Apple</span>(<span class="pl-c1">true</span>), <span class="pl-en">Apple</span>(<span class="pl-c1">false</span>))
  <span class="pl-k">val</span> <span class="pl-en">pickledApples</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoString(apples)
  <span class="pl-k">val</span> <span class="pl-en">rehydratedApples</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Seq</span>[<span class="pl-en">Apple</span>]].fromString(pickledApples)


  println(s<span class="pl-s"><span class="pl-pds">"</span>A bunch of Apples: ${apples}<span class="pl-pds">"</span></span>)
  println(s<span class="pl-s"><span class="pl-pds">"</span>Pickled apples: ${pickledApples}<span class="pl-pds">"</span></span>)
  println(s<span class="pl-s"><span class="pl-pds">"</span>Rehydrated apples: ${rehydratedApples}<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>)


  println(<span class="pl-s"><span class="pl-pds">"</span>2. To pickle a class hierarchy (aka 'Sum Type'), create a CompositePickler and enumerate the concrete types<span class="pl-pds">"</span></span>)

  <span class="pl-c">//implict defs/vals should have an explicitly declared type to work properly</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">fruitPickler</span><span class="pl-k">:</span> <span class="pl-en">PicklerPair</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> <span class="pl-en">CompositePickler</span>[<span class="pl-en">Fruit</span>].
    concreteType[<span class="pl-en">Apple</span>].concreteType[<span class="pl-en">Lemon</span>].concreteType[<span class="pl-en">FruitSalad</span>].concreteType[<span class="pl-en">TheDurian</span>.type]

  <span class="pl-k">val</span> <span class="pl-en">sourLemon</span> <span class="pl-k">=</span> <span class="pl-en">Lemon</span>(sourness <span class="pl-k">=</span> <span class="pl-c1">100.0</span>)
  <span class="pl-c">//fruitSalad's concrete type has been forgotten, replaced by more general supertype</span>
  <span class="pl-k">val</span> <span class="pl-en">fruitSalad</span><span class="pl-k">:</span> <span class="pl-en">Fruit</span> <span class="pl-k">=</span> <span class="pl-en">FruitSalad</span>(<span class="pl-en">Seq</span>(<span class="pl-en">Apple</span>(<span class="pl-c1">true</span>), sourLemon, sourLemon, <span class="pl-en">TheDurian</span>))

  <span class="pl-k">val</span> <span class="pl-en">fruitPickles</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoString(fruitSalad)

  <span class="pl-k">val</span> <span class="pl-en">rehydratedSalad</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Fruit</span>].fromString(fruitPickles)

  println(s<span class="pl-s"><span class="pl-pds">"</span>Notice how the fruit salad has multiple references to the same object 'sourLemon':<span class="pl-cce">\n</span>${fruitSalad}<span class="pl-pds">"</span></span>)

  println(s<span class="pl-s"><span class="pl-pds">"</span>In the JSON, 2nd and subsequent occurences of an object are replaced by refs:<span class="pl-cce">\n</span>${fruitPickles}<span class="pl-pds">"</span></span>)

  println(s<span class="pl-s"><span class="pl-pds">"</span>The rehydrated object graph doesnt contain duplicated lemons:<span class="pl-cce">\n</span>${rehydratedSalad}<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>)
}</pre>
  </div> 
  <h2><a id="user-content-changelog" class="anchor" href="https://github.com/benhutchison/prickle#changelog" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Changelog</h2> 
  <table>
   <thead> 
    <tr> 
     <th>Version</th> 
     <th>When</th> 
     <th>Changes</th> 
    </tr> 
   </thead>
   <tbody> 
    <tr> 
     <td>1.0.3</td> 
     <td>Oct 14</td> 
     <td>SortedMap support. Duration Support. 2.10.x binary added</td> 
    </tr> 
    <tr> 
     <td>1.1.0</td> 
     <td>Nov 14</td> 
     <td>Collection picklers support shared objects properly. Iterable support.</td> 
    </tr> 
    <tr> 
     <td>1.1.1</td> 
     <td>Jan 15</td> 
     <td>Example showing how to handle static reference data in a pickled object graph.</td> 
    </tr> 
    <tr> 
     <td>1.1.2</td> 
     <td>Jan 15</td> 
     <td>Fix #9 Double serialization bug</td> 
    </tr> 
    <tr> 
     <td>1.1.3</td> 
     <td>Feb 15</td> 
     <td>2.10.x support dropped, scala-js-0.6.0 support added</td> 
    </tr> 
    <tr> 
     <td>1.1.4</td> 
     <td>Mar 15</td> 
     <td>List and immutable Seq support, upgrade to Scala.js 0.6.1</td> 
    </tr> 
    <tr> 
     <td>1.1.5</td> 
     <td>Apr 15</td> 
     <td>Performance improvement: use object identity for equality check during unpickle, using mutable Builder during Map unpickle</td> 
    </tr> 
    <tr> 
     <td>1.1.6</td> 
     <td>Jun 15</td> 
     <td>Performance: use builder for Seq/Iterable collections. UUID support. Upgrade scalajs 0.6.3</td> 
    </tr> 
    <tr> 
     <td>1.1.7</td> 
     <td>Jun 15</td> 
     <td>Performance: microjson 1.3 removed some silly inefficiency. Support Unit picklers</td> 
    </tr> 
    <tr> 
     <td>1.1.8</td> 
     <td>Jul 15</td> 
     <td>Support Vector picklers</td> 
    </tr> 
    <tr> 
     <td>1.1.9</td> 
     <td>Aug 15</td> 
     <td>Expose some Pickler/Unpickler helper methods for use by custom picklers</td> 
    </tr> 
    <tr> 
     <td>1.1.10</td> 
     <td>Nov 15</td> 
     <td>Fix #28: account for unstable Set iteration order</td> 
    </tr> 
    <tr> 
     <td>1.1.11</td> 
     <td>Jul 16</td> 
     <td>Fix incorrect utest runtime dependency, freshen libraries</td> 
    </tr> 
    <tr> 
     <td>1.1.12</td> 
     <td>Oct 16</td> 
     <td>Fix #34: fix custom pickle format prefix. Upgrade to scalajs 0.6.12</td> 
    </tr> 
   </tbody>
  </table> 
  <h2><a id="user-content-pickling-to-string-by-default" class="anchor" href="https://github.com/benhutchison/prickle#pickling-to-string-by-default" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Pickling to String by Default</h2> 
  <p>Prickle expects you probably want to pickle to and from a json String, so this is the default. Because Strings are defined in both Scala and Scala.js core lib, there is no need to depend upon a platform-specific json dependency.</p> 
  <p>Call <code>prickle.Pickle.intoString()</code> to pickle your object. The static type of the passed object will be used to search for Pickler typeclasses in implicit scope. If none are found, and the object is a case-class or case-object, a macro will <em>materialize</em> a pickler using compile-time reflection to analyze the fields of the object.</p> 
  <p>When Unpickling with <code>prickle.Unpickle[T].fromString()</code>, you must tell prickle what type to unpickle into, since it's unable to determine this from the String parameter.</p> 
  <pre><code>val p = Person("Ben", "Hutchison")

val s: String = Pickle.intoString(p)

val tryPerson = Unpickle[Person].fromString(s)
</code></pre> 
  <p>Under the hood, prikle converts objects to/from a json model (<code>microjson.JsValue</code>) based on the <a href="https://github.com/benhutchison/MicroJson" target="_blank">microjson library</a>. MicroJson then renders or parses the JSON object graph to a flat String.</p> 
  <h2><a id="user-content-support-for-class-hierarchies-and-sum-types" class="anchor" href="https://github.com/benhutchison/prickle#support-for-class-hierarchies-and-sum-types" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Support for Class Hierarchies and Sum Types</h2> 
  <p>It's common to have a hierarchy of classes where the concrete type of a value is not known statically. In some contexts these are called <a href="http://en.wikipedia.org/wiki/Tagged_union" target="_blank">Sum Types</a>.</p> 
  <p>Prickle supports these via CompositePicklers. These are not automically derived by a macro, but must be configured by the programmer, and assigned to an implicit val. </p> 
  <p>Example: How to creates a PicklerPair[Fruit], that handles two cases of fruit, <code>Apple</code>s and <code>Lemon</code>s:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">prickle.</span><span class="pl-v">_ </span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">fruitPickler</span> <span class="pl-k">=</span> <span class="pl-en">CompositePickler</span>[<span class="pl-en">Fruit</span>].concreteType[<span class="pl-en">Apple</span>].concreteType[<span class="pl-en">Lemon</span>]

<span class="pl-k">val</span> <span class="pl-en">fruit1</span><span class="pl-k">:</span> <span class="pl-en">Fruit</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Apple</span>(<span class="pl-c1">true</span>)

<span class="pl-k">val</span> <span class="pl-en">jsonString</span> <span class="pl-k">=</span> <span class="pl-en">Pickle</span>.intoString(apple)</pre>
  </div> 
  <p>The pickle and unpickle operations can be specified together, yielding a <code>PicklerPair[A]</code>, that knows how to pickle/unpickle values of type <code>A</code>, and all specified concrete subclasses. There are background implicit conversions in the <code>Pickler</code> and <code>Unpickler</code> that can auto-unpack <code>PicklerPairs</code> into their two parts.</p> 
  <p>(Note also the detail that <code>fruit1</code> is declared to have super-type <code>Fruit</code>. Problems would result if this was omitted, as the val <code>fruit1</code> would then have inferred subtype <code>Apple</code>. In that case, the compiler will prefer to auto-generate a <code>Pickler[Apple]</code> via macro rather than use the <code>Pickler[Fruit]</code>.)</p> 
  <h3><a id="user-content-improved-type-safety-vs-scala-js-pickling" class="anchor" href="https://github.com/benhutchison/prickle#improved-type-safety-vs-scala-js-pickling" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Improved Type-Safety vs <a href="https://github.com/scala-js/scala-js-pickling" target="_blank">scala-js-pickling</a></h3> 
  <p>CompositePicklers play a similar role to the PicklerRegistry used in scala-js-pickling, but are safer. In Prickle, missing Picklers will normally result in a compile-time error, as an implicit not found. (The exception is unregistered concrete subclasses of a CompositePickler.) However, in Scala-js-pickling, the discovery of missing un/picklers occurs at runtime when un/pickling is attempted.</p> 
  <p><a href="https://github.com/benhutchison/prickle/blob/master/docs/CompositePicklersVsRegistry.png?raw=true" target="_blank"><img src="https://github.com/benhutchison/prickle/raw/master/docs/CompositePicklersVsRegistry.png?raw=true" alt="Composite Picklers Vs Singleton Registry" title="Composite Picklers Vs Singleton Registry" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-picklers-unpicklers-macros-and-formats" class="anchor" href="https://github.com/benhutchison/prickle#picklers-unpicklers-macros-and-formats" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Picklers, Unpicklers, Macros and Formats</h2> 
  <p>Like scala-pickling and scala-js-pickling, prickle uses implicit <code>Pickler[T]</code> and <code>Unpickler[T]</code> type-classes to transform values of type T. </p> 
  <p>For case classes and case objects, these type classes will be automatically <em>materialized</em> via an implicit macro, if they aren't found in implicit scope. This is recursive, so picklers &amp; unpicklers for each field will also be resolved and possibly materialized.</p> 
  <p>If there is a non-case class you wish to pickle that's unsupported out-of-the-box, you can define your own and put them in implicit scope. See <code>prickle.Pickler</code> and <code>prickle.Unpickler</code> for examples.</p> 
  <p>Prickle isn't limited to pickling to Strings - any json-like format can be used. You will need to implement<code>prickle.PReader</code> and <code>prickle.PBuilder</code> for your format, and pass a custom PConfig when un/pickling.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">prickle.</span><span class="pl-v">_</span>

<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">myConfig</span><span class="pl-k">:</span> <span class="pl-en">PConfig</span>[<span class="pl-en">Array</span>[<span class="pl-k">Byte</span>]] <span class="pl-k">=</span> <span class="pl-k">???</span> <span class="pl-c">//..your defn goes here</span>

<span class="pl-k">val</span> <span class="pl-en">p</span> <span class="pl-k">=</span> <span class="pl-en">Person</span>(<span class="pl-s"><span class="pl-pds">"</span>Ben<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>Hutchison<span class="pl-pds">"</span></span>)

<span class="pl-k">val</span> <span class="pl-en">bytes</span><span class="pl-k">:</span> <span class="pl-en">Array</span>[<span class="pl-k">Byte</span>] <span class="pl-k">=</span> <span class="pl-en">Pickle</span>(p)

<span class="pl-k">val</span> <span class="pl-en">tryPerson</span> <span class="pl-k">=</span> <span class="pl-en">Unpickle</span>[<span class="pl-en">Person</span>].from(bytes)</pre>
  </div> 
  <h3><a id="user-content-unpickling-yields-a-try" class="anchor" href="https://github.com/benhutchison/prickle#unpickling-yields-a-try" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Unpickling yields a Try</h3> 
  <p>It's tempting to think of Pickling and Unpickling as symmetrical, inverse operations (eg <code>T =&gt; String</code>, <code>String =&gt; T</code>) but there's a difference: Unpickling is far more likely to fail. </p> 
  <p>This stems from the nature of the operations. Pickling transforms a structured, well typed object graph into flattened, stringly-typed data. Unpickling takes a weakly-typed string and re-constructs the typed object-graph from it. Most arbitrary strings won't re-construct valid object graphs, so the unpickle operation attempts to move from a higher entropy state to a lower entropy state.</p> 
  <p>Prickle acknowledges the possibility of failure by returning a Try[T] when attempting to unpickle (<a href="https://www.youtube.com/watch?v=ujpHtodp6OQ" target="_blank">An extended talk about the philosophy guiding this design, with supa-crunch audio</a>) </p> 
  <h2><a id="user-content-support-for-shared-objects" class="anchor" href="https://github.com/benhutchison/prickle#support-for-shared-objects" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Support for Shared objects</h2> 
  <p>What is meant by "shared" here are objects that are referenced more than once in an object graph. To avoid duplicating such objects when pickling, prickle's algorithm remembers what objects it has pickled so far, and introduce references to already pickled state when it re-encounters them. On the unpickle side, prickle tracks an IDs associated with each unpickled object and resolved references to IDs it has already encountered in the stream.</p> 
  <p>Shared objects brings a memory and pickled-data overhead, since a mapping between objects and IDs must be maintained during pickling and unpickling. It can be turned off in the PConfig by setting <code>isCyclesSupported = false</code>.</p> 
  <p>Note on terminology: sometimes object graphs with shared objects are described as having <em>circular</em> or cyclic references, but there is a subtle difference. Circular references implies there is a path through the graph that returns to the originating object. Shared references is a weaker condition, that simply implies there are two different paths to the same object. The former cannot result from the use of purely immutable data, but shared objects certainly can- and does- often.</p> 
  <h2><a id="user-content-supporting-static-reference-data" class="anchor" href="https://github.com/benhutchison/prickle#supporting-static-reference-data" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Supporting Static Reference Data</h2> 
  <p>The second <a href="https://github.com/benhutchison/prickle/blob/master/example/src/main/scala/Example.scala" target="_blank">AdvancedLookupExample</a> shows how prickle can be extended to handle <em>reference data</em> in the pickled object graph. Here, <em>reference data</em> denotes pre-existing values presumed to exist the static environment on both the pickle and unpickle sides. When an object graph refers to such values, typically it is not desirable to pickle the actual data, but just a reference to it, and then to re-enstate the reference on the other side by looking it up from an Id. </p> 
  <h2><a id="user-content-controlling-pickling-via-pconfig" class="anchor" href="https://github.com/benhutchison/prickle#controlling-pickling-via-pconfig" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Controlling Pickling via PConfig</h2> 
  <p>The pickle and unpickle operations take an implicit PConfig ("pickle-config") which specifies:</p> 
  <ul> 
   <li>The type/format of the pickled data. Default: String</li> 
   <li>Whether support for shared/cyclic objects is required. Default: true.</li> 
   <li>The prefix String to prepend to <em>internal keys</em> in the Json objects used by prickle itself. Default: #</li> 
  </ul> 
  <p>These <em>internal keys</em> are</p> 
  <ul> 
   <li>id: identifies an object that may be shared</li> 
   <li>ref: refers to the id of an earlier object in the stream</li> 
   <li>scalaObj: refers to the name of a scala object</li> 
   <li>cls: the concrete class of a pickled object</li> 
   <li>val: identifies the fields of a pickled object</li> 
  </ul> 
  <h2><a id="user-content-limitations" class="anchor" href="https://github.com/benhutchison/prickle#limitations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Limitations</h2> 
  <ul> 
   <li>Prickle focuses on 2-way data transfer from object graph to pickled form and back. The pickled layout (ie the json) should be considered an implementation detail (issues #17 #21).</li> 
   <li>Objects must be unpickled with the corresponding type of pickler as they were pickled with (issue #15).</li> 
  </ul> 
  <h2><a id="user-content-troubleshooting" class="anchor" href="https://github.com/benhutchison/prickle#troubleshooting" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Troubleshooting</h2> 
  <p>If you escape "Implicit Parameter Not Found" errors when you first use prickle on a non-trivial problem, you're very lucky! For the rest of you, here's some tips for diagnosing such problems:</p> 
  <ul> 
   <li>Firstly, be patient: Prickle pushes more errors to compile-time, so you're doing the debugging early. </li> 
   <li>Typically, the errors result from a missing type-class for some type in your object graph. The goal therefore is to find which one and why.</li> 
   <li>Divide and conquer: break up big chains of implicit dependencies into simpler pieces, get them working, then combine.</li> 
   <li>Don't always take the compiler errors literally - the root cause often lies elsewhere to the sympton. Especially when implicit materialization is involved.</li> 
   <li>You can manually invoke materialisation, to test if its working OK, eg like this </li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">personPickler</span><span class="pl-k">:</span> <span class="pl-en">Pickler</span>[<span class="pl-en">Person</span>] <span class="pl-k">=</span> <span class="pl-en">Pickler</span>.materializePickler[<span class="pl-en">Person</span>]</pre>
  </div> 
  <ul> 
   <li>This compiler option can help diagnose implicit problems (in <code>build.sbt</code> form): <code>scalacOptions ++= Seq("-Xlog-implicits")</code></li> 
   <li>Be aware that Picklers and Unpicklers are <a href="http://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)" target="_blank">invariant</a>, which can lead to puzzling errors:</li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">prickle.</span><span class="pl-v">_</span>
<span class="pl-k">trait</span> <span class="pl-en">Fruit</span>
<span class="pl-k">class</span> <span class="pl-en">Lemon</span> <span class="pl-k">extends</span> <span class="pl-e">Fruit</span>
<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">fruitPickler</span><span class="pl-k">:</span> <span class="pl-en">Pickler</span>[<span class="pl-en">Fruit</span>] <span class="pl-k">=</span> <span class="pl-k">???</span>
<span class="pl-k">val</span> <span class="pl-en">l</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">Lemon</span>()

<span class="pl-c">//won't compile, because we don't have a Pickler of *Lemons*</span>
<span class="pl-c">//Pickle(l)</span>

<span class="pl-c">//Acribing type Fruit (up-casting) compiles OK</span>
<span class="pl-en">Pickle</span>(<span class="pl-v">l</span>: <span class="pl-en">Fruit</span>)</pre>
  </div> 
  <h2><a id="user-content-contributors" class="anchor" href="https://github.com/benhutchison/prickle#contributors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Contributors</h2> 
  <p>Prickle is written and maintained by Ben Hutchison.</p> 
  <p>Credit &amp; thanks for prior work to Sebastien Doeraene for scala-js-pickling, Li Haoyi for microjson</p> 
  <p>Contributors: @xeno-by, @antonkulaga, @ddispaltro, @mysticfall</p> 
  <p>YourKit is kindly supporting this open source project with its full-featured <a href="http://www.yourkit.com/java/profiler/index.jsp" target="_blank">Java Profiler</a>.</p> 
 </article>
</div>