<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-sodatime-port-of-jodatime-for-scalascalajs" class="anchor" href="https://github.com/mdedetrich/soda-time#sodatime-port-of-jodatime-for-scalascalajs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>SodaTime, Port of JodaTime for Scala/Scala.js</h1> 
  <p><a href="https://gitter.im/mdedetrich/soda-time?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/mdedetrich/soda-time" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/mdedetrich/soda-time" target="_blank"><img src="https://camo.githubusercontent.com/f92eae3f3d5125028324189e4606c75fc0929490/68747470733a2f2f7472617669732d63692e6f72672f6d6465646574726963682f736f64612d74696d652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/mdedetrich/soda-time.svg?branch=master" style="max-width:100%;"></a></p> 
  <p>SodaTime is a port of <a href="http://www.joda.org/joda-time/" target="_blank">JodaTime</a> to Scala, so that it can be compiled with <code>Scala.js</code>. The intention is to have a cross compiled, high quality Date/Time library that can be used across all JVM's, as well as <code>Scala.js</code></p> 
  <h2><a id="user-content-goals" class="anchor" href="https://github.com/mdedetrich/soda-time#goals" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Goals</h2> 
  <ul> 
   <li>Be completely API compatible with <code>JodaTime</code> for both Scala (JVM) and as much as possible for <code>Scala.js</code>. Please see notable changes for more info.</li> 
  </ul> 
  <h2><a id="user-content-artifacts" class="anchor" href="https://github.com/mdedetrich/soda-time#artifacts" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Artifacts</h2> 
  <p>Current <code>SNAPSHOT</code> artifacts are deployed to SonaType Snapshots, so you should be able to use the current version using</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-s"><span class="pl-pds">"</span>org.mdedetrich<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>soda-time<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>0.0.1-SNAPSHOT<span class="pl-pds">"</span></span></pre>
  </div> 
  <h2><a id="user-content-what-still-needs-to-be-done" class="anchor" href="https://github.com/mdedetrich/soda-time#what-still-needs-to-be-done" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>What still needs to be done</h2> 
  <p>This is still <strong>ALPHA</strong> quality, Joda Time is a big library, and there is stuff that still needs to be done. Definitely try it out, but I wouldn't recommend using it in production.</p> 
  <ul class="contains-task-list"> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Take a look at sections of the converted code that used <code>continue</code>/<code>break</code> to a label.</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Tests</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> v2.8.x of the Joda-Time API (v2.7.x is what is currently being implemented)</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> <code>java.util.Locale</code> needs to be implemented</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Possible better solution for aux constructors</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Remove all mentions of file/io/streams from <code>Javascript</code> based API</li> 
   <li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" disabled> Adding utility methods for <code>Javascript</code> (i.e. java Date constructors)</li> 
  </ul> 
  <h2><a id="user-content-why" class="anchor" href="https://github.com/mdedetrich/soda-time#why" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Why</h2> 
  <p>The state of Date/Time libraries for <code>Java</code> is pretty grim (in fact its grim for most languages that haven't been made in the past decade). Because of this, <a href="http://www.joda.org/joda-time/" target="_blank">JodaTime</a> was created, which provided a high quality implementation of Date/Time library for Java.</p> 
  <p>In regards to Scala, most people just use <a href="http://www.joda.org/joda-time/" target="_blank">JodaTime</a>, and the few who have completely migrated to <code>JDK-8</code> use <code>JSR-310</code>. Unfortunately, this poses a problem for people intending to use <code>Scala.js</code> (and possible any other future backend for Scala).</p> 
  <ul> 
   <li><code>Scala.js</code> can only compile Scala source code, not Java source code/JVM bytecode. This means it won't work with <a href="http://www.joda.org/joda-time/" target="_blank">JodaTime</a></li> 
   <li>The <code>JSR-310</code> (designed to supersede <a href="http://www.joda.org/joda-time/" target="_blank">JodaTime</a>) has a GPL style license, which is incompatible with <code>Scala.js</code>'s license. This means that to implement <code>JSR-310</code> (i.e. <code>java.time.*</code>) for <code>Scala.js</code>, a complete cleanroom implementation of <code>java.time.*</code> needs to be done. Please see this <a href="https://github.com/scala-js/scala-js/issues/1618" target="_blank">ticket</a> for more info.</li> 
   <li>Even with <code>JSR-310</code> implemented, users who run on <code>JDK-7</code> and less will still be stuck. Although there are backports for <code>JSR-310</code>, it is still unknown whether these backports will work in context of <code>Scala.js</code> (needs to be confirmed)</li> 
   <li>Implementing a <strong>correct</strong> Date/Time library is really hard (see this <a href="https://www.youtube.com/watch?v=-5wpm-gesOY" target="_blank">video</a> for more info)</li> 
  </ul> 
  <p>Due to all of the above, the only real solution (at least for the short/medium term) is to have a cross compatile version of <a href="http://www.joda.org/joda-time/" target="_blank">JodaTime</a> that will work on <code>Java/Scala/Scala.js</code>). The ultimate solution would be to provide a clean version of a Date/Time library code Scala (something along the lines <code>scala.time.*</code>) that would be in the Scala <code>stdlib</code>. However due to the difficulty of coding a correct Date/Time library (as mentioned before), plus other reasons, we shouldn't be expecting this any time soon.</p> 
  <p>There are other reasons (outside of compatibility/cross platform) as to why you might want to use SodaTime.</p> 
  <ul> 
   <li>Its a clean implementation of Date/Time for javascript (unlike, for example, <a href="http://momentjs.com/" target="_blank">moment.js</a>, which uses <code>Javascript</code>'s <code>Date</code> object behind the scenes). <code>Javascript</code> clients (including web browsers) are notorious for having quirks in how they implement the <code>Javascript</code> <code>Date</code> object (see <a href="https://github.com/ChiperSoft/Kalendae/issues/134" target="_blank">here</a> as an example). <code>SodaTime</code> would not have an issue in this regard since it provides a correct implementation of Date/Time across all browsers (assuming that UTC timestamp retrieved from <code>Date.getMilliseconds</code> is correct)</li> 
   <li><code>JodaTime</code> has been battle tested for 13 years, and its the defacto standard for Date/Time on Java. This means its well tested. Any Java developer who is worth their salt uses <code>JodaTime</code>. <code>SodaTime</code> was mainly ported using the <a href="https://github.com/mysema/scalagen" target="_blank">Scalagen</a> library, which means that the majority of critical business logic code has been ported correctly and automatically. Please see methodology for more info</li> 
   <li>It has a very good design (even when used in <code>Scala</code>), due to it putting high emphasis on using immutable types</li> 
  </ul> 
  <h2><a id="user-content-differences" class="anchor" href="https://github.com/mdedetrich/soda-time#differences" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Differences</h2> 
  <h3><a id="user-content-breaking-api-differences" class="anchor" href="https://github.com/mdedetrich/soda-time#breaking-api-differences" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Breaking API differences</h3> 
  <p>There are difference for <code>SodaTime</code> on Scala.js, mainly due dealing with Javascript. In regards to API, there are <em>some</em> breaking changes, which are noted below</p> 
  <ul> 
   <li>Methods that deal with file operations (i.e. <code>java.io.File</code>) are not exported, as they make no sense on <code>Javascript</code></li> 
   <li>Error classes, such as <code>org.joda.IllegalFieldValueException</code>, only have a single primary constructor, rather than various constructors as the original <code>JodaTime</code>. This is because of a <code>Scala</code> limitation that does not allow you to have different <code>super</code> calls within different constructors. Since <code>IllegalFieldValueException</code> extends a class we have no control over (<code>java.lang.IllegalArgumentException</code>) we had no choice but to do this. Luckily, the use case for users making <code>IllegalFieldValueException</code> with custom error messages is non existent.</li> 
  </ul> 
  <h3><a id="user-content-other-api-changes" class="anchor" href="https://github.com/mdedetrich/soda-time#other-api-changes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Other API changes</h3> 
  <p>These are API changes which aren't breaking (i.e. usually the addition of certain utility methods)</p> 
  <ul> 
   <li>Constructors for <code>DateTime</code> for the <code>Javascript</code> <code>Date</code> object, i.e. from <code>Scala</code></li> 
  </ul> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">dateTime</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">org.joda.DateTime</span>(<span class="pl-k">new</span> <span class="pl-en">js.Date</span>())</pre>
  </div> 
  <p>And also from <code>Javascript</code></p> 
  <div class="highlight highlight-source-js">
   <pre><span class="pl-k">var</span> dateTime <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">org.joda</span>.<span class="pl-en">DateTime</span>(<span class="pl-k">new</span> <span class="pl-en">Date</span>());</pre>
  </div> 
  <h2><a id="user-content-methodology" class="anchor" href="https://github.com/mdedetrich/soda-time#methodology" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Methodology</h2> 
  <p>The main goal for <code>SodaTime</code> is to provide a correct implementation of <code>JodaTime</code> for <code>Scala</code>/<code>Scala.js</code>. At the same time, <code>JodaTime</code> itself is a massive library, so providing a clean, idiomatic Scala implementation of <code>JodaTime</code> is unrealistic and unwise. Such effort should be used in creating a new Scala implementation of a Date/Time library.</p> 
  <p>Hence to verify the correctness of SodaTime, we rely on the following principles</p> 
  <ul> 
   <li>The <code>JodaTime</code> implementation is itself is "correct". Note that JodaTime itself may not be correct, but if this is the case, then we want <code>SodaTime</code> to simulate this</li> 
   <li>Following on, the code that is converted from <code>JodaTime</code> using <code>ScalaGen</code> will be mainly correct in regards to business logic (see below for more details)</li> 
   <li>Converting the test cases from <code>JodaTime</code>, and implementing our own.</li> 
  </ul> 
  <p>With this in mind, we generally want to leverage as many tools/methods to obtain this goal, described below</p> 
  <ol> 
   <li><p>Convert the <code>Java</code> code to <code>Scala</code> code using <code>ScalaGen</code>, one can also use <a href="http://javatoscala.com/" target="_blank">javatoscala</a>. <code>ScalaGen</code> is not perfect, and it has issues with the following (in order of being problematic)</p> 
    <ol> 
     <li>break/continue/break to label. Only <code>break</code> is supported in <code>Scala</code>, (and that is through an explicit import, <code>scala.util.control.Breaks._</code>). This is the only known change that <code>ScalaGen</code> does which actually breaks business logic (at least on a semantic level) apart from switch statements. <code>ScalaGen</code> will usually output commented code such as <code>// break</code> or <code>// continue</code> in this case . To fix this, the following is done 
      <ul> 
       <li>If its only a <code>break</code>, we do use <code>scala.util.control.Break</code></li> 
       <li>If its a continue, we simulate the behaviour using a flag <code>name</code>continueFlag<code>) in code, along with a simple</code>if` condition.</li> 
       <li>If its a break to label, we have to manually rewrite the code. we have to carefully rewrite the code </li> 
      </ul></li> 
     <li><p><code>ScalaGen</code> will try to convert <code>switch</code> statement to <code>match</code>, however it usually doesn't fully work for because of the existence/ non existence of break. Here are the following issues with this</p> 
      <ul> 
       <li>It Typically places the Scala equivalent of <code>default</code> (<code>case _ =&gt;</code>) statement at the top of the match block, which is obviously semantically different to how the <code>default</code> works in switch. <code>Scala</code> compiler will emit a warning to detect this, and its an easy fix (move the <code>case _ =&gt;</code> to the bottom of the match statement). There are however </li> 
       <li><p><code>Java</code> switch uses <code>break</code>. Depending on what the switch statement does, this may or may not be semantically equivalent. As an example, the following code attempts to mutate a variable</p> 
        <div class="highlight highlight-source-java">
         <pre><span class="pl-smi">String</span> seconds;
<span class="pl-k">switch</span> (getSeconds()) {
    <span class="pl-k">default</span><span class="pl-k">:</span> 
        seconds <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>;
        <span class="pl-k">break</span>;
    <span class="pl-k">case</span> <span class="pl-c1">1</span><span class="pl-k">:</span>
        seconds <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>one<span class="pl-pds">"</span></span>;
        <span class="pl-k">break</span>;
}</pre>
        </div> <p>The equivalent can be converted to</p> 
        <div class="highlight highlight-source-scala">
         <pre><span class="pl-k">val</span> <span class="pl-en">seconds</span> <span class="pl-k">=</span> getSeconds() <span class="pl-k">match</span> {
  <span class="pl-k">case</span> <span class="pl-c1">1</span> <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>1<span class="pl-pds">"</span></span>
  <span class="pl-k">case</span> _ <span class="pl-k">=&gt;</span> <span class="pl-s"><span class="pl-pds">"</span>0<span class="pl-pds">"</span></span>
}</pre>
        </div> <p>Sometimes its not so straight forward, especially when there is a combination of side effects/mutation. Generally speaking, generated match statements should be inspected</p></li> 
      </ul></li> 
     <li>Generally doesn't work with constructors/super/subclassing. This is mainly due to the fact that <code>Scala</code> doesn't support all of the <code>Java</code>s methdods of instantiating a new class. As an example, <code>Scala</code> has no API equivalent of supporting multiple different <code>super</code> calls in different constructors of the same class. When this occurs, we either use auxiallary constructors (named <code>auxConstructor</code>) if we have control of the classes that is being extended, else we resort making an API incompatible change which involves manually creating constructors in a companion object (see <code>org.joda.IllegalFieldValueException</code> for more info). In this sitaution, the following this done 
      <ul> 
       <li>Attempt to manually rewrite the constructors. If there is a common super constructor, we can avoid the before mentioned limitation</li> 
       <li>If the above isn't the case, we create an empty constructor (which doesn't initialize any state), and then we make <code>auxConstructors</code> in the super class to simulate the same behaviour.</li> 
       <li>If we don't have control over the super class (i.e the case with <code>org.joda.IllegalFieldValueException</code>), we have to make a breaking <code>API</code> change, and use factory instant creation methods in the companion object. So far, this has only occurred for exception classes</li> 
       <li>Not onlining parameters properly. <code>JodaTime</code> uses the Java conversion of using constructors to set internal private mutable variables. <code>ScalaGen</code> usually tries to move these online private variables into the constructor, which combined with the general super/constructor issues, causes problems. This code is often rewritten to resemble the <code>Java</code> equivalent</li> 
      </ul></li> 
     <li><p>Side effect statements. The <code>Java</code> code written in <code>JodaTime</code> has some parts which is written like old C style, with the equivalent expressions either not existing in <code>Scala</code>, or being semantically different. Examples include</p> 
      <ul> 
       <li><p>The following <code>Java</code> code</p> 
        <div class="highlight highlight-source-java">
         <pre>    <span class="pl-k">if</span> (c <span class="pl-k">=</span> getSomeChar()) {
        <span class="pl-c">// Do stuff</span>
    };</pre>
        </div> <p>Is legitimate, and the return type of that code is <code>Char</code> (assuming that <code>getSomeChar()</code> returns a <code>Char</code> and type of <code>c</code> is <code>Char</code>). The equivalent (which is what <code>ScalaGen</code> outputs) returns type <code>Unit</code>, which often means the code needs to be rewritten to something like</p> 
        <div class="highlight highlight-source-scala">
         <pre>    <span class="pl-k">if</span> ({c <span class="pl-k">=</span> getSomeChar();c}) {
        <span class="pl-c">// Do stuff</span>
    }</pre>
        </div></li> 
       <li><p>Another example is double assignment, which is often used in <code>C</code>, i.e.</p> 
        <div class="highlight highlight-source-java">
         <pre>someVar <span class="pl-k">=</span> anotherVar <span class="pl-k">=</span> yetAnotherVar;</pre>
        </div> <p>This has no <code>Scala</code> equivalent, so its rewritten to</p> 
        <div class="highlight highlight-source-scala">
         <pre>someVar <span class="pl-k">=</span> anotherVar
anotherVar <span class="pl-k">=</span> yetAnotherVar</pre>
        </div></li> 
       <li><p>There is also the shorthand increment operation, which often doesn't work in <code>Scala</code>. i.e.</p> 
        <div class="highlight highlight-source-java">
         <pre><span class="pl-smi">Int</span> counter <span class="pl-k">=</span> <span class="pl-c1">0</span>;
counter <span class="pl-k">+=</span> <span class="pl-c1">1</span>;</pre>
        </div> <p>In scala this is done like so</p> 
        <div class="highlight highlight-source-scala">
         <pre><span class="pl-k">var</span> <span class="pl-en">counter</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
counter <span class="pl-k">=</span> counter <span class="pl-k">+</span> <span class="pl-c1">1</span></pre>
        </div></li> 
      </ul></li> 
     <li><p>Not creating <code>var</code>'s when variable referenced is method a parameter. As an example, <code>ScalaGen</code> usually creates the following</p> 
      <div class="highlight highlight-source-scala">
       <pre>      <span class="pl-k">def</span> <span class="pl-en">toDateTime</span>(<span class="pl-v">zone</span>: <span class="pl-en">DateTimeZone</span>)<span class="pl-k">:</span> <span class="pl-en">DateTime</span> <span class="pl-k">=</span> {
        zone <span class="pl-k">=</span> <span class="pl-en">DateTimeUtils</span>.getZone(zone)
        <span class="pl-k">if</span> (getZone <span class="pl-k">==</span> zone) {
          <span class="pl-k">return</span> <span class="pl-v">this</span>
        }
        <span class="pl-v">super</span>.toDateTime(zone)
      }</pre>
      </div> <p>Which wont compile, so this is what is often done</p> 
      <div class="highlight highlight-source-scala">
       <pre>      <span class="pl-k">override</span> <span class="pl-k">def</span> <span class="pl-en">toDateTime</span>(<span class="pl-v">zone</span>: <span class="pl-en">DateTimeZone</span>)<span class="pl-k">:</span> <span class="pl-en">DateTime</span> <span class="pl-k">=</span> {
        <span class="pl-k">var</span> <span class="pl-en">_zone</span> <span class="pl-k">=</span> zone
        _zone <span class="pl-k">=</span> <span class="pl-en">DateTimeUtils</span>.getZone(_zone)
        <span class="pl-k">if</span> (getZone <span class="pl-k">==</span> _zone) {
          <span class="pl-k">return</span> <span class="pl-v">this</span>
        }
        <span class="pl-v">super</span>.toDateTime(_zone)
      }</pre>
      </div></li> 
     <li>Not adding overrides. <code>ScalaGen</code> sometimes won't create overrides for functions which override super members. This isn't really the fault of the tool, since <code>@Override</code> is a convention in <code>Java</code>, where as the <code>Scala</code> compiler will force you to use <code>override</code> if you are overriding the super member. Thankfully, <code>IntelliJ</code> has an inspection which picks this up automatically</li> 
     <li><p><code>ScalaGen</code> doesn't correctly generate for loops for <code>Java</code> code that uses the <code>Consumer</code> API. It will convert the <code>Java</code> for statement</p> 
      <div class="highlight highlight-source-java">
       <pre><span class="pl-k">for</span> (item <span class="pl-k">:</span> someCollection) {
    \\ <span class="pl-smi">Do</span> stuff
};</pre>
      </div> <p>Into this</p> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">for</span> (item <span class="pl-k">&lt;</span><span class="pl-k">-</span> someCollection) {
    \\ <span class="pl-en">Do</span> stuff
}</pre>
      </div> <p>The scala converted code will show as correct in some tools (i.e. Intellij), but it won't compile. Scala doesn't (yet) have interopt for the Java consumer API. This means the above code will be typically changed to</p> 
      <div class="highlight highlight-source-scala">
       <pre><span class="pl-k">val</span> <span class="pl-en">iterator</span> <span class="pl-k">=</span> someCollection.iterator

<span class="pl-k">while</span>(iterator.hasNext) {
    <span class="pl-c">// Do stuff here</span>
}</pre>
      </div></li> 
     <li><p>Manually annotate types, <code>Scalagen</code> by default doesn't annotate converted variable declarations types. This usually isn't an issue, but there are instances of implicitly converted types which don't work out (<code>i.e.</code> conversions between <code>Long</code>/<code>Int</code>, and vice versa). Manually specifying the type (i.e. <code>var millis:Long</code>) fixes this problem</p></li> 
    </ol></li> 
   <li>At this point, the code will usually compile, so we do the following things 
    <ul> 
     <li>Really quick and easy syntax fixes. As an example, <code>ScalaGen</code> sometimes unnecessarily puts statements in extra enclosing parenthesis, amongst other things</li> 
    </ul></li> 
   <li><p>Split out the code into <code>js</code> and <code>jvm</code> if it makes sense to do so. The following are reasons why you would do this</p> 
    <ul> 
     <li>Replace internal collections used in business logic to ones that make sense and/or ones that have JS equivalent (performance). Examples includes 
      <ul> 
       <li>Using <code>js.Array</code> instead of <code>Array</code> internally for performance reasons</li> 
       <li>Changing <code>java.util.concurrent.ConcurrentHashMap</code> to standard <code>java.util.HashMap</code> internally (<code>Javascript</code> has no concept of multithreading, so concurrent data structures are not required)</li> 
       <li>In general using Scala collections over Java ones for <code>Javascript</code> implementation. This is because <code>Scala.js</code> uses a deep linking optimizer, and people are much more likely to use Scala collections than Java ones, saving room on theoretical outputted <code>Javascript</code> size. <code>JVM</code> implementation is untouched, as there is little point in converting it to <code>Scala</code> collections</li> 
      </ul></li> 
     <li>Providing alternate types to the <code>opaque</code> types to be @JSExported. This is done just for the <code>Javascript</code> access to the API</li> 
     <li>Adding extra constructors for JS types (i.e. <code>Javascripts</code> array as <code>js.Array</code> as well as <code>scala.Array</code>)</li> 
     <li><p>Separate implementations of annotations that don't make sense on <code>Javascript</code>. i.e., for <code>joda.convert.ToString</code>, the <code>JVM</code> version is a <code>Java</code> source that looks like this (which is an exact copy of the source from <code>JodaTime</code>)</p> 
      <div class="highlight highlight-source-java">
       <pre>       @Target(<span class="pl-smi">ElementType</span><span class="pl-c1"><span class="pl-k">.</span>METHOD</span>)
       @Retention(<span class="pl-smi">RetentionPolicy</span><span class="pl-c1"><span class="pl-k">.</span>RUNTIME</span>)
       <span class="pl-k">public</span> <span class="pl-k">@interface</span> <span class="pl-en">ToString</span> {

       }</pre>
      </div> <p>The JS version looks like this</p> 
      <div class="highlight highlight-source-scala">
       <pre>   <span class="pl-k">import</span> <span class="pl-v">scala.annotation.</span><span class="pl-v">StaticAnnotation</span>

   <span class="pl-k">class</span> <span class="pl-en">ToString</span> <span class="pl-k">extends</span> <span class="pl-e">StaticAnnotation</span></pre>
      </div></li> 
    </ul></li> 
  </ol> 
 </article>
</div>