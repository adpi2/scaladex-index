<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-simple-scala-amqp-client" class="anchor" href="https://github.com/sstone/amqp-client#simple-scala-amqp-client" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Simple Scala AMQP client</h1> 
  <p>Simple <a href="http://www.amqp.org/" target="_blank">AMQP</a> client in Scala/Akka based on the <a href="http://www.rabbitmq.com/" target="_blank">RabbitMQ</a> java client.</p> 
  <p><a href="https://travis-ci.org/sstone/amqp-client" target="_blank"><img src="https://camo.githubusercontent.com/3d690872362d4b418fd3c80c3a47df1ba0663d72/68747470733a2f2f7472617669732d63692e6f72672f7373746f6e652f616d71702d636c69656e742e706e673f6272616e63683d7363616c61322e3130" alt="Build Status" data-canonical-src="https://travis-ci.org/sstone/amqp-client.png?branch=scala2.10" style="max-width:100%;"></a></p> 
  <h2><a id="user-content-overview" class="anchor" href="https://github.com/sstone/amqp-client#overview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Overview</h2> 
  <p>This client provides a simple API for</p> 
  <ul> 
   <li>publishing and consuming messages over AMQP</li> 
   <li>setting up RPC clients and servers</li> 
   <li>automatic reconnection</li> 
  </ul> 
  <p>It is based on the <a href="http://akka.io/" target="_blank">Akka</a> 2.0 framework.</p> 
  <h2><a id="user-content-limitations-and-compatibility-issues" class="anchor" href="https://github.com/sstone/amqp-client#limitations-and-compatibility-issues" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Limitations and compatibility issues</h2> 
  <ul> 
   <li>This client is compatible with AMQP 0.9.1, not AMQP 1.0.</li> 
   <li>This client is most probably not easily usable from Java</li> 
  </ul> 
  <h2><a id="user-content-production-status" class="anchor" href="https://github.com/sstone/amqp-client#production-status" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>"Production" status</h2> 
  <p>This very simple library is being used in production in a few projects now, either directly or through the <a href="https://github.com/sstone/akka-amqp-proxies" target="_blank">Akka AMQP Proxies pattern</a>, and so far so good.... So it kind of works and will be maintained for some time :-)</p> 
  <h2><a id="user-content-configuring-mavensbt" class="anchor" href="https://github.com/sstone/amqp-client#configuring-mavensbt" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Configuring maven/sbt</h2> 
  <ul> 
   <li>releases and milestones are pushed to maven central</li> 
   <li>snapshots are pushed to the sonatype snapshot repository</li> 
  </ul> 
  <div class="highlight highlight-text-xml">
   <pre> &lt;<span class="pl-ent">repositories</span>&gt;
    &lt;<span class="pl-ent">repository</span>&gt;
        &lt;<span class="pl-ent">id</span>&gt;sonatype snapshots&lt;/<span class="pl-ent">id</span>&gt;
        &lt;<span class="pl-ent">url</span>&gt;https://oss.sonatype.org/content/repositories/snapshots/&lt;/<span class="pl-ent">url</span>&gt;
    &lt;/<span class="pl-ent">repository</span>&gt;
&lt;/<span class="pl-ent">repositories</span>&gt;

&lt;<span class="pl-ent">dependencies</span>&gt;
  &lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;com.github.sstone&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;amqp-client_SCALA-VERSION&lt;/<span class="pl-ent">artifactId</span>&gt;
    &lt;<span class="pl-ent">version</span>&gt;1.5&lt;/<span class="pl-ent">version</span>&gt;
  &lt;/<span class="pl-ent">dependency</span>&gt;
  &lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;com.typesafe.akka&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;akka-actor&lt;/<span class="pl-ent">artifactId</span>&gt; <span class="pl-c"><span class="pl-c">&lt;!--</span> for Akka 2.0.X <span class="pl-c">--&gt;</span></span>
    &lt;<span class="pl-ent">artifactId</span>&gt;akka-actor_SCALA-VERSION&lt;/<span class="pl-ent">artifactId</span>&gt; <span class="pl-c"><span class="pl-c">&lt;!--</span> from Akka 2.1.X on <span class="pl-c">--&gt;</span></span>
    &lt;<span class="pl-ent">version</span>&gt;AKKA-VERSION&lt;/<span class="pl-ent">version</span>&gt;
  &lt;/<span class="pl-ent">dependency</span>&gt;
&lt;/<span class="pl-ent">dependencies</span>&gt;</pre>
  </div> 
  <p>Please note that the Akka dependency is now in the "provided" scope which means that you'll have to define it explicitly in your maven/sbt projects. </p> 
  <p>The latest snapshot (development) version is 1.6-SNAPSHOT, the latest released version is 1.5</p> 
  <ul> 
   <li>amqp-client 1.0 is compatible with Scala 2.9.2 and Akka 2.0.3</li> 
   <li>amqp-client 1.1 is compatible with Scala 2.9.2 and Akka 2.0.5</li> 
   <li>amqp-client 1.1 is compatible with Scala 2.10.0 and Akka 2.1.0</li> 
   <li>amqp-client 1.2 is compatible with Scala 2.10 and Akka 2.1</li> 
   <li>amqp-client 1.3 is compatible with Scala 2.10 and Akka 2.2</li> 
   <li>amqp-client 1.4 is compatible with Scala 2.10, Scala 2.11 and Akka 2.3.2</li> 
   <li>amqp-client 1.5 is compatible with Scala 2.10, Scala 2.11 and Akka 2.3.11</li> 
   <li>amqp-client 1.6-SNAPSHOT is compatible with Scala 2.10, Scala 2.11 and Akka 2.4.3</li> 
  </ul> 
  <h2><a id="user-content-library-design" class="anchor" href="https://github.com/sstone/amqp-client#library-design" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Library design</h2> 
  <p>This is a thin wrapper over the RabbitMQ java client, which tries to take advantage of the nice actor model provided by the Akka library. There is no effort to "hide/encapsulate" the RabbitMQ library (and I don't really see the point anyway since AMQP is a binary protocol spec, not an API spec). So to make the most of this library you should first check the documentation for the RabbitMQ client, and learn a bit about AMQP 0.9.1. There are very nice tutorial on the <a href="http://www.rabbitmq.com/" target="_blank">RabbitMQ</a> website, and also <a href="http://www.zeromq.org/whitepapers:amqp-analysis" target="_blank">there</a>, and probably many other...</p> 
  <h3><a id="user-content-connection-and-channel-management" class="anchor" href="https://github.com/sstone/amqp-client#connection-and-channel-management" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Connection and channel management</h3> 
  <ul> 
   <li>AMQP connections are equivalent to "physical" connections. They are managed by ConnectionOwner objects. Each ConnectionOwner object manages a single connection and will try and reconnect when the connection is lost.</li> 
   <li>AMQP channels are multiplexed over AMQP connections. You use channels to publish and consume messages. Channels are managed by ChannelOwner objects.</li> 
  </ul> 
  <p>ConnectionOwner and ChannelOwner are implemened as Akka actors:</p> 
  <ul> 
   <li>channel owners are created by connection owners</li> 
   <li>when a connection is lost, the connection owner will create a new connection and provide each of its children with a new channel</li> 
   <li>connection owners and channel owners are implemented as Finite State Machines, with 2 possible states: Connected and Disconnected</li> 
   <li>For a connection owner, "connected" means that it owns a valid connection to the AMQP broker</li> 
   <li>For a channel owner, "connected" means that it owns a valid AMQP channel</li> 
  </ul> 
  <p>YMMV, but using few connections (one per JVM) and many channels per connection (one per thread) is a common practice.</p> 
  <h3><a id="user-content-wrapping-the-rabbitmq-client" class="anchor" href="https://github.com/sstone/amqp-client#wrapping-the-rabbitmq-client" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Wrapping the RabbitMQ client</h3> 
  <p>As explained above, this is an actor-based wrapper around the RabbitMQ client, with 2 main classes: ConnectionOwner and ChannelOwner. Instead of calling the RabbitMQ <a href="http://www.rabbitmq.com/releases/rabbitmq-java-client/v3.1.1/rabbitmq-java-client-javadoc-3.1.1/com/rabbitmq/client/Channel.html" target="_blank">Channel</a> interface, you send a message to a ChannelOwner actor, which replies with whatever the java client returned wrapped in an Amqp.Ok() message if the call was successful, or an Amqp.Error if it failed.</p> 
  <p>For example, to declare a queue you could write:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">connFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ConnectionFactory</span>()
  connFactory.setUri(<span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost/%2F<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">conn</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">ConnectionOwner</span>.props(connFactory, <span class="pl-c1">1</span> second))
  <span class="pl-k">val</span> <span class="pl-en">channel</span> <span class="pl-k">=</span> <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">ChannelOwner</span>.props())

  channel <span class="pl-k">!</span> <span class="pl-en">DeclareQueue</span>(<span class="pl-en">QueueParameters</span>(<span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">false</span>, durable <span class="pl-k">=</span> <span class="pl-c1">false</span>, exclusive <span class="pl-k">=</span> <span class="pl-c1">false</span>, autodelete <span class="pl-k">=</span> <span class="pl-c1">true</span>))
</pre>
  </div> 
  <p>Or, if you want to check the number of messages in a queue:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">connFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ConnectionFactory</span>()
  connFactory.setUri(<span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost/%2F<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">conn</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">ConnectionOwner</span>.props(connFactory, <span class="pl-c1">1</span> second))
  <span class="pl-k">val</span> <span class="pl-en">channel</span> <span class="pl-k">=</span> <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">ChannelOwner</span>.props())

  <span class="pl-k">val</span> <span class="pl-en">Amqp</span>.<span class="pl-en">Ok</span>(_, <span class="pl-en">Some</span>(<span class="pl-v">result</span>: <span class="pl-en">Queue</span>.<span class="pl-en">DeclareOk</span>)) <span class="pl-k">=</span> <span class="pl-en">Await</span>.result(
    (channel <span class="pl-k">?</span> <span class="pl-en">DeclareQueue</span>(<span class="pl-en">QueueParameters</span>(name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">true</span>))).mapTo[<span class="pl-en">Amqp</span>.<span class="pl-en">Ok</span>],
    <span class="pl-c1">5</span> seconds
  )
  println(<span class="pl-s"><span class="pl-pds">"</span>there are %d messages in the queue named %s<span class="pl-pds">"</span></span>.format(result.getMessageCount, result.getQueue))
</pre>
  </div> 
  <h3><a id="user-content-initialization-and-failure-handling" class="anchor" href="https://github.com/sstone/amqp-client#initialization-and-failure-handling" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Initialization and failure handling</h3> 
  <p>If the connection to the broker is lost, ConnectionOwner actors will try and reconnect, and once they are connected again they will send a new AMQP channel to each of their ChannelOwner children.</p> 
  <p>Likewise, if the channel owned by a ChannelOwner is shut down because of an error it will request a new one from its parent.</p> 
  <p>In this case you might want to "replay" some of the messages that were sent to the ChannelOwner actor before it lost its channel, like queue declarations and bindings.</p> 
  <p>For this, you have 2 options:</p> 
  <ul> 
   <li>initialize the ChannelOwner with a list of requests</li> 
   <li>wrap requests inside a Record message</li> 
  </ul> 
  <p>Here, queues and bindings will be gone if the connection is lost and restored:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">connFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ConnectionFactory</span>()
  connFactory.setUri(<span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost/%2F<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">conn</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">ConnectionOwner</span>.props(connFactory, <span class="pl-c1">1</span> second))

  <span class="pl-c"><span class="pl-c">//</span> create an actor that will receive AMQP deliveries</span>
  <span class="pl-k">val</span> <span class="pl-en">listener</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">Props</span>(<span class="pl-k">new</span> <span class="pl-en">Actor</span> {
    <span class="pl-k">def</span> <span class="pl-en">receive</span> <span class="pl-k">=</span> {
      <span class="pl-k">case</span> <span class="pl-en">Delivery</span>(consumerTag, envelope, properties, body) <span class="pl-k">=&gt;</span> {
        println(<span class="pl-s"><span class="pl-pds">"</span>got a message: <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-k">new</span> <span class="pl-en">String</span>(body))
        sender <span class="pl-k">!</span> <span class="pl-en">Ack</span>(envelope.getDeliveryTag)
      }
    }
  }))

  <span class="pl-c"><span class="pl-c">//</span> create a consumer that will route incoming AMQP messages to our listener</span>
  <span class="pl-c"><span class="pl-c">//</span> it starts with an empty list of queues to consume from</span>
  <span class="pl-k">val</span> <span class="pl-en">consumer</span> <span class="pl-k">=</span> <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">Consumer</span>.props(listener, channelParams <span class="pl-k">=</span> <span class="pl-c1">None</span>, autoack <span class="pl-k">=</span> <span class="pl-c1">false</span>))

  <span class="pl-c"><span class="pl-c">//</span> wait till everyone is actually connected to the broker</span>
  <span class="pl-en">Amqp</span>.waitForConnection(system, consumer).await()

  <span class="pl-c"><span class="pl-c">//</span> create a queue, bind it to a routing key and consume from it</span>
  <span class="pl-c"><span class="pl-c">//</span> here we don't wrap our requests inside a Record message, so they won't replayed when if the connection to</span>
  <span class="pl-c"><span class="pl-c">//</span> the broker is lost: queue and binding will be gone</span>

  <span class="pl-c"><span class="pl-c">//</span> create a queue</span>
  <span class="pl-k">val</span> <span class="pl-en">queueParams</span> <span class="pl-k">=</span> <span class="pl-en">QueueParameters</span>(<span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">false</span>, durable <span class="pl-k">=</span> <span class="pl-c1">false</span>, exclusive <span class="pl-k">=</span> <span class="pl-c1">false</span>, autodelete <span class="pl-k">=</span> <span class="pl-c1">true</span>)
  consumer <span class="pl-k">!</span> <span class="pl-en">DeclareQueue</span>(queueParams)
  <span class="pl-c"><span class="pl-c">//</span> bind it</span>
  consumer <span class="pl-k">!</span> <span class="pl-en">QueueBind</span>(queue <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, exchange <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>amq.direct<span class="pl-pds">"</span></span>, routing_key <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>)
  <span class="pl-c"><span class="pl-c">//</span> tell our consumer to consume from it</span>
  consumer <span class="pl-k">!</span> <span class="pl-en">AddQueue</span>(<span class="pl-en">QueueParameters</span>(name <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">false</span>))
</pre>
  </div> 
  <p>We can initialize our consumer with a list of messages that will be replayed each time its receives a new channel:</p> 
  <div class="highlight highlight-source-scala">
   <pre> <span class="pl-k">val</span> <span class="pl-en">consumer</span> <span class="pl-k">=</span> <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">Consumer</span>.props(
    listener <span class="pl-k">=</span> <span class="pl-en">Some</span>(listener),
    init <span class="pl-k">=</span> <span class="pl-en">List</span>(<span class="pl-en">AddBinding</span>(<span class="pl-en">Binding</span>(<span class="pl-en">StandardExchanges</span>.amqDirect, queueParams, <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>)))
  ), name <span class="pl-k">=</span> <span class="pl-en">Some</span>(<span class="pl-s"><span class="pl-pds">"</span>consumer<span class="pl-pds">"</span></span>))
</pre>
  </div> 
  <p>Or can can wrap our initialization messages with Record to make sure they will be replayed each time its receives a new channel:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  consumer <span class="pl-k">!</span> <span class="pl-en">Record</span>(<span class="pl-en">AddBinding</span>(<span class="pl-en">Binding</span>(<span class="pl-en">StandardExchanges</span>.amqDirect, <span class="pl-en">QueueParameters</span>(<span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">false</span>, durable <span class="pl-k">=</span> <span class="pl-c1">false</span>, exclusive <span class="pl-k">=</span> <span class="pl-c1">false</span>, autodelete <span class="pl-k">=</span> <span class="pl-c1">true</span>), <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>)))
</pre>
  </div> 
  <p>If you have a reason to add a heartbeat (for instance, to keep your load balancer from dropping the connection), you can easily do so:</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-k">val</span> <span class="pl-en">connFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ConnectionFactory</span>()
  connFactory.setRequestedHeartbeat(<span class="pl-c1">5</span>) <span class="pl-c"><span class="pl-c">//</span> seconds</span></pre>
  </div> 
  <h2><a id="user-content-rpc-patterns" class="anchor" href="https://github.com/sstone/amqp-client#rpc-patterns" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>RPC patterns</h2> 
  <p>Typical RPC with AMQP follows this pattern:</p> 
  <ol> 
   <li> client sets up a private, exclusive response queue</li> 
   <li> client sends message and set their 'replyTo' property to the name of this response queue</li> 
   <li> server processes the message and replies to its 'replyTo' queue by publishing the response to the default exchange using the queue name as routing key (all queues are bound to their name on the default exchange)</li> 
  </ol> 
  <h3><a id="user-content-distributed-worker-pattern" class="anchor" href="https://github.com/sstone/amqp-client#distributed-worker-pattern" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Distributed Worker Pattern</h3> 
  <p>This is one of the simplest but most useful pattern: using a shared queue to distributed work among consumers. The broker will load-balance messages between these consumers using round-robin distribution, which can be combined with 'prefetch' channel settings. Setting 'prefetch' to 1 is very useful if you need resource-based (CPU, ...) load-balancing. You will typically use explicit acknowledgments and ack messages once they have been processed and the response has been sent. This way, if your consumer fails to process the request or is disconnected, the broker will re-send the same request to another consumer.</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-c"><span class="pl-c">//</span> typical "work queue" pattern, where a job can be picked up by any running node</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>(<span class="pl-s"><span class="pl-pds">"</span>mySystem<span class="pl-pds">"</span></span>)

  <span class="pl-c"><span class="pl-c">//</span> create an AMQP connection</span>
  <span class="pl-k">val</span> <span class="pl-en">connFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ConnectionFactory</span>()
  connFactory.setUri(<span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost/%2F<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">conn</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">ConnectionOwner</span>.props(connFactory, <span class="pl-c1">1</span> second))

  <span class="pl-k">val</span> <span class="pl-en">queueParams</span> <span class="pl-k">=</span> <span class="pl-en">QueueParameters</span>(<span class="pl-s"><span class="pl-pds">"</span>my_queue<span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">false</span>, durable <span class="pl-k">=</span> <span class="pl-c1">false</span>, exclusive <span class="pl-k">=</span> <span class="pl-c1">false</span>, autodelete <span class="pl-k">=</span> <span class="pl-c1">true</span>)

  <span class="pl-c"><span class="pl-c">//</span> create 2 equivalent servers</span>
  <span class="pl-k">val</span> <span class="pl-en">rpcServers</span> <span class="pl-k">=</span> <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">1</span> to <span class="pl-c1">2</span>) <span class="pl-k">yield</span> {
    <span class="pl-c"><span class="pl-c">//</span> create a "processor"</span>
    <span class="pl-c"><span class="pl-c">//</span> in real life you would use a serialization framework (json, protobuf, ....), define command messages, etc...</span>
    <span class="pl-c"><span class="pl-c">//</span> check the Akka AMQP proxies project for examples</span>
    <span class="pl-k">val</span> <span class="pl-en">processor</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">IProcessor</span> {
      <span class="pl-k">def</span> <span class="pl-en">process</span>(<span class="pl-v">delivery</span>: <span class="pl-en">Delivery</span>) <span class="pl-k">=</span> {
        <span class="pl-c"><span class="pl-c">//</span> assume that the message body is a string</span>
        <span class="pl-k">val</span> <span class="pl-en">response</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>response to <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-k">new</span> <span class="pl-en">String</span>(delivery.body)
        <span class="pl-en">Future</span>(<span class="pl-en">ProcessResult</span>(<span class="pl-en">Some</span>(response.getBytes)))
      }
      <span class="pl-k">def</span> <span class="pl-en">onFailure</span>(<span class="pl-v">delivery</span>: <span class="pl-en">Delivery</span>, <span class="pl-v">e</span>: <span class="pl-en">Throwable</span>) <span class="pl-k">=</span> <span class="pl-en">ProcessResult</span>(<span class="pl-c1">None</span>) <span class="pl-c"><span class="pl-c">//</span> we don't return anything</span>
    }
    <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">RpcServer</span>.props(queueParams, <span class="pl-en">StandardExchanges</span>.amqDirect,  <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>, processor, <span class="pl-en">ChannelParameters</span>(qos <span class="pl-k">=</span> <span class="pl-c1">1</span>)))
  }

  <span class="pl-k">val</span> <span class="pl-en">rpcClient</span> <span class="pl-k">=</span> <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">RpcClient</span>.props())

  <span class="pl-c"><span class="pl-c">//</span> wait till everyone is actually connected to the broker</span>
  <span class="pl-en">Amqp</span>.waitForConnection(system, <span class="pl-v">rpcServers</span>: _<span class="pl-k">*</span>).await()
  <span class="pl-en">Amqp</span>.waitForConnection(system, rpcClient).await()

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">timeout</span><span class="pl-k">:</span> <span class="pl-en">Timeout</span> <span class="pl-k">=</span> <span class="pl-c1">2</span> seconds

  <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">0</span> to <span class="pl-c1">5</span>) {
    <span class="pl-k">val</span> <span class="pl-en">request</span> <span class="pl-k">=</span> (<span class="pl-s"><span class="pl-pds">"</span>request <span class="pl-pds">"</span></span> <span class="pl-k">+</span> i).getBytes
    <span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> (rpcClient <span class="pl-k">?</span> <span class="pl-en">Request</span>(<span class="pl-en">List</span>(<span class="pl-en">Publish</span>(<span class="pl-s"><span class="pl-pds">"</span>amq.direct<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>, request)))).mapTo[<span class="pl-en">RpcClient</span>.<span class="pl-en">Response</span>]
    f.onComplete {
      <span class="pl-k">case</span> <span class="pl-en">Success</span>(response) <span class="pl-k">=&gt;</span> println(<span class="pl-k">new</span> <span class="pl-en">String</span>(response.deliveries.head.body))
      <span class="pl-k">case</span> <span class="pl-en">Failure</span>(error) <span class="pl-k">=&gt;</span> println(error)
    }
  }
  <span class="pl-c"><span class="pl-c">//</span> wait 10 seconds and shut down</span>
  <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">10000</span>)
  system.shutdown()
</pre>
  </div> 
  <h3><a id="user-content-one-requestseveral-responses" class="anchor" href="https://github.com/sstone/amqp-client#one-requestseveral-responses" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>One request/several responses</h3> 
  <p>If your process is "sharded" and one request should result in several responses (one per shard for example) you can use private exclusive queues which are all bound to the same key. In this case, each server will receive the same request and will send back a response.</p> 
  <p>This is very useful if you want to break a single operation into multiple, parallel steps.</p> 
  <div class="highlight highlight-source-scala">
   <pre>  <span class="pl-c"><span class="pl-c">//</span> one request/several responses pattern</span>
  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">system</span> <span class="pl-k">=</span> <span class="pl-en">ActorSystem</span>(<span class="pl-s"><span class="pl-pds">"</span>mySystem<span class="pl-pds">"</span></span>)

  <span class="pl-c"><span class="pl-c">//</span> create an AMQP connection</span>
  <span class="pl-k">val</span> <span class="pl-en">connFactory</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">ConnectionFactory</span>()
  connFactory.setUri(<span class="pl-s"><span class="pl-pds">"</span>amqp://guest:guest@localhost/%2F<span class="pl-pds">"</span></span>)
  <span class="pl-k">val</span> <span class="pl-en">conn</span> <span class="pl-k">=</span> system.actorOf(<span class="pl-en">ConnectionOwner</span>.props(connFactory, <span class="pl-c1">1</span> second))

  <span class="pl-c"><span class="pl-c">//</span> typical "reply queue"; the name if left empty: the broker will generate a new random name</span>
  <span class="pl-k">val</span> <span class="pl-en">privateReplyQueue</span> <span class="pl-k">=</span> <span class="pl-en">QueueParameters</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, passive <span class="pl-k">=</span> <span class="pl-c1">false</span>, durable <span class="pl-k">=</span> <span class="pl-c1">false</span>, exclusive <span class="pl-k">=</span> <span class="pl-c1">true</span>, autodelete <span class="pl-k">=</span> <span class="pl-c1">true</span>)

  <span class="pl-c"><span class="pl-c">//</span> we have a problem that can be "sharded", we create one server per shard, and for each request we expect one</span>
  <span class="pl-c"><span class="pl-c">//</span> response from each shard</span>

  <span class="pl-c"><span class="pl-c">//</span> create one server per shard</span>
  <span class="pl-k">val</span> <span class="pl-en">rpcServers</span> <span class="pl-k">=</span> <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">0</span> to <span class="pl-c1">2</span>) <span class="pl-k">yield</span> {
    <span class="pl-c"><span class="pl-c">//</span> create a "processor"</span>
    <span class="pl-c"><span class="pl-c">//</span> in real life you would use a serialization framework (json, protobuf, ....), define command messages, etc...</span>
    <span class="pl-c"><span class="pl-c">//</span> check the Akka AMQP proxies project for examples</span>
    <span class="pl-k">val</span> <span class="pl-en">processor</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">IProcessor</span> {
      <span class="pl-k">def</span> <span class="pl-en">process</span>(<span class="pl-v">delivery</span>: <span class="pl-en">Delivery</span>) <span class="pl-k">=</span> {
        <span class="pl-c"><span class="pl-c">//</span> assume that the message body is a string</span>
        <span class="pl-k">val</span> <span class="pl-en">response</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>response to <span class="pl-pds">"</span></span> <span class="pl-k">+</span> <span class="pl-k">new</span> <span class="pl-en">String</span>(delivery.body) <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">"</span> from shard <span class="pl-pds">"</span></span> <span class="pl-k">+</span> i
        <span class="pl-en">Future</span>(<span class="pl-en">ProcessResult</span>(<span class="pl-en">Some</span>(response.getBytes)))
      }
      <span class="pl-k">def</span> <span class="pl-en">onFailure</span>(<span class="pl-v">delivery</span>: <span class="pl-en">Delivery</span>, <span class="pl-v">e</span>: <span class="pl-en">Throwable</span>) <span class="pl-k">=</span> <span class="pl-en">ProcessResult</span>(<span class="pl-c1">None</span>) <span class="pl-c"><span class="pl-c">//</span> we don't return anything</span>
    }
    <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">RpcServer</span>.props(privateReplyQueue, <span class="pl-en">StandardExchanges</span>.amqDirect,  <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>, processor, <span class="pl-en">ChannelParameters</span>(qos <span class="pl-k">=</span> <span class="pl-c1">1</span>)))
  }

  <span class="pl-k">val</span> <span class="pl-en">rpcClient</span> <span class="pl-k">=</span> <span class="pl-en">ConnectionOwner</span>.createChildActor(conn, <span class="pl-en">RpcClient</span>.props())

  <span class="pl-c"><span class="pl-c">//</span> wait till everyone is actually connected to the broker</span>
  <span class="pl-en">Amqp</span>.waitForConnection(system, <span class="pl-v">rpcServers</span>: _<span class="pl-k">*</span>).await()
  <span class="pl-en">Amqp</span>.waitForConnection(system, rpcClient).await()

  <span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">timeout</span><span class="pl-k">:</span> <span class="pl-en">Timeout</span> <span class="pl-k">=</span> <span class="pl-c1">2</span> seconds

  <span class="pl-k">for</span> (i <span class="pl-k">&lt;</span><span class="pl-k">-</span> <span class="pl-c1">0</span> to <span class="pl-c1">5</span>) {
    <span class="pl-k">val</span> <span class="pl-en">request</span> <span class="pl-k">=</span> (<span class="pl-s"><span class="pl-pds">"</span>request <span class="pl-pds">"</span></span> <span class="pl-k">+</span> i).getBytes
    <span class="pl-k">val</span> <span class="pl-en">f</span> <span class="pl-k">=</span> (rpcClient <span class="pl-k">?</span> <span class="pl-en">Request</span>(<span class="pl-en">List</span>(<span class="pl-en">Publish</span>(<span class="pl-s"><span class="pl-pds">"</span>amq.direct<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>my_key<span class="pl-pds">"</span></span>, request)), <span class="pl-c1">3</span>)).mapTo[<span class="pl-en">RpcClient</span>.<span class="pl-en">Response</span>]
    f.onComplete {
      <span class="pl-k">case</span> <span class="pl-en">Success</span>(response) <span class="pl-k">=&gt;</span> {
        response.deliveries.foreach(delivery <span class="pl-k">=&gt;</span> println(<span class="pl-k">new</span> <span class="pl-en">String</span>(delivery.body)))
      }
      <span class="pl-k">case</span> <span class="pl-en">Failure</span>(error) <span class="pl-k">=&gt;</span> println(error)
    }
  }
  <span class="pl-c"><span class="pl-c">//</span> wait 10 seconds and shut down</span>
  <span class="pl-en">Thread</span>.sleep(<span class="pl-c1">10000</span>)
  system.shutdown()
</pre>
  </div> 
  <h3><a id="user-content-workflow-pattern" class="anchor" href="https://github.com/sstone/amqp-client#workflow-pattern" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Workflow Pattern</h3> 
  <p>This could be further extended with a simple 'workflow' pattern where each server publishes its results to the shared queue used by the next step. For example, if you want to chain steps A, B and C, set up a shared queue for each step, have 'A' processors publish to queue 'B', 'B' processors publish to queue 'C' ....</p> 
  <h2><a id="user-content-samples" class="anchor" href="https://github.com/sstone/amqp-client#samples" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Samples</h2> 
  <p>You can check either samples <a href="https://github.com/sstone/amqp-client/tree/scala2.11/src/main/scala/com/github/sstone/amqp/samples" target="_blank">src/main/scala/com/github/sstone/amqp/samples</a> or spec tests <a href="https://github.com/sstone/amqp-client/tree/scala2.11/src/test/scala/com/github/sstone/amqp" target="_blank">src/test/scala/com/github/sstone/amqp</a> for examples of how to use the library.</p> 
 </article>
</div>