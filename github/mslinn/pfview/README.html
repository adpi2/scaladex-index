<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="https://raw.githubusercontent.com/mslinn/PFView/master/images/pfview_355x148.png" target="_blank"><img src="https://raw.githubusercontent.com/mslinn/PFView/master/images/pfview_355x148.png" alt="PFView logo" title="PFView Logo" style="max-width:100%;"></a></p> 
  <p>This project is sponsored by <a href="http://www.micronauticsresearch.com/" target="_blank">Micronautics Research Corporation</a>, the company that delivers online Scala and Play training via <a href="http://www.ScalaCourses.com" target="_blank">ScalaCourses.com</a>. You can learn exactly how this project works by taking the <a href="http://www.ScalaCourses.com/showCourse/40" target="_blank">Introduction to Scala</a>, <a href="http://www.ScalaCourses.com/showCourse/45" target="_blank">Intermediate Scala</a> and <a href="http://www.ScalaCourses.com/showCourse/39" target="_blank">Introduction to Play</a> courses.</p> 
  <p><code>PFView</code> is a drop-in replacement for Play Framework's <a href="https://github.com/playframework/twirlhttps://github.com/playframework/twirl" target="_blank">Twirl template language</a>. Twirl is good for simple view templates because for simple pages, the HTML structure is left mostly intact. For more complex pages, <code>PFView</code> is:</p> 
  <ul> 
   <li>Simpler to write</li> 
   <li>Faster, because conversions between XML elements, <code>Html</code> and <code>String</code> can be eliminated. The job of a view is to generate a <code>String</code> that is sent to a client.</li> 
   <li>Testable</li> 
   <li>Debuggable</li> 
   <li>Optimizable, by defining portions as <code>lazy val</code>s which are evaluated only once instead of every time a page is parsed.</li> 
   <li>100% Scala, so IDEs know how to refactor views defined by PFView</li> 
  </ul> 
  <p>The job of a view is to work with data passed from a controller, as well as global state, and render output. No business logic should exist in a view, however traversing data structures requires an expressive computing language.</p> 
  <p><code>PFView</code> was created to overcome <code>Twirl</code>'s shortcomings:</p> 
  <ul> 
   <li>Generates Scala code which is an unreadable mess, which is horrible to debug</li> 
   <li>Cannot be refactored by any available IDE</li> 
   <li>Components must be stored in separate files, instead of merely defining a class or method</li> 
   <li>DSL is less expressive than Scala, and is not a successful functional language.</li> 
   <li>All of a web page's contents are created dynamically; no portion can be designated as being immutable</li> 
  </ul> 
  <p>As a result, a non-trivial <code>Twirl</code> template becomes an unholy mess that is difficult to maintain.</p> 
  <p>As well, <code>Twirl</code> has an awkward syntax and limited capabilities compared to other view templating languages, such as ASP, JSP, JSP EL, etc. PFView is 100% Scala. It could be made to work to with Play for Java projects, but no work has been done to document how to do this.</p> 
  <p>When Adobe Flex was popular, it was common to initially write view templates in <a href="http://en.wikipedia.org/wiki/MXML" target="_blank">MXML</a>, then rewrite them in <a href="http://en.wikipedia.org/wiki/ActionScript" target="_blank">ActionScript</a> as complexity increased. MXML is to Twirl as ActionScript is to PFView.</p> 
  <h2><a id="user-content-installing" class="anchor" href="https://github.com/mslinn/pfview#installing" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installing</h2> 
  <p>Add two lines to <code>build.sbt</code>.</p> 
  <ul> 
   <li>Add the <code>pfview</code> dependency:</li> 
  </ul> 
  <pre><code>"com.micronautics" %% "pfview" % "0.0.4" withSources()
</code></pre> 
  <ul> 
   <li>Add this to the <code>resolvers</code>:</li> 
  </ul> 
  <pre><code>"micronautics/play on bintray" at "http://dl.bintray.com/micronautics/play"
</code></pre> 
  <p>This library has been built against Scala 2.11.8 / Play 2.5.3.</p> 
  <h2><a id="user-content-working-with-pfview" class="anchor" href="https://github.com/mslinn/pfview#working-with-pfview" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Working with PFView</h2> 
  <h3><a id="user-content-creating-an-instance" class="anchor" href="https://github.com/mslinn/pfview#creating-an-instance" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Creating an Instance</h3> 
  <p>Create an <code>PFView</code> instance and invoke the <code>++</code> method to provide content to be appended to the PFView's instance's internal <code>StringBuilder</code> buffer. When the PFView instance has been created, it returns the contents of the buffer as a <code>String</code> - just send that <code>String</code> to the web client. That's all there is to it!</p> 
  <p>There are several ways of creating <code>PFView</code> instances. Examples of all of these are provided in the unit tests.</p> 
  <ul> 
   <li>To define a Twirl-compatible dynamic view, define an <code>object</code> that does not extend <code>PFView</code>. The <code>object</code> needs to define a method called <code>apply</code> that returns <code>Html</code>.</li> 
  </ul> 
  <pre><code>object dynamicView {
  def apply(suffix: String): Html = new PFView {
    ++(s"Feeling $suffix?")
  }.toHtml
}
</code></pre> 
  <p>Of course, <code>apply</code> can be defined have as many arguments and argument lists as required, including typical play signatures such as: <code>def apply(suffix: String)(implicit request: RequestHeader): Html</code></p> 
  <ul> 
   <li>Define a method that creates an anonymous subclass of <code>PFView</code>, which is then implicitly converted to <code>String</code>. This is useful for complex, dynamic content.</li> 
  </ul> 
  <pre><code>def simple = new PFView {
  ++("simple")
}
</code></pre> 
  <ul> 
   <li><code>PFView</code> instances can be recursively nested:</li> 
  </ul> 
  <pre><code>object nestedViews {
  def apply(msg: String="") = new PFView {
    def repeatContent(msg: String): String = new PFView {
      ++(msg * 2)
    }.toString

    val repeatedContent = repeatContent(msg)
    ++(repeatedContent)
  }
}
</code></pre> 
  <ul> 
   <li>To define a static view, define an <code>object</code> that extends <code>PFView</code>. This should only be done when assigning the result to a lazy val.</li> 
  </ul> 
  <pre><code>object staticView extends PFView {
    ++("&lt;h1&gt;This is a test&lt;/h1&gt;")
    ++{s"""&lt;p&gt;The time is now ${new java.util.Date}
          |This is another line&lt;/p&gt;
          |${ unIf (6==9) { "Somehow 6 equals 9" } }""".stripMargin}
}
</code></pre> 
  <h3><a id="user-content-methods" class="anchor" href="https://github.com/mslinn/pfview#methods" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Methods</h3> 
  <p>The following methods are provided by <code>PFView</code>:</p> 
  <ul> 
   <li><code>++</code> - appends content to the buffer</li> 
   <li><code>If</code> - a convenience method for conditionally appending content to the buffer. <code>If (condition) { thenClause }</code> is equivalent to <code>if (condition) thenClause else ""</code>. This method is useful within string interpolation. Unlike Twirl's <code>@if</code> expression, spaces can exist anywhere in an <code>If</code> expression.</li> 
   <li><code>includeFile</code> - append the contents of a local file into the buffer; localized versions of files are searched for, according to standard <a href="http://en.wikipedia.org/wiki/Internationalization_and_localization" target="_blank">i18n</a> behavior using the value of the implicit <a href="https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.i18n.Lang" target="_blank">Lang</a> parameter. For example, if <code>filePath</code> is specified as <code>blah.html</code> and <code>lang</code> has the value <code>en-US</code> then the file <code>blah_en-US.html</code> is searched for, then if not found <code>blah_en.html</code> is searched for and finally <code>blah.html</code> is searched for.</li> 
  </ul> 
  <pre><code>includeFile("blah.html")
</code></pre> 
  <p>You can also specify the <code>lang</code> argument implicitly or explicitly for the <code>localizedFile</code> flavor:</p> 
  <pre><code>localizedFile("blah.html")(Lang("fr"))

implicit val lang = play.api.i18n.Lang("en-US")
localizedFile("blah.html")
</code></pre> 
  <p>By default, files are searched for in the <code>public</code> directory. You can override this by specifying a value for <code>baseDir</code>; the value can be relative or absolute.</p> 
  <pre><code>includeFile("blah.html", "/var/tmp")
localizedFile("blah.html", "/var/tmp")
</code></pre> 
  <p>also:</p> 
  <pre><code>localizedFile("blah.html", "/var/tmp")(Lang("de"))
</code></pre> 
  <ul> 
   <li><code>includeUrl</code> - append the contents of the web page pointed to by a URL into the buffer. Relative URLs are not supported. The default <a href="https://www.playframework.com/documentation/2.3.x/api/scala/index.html#play.api.mvc.Codec" target="_blank">encoding</a> is UTF-8. For example, include this <code>README.md</code> file from its GitHub repo like this:</li> 
  </ul> 
  <pre><code>includeUrl("https://raw.githubusercontent.com/mslinn/PFView/master/README.md")
</code></pre> 
  <p>You can specify an alternative encoding like this:</p> 
  <pre><code>includeUrl("https://raw.githubusercontent.com/mslinn/PFView/master/README.md", "iso-8859-1")
</code></pre> 
 </article>
</div>