<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <p><a href="http://search.maven.org/#search%7Cga%7C1%7Ca%3A%22iothub-react_2.11%22" target="_blank"><img src="https://camo.githubusercontent.com/68cca729d11fcc20e7fc3f00308e330bcf4aa604/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f636f6d2e6d6963726f736f66742e617a7572652e696f742f696f746875622d72656163745f322e31312e737667" alt="Maven Central" data-canonical-src="https://img.shields.io/maven-central/v/com.microsoft.azure.iot/iothub-react_2.11.svg" style="max-width:100%;"></a> <a href="https://bintray.com/microsoftazuretoketi/toketi-repo/iothub-react" target="_blank"><img src="https://camo.githubusercontent.com/9dcdd9907f2e2ff934169f9523559c0ebb552be0/68747470733a2f2f696d672e736869656c64732e696f2f62696e747261792f762f6d6963726f736f6674617a757265746f6b6574692f746f6b6574692d7265706f2f696f746875622d72656163742e737667" alt="Bintray" data-canonical-src="https://img.shields.io/bintray/v/microsoftazuretoketi/toketi-repo/iothub-react.svg" style="max-width:100%;"></a> <a href="https://travis-ci.org/Azure/toketi-iothubreact" target="_blank"><img src="https://camo.githubusercontent.com/b68eb38c8b2936fcbc025d90667dbb027ff0b72d/68747470733a2f2f696d672e736869656c64732e696f2f7472617669732f417a7572652f746f6b6574692d696f7468756272656163742e737667" alt="Build" data-canonical-src="https://img.shields.io/travis/Azure/toketi-iothubreact.svg" style="max-width:100%;"></a> <a href="https://github.com/azure/toketi-iothubreact/issues" target="_blank"><img src="https://camo.githubusercontent.com/6be9248fc9a01df23485a06d323103de97fa3492/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6973737565732f617a7572652f746f6b6574692d696f7468756272656163742e7376673f7374796c653d666c61742d737175617265" alt="Issues" data-canonical-src="https://img.shields.io/github/issues/azure/toketi-iothubreact.svg?style=flat-square" style="max-width:100%;"></a> <a href="https://gitter.im/azure-toketi/iothub-react" target="_blank"><img src="https://camo.githubusercontent.com/c0f9f4abb1e6e7afc2545dd559c2bf0506504edd/68747470733a2f2f696d672e736869656c64732e696f2f6769747465722f726f6f6d2f617a7572652f746f6b6574692d7265706f2e6a732e737667" alt="Gitter" data-canonical-src="https://img.shields.io/gitter/room/azure/toketi-repo.js.svg" style="max-width:100%;"></a></p> 
  <h1><a href="https://github.com/azure/toketi-iothubreact#iothubreact" aria-hidden="true" class="anchor" id="user-content-iothubreact" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>IoTHubReact</h1> 
  <p>IoTHub React is an Akka Stream library that can be used <strong>to read events</strong> from <a href="https://azure.microsoft.com/en-us/services/iot-hub/" target="_blank">Azure IoT Hub</a>, via a <strong>reactive stream</strong> with <strong>asynchronous back pressure</strong>, and <strong>to send commands</strong> to connected devices. Azure IoT Hub is a service used to connect thousands to millions of devices to the Azure cloud.</p> 
  <p>The library can be used both in Java and Scala, providing a fluent DSL for both programming languages, similarly to the approach used by Akka.</p> 
  <p>The following is a simple example showing how to use the library in Scala. A stream of incoming telemetry data is read, parsed and converted to a <code>Temperature</code> object, and then filtered based on the temperature value:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-en">IoTHub</span>().source()
    .map(m <span class="pl-k">⇒</span> parse(m.contentAsString).extract[<span class="pl-en">Temperature</span>])
    .filter(_.value <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)
    .to(console)
    .run()</pre>
  </div> 
  <p>and the equivalent code in Java:</p> 
  <div class="highlight highlight-source-java">
   <pre><span class="pl-k">TypeReference&lt;<span class="pl-smi">Temperature</span>&gt;</span> type <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-k">TypeReference&lt;<span class="pl-smi">Temperature</span>&gt;</span>() {};

<span class="pl-k">new</span> <span class="pl-smi">IoTHub</span>()<span class="pl-k">.</span>source()
    .map(m <span class="pl-k">-</span><span class="pl-k">&gt;</span> (<span class="pl-smi">Temperature</span>) jsonParser<span class="pl-k">.</span>readValue(m<span class="pl-k">.</span>contentAsString(), type))
    .filter(x <span class="pl-k">-</span><span class="pl-k">&gt;</span> x<span class="pl-k">.</span>value <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)
    .to(console())
    .run(streamMaterializer);</pre>
  </div> 
  <p>The following shows how to send a command to devices connected to Azure IoT Hub, for instance when the device is measuring a high temperature, this sends a command to "turn fan ON":</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">turnFanOn</span>  <span class="pl-k">=</span> <span class="pl-en">MessageToDevice</span>(<span class="pl-s"><span class="pl-pds">"</span>Turn fan ON<span class="pl-pds">"</span></span>)

<span class="pl-en">IoTHub</span>()
    .source()
    .filter(<span class="pl-en">MessageSchema</span>(<span class="pl-s"><span class="pl-pds">"</span>temperature<span class="pl-pds">"</span></span>))
    .map(m <span class="pl-k">⇒</span> parse(m.contentAsString).extract[<span class="pl-en">Temperature</span>])
    .filter(_.value <span class="pl-k">&gt;</span> <span class="pl-c1">85</span>)
    .map(t <span class="pl-k">⇒</span> turnFanOn.to(t.deviceId))
    .to(hub.sink())</pre>
  </div> 
  <h4><a href="https://github.com/azure/toketi-iothubreact#streaming-from-iot-hub-to-any" aria-hidden="true" class="anchor" id="user-content-streaming-from-iot-hub-to-any" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Streaming from IoT hub to <em>any</em></h4> 
  <p>An interesting example is reading telemetry data from Azure IoT Hub, and sending it to a Kafka topic, so that it can be consumed by other services downstream:</p> 
  <div class="highlight highlight-source-scala">
   <pre>...
<span class="pl-k">import</span> <span class="pl-v">org.apache.kafka.common.serialization.</span><span class="pl-v">StringSerializer</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.kafka.common.serialization.</span><span class="pl-v">ByteArraySerializer</span>
<span class="pl-k">import</span> <span class="pl-v">org.apache.kafka.clients.producer.</span><span class="pl-v">ProducerRecord</span>
<span class="pl-k">import</span> <span class="pl-v">akka.kafka.</span><span class="pl-v">ProducerSettings</span>
<span class="pl-k">import</span> <span class="pl-v">akka.kafka.scaladsl.</span><span class="pl-v">Producer</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">KafkaProducer</span>(<span class="pl-v">bootstrapServer</span>: <span class="pl-k">String</span>)(<span class="pl-k">implicit</span> <span class="pl-k">val</span> <span class="pl-en">system</span><span class="pl-k">:</span> <span class="pl-en">ActorSystem</span>) {

  <span class="pl-k">protected</span> <span class="pl-k">val</span> <span class="pl-en">producerSettings</span> <span class="pl-k">=</span> <span class="pl-en">ProducerSettings</span>(system, <span class="pl-k">new</span> <span class="pl-en">ByteArraySerializer,</span> <span class="pl-k">new</span> <span class="pl-en">StringSerializer)</span>
    .withBootstrapServers(bootstrapServer)

  <span class="pl-k">def</span> <span class="pl-en">getSink</span>() <span class="pl-k">=</span> <span class="pl-en">Producer</span>.plainSink(producerSettings)

  <span class="pl-k">def</span> <span class="pl-en">packageMessage</span>(<span class="pl-v">elem</span>: <span class="pl-k">String</span>, <span class="pl-v">topic</span>: <span class="pl-k">String</span>)<span class="pl-k">:</span> <span class="pl-en">ProducerRecord</span>[<span class="pl-en">Array</span>[<span class="pl-k">Byte</span>], <span class="pl-k">String</span>] <span class="pl-k">=</span> {
    <span class="pl-k">new</span> <span class="pl-en">ProducerRecord</span>[<span class="pl-en">Array</span>[<span class="pl-k">Byte</span>], <span class="pl-k">String</span>](topic, elem)
  }
}</pre>
  </div> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">kafkaProducer</span> <span class="pl-k">=</span> <span class="pl-en">KafkaProducer</span>(bootstrapServer)

<span class="pl-en">IoTHub</span>().source()
    .map(m <span class="pl-k">⇒</span> parse(m.contentAsString).extract[<span class="pl-en">Temperature</span>])
    .filter(_.value <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)
    .runWith(kafkaProducer.getSink())</pre>
  </div> 
  <h2><a href="https://github.com/azure/toketi-iothubreact#source-options" aria-hidden="true" class="anchor" id="user-content-source-options" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Source options</h2> 
  <h3><a href="https://github.com/azure/toketi-iothubreact#iot-hub-partitions" aria-hidden="true" class="anchor" id="user-content-iot-hub-partitions" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>IoT hub partitions</h3> 
  <p>The library supports reading from a subset of <a href="https://azure.microsoft.com/en-us/documentation/articles/event-hubs-overview" target="_blank">partitions</a>, to enable the development of distributed applications. Consider for instance the scenario of a client application deployed to multiple nodes, where each node processes independently a subset of the incoming telemetry.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">p1</span> <span class="pl-k">=</span> <span class="pl-c1">0</span>
<span class="pl-k">val</span> <span class="pl-en">p2</span> <span class="pl-k">=</span> <span class="pl-c1">3</span>

<span class="pl-en">IoTHub</span>().source(<span class="pl-en">Seq</span>(p1, p2))
    .map(m <span class="pl-k">⇒</span> parse(m.contentAsString).extract[<span class="pl-en">Temperature</span>])
    .filter(_.value <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)
    .to(console)
    .run()</pre>
  </div> 
  <h3><a href="https://github.com/azure/toketi-iothubreact#starting-point" aria-hidden="true" class="anchor" id="user-content-starting-point" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Starting point</h3> 
  <p>Unless specified, the stream starts from the beginning of the data present in each partition. It's possible to start the stream from a given date and time too:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">start</span> <span class="pl-k">=</span> java.time.<span class="pl-en">Instant</span>.now()

<span class="pl-en">IoTHub</span>().source(start)
    .map(m <span class="pl-k">⇒</span> parse(m.contentAsString).extract[<span class="pl-en">Temperature</span>])
    .filter(_.value <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)
    .to(console)
    .run()</pre>
  </div> 
  <h3><a href="https://github.com/azure/toketi-iothubreact#multiple-options" aria-hidden="true" class="anchor" id="user-content-multiple-options" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Multiple options</h3> 
  <p><code>IoTHub().source()</code> provides a quick API to specify the start time or the partitions. To specify more options, you can use the <code>SourceOptions</code> class, combining multiple settings:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">val</span> <span class="pl-en">options</span> <span class="pl-k">=</span> <span class="pl-en">SourceOptions</span>()
  .partitions(<span class="pl-c1">0</span>,<span class="pl-c1">2</span>,<span class="pl-c1">3</span>)
  .fromTime(java.time.<span class="pl-en">Instant</span>.now())
  .withRuntimeInfo()
  .saveOffsets()

<span class="pl-en">IoTHub</span>().source(options)
    .map(m <span class="pl-k">⇒</span> parse(m.contentAsString).extract[<span class="pl-en">Temperature</span>])
    .filter(_.value <span class="pl-k">&gt;</span> <span class="pl-c1">100</span>)
    .to(console)
    .run()</pre>
  </div> 
  <h3><a href="https://github.com/azure/toketi-iothubreact#stream-processing-restart---saving-the-current-position" aria-hidden="true" class="anchor" id="user-content-stream-processing-restart---saving-the-current-position" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Stream processing restart - saving the current position</h3> 
  <p>The library provides a mechanism to restart the stream from a recent <em>checkpoint</em>, to be resilient to restarts and crashes. <em>Checkpoints</em> are saved automatically, with a configured frequency, on a storage provided. For instance, the stream position can be saved every 30 seconds and/or every 500 messages (the values are configurable), in a table in Cassandra or using Azure blobs.</p> 
  <p>Currently the position may be saved in two different ways. The first, simpler method is accomplished by saving in a concurrent thread, delayed by time and/or count, depending on the configuration settings. The second requires slightly more coding but allows the developer to implement <a href="http://www.cloudcomputingpatterns.org/at_least_once_delivery/" target="_blank">at-least-once delivery semantics</a>, due to the fact the offset saves can be included downstream of processing in your graph.</p> 
  <p>For more information about the checkpointing feature, <a href="https://github.com/azure/toketi-iothubreact/blob/master/CHECKPOINTING.md" target="_blank">please read here</a>.</p> 
  <h2><a href="https://github.com/azure/toketi-iothubreact#build-configuration" aria-hidden="true" class="anchor" id="user-content-build-configuration" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Build configuration</h2> 
  <p>IoTHubReact is available in Maven Central for Scala 2.11 and 2.12. To import the library into your project, add the following reference in your <code>build.sbt</code> file:</p> 
  <p><code>libraryDependencies += "com.microsoft.azure.iot" %% "iothub-react" % "0.9.1"</code></p> 
  <p>or this dependency in <code>pom.xml</code> file when working with Maven:</p> 
  <div class="highlight highlight-text-xml">
   <pre>&lt;<span class="pl-ent">dependency</span>&gt;
    &lt;<span class="pl-ent">groupId</span>&gt;com.microsoft.azure.iot&lt;/<span class="pl-ent">groupId</span>&gt;
    &lt;<span class="pl-ent">artifactId</span>&gt;iothub-react_2.12&lt;/<span class="pl-ent">artifactId</span>&gt;
    &lt;<span class="pl-ent">version</span>&gt;0.9.1&lt;/<span class="pl-ent">version</span>&gt;
&lt;/<span class="pl-ent">dependency</span>&gt;</pre>
  </div> 
  <p>IoTHubReact internally uses some libraries like Azure IoT SDK, Azure Storage SDK, Akka etc. If your project depends on these libraries too, your can override the versions, explicitly importing the packages in your <code>build.sbt</code> and <code>pom.xml</code> files. If you encounter some incompatibility with future versions of these, please let us know opening an issue, or sending a PR.</p> 
  <h3><a href="https://github.com/azure/toketi-iothubreact#iothub-configuration" aria-hidden="true" class="anchor" id="user-content-iothub-configuration" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>IoTHub configuration</h3> 
  <p>By default IoTHubReact uses an <code>application.conf</code> configuration file to fetch the parameters required to connect to Azure IoT Hub. The connection and authentication values to use, can be found in the <a href="https://portal.azure.com" target="_blank">Azure Portal</a>:</p> 
  <p>Properties required to receive Device-to-Cloud (D2C) messages:</p> 
  <ul> 
   <li><strong>hubName</strong>: see <code>Endpoints</code> ⇒ <code>Messaging</code> ⇒ <code>Events</code> ⇒ <code>Event Hub-compatible name</code></li> 
   <li><strong>hubEndpoint</strong>: see <code>Endpoints</code> ⇒ <code>Messaging</code> ⇒ <code>Events</code> ⇒ <code>Event Hub-compatible endpoint</code></li> 
   <li><strong>hubPartitions</strong>: see <code>Endpoints</code> ⇒ <code>Messaging</code> ⇒ <code>Events</code> ⇒ <code>Partitions</code></li> 
   <li><strong>accessPolicy</strong>: usually <code>service</code>, see <code>Shared access policies</code></li> 
   <li><strong>accessKey</strong>: see <code>Shared access policies</code> ⇒ <code>key name</code> ⇒ <code>Primary key</code> (it's a base64 encoded string)</li> 
  </ul> 
  <p>Properties required to send Cloud-to-Device (C2D) commands:</p> 
  <ul> 
   <li><strong>accessHostName</strong>: see <code>Shared access policies</code> ⇒ <code>key name</code> ⇒ <code>Connection string</code> ⇒ <code>HostName</code></li> 
  </ul> 
  <p>The values should be stored in your <code>application.conf</code> resource (or equivalent). Optionally you can reference environment settings if you prefer, for example to hide sensitive data.</p> 
  <pre><code>iothub-react {

  connection {
    hubName        = "&lt;Event Hub compatible name&gt;"
    hubEndpoint    = "&lt;Event Hub compatible endpoint&gt;"
    hubPartitions  = &lt;the number of partitions in your IoT Hub&gt;
    accessPolicy   = "&lt;access policy name&gt;"
    accessKey      = "&lt;access policy key&gt;"
    accessHostName = "&lt;access host name&gt;"
  }

  [... other settings...]
}
</code></pre> 
  <p>Example using environment settings:</p> 
  <pre><code>iothub-react {

  connection {
    hubName        = ${?IOTHUB_EVENTHUB_NAME}
    hubEndpoint    = ${?IOTHUB_EVENTHUB_ENDPOINT}
    hubPartitions  = ${?IOTHUB_EVENTHUB_PARTITIONS}
    accessPolicy   = ${?IOTHUB_ACCESS_POLICY}
    accessKey      = ${?IOTHUB_ACCESS_KEY}
    accessHostName = ${?IOTHUB_ACCESS_HOSTNAME}
  }

  [... other settings...]
}
</code></pre> 
  <p>Note that the library will automatically use these exact environment variables, unless overridden in your configuration file (all the default settings are stored in <a href="https://github.com/azure/toketi-iothubreact/blob/master/src/main/resources/reference.conf" target="_blank">reference.conf</a>).</p> 
  <p>Although using a configuration file is the preferred approach, it's also possible to inject a different configuration at runtime, providing an object implementing the <code>IConfiguration</code> interface.</p> 
  <p>The logging level can be managed overriding Akka configuration, for example:</p> 
  <pre><code>akka {
  # Options: OFF, ERROR, WARNING, INFO, DEBUG
  loglevel = "WARNING"
}
</code></pre> 
  <p>There are other settings, to tune performance and connection details:</p> 
  <ul> 
   <li><strong>streaming.consumerGroup</strong>: the <a href="https://azure.microsoft.com/en-us/documentation/articles/event-hubs-overview" target="_blank">consumer group</a> used during the connection</li> 
   <li><strong>streaming.receiverBatchSize</strong>: the number of messages retrieved on each call to Azure IoT hub. The default (and maximum) value is 999.</li> 
   <li><strong>streaming.receiverTimeout</strong>: timeout applied to calls while retrieving messages. The default value is 3 seconds.</li> 
   <li><strong>streaming.retrieveRuntimeInfo</strong>: when enabled, the messages returned by <code>IoTHub.Source</code> will contain some runtime information about the last message in each partition. You can use this information to calculate how many telemetry events remain to process.</li> 
  </ul> 
  <p>The complete configuration reference (and default values) is available in <a href="https://github.com/azure/toketi-iothubreact/blob/master/src/main/resources/reference.conf" target="_blank">reference.conf</a>.</p> 
  <h1><a href="https://github.com/azure/toketi-iothubreact#samples" aria-hidden="true" class="anchor" id="user-content-samples" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Samples</h1> 
  <p>The project includes several demos in Java and Scala, showing some of the use cases and how IoThub React API works. All the demos require an instance of Azure IoT hub, with some devices and messages.</p> 
  <ol> 
   <li><strong>DisplayMessages</strong> [Java]: how to stream Azure IoT hub withing a Java application, filtering temperature values greater than 60C</li> 
   <li><strong>SendMessageToDevice</strong> [Java]: how to turn on a fan when a device reports a temperature higher than 22C</li> 
   <li><strong>AllMessagesFromBeginning</strong> [Scala]: simple example streaming all the events in the hub.</li> 
   <li><strong>OnlyRecentMessages</strong> [Scala]: stream all the events, starting from the current time.</li> 
   <li><strong>OnlyTwoPartitions</strong> [Scala]: shows how to stream events from a subset of partitions.</li> 
   <li><strong>MultipleDestinations</strong> [Scala]: shows how to read once and deliver events to multiple destinations.</li> 
   <li><strong>FilterByMessageSchema</strong> [Scala]: how to filter events by message schema. Note: the name of the schema must be set by the device using the <code>$$MessageSchema</code> message property. In future this will be a system property, explicitly supported by Azure IoT SDK.</li> 
   <li><strong>FilterByDeviceID</strong> [Scala]: how to filter events by device ID. The device ID is automatically set by Azure IoT SDK.</li> 
   <li><strong>CloseStream</strong> [Scala]: show how to close the stream</li> 
   <li><strong>SendMessageToDevice</strong> [Scala]: shows the API to send messages to connected devices.</li> 
   <li><strong>PrintTemperature</strong> [Scala]: stream all Temperature events and print data to the console.</li> 
   <li><strong>Throughput</strong> [Scala]: stream all events and display statistics about the throughput.</li> 
   <li><strong>Throttling</strong> [Scala]: throttle the incoming stream to a defined speed of events/second.</li> 
   <li><strong>StoreOffsets_While_Processing</strong> [Scala]: demonstrates how the stream can be restarted without losing its position, using an optimistic approach (the position is stored in parallel, with some configurable delay fomr the moment of processing). The current position is stored in a Cassandra table (we suggest to run a docker container for the purpose of the demo, e.g. <code>docker run -ip 9042:9042 --rm cassandra</code>).</li> 
   <li><strong>StoreOffsets_After_Processing</strong> [Scala]: demonstrates how the stream can be restarted without losing its position, using At Least Once Delivery semantic (this guarantees that every event is delivered at least once, regardless of frequency and crashes).The current position is stored in a Cassandra table (we suggest to run a docker container for the purpose of the demo, e.g. <code>docker run -ip 9042:9042 --rm cassandra</code>).</li> 
   <li><strong>StartFromStoredOffsetsButDontWriteNewOffsets</strong> [Scala]: shows how to use the saved checkpoints to start streaming from a known position, without changing the value in the storage. If the storage doesn't contain checkpoints, the stream starts from the beginning.</li> 
   <li><strong>StartFromStoredOffsetsIfAvailableOrByTimeOtherwise</strong> [Scala]: similar to the previous demo, with a fallback datetime when the storage doesn't contain checkpoints.</li> 
   <li><strong>StreamIncludingRuntimeInformation</strong> [Scala]: shows how runtime information works.</li> 
   <li><strong>SendMessageToDevice</strong> [Scala]: another example showing how to send 2 different messages to connected devices.</li> 
  </ol> 
  <p>We provide a <a href="https://github.com/azure/toketi-iothubreact/blob/master/tools/devices-simulator/README.md" target="_blank">device simulator</a> in the tools section, which will help simulating some devices sending sample telemetry events.</p> 
  <p>When ready, you should either edit the <code>application.conf</code> configuration files (<a href="https://github.com/azure/toketi-iothubreact/blob/master/samples-scala/src/main/resources/application.conf" target="_blank">scala</a> and <a href="https://github.com/azure/toketi-iothubreact/blob/master/samples-java/src/main/resources/application.conf" target="_blank">java</a>) with your credentials, or set the corresponding environment variables. Follow the instructions described in the previous section on how to set the correct values.</p> 
  <p>The root folder includes also a script showing how to set the environment variables in <a href="https://github.com/azure/toketi-iothubreact/blob/master/setup-env-vars.sh" target="_blank">Linux/MacOS</a> and <a href="https://github.com/azure/toketi-iothubreact/blob/master/setup-env-vars.bat" target="_blank">Windows</a>.</p> 
  <p>The demos can be executed using the scripts included in the root folder (<code>run_&lt;language&gt;_samples.sh</code> and <code>run_&lt;language&gt;_samples.cmd</code>):</p> 
  <ul> 
   <li><a href="https://github.com/azure/toketi-iothubreact/blob/master/run_scala_samples.sh" target="_blank"><code>run_scala_samples.sh</code></a>: execute Scala demos</li> 
   <li><a href="https://github.com/azure/toketi-iothubreact/blob/master/run_java_samples.sh" target="_blank"><code>run_java_samples.sh</code></a>: execute Java demos</li> 
  </ul> 
  <h1><a href="https://github.com/azure/toketi-iothubreact#running-the-tests" aria-hidden="true" class="anchor" id="user-content-running-the-tests" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Running the tests</h1> 
  <p>You can use the included <code>build.sh</code> script to execute all the unit and functional tests in the suite.</p> 
  <p>The functional tests require an existing Azure IoT Hub resource, that yous should setup. For the tests to connect to your IoT Hub, configure your environment using the <code>setup-env-vars.*</code> scripts mentioned above in this page.</p> 
  <h1><a href="https://github.com/azure/toketi-iothubreact#other-docs" aria-hidden="true" class="anchor" id="user-content-other-docs" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Other docs</h1> 
  <ul> 
   <li><a href="https://github.com/azure/toketi-iothubreact/blob/master/CONTRIBUTING.md" target="_blank">Contributing</a></li> 
   <li><a href="https://github.com/azure/toketi-iothubreact/blob/master/CHECKPOINTING.md" target="_blank">Checkpointing</a></li> 
   <li><a href="https://azure.github.io/toketi-iothubreact" target="_blank">API specs</a></li> 
  </ul> 
 </article>
</div>