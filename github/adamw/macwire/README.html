<div class="announce instapaper_body md" data-path="README.md" id="readme">
 <article class="markdown-body entry-content" itemprop="text">
  <h1><a id="user-content-table-of-contents" class="anchor" href="https://github.com/adamw/macwire#table-of-contents" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Table of Contents</h1> 
  <ul> 
   <li><a href="https://github.com/adamw/macwire#macwire" target="_blank">Introduction</a></li> 
   <li><a href="http://di-in-scala.github.io/" target="_blank">Guide to DI in Scala</a> (external link)</li> 
   <li><a href="https://github.com/adamw/macwire#how-wiring-works" target="_blank">How wiring works</a></li> 
   <li><a href="https://github.com/adamw/macwire#factories" target="_blank">Factories</a></li> 
   <li><a href="https://github.com/adamw/macwire#factory-methods" target="_blank">Factory methods</a></li> 
   <li><a href="https://github.com/adamw/macwire#lazy-val-vs-val" target="_blank"><code>lazy val</code> vs. <code>val</code></a></li> 
   <li><a href="https://github.com/adamw/macwire#composing-modules" target="_blank">Composing modules</a></li> 
   <li><a href="https://github.com/adamw/macwire#scopes" target="_blank">Scopes</a></li> 
   <li><a href="https://github.com/adamw/macwire#accessing-wired-instances-dynamically" target="_blank">Accessing wired instances dynamically</a></li> 
   <li><a href="https://github.com/adamw/macwire#interceptors" target="_blank">Interceptors</a></li> 
   <li><a href="https://github.com/adamw/macwire#qualifiers" target="_blank">Qualifiers</a><br></li> 
   <li><a href="https://github.com/adamw/macwire#limitations" target="_blank">Limitations</a></li> 
   <li><a href="https://github.com/adamw/macwire#installation-using-with-sbt" target="_blank">Installation, using with SBT</a></li> 
   <li><a href="https://github.com/adamw/macwire#debugging" target="_blank">Debugging</a></li> 
   <li><a href="https://github.com/adamw/macwire#scalajs" target="_blank">Scala.js</a></li> 
   <li><a href="https://github.com/adamw/macwire#future-development---vote" target="_blank">Future development - vote!</a></li> 
   <li><a href="https://github.com/adamw/macwire#activators" target="_blank">Activators</a></li> 
   <li><a href="https://github.com/adamw/macwire#migrating" target="_blank">Migrating from 1.x</a></li> 
   <li><a href="https://github.com/adamw/macwire#play24x" target="_blank">Play 2.4.x</a></li> 
  </ul> 
  <h1><a id="user-content-macwire" class="anchor" href="https://github.com/adamw/macwire#macwire" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>MacWire</h1> 
  <p><a href="https://travis-ci.org/adamw/macwire" target="_blank"><img src="https://camo.githubusercontent.com/9106a872a2016b804c101c63d892f0425f66a6c3/68747470733a2f2f7472617669732d63692e6f72672f6164616d772f6d6163776972652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/adamw/macwire.svg?branch=master" style="max-width:100%;"></a> <a href="https://gitter.im/adamw/macwire?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge" target="_blank"><img src="https://camo.githubusercontent.com/da2edb525cde1455a622c58c0effc3a90b9a181c/68747470733a2f2f6261646765732e6769747465722e696d2f4a6f696e253230436861742e737667" alt="Join the chat at https://gitter.im/adamw/macwire" data-canonical-src="https://badges.gitter.im/Join%20Chat.svg" style="max-width:100%;"></a> <a href="https://maven-badges.herokuapp.com/maven-central/com.softwaremill.macwire/macros_2.11" target="_blank"><img src="https://camo.githubusercontent.com/9e8a67a30a3c29be53c40aa053529f353d58f458/68747470733a2f2f6d6176656e2d6261646765732e6865726f6b756170702e636f6d2f6d6176656e2d63656e7472616c2f636f6d2e736f6674776172656d696c6c2e6d6163776972652f6d6163726f735f322e31312f62616467652e737667" alt="Maven Central" data-canonical-src="https://maven-badges.herokuapp.com/maven-central/com.softwaremill.macwire/macros_2.11/badge.svg" style="max-width:100%;"></a> <a href="https://app.updateimpact.com/latest/634276070333485056/macwire" target="_blank"><img src="https://camo.githubusercontent.com/fd340fe016d1b9a0b26fc903901cca6b1ed1707d/68747470733a2f2f6170702e757064617465696d706163742e636f6d2f62616467652f3633343237363037303333333438353035362f6d6163776972652e7376673f636f6e6669673d636f6d70696c65" alt="Dependencies" data-canonical-src="https://app.updateimpact.com/badge/634276070333485056/macwire.svg?config=compile" style="max-width:100%;"></a> </p> 
  <p>MacWire generates <code>new</code> instance creation code of given classes, using values in the enclosing type for constructor parameters, with the help of <a href="http://scalamacros.org/" target="_blank">Scala Macros</a>.</p> 
  <p>For a general introduction to DI in Scala, take a look at the <a href="http://di-in-scala.github.io/" target="_blank">Guide to DI in Scala</a>, which also features MacWire.</p> 
  <p>MacWire helps to implement the Dependency Injection (DI) pattern, by removing the need to write the class-wiring code by hand. Instead, it is enough to declare which classes should be wired, and how the instances should be accessed (see Scopes).</p> 
  <p>Classes to be wired should be organized in "modules", which can be Scala <code>trait</code>s, <code>class</code>es or <code>object</code>s. Multiple modules can be combined using inheritance or composition; values from the inherited/nested modules are also used for wiring.</p> 
  <p>MacWire can be in many cases a replacement for DI containers, offering greater control on when and how classes are instantiated, typesafety and using only language (Scala) mechanisms.</p> 
  <p>Example usage:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">DatabaseAccess</span>()
<span class="pl-k">class</span> <span class="pl-en">SecurityFilter</span>()
<span class="pl-k">class</span> <span class="pl-en">UserFinder</span>(<span class="pl-v">databaseAccess</span>: <span class="pl-en">DatabaseAccess</span>, <span class="pl-v">securityFilter</span>: <span class="pl-en">SecurityFilter</span>)
<span class="pl-k">class</span> <span class="pl-en">UserStatusReader</span>(<span class="pl-v">userFinder</span>: <span class="pl-en">UserFinder</span>)

<span class="pl-k">trait</span> <span class="pl-en">UserModule</span> {
    <span class="pl-k">import</span> <span class="pl-v">com.softwaremill.macwire.</span><span class="pl-v">_</span>

    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theDatabaseAccess</span>   <span class="pl-k">=</span> wire[<span class="pl-en">DatabaseAccess</span>]
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theSecurityFilter</span>   <span class="pl-k">=</span> wire[<span class="pl-en">SecurityFilter</span>]
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theUserFinder</span>       <span class="pl-k">=</span> wire[<span class="pl-en">UserFinder</span>]
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theUserStatusReader</span> <span class="pl-k">=</span> wire[<span class="pl-en">UserStatusReader</span>]
}</pre>
  </div> 
  <p>will generate:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">UserModule</span> {
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theDatabaseAccess</span>   <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DatabaseAccess</span>()
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theSecurityFilter</span>   <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SecurityFilter</span>()
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theUserFinder</span>       <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">UserFinder</span>(theDatabaseAccess, theSecurityFilter)
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theUserStatusReader</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">UserStatusReader</span>(theUserFinder)
}</pre>
  </div> 
  <p>For testing, just extend the base module and override any dependencies with mocks/stubs etc, e.g.:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">UserModuleForTests</span> <span class="pl-k">extends</span> <span class="pl-e">UserModule</span> {
    <span class="pl-k">override</span> <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theDatabaseAccess</span> <span class="pl-k">=</span> mockDatabaseAccess
    <span class="pl-k">override</span> <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theSecurityFilter</span> <span class="pl-k">=</span> mockSecurityFilter
}</pre>
  </div> 
  <p>The core library has no dependencies.</p> 
  <p>For more motivation behind the project see also these blogs:</p> 
  <ul> 
   <li><a href="http://www.warski.org/blog/2013/03/dependency-injection-with-scala-macros-auto-wiring/" target="_blank">Dependency injection with Scala macros: auto-wiring</a></li> 
   <li><a href="http://www.warski.org/blog/2013/04/macwire-0-1-framework-less-dependency-injection-with-scala-macros/" target="_blank">MacWire 0.1: Framework-less Dependency Injection with Scala Macros</a></li> 
   <li><a href="http://www.warski.org/blog/2013/04/macwire-0-2-scopes-are-simple/" target="_blank">MacWire 0.2: Scopes are simple!</a></li> 
   <li><a href="http://www.warski.org/blog/2013/06/implementing-factories-in-scala-macwire-0-3/" target="_blank">Implementing factories in Scala &amp; MacWire 0.3</a></li> 
   <li><a href="http://www.warski.org/blog/2013/08/dependency-injection-in-play-with-macwire/" target="_blank">Dependency Injection in Play! with MacWire</a></li> 
   <li><a href="http://www.warski.org/blog/2013/10/macwire-0-5-interceptors/" target="_blank">MacWire 0.5: Interceptors</a></li> 
   <li><a href="http://www.warski.org/blog/2014/02/using-scala-traits-as-modules-or-the-thin-cake-pattern/" target="_blank">Using Scala traits as modules, or the "Thin Cake" Pattern</a></li> 
  </ul> 
  <p>You can also try MacWire through <a href="http://typesafe.com/activator/template/macwire-activator" target="_blank">Typesafe Activator</a>.</p> 
  <p>A similar project for Java is <a href="https://github.com/square/dagger" target="_blank">Dagger</a>.</p> 
  <h2><a id="user-content-how-wiring-works" class="anchor" href="https://github.com/adamw/macwire#how-wiring-works" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>How wiring works</h2> 
  <p>For each constructor parameter of the given class, MacWire tries to find a value <a href="http://www.scala-lang.org/files/archive/spec/2.11/03-types.html#conformance" target="_blank">conforming</a> to the parameter's type in the enclosing method and trait/class/object:</p> 
  <ul> 
   <li>first it tries to find a unique value declared as a value in the current block, argument of enclosing methods and anonymous functions.</li> 
   <li>then it tries to find a unique value declared or imported in the enclosing type</li> 
   <li>then it tries to find a unique value in parent types (traits/classes)</li> 
   <li>if the parameter is marked as implicit, it is ignored by MacWire and handled by the normal implicit resolution mechanism </li> 
  </ul> 
  <p>Here value means either a <code>val</code> or a no-parameter <code>def</code>, as long as the return type matches.</p> 
  <p>A compile-time error occurs if:</p> 
  <ul> 
   <li>there are multiple values of a given type declared in the enclosing block/method/function's arguments list, enclosing type or its parents.</li> 
   <li>parameter is marked as implicit and implicit lookup fails to find a value</li> 
   <li>there is no value of a given type</li> 
  </ul> 
  <p>The generated code is then once again type-checked by the Scala compiler.</p> 
  <h2><a id="user-content-factories" class="anchor" href="https://github.com/adamw/macwire#factories" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Factories</h2> 
  <p>A factory is simply a method. The constructor of the wired class can contain parameters both from the factory (method) parameters, and from the enclosing/super type(s).</p> 
  <p>For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">DatabaseAccess</span>()
<span class="pl-k">class</span> <span class="pl-en">TaxDeductionLibrary</span>(<span class="pl-v">databaseAccess</span>: <span class="pl-en">DatabaseAccess</span>)
<span class="pl-k">class</span> <span class="pl-en">TaxCalculator</span>(<span class="pl-v">taxBase</span>: <span class="pl-k">Double</span>, <span class="pl-v">taxDeductionLibrary</span>: <span class="pl-en">TaxDeductionLibrary</span>)

<span class="pl-k">trait</span> <span class="pl-en">TaxModule</span> {
    <span class="pl-k">import</span> <span class="pl-v">com.softwaremill.macwire.</span><span class="pl-v">_</span>

    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theDatabaseAccess</span>      <span class="pl-k">=</span> wire[<span class="pl-en">DatabaseAccess</span>]
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theTaxDeductionLibrary</span> <span class="pl-k">=</span> wire[<span class="pl-en">TaxDeductionLibrary</span>]
    <span class="pl-k">def</span> <span class="pl-en">taxCalculator</span>(<span class="pl-v">taxBase</span>: <span class="pl-k">Double</span>) <span class="pl-k">=</span> wire[<span class="pl-en">TaxCalculator</span>]
    <span class="pl-c">// or: lazy val taxCalculator = (taxBase: Double) =&gt; wire[TaxCalculator]</span>
}</pre>
  </div> 
  <p>will generate:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">TaxModule</span> {
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theDatabaseAccess</span>      <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">DatabaseAccess</span>()
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theTaxDeductionLibrary</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">TaxDeductionLibrary</span>(theDatabaseAccess)
    <span class="pl-k">def</span> <span class="pl-en">taxCalculator</span>(<span class="pl-v">taxBase</span>: <span class="pl-k">Double</span>) <span class="pl-k">=</span>
       <span class="pl-k">new</span> <span class="pl-en">TaxCalculator</span>(taxBase, theTaxDeductionLibrary)
}</pre>
  </div> 
  <h2><a id="user-content-factory-methods" class="anchor" href="https://github.com/adamw/macwire#factory-methods" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Factory methods</h2> 
  <p>You can also wire an object using a factory method, instead of a constructor. For that, use <code>wireWith</code> instead of <code>wire</code>. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">A</span>()

<span class="pl-k">class</span> <span class="pl-en">C</span>(<span class="pl-v">a</span>: <span class="pl-en">A</span>, <span class="pl-v">specialValue</span>: <span class="pl-k">Int</span>)
<span class="pl-k">object</span> <span class="pl-en">C</span> {
  <span class="pl-k">def</span> <span class="pl-en">create</span>(<span class="pl-v">a</span>: <span class="pl-en">A</span>) <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">C</span>(a, <span class="pl-c1">42</span>)
}

<span class="pl-k">trait</span> <span class="pl-en">MyModule</span> {
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">a</span> <span class="pl-k">=</span> wire[<span class="pl-en">A</span>]
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">c</span> <span class="pl-k">=</span> wireWith(<span class="pl-en">C</span>.create _)
}</pre>
  </div> 
  <h2><a id="user-content-lazy-val-vs-val" class="anchor" href="https://github.com/adamw/macwire#lazy-val-vs-val" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a><code>lazy val</code> vs. <code>val</code></h2> 
  <p>It is safer to use <code>lazy val</code>s, as when using <code>val</code>, if a value is forward-referenced, it's value during initialization will be <code>null</code>. With <code>lazy val</code> the correct order of initialization is resolved by Scala.</p> 
  <h2><a id="user-content-composing-modules" class="anchor" href="https://github.com/adamw/macwire#composing-modules" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Composing modules</h2> 
  <p>Modules (traits or classes containing parts of the object graph) can be combined using inheritance or composition. The inheritance case is straightforward, as <code>wire</code> simply looks for values in parent traits/classes. With composition, you need to tell MacWire that it should look inside the nested modules.</p> 
  <p>To do that, you can use imports:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">FacebookAccess</span>(<span class="pl-v">userFind</span>: <span class="pl-en">UserFinder</span>) 

<span class="pl-k">class</span> <span class="pl-en">UserModule</span> { 
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">userFinder</span> <span class="pl-k">=</span> ... <span class="pl-c">// as before </span>
} 

<span class="pl-k">class</span> <span class="pl-en">SocialModule</span>(<span class="pl-v">userModule</span>: <span class="pl-en">UserModule</span>) {
  <span class="pl-k">import</span> <span class="pl-v">userModule.</span><span class="pl-v">_</span>

  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">facebookAccess</span> <span class="pl-k">=</span> wire[<span class="pl-en">FacebookAccess</span>] 
}</pre>
  </div> 
  <p>Or, if you are using that pattern a lot, you can annotate your modules using <code>@Module</code>, and they will be used when searching for values automatically:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">FacebookAccess</span>(<span class="pl-v">userFind</span>: <span class="pl-en">UserFinder</span>) 

<span class="pl-k">@</span><span class="pl-en">Module</span>
<span class="pl-k">class</span> <span class="pl-en">UserModule</span> { ... } <span class="pl-c">// as before</span>

<span class="pl-k">class</span> <span class="pl-en">SocialModule</span>(<span class="pl-v">userModule</span>: <span class="pl-en">UserModule</span>) {
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">facebookAccess</span> <span class="pl-k">=</span> wire[<span class="pl-en">FacebookAccess</span>] 
}</pre>
  </div> 
  <p><strong>Warning</strong>: the <code>@Module</code> annotation is an experimental feature, if you have any feedback regarding its usage, let us know!</p> 
  <h2><a id="user-content-scopes" class="anchor" href="https://github.com/adamw/macwire#scopes" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scopes</h2> 
  <p>There are two "built-in" scopes, depending on how the dependency is defined:</p> 
  <ul> 
   <li>singleton: <code>lazy val</code> / <code>val</code></li> 
   <li>dependent - separate instance for each dependency usage: <code>def</code></li> 
  </ul> 
  <p>MacWire also supports user-defined scopes, which can be used to implement request or session scopes in web applications. The <code>proxy</code> subproject defines a <code>Scope</code> trait, which has two methods:</p> 
  <ul> 
   <li><code>apply</code>, to create a scoped value</li> 
   <li><code>get</code>, to get or create the current value from the scope</li> 
  </ul> 
  <p>To define a dependency as scoped, we need a scope instance, e.g.:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">WebModule</span> {
   <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">loggedInUser</span> <span class="pl-k">=</span> session(<span class="pl-k">new</span> <span class="pl-en">LoggedInUser)</span>

   <span class="pl-k">def</span> <span class="pl-en">session</span><span class="pl-k">:</span> <span class="pl-en">Scope</span>
}</pre>
  </div> 
  <p>With abstract scopes as above, it is possible to use no-op scopes for testing (<code>NoOpScope</code>).</p> 
  <p>There's an implementation of <code>Scope</code> targeted at classical synchronous frameworks, <code>ThreadLocalScope</code>. The apply method of this scope creates a proxy (using <a href="http://www.csg.is.titech.ac.jp/%7Echiba/javassist/" target="_blank">javassist</a>); the get method stores the value in a thread local. The proxy should be defined as a <code>val</code> or <code>lazy val</code>.</p> 
  <p>In a web application, the scopes have to be associated and disassociated with storages. This can be done for example in a servlet filter. To implement a:</p> 
  <ul> 
   <li>request scope, we need a new empty storage for every request. The <code>associateWithEmptyStorage</code> is useful here</li> 
   <li>session scope, the storage (a <code>Map</code>) should be stored in the <code>HttpSession</code>. The <code>associate(Map)</code> method is useful here</li> 
  </ul> 
  <p>For example usage see the <a href="https://github.com/adamw/macwire/tree/master/examples/scalatra/src/main/scala/com/softwaremill/macwire/examples/scalatra" target="_blank">MacWire+Scalatra example</a> sources.</p> 
  <p>You can run the example with <code>sbt examples-scalatra/run</code> and going to <a href="http://localhost:8080" target="_blank">http://localhost:8080</a>.</p> 
  <p>Note that the <code>proxy</code> subproject does not depend on MacWire core, and can be used stand-alone with manual wiring or any other frameworks.</p> 
  <h2><a id="user-content-accessing-wired-instances-dynamically" class="anchor" href="https://github.com/adamw/macwire#accessing-wired-instances-dynamically" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Accessing wired instances dynamically</h2> 
  <p>To integrate with some frameworks (e.g. <a href="http://www.playframework.com/" target="_blank">Play 2</a>) or to create instances of classes which names are only known at run-time (e.g. plugins) it is necessary to access the wired instances dynamically. MacWire contains a utility class in the <code>util</code> subproject, <code>Wired</code>, to support such functionality.</p> 
  <p>An instance of <code>Wired</code> can be obtained using the <code>wiredInModule</code> macro, given an instance of a module containing the wired object graph. Any <code>vals</code>, <code>lazy val</code>s and parameter-less <code>def</code>s (factories) from the module which are references will be available in the <code>Wired</code> instance. </p> 
  <p>The object graph in the module can be hand-wired, wired using <code>wire</code>, or a result of any computation.</p> 
  <p><code>Wired</code> has two basic functionalities: looking up an instance by its class (or trait it implements), and instantiating new objects using the available dependencies. You can also extend <code>Wired</code> with new instances/instance factories.</p> 
  <p>For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-c">// 1. Defining the object graph and the module</span>
<span class="pl-k">trait</span> <span class="pl-en">DatabaseConnector</span>
<span class="pl-k">class</span> <span class="pl-en">MysqlDatabaseConnector</span> <span class="pl-k">extends</span> <span class="pl-e">DatabaseConnector</span>

<span class="pl-k">class</span> <span class="pl-en">MyApp</span> {
    <span class="pl-k">def</span> <span class="pl-en">securityFilter</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">SecurityFilter</span>()
    <span class="pl-k">val</span> <span class="pl-en">databaseConnector</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">MysqlDatabaseConnector</span>()
}

<span class="pl-c">// 2. Creating a Wired instance</span>
<span class="pl-k">import</span> <span class="pl-v">com.softwaremill.macwire.</span><span class="pl-v">_</span>
<span class="pl-k">val</span> <span class="pl-en">wired</span> <span class="pl-k">=</span> wiredInModule(<span class="pl-k">new</span> <span class="pl-en">MyApp)</span>

<span class="pl-c">// 3. Dynamic lookup of instances</span>
wired.lookup(<span class="pl-c1">classOf</span>[<span class="pl-en">SecurityFilter</span>])

<span class="pl-c">// Returns the mysql database connector, even though its type is MysqlDatabaseConnector, which is </span>
<span class="pl-c">// assignable to DatabaseConnector.</span>
wired.lookup(<span class="pl-c1">classOf</span>[<span class="pl-en">DatabaseConnector</span>])

<span class="pl-c">// 4. Instantiation using the available dependencies</span>
{
    <span class="pl-k">package</span> <span class="pl-en">com.softwaremill</span>
    <span class="pl-k">class</span> <span class="pl-en">AuthenticationPlugin</span>(<span class="pl-v">databaseConnector</span>: <span class="pl-en">DatabaseConnector</span>)
}

<span class="pl-c">// Creates a new instance of the given class using the dependencies available in MyApp</span>
wired.wireClassInstanceByName(<span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.AuthenticationPlugin<span class="pl-pds">"</span></span>)</pre>
  </div> 
  <h2><a id="user-content-interceptors" class="anchor" href="https://github.com/adamw/macwire#interceptors" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Interceptors</h2> 
  <p>MacWire contains an implementation of interceptors, which can be applied to class instances in the modules. Similarly to scopes, the <code>proxy</code> subproject defines an <code>Interceptor</code> trait, which has only one method: <code>apply</code>. When applied to an instance, it should return an instance of the same class, but with the interceptor applied.</p> 
  <p>There are two implementations of the <code>Interceptor</code> trait provided:</p> 
  <ul> 
   <li><code>NoOpInterceptor</code>: returns the given instance without changes</li> 
   <li><code>ProxyingInterceptor</code>: proxies the instance, and returns the proxy. A provided function is called with information on the invocation</li> 
  </ul> 
  <p>Interceptors can be abstract in modules. E.g.:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">trait</span> <span class="pl-en">BusinessLogicModule</span> {
   <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">moneyTransferer</span> <span class="pl-k">=</span> transactional(wire[<span class="pl-en">MoneyTransferer</span>])

   <span class="pl-k">def</span> <span class="pl-en">transactional</span><span class="pl-k">:</span> <span class="pl-en">Interceptor</span>
}</pre>
  </div> 
  <p>During tests, you can then use the <code>NoOpInterceptor</code>. In production code or integration tests, you can specify a real interceptor, either by extending the <code>ProxyingInterceptor</code> trait, or by passing a function to the <code>ProxyingInterceptor</code> object:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">object</span> <span class="pl-en">MyApplication</span> <span class="pl-k">extends</span> <span class="pl-e">BusinessLogicModule</span> {
    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">tm</span> <span class="pl-k">=</span> wire[<span class="pl-en">TransactionManager</span>]

    <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">transactional</span> <span class="pl-k">=</span> <span class="pl-en">ProxyingInterceptor</span> { ctx <span class="pl-k">=&gt;</span>
        <span class="pl-k">try</span> {
            tm.begin()
            <span class="pl-k">val</span> <span class="pl-en">result</span> <span class="pl-k">=</span> ctx.proceed()
            tm.commit()

            result
        } <span class="pl-k">catch</span> {
            <span class="pl-k">case</span> <span class="pl-v">e</span>: <span class="pl-en">Exception</span> <span class="pl-k">=&gt;</span> tm.rollback()
        }
    }
}</pre>
  </div> 
  <p>The <code>ctx</code> is an instance of an <code>InvocationContext</code>, and contains information on the parameters passed to the method, the method itself, and the target object. It also allows to proceed with the invocation with the same or changed parameters.</p> 
  <p>For more general AOP, e.g. if you want to apply an interceptor to all methods matching a given pointcut expression, you should use <a href="http://eclipse.org/aspectj/" target="_blank">AspectJ</a> or an equivalent library. The interceptors that are implemented in MacWire correspond to annotation-based interceptors in Java.</p> 
  <h2><a id="user-content-qualifiers" class="anchor" href="https://github.com/adamw/macwire#qualifiers" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Qualifiers</h2> 
  <p>Sometimes you have multiple objects of the same type that you want to use during wiring. Macwire needs to have some way of telling the instances apart. As with other things, the answer is: types! Even when not using <code>wire</code>, it may be useful to give the instances distinct types, to get compile-time checking.</p> 
  <p>For that purpose Macwire includes support for tagging via <a href="https://github.com/softwaremill/scala-common" target="_blank">scala-common</a>, which lets you attach tags to instances to qualify them. This is a compile-time only operation, and doesn't affect the runtime. The tags are derived from <a href="https://gist.github.com/milessabin/89c9b47a91017973a35f" target="_blank">Miles Sabin's gist</a>.</p> 
  <p>To bring the tagging into scope, import <code>com.softwaremill.tagging._</code>.</p> 
  <p>Using tagging has two sides. In the constructor, when declaring a dependency, you need to declare what tag it needs to have. You can do this with the <code>_ @@ _</code> type constructor, or if you prefer another syntax <code>Tagged[_, _]</code>. The first type parameter is the type of the dependency, the second is a tag.</p> 
  <p>The tag can be any type, but usually it is just an empty marker trait.</p> 
  <p>When defining the available instances, you need to specify which instance has which tag. This can be done with the <code>taggedWith[_]</code> method, which returns a tagged instance (<code>A.taggedWith[T]: A @@ T</code>). Tagged instances can be used as regular ones, without any constraints.</p> 
  <p>The <code>wire</code> macro does not contain any special support for tagging, everything is handled by subtyping. For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">Berry</span>()
<span class="pl-k">trait</span> <span class="pl-en">Black</span>
<span class="pl-k">trait</span> <span class="pl-en">Blue</span>

<span class="pl-k">case</span> <span class="pl-k">class</span> <span class="pl-en">Basket</span>(<span class="pl-v">blueberry</span>: <span class="pl-en">Berry</span> <span class="pl-k">@@</span> <span class="pl-en">Blue</span>, <span class="pl-v">blackberry</span>: <span class="pl-en">Berry</span> <span class="pl-k">@@</span> <span class="pl-en">Black</span>)

<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">blueberry</span> <span class="pl-k">=</span> wire[<span class="pl-en">Berry</span>].taggedWith[<span class="pl-en">Blue</span>]
<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">blackberry</span> <span class="pl-k">=</span> wire[<span class="pl-en">Berry</span>].taggedWith[<span class="pl-en">Black</span>]
<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">basket</span> <span class="pl-k">=</span> wire[<span class="pl-en">Basket</span>]</pre>
  </div> 
  <p>Multiple tags can be combined using the <code>andTaggedWith</code> method. E.g. if we had a berry that is both blue and black:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">blackblueberry</span> <span class="pl-k">=</span> wire[<span class="pl-en">Berry</span>].taggedWith[<span class="pl-en">Black</span>].andTaggedWith[<span class="pl-en">Blue</span>]</pre>
  </div> 
  <p>The resulting value has type <code>Berry @ (Black with Blue)</code> and can be used both as a blackberry and as a blueberry.</p> 
  <h2><a id="user-content-limitations" class="anchor" href="https://github.com/adamw/macwire#limitations" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Limitations</h2> 
  <p>When:</p> 
  <ul> 
   <li>referencing wired values within the trait/class/object</li> 
   <li>using multiple modules in the same compilation unit</li> 
   <li>using multiple modules with scopes</li> 
  </ul> 
  <p>due to limitations of the current macros implementation in Scala (for more details see <a href="https://groups.google.com/forum/?fromgroups=#!topic/scala-user/k_2KCvO5g04" target="_blank">this discussion</a>) to avoid compilation errors it is recommended to add type ascriptions to the dependencies. This is a way of helping the type-checker that is invoked by the macro to figure out the types of the values which can be wired.</p> 
  <p>For example:</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">class</span> <span class="pl-en">A</span>()
<span class="pl-k">class</span> <span class="pl-en">B</span>(<span class="pl-v">a</span>: <span class="pl-en">A</span>)

<span class="pl-c">// note the explicit type. Without it wiring would fail with recursive type compile errors</span>
<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theA</span><span class="pl-k">:</span> <span class="pl-en">A</span> <span class="pl-k">=</span> wire[<span class="pl-en">A</span>]
<span class="pl-c">// reference to theA; if for some reason we need explicitly write the constructor call</span>
<span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">theB</span> <span class="pl-k">=</span> <span class="pl-k">new</span> <span class="pl-en">B</span>(theA)</pre>
  </div> 
  <p>This is an inconvenience, but hopefully will get resolved once post-typer macros are introduced to the language.</p> 
  <p>Also, wiring will probably not work properly for traits and classes defined inside the containing trait/class, or in super traits/classes.</p> 
  <p>Note that the type ascription may be a subtype of the wired type. This can be useful if you want to expose e.g. a trait that the wired class extends, instead of the full implementation.</p> 
  <h2><a id="user-content-installation-using-with-sbt" class="anchor" href="https://github.com/adamw/macwire#installation-using-with-sbt" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Installation, using with SBT</h2> 
  <p>The jars are deployed to <a href="https://oss.sonatype.org/content/repositories/snapshots/com/softwaremill/macwire/" target="_blank">Sonatype's OSS repository</a>. To use MacWire in your project, add a dependency:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>macros<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.2.5<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>provided<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>util<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.2.5<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>proxy<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.2.5<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>The <code>macros</code> subproject contains only code which is used at compile-time, hence the <code>provided</code> scope. </p> 
  <p>The <code>util</code> subproject contains tagging, <code>Wired</code> and the <code>@Module</code> annotation; if you don't use these features, you don't need to include this dependency.</p> 
  <p>The <code>proxy</code> subproject contains interceptors and scopes, and has a dependency on <code>javassist</code>.</p> 
  <p>To use the snapshot version:</p> 
  <div class="highlight highlight-source-scala">
   <pre>resolvers <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>Sonatype OSS Snapshots<span class="pl-pds">"</span></span> at <span class="pl-s"><span class="pl-pds">"</span>https://oss.sonatype.org/content/repositories/snapshots<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>macros<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.2.5-SNAPSHOT<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>provided<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>util<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>2.2.5-SNAPSHOT<span class="pl-pds">"</span></span></pre>
  </div> 
  <p>Currently 2.x supports Scala 2.11 and 2.12.</p> 
  <p>Older 1.x release for Scala 2.10 and 2.11:</p> 
  <div class="highlight highlight-source-scala">
   <pre>libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>macros<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.0.7<span class="pl-pds">"</span></span>

libraryDependencies <span class="pl-k">+</span><span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>com.softwaremill.macwire<span class="pl-pds">"</span></span> <span class="pl-k">%%</span> <span class="pl-s"><span class="pl-pds">"</span>runtime<span class="pl-pds">"</span></span> <span class="pl-k">%</span> <span class="pl-s"><span class="pl-pds">"</span>1.0.7<span class="pl-pds">"</span></span></pre>
  </div> 
  <h2><a id="user-content-debugging" class="anchor" href="https://github.com/adamw/macwire#debugging" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Debugging</h2> 
  <p>To print debugging information on what MacWire does when looking for values, and what code is generated, set the <code>macwire.debug</code> system property. E.g. with SBT, just add a <code>System.setProperty("macwire.debug", "")</code> line to your build file.</p> 
  <h2><a id="user-content-scalajs" class="anchor" href="https://github.com/adamw/macwire#scalajs" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Scala.js</h2> 
  <p>Macwire also works with <a href="http://www.scala-js.org/" target="_blank">Scala.js</a>. For an example, see here: <a href="https://github.com/adamw/macwire/tree/master/examples/scalajs" target="_blank">Macwire+Scala.js example</a>.</p> 
  <h2><a id="user-content-future-development---vote" class="anchor" href="https://github.com/adamw/macwire#future-development---vote" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Future development - vote!</h2> 
  <p>Take a look at the <a href="https://github.com/adamw/macwire/issues" target="_blank">available issues</a>. If you'd like to see one developed please vote on it. Or maybe you'll attempt to create a pull request?</p> 
  <h2><a id="user-content-activators" class="anchor" href="https://github.com/adamw/macwire#activators" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Activators</h2> 
  <p>There are two Typesafe Activators which can help you to get started with Scala, Dependency Injection and Macwire:</p> 
  <ul> 
   <li><a href="https://typesafe.com/activator/template/macwire-akka-activator" target="_blank">No-framework Dependency Injection with MacWire and Akka Activator</a></li> 
   <li><a href="https://typesafe.com/activator/template/macwire-activator" target="_blank">No-framework Dependency Injection with MacWire and Play Activator</a></li> 
  </ul> 
  <h2><a id="user-content-migrating-from-1x-" class="anchor" href="https://github.com/adamw/macwire#migrating-from-1x-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Migrating from 1.x <a id="user-content-migrating" target="_blank" href=""></a></h2> 
  <ul> 
   <li>changed how code is split across modules. You'll need to depend on <code>util</code> to get tagging &amp; <code>Wired</code>, and <code>proxy</code> to get interceptors and scopes</li> 
   <li>tagging moved to a separate package. If you use tagging, you'll need to import <code>com.softwaremill.tagging._</code></li> 
   <li>removed <code>wireImplicit</code></li> 
   <li>implicit parameters aren't handled by <code>wire</code> at all (they used to be subject to the same lookup procedure as normal parameters + implicit lookup)</li> 
  </ul> 
  <h2><a id="user-content-play-24x-" class="anchor" href="https://github.com/adamw/macwire#play-24x-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Play 2.4.x <a id="user-content-play24x" target="_blank" href=""></a></h2> 
  <p>In Play 2.4.x, you can no longer use getControllerInstance in GlobalSettings for injection. Play has a new pattern for injecting controllers. You must extend ApplicationLoader, from there you can mix in your modules. </p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">controllers.</span>{<span class="pl-v">Application</span>, <span class="pl-v">Assets</span>}
<span class="pl-k">import</span> <span class="pl-v">play.api.ApplicationLoader.</span><span class="pl-v">Context</span>
<span class="pl-k">import</span> <span class="pl-v">play.api.</span><span class="pl-v">_</span>
<span class="pl-k">import</span> <span class="pl-v">play.api.routing.</span><span class="pl-v">Router</span>
<span class="pl-k">import</span> <span class="pl-v">router.</span><span class="pl-v">Routes</span>
<span class="pl-k">import</span> <span class="pl-v">com.softwaremill.macwire.</span><span class="pl-v">_</span>

<span class="pl-k">class</span> <span class="pl-en">AppApplicationLoader</span> <span class="pl-k">extends</span> <span class="pl-e">ApplicationLoader</span> {
  <span class="pl-k">def</span> <span class="pl-en">load</span>(<span class="pl-v">context</span>: <span class="pl-en">Context</span>) <span class="pl-k">=</span> {

    <span class="pl-c">// make sure logging is configured</span>
    <span class="pl-en">Logger</span>.configure(context.environment)

    (<span class="pl-k">new</span> <span class="pl-en">BuiltInComponentsFromContext</span>(context) <span class="pl-k">with</span> <span class="pl-e">AppComponents).application</span>
  }
}

<span class="pl-k">trait</span> <span class="pl-en">AppComponents</span> <span class="pl-k">extends</span> <span class="pl-e">BuiltInComponents</span> <span class="pl-k">with</span> <span class="pl-e">AppModule</span> {
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">assets</span><span class="pl-k">:</span> <span class="pl-en">Assets</span> <span class="pl-k">=</span> wire[<span class="pl-en">Assets</span>]
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">prefix</span><span class="pl-k">:</span> <span class="pl-k">String</span> <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">"</span>/<span class="pl-pds">"</span></span>
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">router</span><span class="pl-k">:</span> <span class="pl-en">Router</span> <span class="pl-k">=</span> wire[<span class="pl-en">Routes</span>]
}

<span class="pl-k">trait</span> <span class="pl-en">AppModule</span> {
  <span class="pl-c">// Define your dependencies and controllers</span>
  <span class="pl-k">lazy</span> <span class="pl-k">val</span> <span class="pl-en">applicationController</span> <span class="pl-k">=</span> wire[<span class="pl-en">Application</span>]
}</pre>
  </div> 
  <p>In application.conf, add the reference to the ApplicationLoader.</p> 
  <pre><code>play.application.loader = "AppApplicationLoader"
</code></pre> 
  <p>For more information and to see the sample project, go to <a href="https://github.com/adamw/macwire/tree/master/examples/play24" target="_blank">examples/play24</a></p> 
  <p>Reference Play docs for more information:</p> 
  <ul> 
   <li><a href="https://www.playframework.com/documentation/2.4.x/ScalaCompileTimeDependencyInjection" target="_blank">ScalaCompileTimeDependencyInjection</a></li> 
  </ul> 
  <h2><a id="user-content-play-25x-" class="anchor" href="https://github.com/adamw/macwire#play-25x-" aria-hidden="true" target="_blank">
    <svg aria-hidden="true" class="octicon octicon-link" height="16" version="1.1" viewbox="0 0 16 16" width="16">
     <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
    </svg></a>Play 2.5.x <a id="user-content-play25x" target="_blank" href=""></a></h2> 
  <p>For Play 2.5.x, you must do the same as for Play 2.4.x, except the <code>Logger</code> configuration.</p> 
  <div class="highlight highlight-source-scala">
   <pre><span class="pl-k">import</span> <span class="pl-v">play.api.</span><span class="pl-v">LoggerConfigurator</span>
<span class="pl-k">class</span> <span class="pl-en">AppApplicationLoader</span> <span class="pl-k">extends</span> <span class="pl-e">ApplicationLoader</span> {
  <span class="pl-k">def</span> <span class="pl-en">load</span>(<span class="pl-v">context</span>: <span class="pl-en">Context</span>) <span class="pl-k">=</span> {

    <span class="pl-en">LoggerConfigurator</span>(context.environment.classLoader).foreach {
      _.configure(context.environment)
    }
    <span class="pl-c">// ... do the same as for Play 2.4.x</span>
  }
}</pre>
  </div> 
 </article>
</div>